{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "43c58da2_da023f0a",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T21:09:05Z",
      "side": 1,
      "message": "These don\u0027t look right; IIRC `GL_RGBX8_ANGLE + R8G8B8X8_UNORM` for example means the internal format is RGBX, and the upload data is also RGBX. In this case, we shouldn\u0027t pick 3 components from upload data, because upload data also has 4 components. Don\u0027t you think so?\n\nWasn\u0027t the `glTexSubImage2D` call passing in `GL_RGB8` data? Shouldn\u0027t then a new entry be needed here like:\n\n```\n    \"R8G8B8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n```\n\nand the old entries left as-is?\n\n---\n\nThere\u0027s an existing bug here that the alpha channel is not overriden to 0xFF when copying from RGBA (or RGBX for that matter)",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d30911a2_b9817079",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:33:44Z",
      "side": 1,
      "message": "Hmm, that doesn\u0027t match my understanding here. `GL_RGBX8_ANGLE` decides the upload data is 3 channel",
      "parentUuid": "43c58da2_da023f0a",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8a6d19a_68b2a77c",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:44:48Z",
      "side": 1,
      "message": "(sorry, false click cuts my comment)\n\nwhich is reflected in `ImageHelper::CalculateBufferInfo`, and the `R8G8B8X8_UNORM`/`R8G8B8A8_UNORM` suggests the actual backing storage and either can ensure a match against `AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM`.\n\n(I was tracing the upload path to `ImageHelper::stageSubresourceUpdateImpl`, but maybe something else is deeply broken since `GL_RGBX8_ANGLE` doesn\u0027t quite match your expectation?)",
      "parentUuid": "d30911a2_b9817079",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "789b2a59_99ac30ba",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:59:06Z",
      "side": 1,
      "message": "e.g. My previous attempt to force `forceFallbackFormat` when RGBX8 AHB still maps to `GL_RGB8`, that enables the below load function for frontend/internal `GL_RGB8` format \u003d\u003e actual `RGBA8`.\n```\n    \"R8G8B8A8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n```\n\nThat\u0027s also why I think frontend `GL_RGB8` + internal `GL_RGBX8_ANGLE` + actual `RGBX8` is intended to use\n```\n    \"R8G8B8X8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n```\n(PS: it\u0027s also `RGBA8` used as actual here due to Vulkan)\n\nI gave your suggestion a try, and that didn\u0027t work, which matched what those functions do. Unless I missed another layer of data conversion at further frontend between `GL_RGB8` \u003c\u003d\u003e `GL_RGBX8_ANGLE`, since I\u0027m not that familiar with angle.",
      "parentUuid": "f8a6d19a_68b2a77c",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aabd7f37_cfdca119",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:13:05Z",
      "side": 1,
      "message": "Something\u0027s definitely wrong, but I don\u0027t know where. See the `GL_BGRX8_ANGLEX` case above for example, this should be very similar to that, one way or another.\n\nActually this table is always a headache to read. Looking again, it looks like the source is defined by the outer format and inner type, and the internal format is the middle one, for example:\n\n```\n  \"GL_LUMINANCE_ALPHA\": {\n    \"R32G32B32A32_FLOAT\": {\n      \"GL_FLOAT\": \"LoadLA32FToRGBA32F\"\n    }\n  },\n```\n\nso input LUMA + GL_FLOAT is loaded into RGBA32 :/\n\nIn that case, maybe what we need is something like this?\n\n```\n  \"GL_RGB\" : {\n    \"R8G8B8X8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n  },\n```\n\nBut I also can\u0027t make sense of the code right now. I see this:\n\n```\nangle::Result ImageHelper::stageSubresourceUpdateImpl(...,\n                                                      const gl::InternalFormat \u0026formatInfo,\n                                                      GLenum type,\n                                                      const uint8_t *pixels,\n                                                      const Format \u0026vkFormat,\n                                                      ...)\n```\n\nFrom what I can make, `formatInfo` and `type` are what\u0027s passed to `glTexSubImage2D`, i.e. they declare the format of data in the `pixels` buffer. `vkFormat` on the other hand is the existing format of the image. Can you tell me what these values are in the test?\n\nWhat I thought is the input is that `formatInfo` is RGB, type is UNSIGNED_BYTE, and `vkFormat` is RGBX.\n\nNow the code then does this:\n\n```\n    LoadImageFunctionInfo loadFunctionInfo \u003d vkFormat.getTextureLoadFunction(access, type);\n```\n\nand looking at what `getTextureLoadFunction` returns, it\u0027s about converting the data from the intended format of the image to its actual format. For example, LUMA to RG, or in this case, RGBX to RGBA. It has nothing to do with the _input_ data format! It seems to me that this is fundamentally broken, why is the `pixels` format not part of the equation?",
      "parentUuid": "f8a6d19a_68b2a77c",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dec02ac3_30860e51",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:13:58Z",
      "side": 1,
      "message": "I\u0027ll need to think about this. If it\u0027s possible for you, do you think you could add an end2end test to ANGLE to reproduce this? That would help a lot. That would go in `ImageTest.cpp`",
      "parentUuid": "aabd7f37_cfdca119",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "002ef4d5_870bd60b",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:49:28Z",
      "side": 1,
      "message": "This might be the same as anglebug.com/5313",
      "parentUuid": "dec02ac3_30860e51",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52eb717e_b28c4aa8",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T23:17:22Z",
      "side": 1,
      "message": "That anglebug.com/5313 helps clarify some of my confusions. With the current upload path, that seems ok, but that was likely not ok while I looked at the usage of load function in `ImageHelper::stageSubresourceUpdateFromFramebuffer`..\n\nIndeed something is deeply broken then. Let me try adding an e2e test here.",
      "parentUuid": "002ef4d5_870bd60b",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2e32c3c_df0e73bf",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T23:33:55Z",
      "side": 1,
      "message": "nope...`ImageHelper::stageSubresourceUpdateFromFramebuffer`\u0027s usage of load function reads about right to me. I need to take some time to understand the issue a bit more.",
      "parentUuid": "52eb717e_b28c4aa8",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "118796f3_2c1d50c6",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-23T00:09:59Z",
      "side": 1,
      "message": "Hi Shahbaz, one thing I\u0027d like to point out again is:\n```\n    /**\n     * 32 bits per pixel, 8 bits per channel format where alpha values are\n     * ignored (always opaque).\n     * Corresponding formats:\n     *   Vulkan: VK_FORMAT_R8G8B8A8_UNORM\n     *   OpenGL ES: GL_RGB8\n     */\n    AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM           \u003d 2,\n```\n\nAdding another load function for `GL_RGB8` doesn\u0027t make any sense to me. If we agree on intenral format being `GL_RGB8`, that will lead to 24bit VkFormat being the storage, which won\u0027t match the RGBX AHB storage intended to be imported as `VK_FORMAT_R8G8B8A8_UNORM` per spec.\n\nAngle picks the internal format best reflecting the frontend `GL_RGB8` and the acutal `VK_FORMAT_R8G8B8A8_UNORM`, which should be `GL_RGBX8_ANGLE` per your early suggestion.\n\nPer this angle extension at `extensions/ANGLE_rgbx_internal_format.txt`:\n\u003e This extension introduces a sized internal RGBX format. This is a 32-bit representation of the 24-bit RGB format, with the Alpha channel ignored.\n\nI reviewed the early patches for this angle internal format: crrev/c/3296625 and crrev/c/3312367, and fixing the load function of `GL_RGBX8_ANGLE` to \"treating GL_RGBX8_ANGLE being GL_RGB8\" seems intended, and aligns with this change.\n\nWhat I\u0027m sure about is the test variants:\n```\nGpuColorOutputCpuRead\nCpuWriteColorGpuRead\nGpuSampledImageCanBeSampled\n```\nnow all pass for RGBX AHB, which at least proves that {readback, exteranl tex import, tex upload} all work.\n\nI\u0027ll try convering them to angle e2e.\n\nPs: `GL_BGRX8_ANGLEX` could be broken or not but I can\u0027t tell since there\u0027s no such code path existed with Vulkan backend. So I\u0027ll leave that to angle side.",
      "parentUuid": "a2e32c3c_df0e73bf",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f836bfd3_7b5152a4",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-23T02:11:34Z",
      "side": 1,
      "message": "I was thinking about it, and I think I know why this was never broken before; `glTexSubImage2D` only allows combinations of format/type that match the internal format. So we only ever need to look at the intended-\u003eactual format conversion, basically because the input data is already in the intended format (at least channel-count-wise)\n\nHowever, this assumption is being broken by AHB here, and the test is providing RGB data to an RGBX image (i.e. not the same number of channels). I realize AHB had no choice but to expect GL_RGB8 in `glTexSubImage2D` because there\u0027s no GL_RGBX8.\n\nSo your change is fine. I was worried about other non-AHB users of RGBX8_ANGLE, but I don\u0027t believe there are any that actually upload texture data. So, let\u0027s codify this in the ANGLE extension. Could you please add this text to `ANGLE_rgbx_internal_format.txt` (after `glReadPixels`):\n\n```\nglTexSubImage* will accept the following format+type combinations:\n    1. format \u003d GL_RGB, type \u003d GL_UNSIGNED_BYTE\n```\n\nI feel like `glReadPixels` should have also accepted `GL_RGB` instead of `GL_RGBX8_ANGLE` as is written in the spec now, but changing that needs some coordination with Chrome",
      "parentUuid": "118796f3_2c1d50c6",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2f372be9_08000252",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-23T06:17:12Z",
      "side": 1,
      "message": "Thanks for confirming! Updated.\n\nFor the end2end test, I found there actually existed plenty of RGBXAHB tests, however, the upload and verification are only for top left corner. I sent a follow up CL for updating `RGBXAHBImportThenUpload` to upload to the right side and the test will fail as expected without this fix.",
      "parentUuid": "f836bfd3_7b5152a4",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}