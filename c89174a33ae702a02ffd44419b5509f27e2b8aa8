{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "43c58da2_da023f0a",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T21:09:05Z",
      "side": 1,
      "message": "These don\u0027t look right; IIRC `GL_RGBX8_ANGLE + R8G8B8X8_UNORM` for example means the internal format is RGBX, and the upload data is also RGBX. In this case, we shouldn\u0027t pick 3 components from upload data, because upload data also has 4 components. Don\u0027t you think so?\n\nWasn\u0027t the `glTexSubImage2D` call passing in `GL_RGB8` data? Shouldn\u0027t then a new entry be needed here like:\n\n```\n    \"R8G8B8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n```\n\nand the old entries left as-is?\n\n---\n\nThere\u0027s an existing bug here that the alpha channel is not overriden to 0xFF when copying from RGBA (or RGBX for that matter)",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d30911a2_b9817079",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:33:44Z",
      "side": 1,
      "message": "Hmm, that doesn\u0027t match my understanding here. `GL_RGBX8_ANGLE` decides the upload data is 3 channel",
      "parentUuid": "43c58da2_da023f0a",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8a6d19a_68b2a77c",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:44:48Z",
      "side": 1,
      "message": "(sorry, false click cuts my comment)\n\nwhich is reflected in `ImageHelper::CalculateBufferInfo`, and the `R8G8B8X8_UNORM`/`R8G8B8A8_UNORM` suggests the actual backing storage and either can ensure a match against `AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM`.\n\n(I was tracing the upload path to `ImageHelper::stageSubresourceUpdateImpl`, but maybe something else is deeply broken since `GL_RGBX8_ANGLE` doesn\u0027t quite match your expectation?)",
      "parentUuid": "d30911a2_b9817079",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "789b2a59_99ac30ba",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T21:59:06Z",
      "side": 1,
      "message": "e.g. My previous attempt to force `forceFallbackFormat` when RGBX8 AHB still maps to `GL_RGB8`, that enables the below load function for frontend/internal `GL_RGB8` format \u003d\u003e actual `RGBA8`.\n```\n    \"R8G8B8A8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n```\n\nThat\u0027s also why I think frontend `GL_RGB8` + internal `GL_RGBX8_ANGLE` + actual `RGBX8` is intended to use\n```\n    \"R8G8B8X8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n```\n(PS: it\u0027s also `RGBA8` used as actual here due to Vulkan)\n\nI gave your suggestion a try, and that didn\u0027t work, which matched what those functions do. Unless I missed another layer of data conversion at further frontend between `GL_RGB8` \u003c\u003d\u003e `GL_RGBX8_ANGLE`, since I\u0027m not that familiar with angle.",
      "parentUuid": "f8a6d19a_68b2a77c",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aabd7f37_cfdca119",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:13:05Z",
      "side": 1,
      "message": "Something\u0027s definitely wrong, but I don\u0027t know where. See the `GL_BGRX8_ANGLEX` case above for example, this should be very similar to that, one way or another.\n\nActually this table is always a headache to read. Looking again, it looks like the source is defined by the outer format and inner type, and the internal format is the middle one, for example:\n\n```\n  \"GL_LUMINANCE_ALPHA\": {\n    \"R32G32B32A32_FLOAT\": {\n      \"GL_FLOAT\": \"LoadLA32FToRGBA32F\"\n    }\n  },\n```\n\nso input LUMA + GL_FLOAT is loaded into RGBA32 :/\n\nIn that case, maybe what we need is something like this?\n\n```\n  \"GL_RGB\" : {\n    \"R8G8B8X8_UNORM\": {\n      \"GL_UNSIGNED_BYTE\": \"LoadToNative3To4\u003cGLubyte, 0xFF\u003e\"\n    },\n  },\n```\n\nBut I also can\u0027t make sense of the code right now. I see this:\n\n```\nangle::Result ImageHelper::stageSubresourceUpdateImpl(...,\n                                                      const gl::InternalFormat \u0026formatInfo,\n                                                      GLenum type,\n                                                      const uint8_t *pixels,\n                                                      const Format \u0026vkFormat,\n                                                      ...)\n```\n\nFrom what I can make, `formatInfo` and `type` are what\u0027s passed to `glTexSubImage2D`, i.e. they declare the format of data in the `pixels` buffer. `vkFormat` on the other hand is the existing format of the image. Can you tell me what these values are in the test?\n\nWhat I thought is the input is that `formatInfo` is RGB, type is UNSIGNED_BYTE, and `vkFormat` is RGBX.\n\nNow the code then does this:\n\n```\n    LoadImageFunctionInfo loadFunctionInfo \u003d vkFormat.getTextureLoadFunction(access, type);\n```\n\nand looking at what `getTextureLoadFunction` returns, it\u0027s about converting the data from the intended format of the image to its actual format. For example, LUMA to RG, or in this case, RGBX to RGBA. It has nothing to do with the _input_ data format! It seems to me that this is fundamentally broken, why is the `pixels` format not part of the equation?",
      "parentUuid": "f8a6d19a_68b2a77c",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dec02ac3_30860e51",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:13:58Z",
      "side": 1,
      "message": "I\u0027ll need to think about this. If it\u0027s possible for you, do you think you could add an end2end test to ANGLE to reproduce this? That would help a lot. That would go in `ImageTest.cpp`",
      "parentUuid": "aabd7f37_cfdca119",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "002ef4d5_870bd60b",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-22T22:49:28Z",
      "side": 1,
      "message": "This might be the same as anglebug.com/5313",
      "parentUuid": "dec02ac3_30860e51",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52eb717e_b28c4aa8",
        "filename": "src/libANGLE/renderer/load_functions_data.json",
        "patchSetId": 2
      },
      "lineNbr": 424,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-08-22T23:17:22Z",
      "side": 1,
      "message": "That anglebug.com/5313 helps clarify some of my confusions. With the current upload path, that seems ok, but that was likely not ok while I looked at the usage of load function in `ImageHelper::stageSubresourceUpdateFromFramebuffer`..\n\nIndeed something is deeply broken then. Let me try adding an e2e test here.",
      "parentUuid": "002ef4d5_870bd60b",
      "range": {
        "startLine": 419,
        "startChar": 0,
        "endLine": 424,
        "endChar": 5
      },
      "revId": "c89174a33ae702a02ffd44419b5509f27e2b8aa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}