{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7a885ad6_14236143",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-06-08T16:37:13Z",
      "side": 1,
      "message": "I wonder if we can detect undefined texture contents in capture instead of forcing everything to be defined in the tests.",
      "revId": "5e227c11d2c002de56c5b2289a81877d9cc96f43",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31e7239d_19139717",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1491823
      },
      "writtenOn": "2021-06-09T15:28:51Z",
      "side": 1,
      "message": "\u003e I wonder if we can detect undefined texture contents in capture instead of forcing everything to be defined in the tests.\n\nThat\u0027s difficult, because the texture data can be initialized in many ways: \n\n* plain data upload through glTexImage*\n* data upload through a pixel pack buffer through glTexImage*\n* glClearTexture\n* data upload through glTexSumImage*\n* data upload through a pixel pack buffer through glTexSumImage*\n* CopyImageSubData \n* glCopyTexImage2D\n* texture is a render target \n\nOnly in the first three cases the initialization is guaranteed to be complete. \n\nI only could imagine that one could add some code so that the texture contents is forcefully initialized when tests are run (same as valgrind and other memory debuggers \"initialize\" uninitialized memory to keep track of uninitialized values.",
      "parentUuid": "7a885ad6_14236143",
      "revId": "5e227c11d2c002de56c5b2289a81877d9cc96f43",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07673e8f_08f1cd4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-06-09T15:44:03Z",
      "side": 1,
      "message": "ANGLE does track uninit contents already, although it looks like this tracking is disabled when the resource resource init extension is disabled.\n\nI wonder if we could track this specifically for frame capture. It may be a slightly bigger scope for something you can easily work around on a per-test basis, but it would be a more complete fix. What do you think Cody/Gert? The change would be to implement just the tracking of uninit data without the resource initialization step we do before the draw for WebGL.",
      "parentUuid": "31e7239d_19139717",
      "revId": "5e227c11d2c002de56c5b2289a81877d9cc96f43",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab370714_21c5e77e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-06-09T15:44:03Z",
      "side": 1,
      "message": "ANGLE does track uninit contents already, although it looks like this tracking is disabled when the resource resource init extension is disabled.\n\nI wonder if we could track this specifically for frame capture. It may be a slightly bigger scope for something you can easily work around on a per-test basis, but it would be a more complete fix. What do you think Cody/Gert? The change would be to implement just the tracking of uninit data without the resource initialization step we do before draws in WebGL.",
      "parentUuid": "31e7239d_19139717",
      "revId": "5e227c11d2c002de56c5b2289a81877d9cc96f43",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}