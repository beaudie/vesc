{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2244d353_e12a7de7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-13T22:40:41Z",
      "side": 1,
      "message": "The thing I worried is that combined with sub-allocation from your previous CL, the offset is going to be change frequently, since the offset here the offsetWithInBuffer+offsetFromSubAllocator, and that can change from each allocation. That will practically defeat the cache. Maybe we should leave the offset/range out of DS cache and always update them even in cache hit?",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6e65428_cc60c1e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-14T02:35:03Z",
      "side": 1,
      "message": "2 points:\n\n1. I doubt the application would make the transform feedback buffer make new allocations frequently. Chances are they allocate it and just use it.\n2. This only affects transform feedback emulation.\n\nEspecially with #2, are you satisfied that this practically means only swiftshader is affected?",
      "parentUuid": "2244d353_e12a7de7",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f9660253_d774f976",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-05-14T16:21:28Z",
      "side": 1,
      "message": "LGTM - ideally all data could be packed into one block like in the other cache, so we could hash/memcmp faster.",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ab47d24_4818271c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-14T16:24:47Z",
      "side": 1,
      "message": "But the exact same issue applies other types of descriptor set cache as well, for example, atomic and storage buffer which does not have the bug this CL try to fix, but also have the same cache miss issue. I was thinking you can fix this and the same mechanism can can be propagate to others.\n\nFor your point #1, you never know how bad app can be, but XFB in general is less common usage anyway. I am okay to deal with cache misses in separate CL.",
      "parentUuid": "b6e65428_cc60c1e0",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f7a49bc_b781ffd4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-14T16:37:23Z",
      "side": 1,
      "message": "Actually I think this is not a regression with sub-allocation. As long as you call glBufferData with different size, you basically will have a cache miss. What can be improved here is that in this case, we know that cache likely will miss, we just use a generic buffer/offset/range as the key to find the cached DS and then update it. It\u0027s a seperate issue from this CL.",
      "parentUuid": "9ab47d24_4818271c",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3812eab6_6b8cd848",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-15T01:18:05Z",
      "side": 1,
      "message": "I\u0027ll leave that as follow up if you don\u0027t mind. In this case, mBufferCount is going to be exactly 1 anywhere with VK_EXT_transform_feedback, so not a big deal probably.",
      "parentUuid": "f9660253_d774f976",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "488f5e42_9cd3a932",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-15T01:18:05Z",
      "side": 1,
      "message": "Ok, I\u0027ll leave that as follow up for future.\n\nWasn\u0027t part of the performance problem all the *writes* to the descriptor set? If the issue was just the allocation of the descriptor set, then what\u0027s stopping us from allocating a number of them and just pick any unused and fully update it every time? Then the cache is really just a recycler, and there\u0027s no key look up or anything.",
      "parentUuid": "0f7a49bc_b781ffd4",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30879aa9_10f8efbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-15T03:42:18Z",
      "side": 1,
      "message": "I think both. The point is if some descriptor we know it behaves like dynamic, there will be cache miss, just no point to walk through the cache and only to find miss and allocate a new one. Its better off just recycle old object and update it. We may do some stats collection against all traces we have and see how often is such case and how do we detect it.",
      "parentUuid": "488f5e42_9cd3a932",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de24131f_c8981f26",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3013,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-05-13T17:31:39Z",
      "side": 1,
      "message": "what is mbuffercount - 1 here?",
      "range": {
        "startLine": 3013,
        "startChar": 69,
        "endLine": 3013,
        "endChar": 82
      },
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73d9502c_9fd5ddfc",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3013,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-13T17:35:01Z",
      "side": 1,
      "message": "mBufferCount includes 1 for the default uniforms buffer. See ref\n\nI\u0027ll add a constant for it.",
      "parentUuid": "de24131f_c8981f26",
      "range": {
        "startLine": 3013,
        "startChar": 69,
        "endLine": 3013,
        "endChar": 82
      },
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "852a35dc_6ebd932e",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3013,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-15T01:18:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "73d9502c_9fd5ddfc",
      "range": {
        "startLine": 3013,
        "startChar": 69,
        "endLine": 3013,
        "endChar": 82
      },
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "898471d8_461debb1",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 1132,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-13T17:35:01Z",
      "side": 1,
      "message": "Ref",
      "revId": "4067f32560a23ded321f35f86ed69d925aad4fbd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}