{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3ccb5a76_d1a3ed7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T15:23:38Z",
      "side": 1,
      "message": "Drive-by",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd6d774a_16349602",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T15:23:38Z",
      "side": 1,
      "message": "RGBA8 is not renderable in GLES2?!\n\nThis change is a bit odd; it\u0027s telling the context that the format is renderable even if it thinks that it isn\u0027t. Why not instead make the format renderable in GLES2?\n\nAlso, regardless of the solution, could you please add a test for this scenario to make sure we don\u0027t break this in the future?",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03606052_361cf190",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1267026
      },
      "writtenOn": "2023-03-20T16:02:23Z",
      "side": 1,
      "message": "RGBA8 is not renderable in GLES2. So we can not make that format renderable.\n\nNote that if a driver is capable of GLES3 and we request a GLES2 context from it, then only it can still render RGBA8 format since it has GLES3 capability. That is the case we are handling here.\n\nThere are good amount of webgl tests already which are testing this case.",
      "parentUuid": "dd6d774a_16349602",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e42588ac_939ca08a",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1394635
      },
      "writtenOn": "2023-03-20T16:29:20Z",
      "side": 1,
      "message": "Nits:\n- `OES_rgb8_rgba8` and/or `OES_required_internalformat` may affect renderability of `GL_RGBA8` in GLES2.\n- Unsized `GL_RGBA` is renderable in WebGL 1.0.",
      "parentUuid": "03606052_361cf190",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae2868f9_3bb3aaf3",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T16:29:39Z",
      "side": 1,
      "message": "Well the format itself (32-bit 8-bit-per-channel RGBA) is most definitely renderable in GLES2. Is this an issue of sized format (RGBA8) vs unsized format (RGBA + GL_UNSIGNED_BYTE)?\n\nThe way we typically handle this is to add an ANGLE extension that exposes the format in the version we want. In this case, you can add something similar to `ANGLE_rgbx_internal_format.txt` but for rgba8 and have it apply to GLES2. Then a GLES2 context in ANGLE that supports the RGBA8 sized format (one that can be GLES3+) can expose the extension which automatically means applications (including Chrome) can use this format for rendering from GLES2 contexts.",
      "parentUuid": "03606052_361cf190",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fee61124_a16e9d85",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T16:31:31Z",
      "side": 1,
      "message": "Race with Alexey\u0027s comment. Looks like `OES_rgb8_rgba8` is for GLES1, but `OES_required_internalformat` is good; if you expose that, there\u0027s no need for an an ANGLE extension.",
      "parentUuid": "ae2868f9_3bb3aaf3",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3adb8bfc_81d6d403",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1394635
      },
      "writtenOn": "2023-03-20T16:54:05Z",
      "side": 1,
      "message": "\u003e Looks like `OES_rgb8_rgba8` is for GLES1\n\nIt requires GLES1 but can be applied to GLES2 as well because unextended GLES2 does not support `GL_RGBA8` for renderbuffer storage (e.g., mentioned in `EXT_sRGB` deps). There\u0027s also `ARM_rgba8` that requires GLES2.",
      "parentUuid": "fee61124_a16e9d85",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66d527e3_3c08a6b6",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1267026
      },
      "writtenOn": "2023-03-20T19:03:50Z",
      "side": 1,
      "message": "Thanks Shahbaz and Alexey.\nYes by \u0027RGBA8\u0027 i was referring to the sized format.\nFor webgl1 tests, chrome currently creates a texture for raster on gles3 context with RGBA8 and then that texture is later shared with webgl1 context(gles2).\nBut the current validation checks in angle does not allows RGBA8 to be supported in gles2.\nso requirement here is to mark the texture attachment with that sized internal format as supported on GLES2 if that texture was originally created on GLES3. Note that in this scenario RGBA8 will always be supported by this gles2 context.\n\nI am not very clear on how we should use OES_required_internalformat or other extensions in this scenario. can u explain more clearly.\nThis siliar caching logic has been already implemented in angle for egl images - https://chromium-review.googlesource.com/c/angle/angle/+/4265252",
      "parentUuid": "3adb8bfc_81d6d403",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f336e88e_1ab367cc",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T19:27:14Z",
      "side": 1,
      "message": "\u003e I am not very clear on how we should use OES_required_internalformat or other extensions in this scenario.\n\nThat\u0027s easy! Step 1 is to get the code in to expose the extension. For example this code already does this for `OES_rgb8_rgba8`, which looks like ANGLE already supports!\n\n```\n    rgb8Rgba8OES             \u003d DetermineRGB8AndRGBA8TextureSupport(textureCaps);\n```\n\nStep 2 is to fix validation so it allows GL_RGB8 and GL_RGBA8 when `rgb8Rgba8OES` is supported.\n\n\u003e This siliar caching logic has been already implemented in angle for egl images\n\nUgh, hopefully we can revert that hack after the proper fix.",
      "parentUuid": "66d527e3_3c08a6b6",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeacd45b_3d818cc7",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-03-20T19:51:53Z",
      "side": 1,
      "message": "Taking a step back a bit: Ideally we solve this in Chrome by using EGL images. Is it not possible to create an EGL image with a texture source and a texture target? That would make a nice boundary between the WebGL texture and raster/composite textures. I think currently in Chrome these textures are coming from legacy mailboxes or GL texture backed SharedImages. Can we find out which it is try using an EGL image backing?\n\nThe approach used currently in EGL images works because they have an opaque format to GL, we can decide that they are renderable outside of the limitations of extensions.\n\nWe can\u0027t really solve this in the ways mentioned. Caching renderability will break WebGL, extensions are enabled dynamically and textures often go from un-renderable to renderable. Adding a new extension also won\u0027t work because all textures in this format will become renderable in WebGL which isn\u0027t the intention.",
      "parentUuid": "f336e88e_1ab367cc",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}