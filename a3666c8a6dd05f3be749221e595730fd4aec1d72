{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3ccb5a76_d1a3ed7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T15:23:38Z",
      "side": 1,
      "message": "Drive-by",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd6d774a_16349602",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T15:23:38Z",
      "side": 1,
      "message": "RGBA8 is not renderable in GLES2?!\n\nThis change is a bit odd; it\u0027s telling the context that the format is renderable even if it thinks that it isn\u0027t. Why not instead make the format renderable in GLES2?\n\nAlso, regardless of the solution, could you please add a test for this scenario to make sure we don\u0027t break this in the future?",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03606052_361cf190",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1267026
      },
      "writtenOn": "2023-03-20T16:02:23Z",
      "side": 1,
      "message": "RGBA8 is not renderable in GLES2. So we can not make that format renderable.\n\nNote that if a driver is capable of GLES3 and we request a GLES2 context from it, then only it can still render RGBA8 format since it has GLES3 capability. That is the case we are handling here.\n\nThere are good amount of webgl tests already which are testing this case.",
      "parentUuid": "dd6d774a_16349602",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e42588ac_939ca08a",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1394635
      },
      "writtenOn": "2023-03-20T16:29:20Z",
      "side": 1,
      "message": "Nits:\n- `OES_rgb8_rgba8` and/or `OES_required_internalformat` may affect renderability of `GL_RGBA8` in GLES2.\n- Unsized `GL_RGBA` is renderable in WebGL 1.0.",
      "parentUuid": "03606052_361cf190",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae2868f9_3bb3aaf3",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T16:29:39Z",
      "side": 1,
      "message": "Well the format itself (32-bit 8-bit-per-channel RGBA) is most definitely renderable in GLES2. Is this an issue of sized format (RGBA8) vs unsized format (RGBA + GL_UNSIGNED_BYTE)?\n\nThe way we typically handle this is to add an ANGLE extension that exposes the format in the version we want. In this case, you can add something similar to `ANGLE_rgbx_internal_format.txt` but for rgba8 and have it apply to GLES2. Then a GLES2 context in ANGLE that supports the RGBA8 sized format (one that can be GLES3+) can expose the extension which automatically means applications (including Chrome) can use this format for rendering from GLES2 contexts.",
      "parentUuid": "03606052_361cf190",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fee61124_a16e9d85",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T16:31:31Z",
      "side": 1,
      "message": "Race with Alexey\u0027s comment. Looks like `OES_rgb8_rgba8` is for GLES1, but `OES_required_internalformat` is good; if you expose that, there\u0027s no need for an an ANGLE extension.",
      "parentUuid": "ae2868f9_3bb3aaf3",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3adb8bfc_81d6d403",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1394635
      },
      "writtenOn": "2023-03-20T16:54:05Z",
      "side": 1,
      "message": "\u003e Looks like `OES_rgb8_rgba8` is for GLES1\n\nIt requires GLES1 but can be applied to GLES2 as well because unextended GLES2 does not support `GL_RGBA8` for renderbuffer storage (e.g., mentioned in `EXT_sRGB` deps). There\u0027s also `ARM_rgba8` that requires GLES2.",
      "parentUuid": "fee61124_a16e9d85",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66d527e3_3c08a6b6",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1267026
      },
      "writtenOn": "2023-03-20T19:03:50Z",
      "side": 1,
      "message": "Thanks Shahbaz and Alexey.\nYes by \u0027RGBA8\u0027 i was referring to the sized format.\nFor webgl1 tests, chrome currently creates a texture for raster on gles3 context with RGBA8 and then that texture is later shared with webgl1 context(gles2).\nBut the current validation checks in angle does not allows RGBA8 to be supported in gles2.\nso requirement here is to mark the texture attachment with that sized internal format as supported on GLES2 if that texture was originally created on GLES3. Note that in this scenario RGBA8 will always be supported by this gles2 context.\n\nI am not very clear on how we should use OES_required_internalformat or other extensions in this scenario. can u explain more clearly.\nThis siliar caching logic has been already implemented in angle for egl images - https://chromium-review.googlesource.com/c/angle/angle/+/4265252",
      "parentUuid": "3adb8bfc_81d6d403",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f336e88e_1ab367cc",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-20T19:27:14Z",
      "side": 1,
      "message": "\u003e I am not very clear on how we should use OES_required_internalformat or other extensions in this scenario.\n\nThat\u0027s easy! Step 1 is to get the code in to expose the extension. For example this code already does this for `OES_rgb8_rgba8`, which looks like ANGLE already supports!\n\n```\n    rgb8Rgba8OES             \u003d DetermineRGB8AndRGBA8TextureSupport(textureCaps);\n```\n\nStep 2 is to fix validation so it allows GL_RGB8 and GL_RGBA8 when `rgb8Rgba8OES` is supported.\n\n\u003e This siliar caching logic has been already implemented in angle for egl images\n\nUgh, hopefully we can revert that hack after the proper fix.",
      "parentUuid": "66d527e3_3c08a6b6",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeacd45b_3d818cc7",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-03-20T19:51:53Z",
      "side": 1,
      "message": "Taking a step back a bit: Ideally we solve this in Chrome by using EGL images. Is it not possible to create an EGL image with a texture source and a texture target? That would make a nice boundary between the WebGL texture and raster/composite textures. I think currently in Chrome these textures are coming from legacy mailboxes or GL texture backed SharedImages. Can we find out which it is try using an EGL image backing?\n\nThe approach used currently in EGL images works because they have an opaque format to GL, we can decide that they are renderable outside of the limitations of extensions.\n\nWe can\u0027t really solve this in the ways mentioned. Caching renderability will break WebGL, extensions are enabled dynamically and textures often go from un-renderable to renderable. Adding a new extension also won\u0027t work because all textures in this format will become renderable in WebGL which isn\u0027t the intention.",
      "parentUuid": "f336e88e_1ab367cc",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e511ed4_f3ecb351",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1267026
      },
      "writtenOn": "2023-03-20T20:11:02Z",
      "side": 1,
      "message": "right now we use egl backed shared images for android 9+ which has DrDc feature enabled(and no other way to share textures directly). My initial thought was also to simply use eglimage backing everywhere instead of gl texture backing. Afaik, that should work but might cause slight regressions in perf in low end devices due to egl image creation sometime being slightly costly.\nThat said i can try enabling it and check perf bots.\ni was under impression that extensions will not work well for reasons you mentioned.\n\nBut not sure why this caching will not work. we determine renderability based on the format set in imagedesc for the texture. anytime the imagedesc is changed, the renderability will be updated accordingly.",
      "parentUuid": "eeacd45b_3d818cc7",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c90e9bdd_b016f875",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-03-21T19:41:11Z",
      "side": 1,
      "message": "I think we should take that small hit unless we can\u0027t rely on EGL images always being present.\n\nFor why caching won\u0027t work: ANGLE supports dynamically enabling extensions for WebGL. This could mean making a texture becoming renderable somewhere in the middle of its lifetime. We would have to invalidate the cached state when extensions are enabled.\n\nI\u0027d also like to avoid it because it\u0027s a spec violation to be able to render to a texture like this. I\u0027d prefer to use a mechanism that\u0027s scoped (not all textures) and for this purpose.",
      "parentUuid": "4e511ed4_f3ecb351",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aacf59ac_190d9004",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1357502
      },
      "writtenOn": "2023-03-23T17:41:14Z",
      "side": 1,
      "message": "I think this leads us to a global decision here, should chrome ever rely on a global shared group or should we always share texture using egl images. For all platforms.\n\nHow does it work on Windows/Linux right now?\n\nIf we use display share group, I\u0027d rather chrome not using glTexStorage for webgl1 backbuffers than using egl images here. Would it solve the problem? Are there any cases when texture created on gles3 context won\u0027t be sample-able in webgl1 context?",
      "parentUuid": "c90e9bdd_b016f875",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a179473_c19949c7",
        "filename": "src/libANGLE/Texture.h",
        "patchSetId": 6
      },
      "lineNbr": 93,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-03-24T21:22:15Z",
      "side": 1,
      "message": "It\u0027s possible that a texture would created by an ES3 context is not renderable or sampleable from an ES2 context.\n\nMoving away from the global share group is a really good goal to have. It makes ANGLE\u0027s architecture more complex and sharing via a GL texture has some context version interactions like this one.\n\nI think we hit the issue here in particular (Nexus 5X) because it doesn\u0027t ever attempt to use EGL image backing for SharedImage. Windows does by default AFIAK. Linux I\u0027m not sure.",
      "parentUuid": "aacf59ac_190d9004",
      "revId": "a3666c8a6dd05f3be749221e595730fd4aec1d72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}