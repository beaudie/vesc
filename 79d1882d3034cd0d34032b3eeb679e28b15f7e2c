{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2247a910_b300c5fe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-29T18:38:47Z",
      "side": 1,
      "message": "These are impressive results, but unfortunately we can\u0027t just unlock things in the backend. This has come up numerous times in the past. See the first section of this comment where I previously explained (to another contributor) why this is dangerous: issuetracker.google.com/268091451#comment5\n\nThe issue of global and display lock is real though (with both deadlocks and performance), and I\u0027m glad you are tackling this. But let\u0027s take a step back and brainstorm a design that fixes things properly once and for all.\n\nI\u0027ll take up the action of learning how the front-end locking works, and then we can perhaps set up a meeting and talk it out. What do you think?",
      "revId": "79d1882d3034cd0d34032b3eeb679e28b15f7e2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80f34512_e5750baa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-29T19:08:02Z",
      "side": 1,
      "message": "\u003e These are impressive results, but unfortunately we can\u0027t just unlock things in the backend. This has come up numerous times in the past. See the first section of this comment where I previously explained (to another contributor) why this is dangerous: issuetracker.google.com/268091451#comment5\n\nI need time to carefully read this. But I understand that it is potentially dangerous.\n\n\u003e In short, we can\u0027t just unlock/lock the mutex in the backend, because neither the backend nor the frontend are written with the assumption that another thread may access the surface during the call.\n\nWhat may happen with the Surface from other thread during ANI?\nI implemented this unlock a very long time ago and investigated before this, that it is safe to unlock the mutex.\n\nUnlocking needed not only to fix this problem with ANI, but also other similar problems. We are using these unlocks and it seems that there is no problems.\n\n\u003e The issue of global and display lock is real though (with both deadlocks and performance), and I\u0027m glad you are tackling this. But let\u0027s take a step back and brainstorm a design that fixes things properly once and for all.\n\nFor this need to know all problems first. \"proper\" solution may take too much time and I\u0027m afraid that we may not wait for it to happen.\n\n\u003e I\u0027ll take up the action of learning how the front-end locking works, and then we can perhaps set up a meeting and talk it out. What do you think?\n\nI think that we need to find what is really wrong with unlocking during ANI. And if there is something wrong - try fix this. And next time take into account that there is unlock during ANI.\nYou say \"we can\u0027t just unlock things in the backend\", but I spend time to investigate. It is not that I just decided to unlock the mutex and do not understand that it is potentially dangerous.",
      "parentUuid": "2247a910_b300c5fe",
      "revId": "79d1882d3034cd0d34032b3eeb679e28b15f7e2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06aa5b25_eb44c83f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-29T18:38:47Z",
      "side": 1,
      "message": "This should be fixed in RenderDoc IMO. it shouldn\u0027t call `eglX` from a call to `vkY`.\n\nWe do have this mutex recursion problem with Android though, and IMO there\u0027s no way to keep things robust as long as ANGLE calls into platform code and the platform code calls back into ANGLE. I\u0027d really like to see Android fixed with this respect and we get rid of the recursiveness of the mutex altogether.",
      "revId": "79d1882d3034cd0d34032b3eeb679e28b15f7e2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdf2360e_d47c7fea",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-29T19:08:02Z",
      "side": 1,
      "message": "\u003e This should be fixed in RenderDoc IMO. it shouldn\u0027t call eglX from a call to vkY.\n\nThat is why I made an option to disable this.\nWhen you need RenderDoc your are not interested who is to blame. Solving this on the RenderDoc side may take time...\n\nAlso there may be other layers as RenderDoc that may have similar problem. We can\u0027t influence everyone...\n\n\u003e We do have this mutex recursion problem with Android though,\n\nNot only a recursion problem. Deadlock happened with two threads that lock two mutexes in a different order.\n\n\u003e  I\u0027d really like to see Android fixed with this respect and we get rid of the recursiveness of the mutex altogether.\n\nAndroid platform must use Vulkan for this.",
      "parentUuid": "06aa5b25_eb44c83f",
      "revId": "79d1882d3034cd0d34032b3eeb679e28b15f7e2c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}