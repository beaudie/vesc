{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "460d53e7_194f187a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-21T20:14:09Z",
      "side": 1,
      "message": "Took another stab at debugging without really knowing what I am doing! Guidance is wanted and appreciated :) ",
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3620427_f00c384b",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "although this is technically a correct change, it\u0027s potentially masking a more serious dirty bit bug. if the issue that the source texture isn\u0027t getting flushed because of the eglMakeCurrent calls blocking some dirty bits, can you test if FramebufferVk::syncState for the **source** FBO happens before we call into the back-end here on the blit call? if it does get called, and we somehow still don\u0027t flush the image updates, that\u0027s indicative it\u0027s a bug with something in that function. if it doesn\u0027t get called, it\u0027s indicative that the dirty objects aren\u0027t reset correctly on a make current call.",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c04608de_6491a80c",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-21T21:03:29Z",
      "side": 1,
      "message": "\u003e can you test if FramebufferVk::syncState for the **source** FBO happens before we call into the back-end here on the blit call?\n\nThe read FBO does appear to have its FramebufferVk::syncState() called with dirty bits 0000001000000000010000000001 during Context::syncStateForBlit().",
      "parentUuid": "e3620427_f00c384b",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2950b084_37cfec48",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T22:19:52Z",
      "side": 1,
      "message": "Thanks Jason!\n\nI\u0027m not sure what that dirty bit mask means although it seems that the dirty bit for color attachment 0 is set?\n\nWhat\u0027s \"dirtyColorAttachments\" after the \"for (size_t dirtyBit : dirtyBits)\" loop?\n\nDo we call \"flushColorAttachmentUpdates\" for the read FBO attachment 0?",
      "parentUuid": "c04608de_6491a80c",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16d06069_0345a8af",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-07-21T22:54:19Z",
      "side": 1,
      "message": "Looking into this, the problem appears to be that FramebufferVk::syncState() is only looking at dirty *draw* render targets, not *read*.   Specifically:\n\n    angle::Result FramebufferVk::syncState(const gl::Context *context,\n                                           GLenum binding,\n                                           const gl::Framebuffer::DirtyBits \u0026dirtyBits,\n                                           gl::Command command)\n    {\n    ...\n        for (size_t colorIndexGL : dirtyColorAttachments)\n        {\n            ASSERT(!previousDeferredClears.test(colorIndexGL));\n            ANGLE_TRY(\n                flushColorAttachmentUpdates(context, deferClears, static_cast\u003cuint32_t\u003e(colorIndexGL)));\n        }\n        \nflushColorAttachmentUpdates() gets the render target via:\n\n    angle::Result FramebufferVk::flushColorAttachmentUpdates(const gl::Context *context,\n                                                             bool deferClears,\n                                                             uint32_t colorIndexGL)\n    {\n        ContextVk *contextVk \u003d vk::GetImpl(context);\n        RenderTargetVk *renderTarget \u003d mRenderTargetCache.getColors()[colorIndexGL];\n    \nWhich is for draw render targets.   We\u0027re missing a check for if the read render target is also dirty.   A quick hack to update it allows the test to pass:\n\n    angle::Result FramebufferVk::flushColorAttachmentUpdates(const gl::Context *context,\n                                                             bool deferClears,\n                                                             uint32_t colorIndexGL)\n    {\n        ContextVk *contextVk \u003d vk::GetImpl(context);\n\n    #if 0 //TIMTIM\n        RenderTargetVk *renderTarget \u003d mRenderTargetCache.getColors()[colorIndexGL];\n    #else\n        RenderTargetVk *renderTarget \u003d getColorReadRenderTarget();\n    #endif\n    \nI\u0027m not sure if we want another version of flushColorAttachmentUpdates() that\u0027s specifically for the read render target and is called in syncState(), or if that should just be added to flushColorAttachmentUpdates().\n\nJamie - Thoughts?",
      "parentUuid": "2950b084_37cfec48",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "389f2c54_a4bdd1ff",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T22:58:33Z",
      "side": 1,
      "message": "Ah, thanks Tim for figuring that out. Yes we should have similar code to flush the read attachment for read FBOs. That would be the most precise fix. Can handle specific design qs tomorrow.",
      "parentUuid": "16d06069_0345a8af",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36f184c1_b35855cf",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-22T14:12:58Z",
      "side": 1,
      "message": "Because the read buffer is also something attached as a color attachment, it should be sufficient to mark the color attachment that the read buffer points to as \"needs update\". This is when you\u0027re processing the dirty bits for the read attachment in syncState.",
      "parentUuid": "389f2c54_a4bdd1ff",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e969818_3b36eb1b",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-22T20:01:58Z",
      "side": 1,
      "message": "\u003e Because the read buffer is also something attached as a color attachment, it should be sufficient to mark the color attachment that the read buffer points to as \"needs update\".\n\nAm I understanding correctly you are suggesting updating\n\n```\ncase gl::Framebuffer::DIRTY_BIT_READ_BUFFER:\n                ANGLE_TRY(mRenderTargetCache.update(context, mState, dirtyBits));\n                break;\n```\n\nwith:\n\n```\ncase gl::Framebuffer::DIRTY_BIT_READ_BUFFER:\n                ANGLE_TRY(mRenderTargetCache.update(context, mState, dirtyBits));\n\n                ANGLE_TRY(updateColorAttachment(context, mState.getReadIndex()));\n                shouldUpdateColorMask  \u003d true;\n                shouldUpdateLayerCount \u003d true;\n                dirtyColorAttachments.set(mState.getReadIndex());\n                break;\n```\n\nIf so, this does not appear to be sufficient to fix the test.",
      "parentUuid": "36f184c1_b35855cf",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b8342a7_d7d99e91",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-07-22T22:47:13Z",
      "side": 1,
      "message": "Jason,\n\nThe issue with your fix is that FramebufferVk::flushColorAttachmentUpdates() is still indexing into the draw color attachments with `mRenderTargetCache.getColors()[colorIndexGL]`.\n\n    const gl::AttachmentArray\u003cRenderTargetT *\u003e \u0026RenderTargetCache\u003cRenderTargetT\u003e::getColors() const\n    {\n        return mColorRenderTargets;\n    }\n    \nInstead, we need to get to the mReadRenderTarget:\n\n    RenderTargetT *RenderTargetCache\u003cRenderTargetT\u003e::getColorRead(\n    const gl::FramebufferState \u0026state) const\n    {\n        return mReadRenderTarget;\n    }\n    \nLooking around, there is RenderTargetCache\u003cRenderTargetT\u003e::updateColorRenderTarget() which we can steal from and come up with:\n\n  angle::Result FramebufferVk::flushColorAttachmentUpdates(const gl::Context *context,\n                                                           bool deferClears,\n                                                           uint32_t colorIndexGL)\n  {\n      ContextVk *contextVk \u003d vk::GetImpl(context);\n      const gl::FramebufferState \u0026state \u003d getState();\n      RenderTargetVk *renderTarget \u003d nullptr;\n\n      if (state.getReadBufferState() !\u003d GL_NONE \u0026\u0026 state.getReadIndex() \u003d\u003d colorIndexGL)\n      {\n          renderTarget \u003d getColorReadRenderTarget();\n      }\n      else\n      {\n          renderTarget \u003d getColorDrawRenderTarget(colorIndexGL);\n      }\n      \nThis version passes the test with the flushAllStagedUpdates() call here removed.\n\nJamie - Is this closer to what you\u0027re describing?",
      "parentUuid": "2e969818_3b36eb1b",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ebb43f4e_6f82b3ee",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-23T12:37:34Z",
      "side": 1,
      "message": "Sounds good Tim. It wasn\u0027t what I was proposing but sounds more correct.",
      "parentUuid": "5b8342a7_d7d99e91",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "379bd9ae_99ded2fe",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T13:53:32Z",
      "side": 1,
      "message": "Thanks Tim! Done.",
      "parentUuid": "ebb43f4e_6f82b3ee",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82d3062c_d06e6924",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1207,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "please run presubmit before you upload changes. in a typical workflow you could use git cl presubmit, which happens automatically when you call git cl upload.",
      "range": {
        "startLine": 1207,
        "startChar": 0,
        "endLine": 1207,
        "endChar": 24
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "993105c6_e859c55e",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1207,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T13:53:32Z",
      "side": 1,
      "message": "Ack, ran presubmit. Was there something specific about this line that you expected presubmit to catch?",
      "parentUuid": "82d3062c_d06e6924",
      "range": {
        "startLine": 1207,
        "startChar": 0,
        "endLine": 1207,
        "endChar": 24
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "344faefa_534f15e2",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1235,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "nit: you can omit this. if you want to verify the color, you can use a PBO or another blit call.",
      "range": {
        "startLine": 1233,
        "startChar": 0,
        "endLine": 1235,
        "endChar": 51
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "957eab4b_5ca6c675",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1235,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T13:53:32Z",
      "side": 1,
      "message": "Removed. This was just a note to see if it helped give any insight as to what was happening.",
      "parentUuid": "344faefa_534f15e2",
      "range": {
        "startLine": 1233,
        "startChar": 0,
        "endLine": 1235,
        "endChar": 51
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}