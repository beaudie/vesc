{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "460d53e7_194f187a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-21T20:14:09Z",
      "side": 1,
      "message": "Took another stab at debugging without really knowing what I am doing! Guidance is wanted and appreciated :) ",
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3620427_f00c384b",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "although this is technically a correct change, it\u0027s potentially masking a more serious dirty bit bug. if the issue that the source texture isn\u0027t getting flushed because of the eglMakeCurrent calls blocking some dirty bits, can you test if FramebufferVk::syncState for the **source** FBO happens before we call into the back-end here on the blit call? if it does get called, and we somehow still don\u0027t flush the image updates, that\u0027s indicative it\u0027s a bug with something in that function. if it doesn\u0027t get called, it\u0027s indicative that the dirty objects aren\u0027t reset correctly on a make current call.",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c04608de_6491a80c",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-21T21:03:29Z",
      "side": 1,
      "message": "\u003e can you test if FramebufferVk::syncState for the **source** FBO happens before we call into the back-end here on the blit call?\n\nThe read FBO does appear to have its FramebufferVk::syncState() called with dirty bits 0000001000000000010000000001 during Context::syncStateForBlit().",
      "parentUuid": "e3620427_f00c384b",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2950b084_37cfec48",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T22:19:52Z",
      "side": 1,
      "message": "Thanks Jason!\n\nI\u0027m not sure what that dirty bit mask means although it seems that the dirty bit for color attachment 0 is set?\n\nWhat\u0027s \"dirtyColorAttachments\" after the \"for (size_t dirtyBit : dirtyBits)\" loop?\n\nDo we call \"flushColorAttachmentUpdates\" for the read FBO attachment 0?",
      "parentUuid": "c04608de_6491a80c",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16d06069_0345a8af",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-07-21T22:54:19Z",
      "side": 1,
      "message": "Looking into this, the problem appears to be that FramebufferVk::syncState() is only looking at dirty *draw* render targets, not *read*.   Specifically:\n\n    angle::Result FramebufferVk::syncState(const gl::Context *context,\n                                           GLenum binding,\n                                           const gl::Framebuffer::DirtyBits \u0026dirtyBits,\n                                           gl::Command command)\n    {\n    ...\n        for (size_t colorIndexGL : dirtyColorAttachments)\n        {\n            ASSERT(!previousDeferredClears.test(colorIndexGL));\n            ANGLE_TRY(\n                flushColorAttachmentUpdates(context, deferClears, static_cast\u003cuint32_t\u003e(colorIndexGL)));\n        }\n        \nflushColorAttachmentUpdates() gets the render target via:\n\n    angle::Result FramebufferVk::flushColorAttachmentUpdates(const gl::Context *context,\n                                                             bool deferClears,\n                                                             uint32_t colorIndexGL)\n    {\n        ContextVk *contextVk \u003d vk::GetImpl(context);\n        RenderTargetVk *renderTarget \u003d mRenderTargetCache.getColors()[colorIndexGL];\n    \nWhich is for draw render targets.   We\u0027re missing a check for if the read render target is also dirty.   A quick hack to update it allows the test to pass:\n\n    angle::Result FramebufferVk::flushColorAttachmentUpdates(const gl::Context *context,\n                                                             bool deferClears,\n                                                             uint32_t colorIndexGL)\n    {\n        ContextVk *contextVk \u003d vk::GetImpl(context);\n\n    #if 0 //TIMTIM\n        RenderTargetVk *renderTarget \u003d mRenderTargetCache.getColors()[colorIndexGL];\n    #else\n        RenderTargetVk *renderTarget \u003d getColorReadRenderTarget();\n    #endif\n    \nI\u0027m not sure if we want another version of flushColorAttachmentUpdates() that\u0027s specifically for the read render target and is called in syncState(), or if that should just be added to flushColorAttachmentUpdates().\n\nJamie - Thoughts?",
      "parentUuid": "2950b084_37cfec48",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "389f2c54_a4bdd1ff",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T22:58:33Z",
      "side": 1,
      "message": "Ah, thanks Tim for figuring that out. Yes we should have similar code to flush the read attachment for read FBOs. That would be the most precise fix. Can handle specific design qs tomorrow.",
      "parentUuid": "16d06069_0345a8af",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36f184c1_b35855cf",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 857,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-22T14:12:58Z",
      "side": 1,
      "message": "Because the read buffer is also something attached as a color attachment, it should be sufficient to mark the color attachment that the read buffer points to as \"needs update\". This is when you\u0027re processing the dirty bits for the read attachment in syncState.",
      "parentUuid": "389f2c54_a4bdd1ff",
      "range": {
        "startLine": 857,
        "startChar": 24,
        "endLine": 857,
        "endChar": 45
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82d3062c_d06e6924",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1207,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "please run presubmit before you upload changes. in a typical workflow you could use git cl presubmit, which happens automatically when you call git cl upload.",
      "range": {
        "startLine": 1207,
        "startChar": 0,
        "endLine": 1207,
        "endChar": 24
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "344faefa_534f15e2",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1235,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-21T20:26:54Z",
      "side": 1,
      "message": "nit: you can omit this. if you want to verify the color, you can use a PBO or another blit call.",
      "range": {
        "startLine": 1233,
        "startChar": 0,
        "endLine": 1235,
        "endChar": 51
      },
      "revId": "2a8f4562bc239d046dad40aea66c2c965cf45fc0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}