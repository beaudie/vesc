{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b019f704_4980ee9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-02-14T21:43:09Z",
      "side": 1,
      "message": "I think we should do a much smaller change here. Here is my proposal:\nBasically we focus on optimize the usage case like hailian\u0027s test, i.e., a back to back glTex{Sub}Image call. In this case, you need layout change for first transfer, there is no way around that. Then the subsequent transfer will actually have no layout change, image already in the desired layout. We need to detect that case and issue memory barrier instead. The code already there, we only need to add this condition into the if check at https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/renderer/vulkan/vk_helpers.cpp;l\u003d6729\n\n    if (mCurrentLayout \u003d\u003d ImageLayout::SharedPresent || mCurrentLayout \u003d\u003d newLayout)\n \n\nFurther, we could even optimize out this memory barrier if that memory barrier itself causes perf issue. There are three different approaches that I can see.\n\nA) We only need to insert memory barrier if there is previous write to that level. i.e., if that specific level does not have any content in it, and image already in that desired layout, we do nothing. \"that specific level does not have any content in it\" can be cheaply implemented by adding another tracking similar to mContentDefined, lets call it mContentInitialized. The only difference is mContentDefined may gets cleared, mContentInitialized never gets cleared.\n\nOr B) Even further, I am personally willing to go slightly out of spec here that \n\nif (mCurrentLayout \u003d\u003d newLayout \u0026\u0026 (mCurrentLayout\u003d\u003d TransferDst|| mCurrentLayout\u003d\u003d TransferDstAndComputeWrite)\n{\n// take risk of WAW and suprress the syncVal complain.\nreturn;\n}\n\nThis is not technically correct but I don\u0027t think it will actually cause any real bug in all GPUs. \n\nOr C), Further improvement on top of A), that you clear the mContentInitialized whenever there is a layout change.\n\nI think A) likely is good enough, but if not, C) is good. Or just do B) and swallow the SyncVal complain.",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77f05ae3_72725660",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-02-14T21:44:31Z",
      "side": 1,
      "message": "In all of above three suggestions, the change will be quite local with minimum CPU overhead.",
      "parentUuid": "b019f704_4980ee9c",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f19523bc_f23847bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-02-14T21:46:57Z",
      "side": 1,
      "message": "I actually provided four suggestions above. Maybe if (mCurrentLayout \u003d\u003d ImageLayout::SharedPresent || mCurrentLayout \u003d\u003d newLayout) just works out well enough?",
      "parentUuid": "77f05ae3_72725660",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de318d51_77a8ba9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-02-15T20:35:52Z",
      "side": 1,
      "message": "Looks like your next CL doing something similar. But I think the change can be much simpler like what I showed in my experimental CL.",
      "parentUuid": "f19523bc_f23847bb",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ab84457_c312bdb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-02-15T20:40:00Z",
      "side": 1,
      "message": "I talked with Amirali about this change. The crux of the issue is that we always assume write-after-write needs a barrier, but that\u0027s not true if the writes are to different parts of the image.\n\nIn `ImageHelper::flushStagedUpdates`, there is an optimization that avoids unnecessary WaW barriers, which as you found out by looking at the next change, I suggested Amirali hoists it up from that function so that WaW barriers can be avoided between any two commands when unnecessary.\n\nWith that optimization, you won\u0027t even need a memory barrier between the texture uploads; the problem really wasn\u0027t the memory barrier (the driver already sees the layouts are the same and turns it into a memory barrier). The problem is the _execution_ barrier that comes with it.\n\nAmirali, maybe set these changes to WIP to make it clear they are being reworked and aren\u0027t meant to be reviewed?",
      "parentUuid": "f19523bc_f23847bb",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5263f532_76f8d3ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-02-15T20:47:57Z",
      "side": 1,
      "message": "Right, that is exactly what I am suggesting in C) as well.\n\nThe other idea is that you do something similar to isEligibleForMutableTextureFlush() logic. Right now we always prefer immediate flush if image already allocated. You could change it to always prefer staged (even for immutable texture), and then you issue the flush when there is a texture switch. That might be a even simpler change, and will work out better since there will be only one flush call per texture.",
      "parentUuid": "7ab84457_c312bdb1",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fb89c7e_6238949e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-02-15T20:59:14Z",
      "side": 1,
      "message": "\u003e The other idea is that you do something similar to isEligibleForMutableTextureFlush() logic\n\nI like the ability to optimize barriers away generally, I had wanted to do that for years, but I agree a lot of places where it might help are probably very rare (like blit after blit to different layers, which might happen in some VR apps). So a stop-gap measure like that is fine too. Let\u0027s see how the generic one turns out, and if it turns into a mess we can go down this route?\n\nThe way I imagine it done feels relatively straightforward TBH.",
      "parentUuid": "5263f532_76f8d3ce",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3aac3431_266a63df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1525982
      },
      "writtenOn": "2024-02-17T01:25:50Z",
      "side": 1,
      "message": "Thank you for the suggestions!\n\nTrue, the first `getOutsideRenderPassCommandBufferHelper()`, when flushing the image updates, adds the write barrier when the texture data is uploaded in a mip level or cubemap face.\n\nA simpler more generalized change has been uploaded, more focused on WAW barriers: https://chromium-review.googlesource.com/c/angle/angle/+/5301855\n\n* It improves the `gpu_time` for Hailin\u0027s test, similar to the current implementation. However, in the new CL, some tests which were using the image as both read and write were failing (including compute-based mipmap generation and self-copy). For this, currently two image layouts have been exempted to always use barriers.",
      "parentUuid": "5fb89c7e_6238949e",
      "revId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:approval_code-owners"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "Submit requirement for the \u0027Verified\u0027 label"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:false"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:true"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:false"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:true"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "7599381f78d596b77753d4a144af560fb2a67ad7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}