{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "308186e5_2f8d9ddd",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2023-01-12T17:10:09Z",
      "side": 1,
      "message": "there\u0027s a bogosity of handling \\r and \\n specially in splitstring. I\u0027d recommend you just alter the algorithm to skip groups of delimiters instead of reporting empty values between each pair of delimiters.",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19500a7d_59b3a77d",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-12T18:00:03Z",
      "side": 1,
      "message": "That is also problematic, if for whatever reason something wants to notice the empty lines (like this stupid protocol: https://microsoft.github.io/debug-adapter-protocol/overview)\n\nMy suggestion is to just `s/\\r//` on the input on the caller side.",
      "parentUuid": "308186e5_2f8d9ddd",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2c5b008_5103856f",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2023-01-12T18:02:30Z",
      "side": 1,
      "message": "I don\u0027t follow what you mean about the debug adapter protocol, can you give an example? This is a text string based protocol?",
      "parentUuid": "19500a7d_59b3a77d",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f70b611d_e3633cf0",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-12T18:04:32Z",
      "side": 1,
      "message": "\u003e Since both the last header field and the overall header itself are each terminated with \\r\\n, and since the header is mandatory, the content part of a message is always preceded (and uniquely identified) by two \\r\\n sequences.",
      "parentUuid": "e2c5b008_5103856f",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73af9f7b_e0802525",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2023-01-12T18:08:01Z",
      "side": 1,
      "message": "Note that what I\u0027m proposing is standard C strtok behaviour, which I verified here:\n\nhttps://godbolt.org/z/nT3v78d61",
      "parentUuid": "e2c5b008_5103856f",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14bba4a0_699a7f57",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2023-01-12T18:08:52Z",
      "side": 1,
      "message": "Shabi, I think for handling the debug adapter protocol, you\u0027re better off writing a custom handler than using angle::SplitString. Can we proceed with my suggestion without getting too afar field?",
      "parentUuid": "73af9f7b_e0802525",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f417283_578970e4",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-12T18:32:52Z",
      "side": 1,
      "message": "I was just mentioning that as an example. I don\u0027t really mind either way, but removing `\\r` from the source seems simpler, doesn\u0027t it?",
      "parentUuid": "14bba4a0_699a7f57",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b11cb3a5_bd512e6a",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2023-01-12T19:36:08Z",
      "side": 1,
      "message": "YMMV. I find pre-parsing the strings to avoid working around an inconsistency in how strtok is implemented (what I would expect) vs our SplitString implementation works (how I copied it directly from Chromium) more confusing than just fixing the parsing.",
      "parentUuid": "1f417283_578970e4",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f6893fa_c2df7e84",
        "filename": "src/common/string_utils.cpp",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2023-01-15T03:43:04Z",
      "side": 1,
      "message": "The problem with searching for multicharacter delimiters is we have to handle both combinations, \"\\n\" and \"\\r\\n\".  So if I do a split on \"\\r\\n\" as a group, it won\u0027t split the \"\\n\" case.  You\u0027d have to call SplitString twice.\n\nI could scan the shaders to see what they are using, but I\u0027m seeing shaders that use a mix!\n\nI\u0027m not too keen on stripping the \"\\r\" on the way in because these are const strings.  So I\u0027d have to make a copy, then call SplitString which makes another copy.\n\nMaybe a new mode to pass in: \"CRLF_is_newline\" and I\u0027ll leave all the other callers alone?\n\nFWIW, if I just pass in \"\\r\\n\" as the collection of delimiters without changing the helper, the shaders compile, they just have extra newlines.",
      "parentUuid": "b11cb3a5_bd512e6a",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 71,
        "endChar": 13
      },
      "revId": "f47d77217ff5a38e74a2bd9b7247737390cee9a5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}