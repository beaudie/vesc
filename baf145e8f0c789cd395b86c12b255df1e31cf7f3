{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "274d898f_2dc901a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-29T17:12:49Z",
      "side": 1,
      "message": "Igor, I apologize I haven\u0027t found the time to review this change yet.\n\nHave you seen the bottom of this commit message? https://chromium-review.googlesource.com/c/angle/angle/+/5006874/6//COMMIT_MSG\n\nI thought about this in the past, I was always a little worried that we\u0027d be implementing a scheduler on top of the OS scheduler and be swamped with complexity and weird behavior because of it.\n\nI am fully aware of the problem, just unsure of the best solution. So I have two asks here:\n\n1. I have a benchmark for this I\u0027ve used in the past: https://chromium-review.googlesource.com/c/angle/angle/+/4859584/ You can see the tasks in perfetto which helps visualize exactly what\u0027s going on and how well the algorithm is working. I assume you also have something you\u0027ve been testing against. How much does this improve things compared with ToT? For my benchmark, I\u0027d easily imagine ~33% reduction in frame time, but it would be good to have an exact measure (verified with a perfetto trace).\n\n2. If instead of all of this, we\u0027d just multiply `mDesiredThreadCount` by 1.5 in ToT of ANGLE, how much do we gain in the same benchmarks? My reasoning for this is that we\u0027d use more threads than there are CPUs, but knowing the link-waits-for-two-compiles pattern, a third of the tasks are blocked, and the rest constitute 100% of the CPUs.\n\nMy hope is that the +50% threads solution gets us close enough to the performance of what you have and we can live with a much simpler implementation.",
      "revId": "baf145e8f0c789cd395b86c12b255df1e31cf7f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4ed8be3_3248fb93",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T17:59:31Z",
      "side": 1,
      "message": "\u003e Have you seen the bottom of this commit message?\n\nYes, I have. In the past and then another time before implementing this.\n\n\u003e I thought about this in the past, I was always a little worried that \nwe\u0027d be implementing a scheduler on top of the OS scheduler and be \nswamped with complexity and weird behavior because of it.\n\nUsing dependency is not mandatory.\nAlso my commits do not change how pools are used in the code.\n\nBut what is complex now?\nWe are already starting tasks from other tasks, but now it will be optimized with dependencies.\nWe will fix problem waiting for shaders in a clean way...\n\u003e How much does this improve things compared with ToT?\n\nI do not have such tests. Also it is hard to make good test. What we need to measure?\n\nI will try to look at your tests, but is there a point?\nIt is look like you already decided to not merge this. Sorry, but I\u0027m tired refactoring from Roman\u0027s suggestions...\n\nI will try to run your tests after I finish...\n\n\u003e For my benchmark, I\u0027d easily imagine ~33% reduction in frame time, but \nit would be good to have an exact measure (verified with a perfetto \ntrace).\n\nTo see differences from my commits need to start using dependencies between tasks. Until then - no significant changes expected.\n\nI implemented this not only to improve the current situation, but to have such functionality available. You are free to ignore dependencies. I\u0027m planning to use it for my own experiments, but remembered, that it might be useful for the current code (probably a mistake)...\n\n\u003e If instead of all of this, we\u0027d just multiply mDesiredThreadCount\n by 1.5 in ToT of ANGLE, how much do we gain in the same benchmarks? My \nreasoning for this is that we\u0027d use more threads than there are CPUs, \nbut knowing the link-waits-for-two-compiles pattern, a third of the \ntasks are blocked, and the rest constitute 100% of the CPUs.\n\nImplementation reason was not to fix specific problem when waiting on shaders in the link task.\n\nWith dependencies we can chain tasks, so that we are not utilizing all threads (create a background thread). For example, we can chain new `CreateMonolithicPipelineTask` to the previous, essentially creating single thread that will compile monolithic pipelines. This can be done manually, but this will require implementing some monolithic pipeline task queue.\n\nIn my work, I wanted to create multiple threads, that will run different stages of the same task. For example pipeline compilation can be divided: load shaders and pipeline data from disk, compiling shader modules, create pipeline. Each this sub-task may be done in different threads. So these threads will act like conveyor stages. But again, we will not load all the available threads. No need to implement scheduling functionality, but rather concentrate on implementing the sub-tasks.\n\nOther part is that we have a `TaskDependencyHint::SubTask`, that will execute sub-task in the same thread as the parent task. Currently this is impossible. When Parent task starts sub-task it itself still running, so the new thread will be started for the sub-task.\n\nWhile I do not have benchmarks, I did quick tests. And simply posting empty tasks runs faster using new implementation than the ToT, because of free thread tracking and avoiding to call `notify_one` unnecessarily (even without any dependencies).\n\n\u003e My hope is that the +50% threads solution gets us close enough to the \nperformance of what you have and we can live with a much simpler \nimplementation.\n\nAgain. Dependency not to fix single problem, but to provide functionality, that may be used for other problems.\n\nTo see if this will work on practice or not, need to have the functionality first (which I do not have).\n\nWe can always stop using dependencies and revert the changes.\n\nI think, that we wasting too much time thinking how scary and complex everything is, instead of trying to understand it...",
      "parentUuid": "274d898f_2dc901a1",
      "revId": "baf145e8f0c789cd395b86c12b255df1e31cf7f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e89bbd40_75c62aa9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-29T19:13:07Z",
      "side": 1,
      "message": "Sorry about all the frustration, Igor.\n\nNote that I did not ask you to make changes according to by comments, but rather asked for your thoughts on my ideas. I did not actually expect you to spend a significant amount of time trying to get them to work, unless you also found them appealing yourself.\n\nAlso note that I myself had to spend a rather significant amount of time to understand the change you\u0027re proposing, and I still do not find the structure easy to reason about and hence error prone for future changes and it makes debugging harder. Changes that are difficult to review tend to be causing maintenance difficulties down the road. This creates risks for the project, which is what ultimately causes discussions. Minimizing or mitigating such risks is part of our job. \"Is there a simpler way to achieve the same goal\" and \"is there a way to make implementation less complex\" are very common questions on that path, let\u0027s please stay focused on the technical details and refrain from making assumptions about other people\u0027s intentions.",
      "parentUuid": "e4ed8be3_3248fb93",
      "revId": "baf145e8f0c789cd395b86c12b255df1e31cf7f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dd6c7e3_4e595cf6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T19:53:45Z",
      "side": 1,
      "message": "\u003e Sorry about all the frustration, Igor.\n\nThank you.\n\n\u003e Note that I did not ask you to make changes according to by comments, \nbut rather asked for your thoughts on my ideas. I did not actually \nexpect you to spend a significant amount of time trying to get them to \nwork, unless you also found them appealing yourself.\n\nI already did as you asked: https://chromium-review.googlesource.com/c/angle/angle/+/5973180\n\nBut I\u0027m not sure that I like it better.\n\nWith templates you need to rely entirely on comments to know what to pass to the method. Also code completion is not working with templates...\n\n\u003e but rather asked for your thoughts on my ideas.\n\nI was spending few week to come up with these classes, methods, names. I\u0027m very critical to myself as well. I\u0027m always trying to compare multiple solutions. But sometimes there is just no better solution (except if not implement it at all).\n\nI\u0027m open to suggestions, but just saying it is confusing, maybe try template, is not very constructive, so I do not know how it may help. As I already mentioned, I was trying to write simplest code possible, that ticked all the boxes and this is the result. In other words - I do not know how to make it simpler. I did all I could.\n\nRegarding splitting `startThreadLocked` into locked/unlocked parts I disagree. Maybe it makes sings clear regarding locking, but will make harder the implementation. But OK, I will to such change in another DRAFT.\n\nRegarding templates. IMO I think, that they generally harder than polymorphism (no clear interface, code completion does not work, convoluted compiler errors). And generally is not always. I\u0027m not a template-phobic. I just think that this solution is not requiring templates.\n\nI agree, that composition is better than inheritance (in order to reuse code and not be used), but more often it requires writing repeated boilerplate code. In this particular case, all classes inside a single CPP, so I decided to go with inheritance for simplicity.\n\n\u003e \"Is there a simpler way to achieve the same goal\" and \"is there a way \nto make implementation less complex\" are very common questions on that \npath,\n\nI\u0027m always asking this myself.\nThe answer is - If there is simpler way - I would have implemented it.\nSo I do not know a simpler way.\n\nIMO, current version is sufficiently simple.\n\n\u003e and I still do not find the structure easy to reason about and hence \nerror prone for future changes and it makes debugging harder.\n\nI open for suggestions.\nBut I need more than just this is complex make it simple.\nThe fact that I made the refactoring to use templates proves that I\u0027m willing to cooperate.\n\n\u003e Changes that are difficult to review tend to be causing maintenance \ndifficulties down the road. This creates risks for the project, which is\n what ultimately causes discussions\n\nI understand, but opposite is also true. Very simple change may brake of fix a lot of thinks.\n\n\u003e let\u0027s please stay focused on the technical details and refrain \nfrom making assumptions about other people\u0027s intentions.\n\nI\u0027m not making assumptions. I\u0027m really physically tired.\nAnd frustrated, because I do no know what I can do so it start to look simpler to you.\n\nSometimes things can\u0027t be simpler...\n\nI even split implementation into separate CLs so it will be simpler to review. Each next CL mostly adds new code - so just review code one CL at a time.\n\nI will really appreciate if you could point to real problems in my code, like a potential deadlock or UB, or something. But currently it is just it is confusing and because of that may cause bugs in the future.",
      "parentUuid": "e89bbd40_75c62aa9",
      "revId": "baf145e8f0c789cd395b86c12b255df1e31cf7f3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}