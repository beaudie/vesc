{
  "comments": [
    {
      "key": {
        "uuid": "320693dd_0fc0006a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T17:53:07Z",
      "side": 1,
      "message": "Can\u0027t VkSemaphore be used for both ways as well?",
      "range": {
        "startLine": 36,
        "startChar": 48,
        "endLine": 42,
        "endChar": 27
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8975ef57_3cf5e2dd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-01-22T18:36:09Z",
      "side": 1,
      "message": "VkSemaphore GPU wait is paired with a submission, which is expensive and undesirable. There\u0027s no CPU wait on semaphores.\n\nIt\u0027s kind of weird that Vulkan has three synchronization semaphores that are really the same thing. Like CPU can wait on Fence, but not event. And semaphores are events that can cross queues. From what I hear, generalizing events to cross queues is too big an implementation hassle (not on the GPU, just the OS glue), so here we are.",
      "parentUuid": "320693dd_0fc0006a",
      "range": {
        "startLine": 36,
        "startChar": 48,
        "endLine": 42,
        "endChar": 27
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11a71612_ab742ed3",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1406,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "This is in reverse order.",
      "range": {
        "startLine": 1399,
        "startChar": 0,
        "endLine": 1406,
        "endChar": 0
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d38b1371_4ab8f8c2",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 81,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "From the description of eglClientWaitSyncKHR, sounds like waiting forever is the correct behavior in that case. Otherwise, flushCommands is unused.",
      "range": {
        "startLine": 80,
        "startChar": 46,
        "endLine": 81,
        "endChar": 25
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96550f3d_d1da65e3",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 87,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "It sounds like it should be possible for eglClientWaitSyncKHR to return before end of submission, i.e. if there are GL commands that were added after creating fence sync and before waiting, it is not necessary to wait for their execution as well.\nIs the current behavior the best we can implement with Vulkan, or is it possible to use something other than VkFence in the end of queue submit to signal the fence sync earlier?",
      "range": {
        "startLine": 87,
        "startChar": 19,
        "endLine": 87,
        "endChar": 82
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e384b3e_c5aebd79",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 91,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "reverse order",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 91,
        "endChar": 77
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d262a039_7766aeb0",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 193,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "I think Jamie wanted to replace egl::Error with angle::Result.\nNot sure if Context already has support for it, though.",
      "range": {
        "startLine": 193,
        "startChar": 0,
        "endLine": 193,
        "endChar": 10
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "132d1b2b_1ec325fd",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.h",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2019-01-22T20:40:01Z",
      "side": 1,
      "message": "I think in ANGLE we usually use containment and not inheritance for Impl functions.",
      "range": {
        "startLine": 53,
        "startChar": 38,
        "endLine": 53,
        "endChar": 56
      },
      "revId": "b6a71b504f39da49d41d5ee1019b990c50e52ca6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}