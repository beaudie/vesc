{
  "comments": [
    {
      "key": {
        "uuid": "fd803f4b_ada4bffa",
        "filename": "src/compiler/translator/SymbolTable.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1088,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-02-20T18:45:07Z",
      "side": 1,
      "message": "I think we should decide what to do here before proceeding to the table implementation.",
      "range": {
        "startLine": 1087,
        "startChar": 2,
        "endLine": 1088,
        "endChar": 28
      },
      "revId": "7fbdd341709da1563e5b1dc07d7dc551c8f07c1b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d113c1a2_f9d9a57c",
        "filename": "src/compiler/translator/SymbolTable.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1088,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2018-02-20T19:10:37Z",
      "side": 1,
      "message": "We could maybe add a second alternative extension field to TSymbol, make it an std::array with length 2 for example since there\u0027s already a function for checking an std::array of extensions. I could also look into a different way to handle ARB_texture_rectangle by defaulting the extension directive state to enabled in case the extension is supported. I\u0027d prefer to do those changes as a separate patch, what do you think?",
      "parentUuid": "fd803f4b_ada4bffa",
      "range": {
        "startLine": 1087,
        "startChar": 2,
        "endLine": 1088,
        "endChar": 28
      },
      "revId": "7fbdd341709da1563e5b1dc07d7dc551c8f07c1b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8917622_f811bbc9",
        "filename": "src/compiler/translator/SymbolTable.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1088,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-02-20T21:56:41Z",
      "side": 1,
      "message": "You could make it a {pointer,count} type array that references other constexpr char arrays of extension names. I looked at your subsequent patches though, and they weren\u0027t quite what I had in mind. Sorry I\u0027ve been busy today, let me take another look and see if I can figure out exactly what I would like to suggest.",
      "parentUuid": "d113c1a2_f9d9a57c",
      "range": {
        "startLine": 1087,
        "startChar": 2,
        "endLine": 1088,
        "endChar": 28
      },
      "revId": "7fbdd341709da1563e5b1dc07d7dc551c8f07c1b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4deb9fa_e53e0bfb",
        "filename": "src/compiler/translator/SymbolTable.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1088,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2018-02-21T08:57:02Z",
      "side": 1,
      "message": "The subsequent patches are still work in progress. It should be possible to construct more of the symbol table structures like mapping from mangled names to built-in symbols beforehand.\n\nThe structure I\u0027ve been thinking about now is that there would be a collection of more fine-grained built-in symbol table levels that are built beforehand. They would then be attached to the symbol table here at symbol table init depending on shader type. We could also look into attaching shader version specific symbol table levels dynamically, so that every symbol table lookup would not need to check for shader version.\n\nEach built-in symbol table level could take the form of a script-generated switch statement that has the hash values as its case labels. Lookup would compute the hash value of the symbol once and then go through the symbol table levels looking for a matching symbol.\n\nThis could also accommodate those symbols which have data that needs to be set at runtime. Symbols that are not constexpr could be accessed in the same switch statements as the constexpr symbols. I don\u0027t think that constexpr unordered_map is supported anyway, so either way we have to roll our own solution for constructing the lookup tables before runtime.\n\nDoes this sound good?\n\nEither way it\u0027s good to remove as many conditions as possible from symbol table init before doing any of these changes.",
      "parentUuid": "e8917622_f811bbc9",
      "range": {
        "startLine": 1087,
        "startChar": 2,
        "endLine": 1088,
        "endChar": 28
      },
      "revId": "7fbdd341709da1563e5b1dc07d7dc551c8f07c1b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}