{
  "comments": [
    {
      "key": {
        "uuid": "0bfb7785_db2fd279",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T21:20:21Z",
      "side": 1,
      "message": "It should be ANGLE_platform_angle_device_type_x11 and the definition would be to use either an GLX or X11 EGL display internally.",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79722c41_59a6fb69",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T23:16:22Z",
      "side": 1,
      "message": "Actually it seems like this should be another dimension entirely; I think all of these configurations are valid:\n\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d egl (*)\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d vulkan\n\n(*) This is what DisplayOzone implements. It should really be renamed to gbm, as unlike other build types ozone doesn\u0027t know what the display type is at compile time.\n\nDisplay type meaning the type of EGLNativeDisplayType which is not what we\u0027re specifying in ANGLE\u0027s \"device type\" attribute. ANGLE doesn\u0027t have its own definition of EGLNativeDisplayType, but it\u0027s taking up the parameter to eglGetPlatformDisplay that disambiguates this on Linux.\n\nEncoding both display type and renderer into one parameter looks like it would be limiting.",
      "parentUuid": "0bfb7785_db2fd279",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b433170f_99c04bfb",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T07:53:27Z",
      "side": 1,
      "message": "Do you mean something like this [1]?\n\nBut how will we identify if it is fuchsia? Does it also use gbm?\nFor wayland - I\u0027m not sure. It crashes with DisplayOzone atm.\n\n\n[1] https://github.com/intel/iotg-lin-gfx-mesa/blob/master/src/egl/main/egldisplay.c#L140",
      "parentUuid": "79722c41_59a6fb69",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac8ae49e_7f880ad7",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:03:10Z",
      "side": 1,
      "message": "We can identify Fuchsia at compile time with ANGLE_PLATFORM_FUCHSIA.\n\nWayland is not supported because there\u0027s no wl_display or wl_surface support in ANGLE right now.\n\nEven if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nOn Linux between X11 and GBM I\u0027d definitely agree we should identify the display type by passing in parameters eglGetPlatformDisplay, not by doing the probing that mesa does. ANGLE EGL should implement\n\n  eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR...)\n  eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,\n                        EGL_PLATFORM_ANGLE_DISPLAY_TYPE_ANGLE \u003d\u003d X11)\n\nChrome would do the latter but the former is what other apps should do if they are using X11 and don\u0027t care who\u0027s providing EGL.\n\nWe could use the existing device type param, but as I said this would be limiting.",
      "parentUuid": "b433170f_99c04bfb",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "325ef47d_f85695ad",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T13:22:45Z",
      "side": 1,
      "message": "\u003e Even if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nExactly, I expected DisplayOzone to work with wayland/gbm, but it crashed (that requires more investigations, but out of the scope of the currents tasks)..\n\nTwo questions just to make it clear:\n\n1) EGL_PLATFORM_X11_KHR should use opengl gl, right? And DisplayEgl impl will be used. We also have EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE display type that uses DisplayEgl impl.\n\n2) You\u0027re proposing to rename EGL_ANGLE_platform_angle_device_type_ozone_angle to EGL_ANGLE_platform_angle_device_type_x11_angle and use as the latter case you mentioned, right?",
      "parentUuid": "ac8ae49e_7f880ad7",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51fef617_8af0dfd6",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:37:54Z",
      "side": 1,
      "message": "Shouldn\u0027t it be DisplayGLX ?\n\nI\u0027m saying that you should likely be able to ask for\n  X11 on DisplayGLX on GLX or EGLGLES\n  X11 on DisplayEGL on swiftshader EGLGLES\n  X11 on DisplayVkXcb on vulkan\n  X11 on DisplayVkXcb on swiftshader vulkan\n\nDo we really want to add 4 new device types for every display type?\n\nSo I was saying that we really need two dimensions: renderer type (which is mostly what device type is doing now) and display type (which would be new, at least for ANGLE, but it is not really new because this is what the |platform| argument to eglGetPlatformDisplay was really for. We could even use those existing platform enums as the value).",
      "parentUuid": "325ef47d_f85695ad",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87dd4b90_59573152",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-22T07:15:36Z",
      "side": 1,
      "message": "Yes. GLX, sorry.\n\nThat\u0027s understandable for what we should ask for. However, I see one problem.\n\neglGetPlatformDisplay looks like\n\nEGL_GetPlatformDisplay(EGLenum platform,\n                       void *native_display,\n                       const EGLAttrib *attrib_list);\n\nwhere platform is EGL_PLATFORM_ANGLE_ANGLE if ANGLE should be used (if I\u0027m not mistaken).\nnative_display is the actual native display, and the attrib_list contains additional attributes including EGL_PLATFORM_ANGLE_TYPE_ANGLE display type attribute that (for linux can be EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE, EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE, or EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE). It also contains additional attribute - EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE, which can be EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE for Linux.\n\nThe CreateDisplayFromAttribs that is called from GetDisplayFromNativeDisplay, which is called by EGL_GetPlatformDisplay looks like\n\nCreateDisplayFromAttribs(EGLAttrib displayType,\n                         EGLAttrib deviceType,\n                         const DisplayState \u0026state);\n\nSo, if we add additional displayType EGL_PLATFORM_ANGLE_DISPLAY_TYPE_ANGLE \u003d\u003d X11, how will be able to choose between OPENGL and OPENGLES? I\u0027m not sure that\u0027s the correct way to do that as it looks like the displayType has already been used for OPENGL and OPENGLES displayTypes.\n\nInstead, we could add 2 new deviceTypes - EGL_ANGLE_platform_angle_device_type_gbm_angle and EGL_ANGLE_platform_angle_device_type_x11_angle (remember that we can compile ozone/x11/wayland/gbm at the same type. None of them should be a default impl if I understand right).\n\nThus,\n\nswitch(displayType) {\ncase EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE:\n  #if defined(ANGLE_USE_GBM)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_GBM_ANGLE) {\n    impl \u003d nullptr;\n    break;\n  }\n  #endif\n\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE) {\n    // This should be disallowed for GBM nativeDisplayType somehow...\n    impl \u003d new DisplayEGL(..);\n    break;\n  }\n\n  #if defined(ANGLE_USE_X11)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE) {\n    impl \u003d new DisplayGLX(..);\n    break;\n  }\n  #endif\n\n  impl \u003d nullptr; // No Display impl available.\n  break;\n\ncase EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE:\n  #if defined(ANGLE_USE_GBM)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_GBM_ANGLE) {\n    impl \u003d DisplayGbm(..);\n    break;\n  }\n  #endif\n\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE) {\n    // This should be disallowed for GBM nativeDisplayType somehow...\n    impl \u003d new DisplayEGL(..);\n    break;\n  }\n\n  #if defined(ANGLE_USE_X11)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE) {\n    impl \u003d new DisplayGLX(..); // But \n    break;\n  }\n  #endif\n\n  impl \u003d nullptr; // No Display impl available.\n  break;\n}\n\nAdding EGL_PLATFORM_ANGLE_TYPE_X11_ANGLE as a new displayType will make it harder to choose between OPENGL and OPENGLES as it looks like EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE and EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE are used in other parts of Angle.\n\nWhy we need two exteensions? I feel like it\u0027s incorrect to allow to choose DisplayGbm by default if not deviceType is provided on Ozone/X11 for example.\n\nAlso, there is a problem with misuse of Angle if ozone/x11/wayland/gbm is compiled. A client can pass EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE for Wayland or Gbm platforms. So it really looks like we have to do probing instead... Wdyt?\n\nPlease also refer to https://cs.chromium.org/chromium/src/ui/gl/gl_surface_egl.h?sq\u003dpackage:chromium\u0026dr\u003dC\u0026g\u003d0\u0026l\u003d55 and https://cs.chromium.org/chromium/src/third_party/angle/src/libANGLE/Display.cpp?q\u003ddisplay.cpp+file:%5Esrc/third_party/angle/+package:%5Echromium$\u0026dr\u003dC\u0026l\u003d231",
      "parentUuid": "51fef617_8af0dfd6",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cb6f630_79cf8465",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-22T12:24:38Z",
      "side": 1,
      "message": "Michael, please see the latest patch set.\n\nIt requires updating Chromium first before landing this... Though, probing the display type might be better in terms of having an automated logic and won\u0027t require changing chromium at all then. Wdyt?",
      "parentUuid": "87dd4b90_59573152",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75386171_2a6f3c01",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-22T14:20:47Z",
      "side": 1,
      "message": "I don\u0027t agree that probing is a better solution, we shouldn\u0027t have to rely on probing for correct behavior. New code should not use eglGetDisplay at all if eglGetPlatformDisplay is available. eglGetPlatformDisplay is supposed to solve any ambiguity about display types, it just doesn\u0027t if you select ANGLE as the platform.\n\nIn your code: \n\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE) {\n    // This should be disallowed for GBM nativeDisplayType somehow...\n    impl \u003d new DisplayEGL(..);\n    break;\n  }\n\nHow do you select the lower platform type for EGL? Maybe call the new argument EGL_PLATFORM_ANGLE_EGL_PLATFORM_ANGLE and have it be the value of |platform| ANGLE passes to eglGetPlatformDisplay.",
      "parentUuid": "1cb6f630_79cf8465",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "558b865c_9e217822",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-22T14:38:58Z",
      "side": 1,
      "message": "Here\u0027s ANGLE\u0027s call to eglGetDisplay that should be able to set to eglGetPlatformDisplay if the caller requests it:\n\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/angle/src/libANGLE/renderer/gl/egl/FunctionsEGL.cpp;drc\u003d9d737966acdf628a7cb4e12e4781179ea3be5d7b;l\u003d186\n\n|platform| that we would pass to eglGetPlatformDisplay is currently a free variable; there is no way for the caller to upper eglGetPlatformDisplay to set that.",
      "parentUuid": "75386171_2a6f3c01",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6a6a7f8_40940fe4",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-22T17:01:23Z",
      "side": 1,
      "message": "what do you mean by lower platform type?\n\nswitch displayType {\ncase OPENGL_ANGLE:\nif deviceType \u003d\u003d NULL || deviceType \u003d\u003d GBM\n  impl \u003d\u003d NULL\n\nif deviceType \u003d\u003d EGL\n  impl \u003d DisplayEgl\n\nif deviceType \u003d\u003d X11\n  impl \u003d DisplayGLX\n\ncase OPENGLES_ANGLE:\n\nif deviceType \u003d\u003d NULL\n  impl \u003d\u003d NULL\n\nif deviceType \u003d\u003d EGL\n  impl \u003d DisplayEgl\n\nif deviceType \u003d\u003d X11\n  impl \u003d DisplayGLX\n\nif deviceType \u003d\u003d GBM\n  impl \u003d DisplayGbm\n\n}\n\nIsn’t that sufficient? or am I missing something? I’m sorry I’m new to egl implementation internals.",
      "parentUuid": "558b865c_9e217822",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f52ca972_4f5b3f93",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-22T18:49:07Z",
      "side": 1,
      "message": "Lower platform type \u003d\u003d the first argument that *ANGLE* should be passing to eglGetPlatformDisplay()\n\ne.g., one of the following values\n\n  EGL_PLATFORM_X11_EXT\n  EGL_PLATFORM_WAYLAND_EXT (if we ever got wayland egl support)\n  EGL_PLATFORM_GBM_KHR (*)\n\n(*) This isn\u0027t what DisplayOzone does, that display was written to run tests and is not compatible with a specified platform. It should ought to be rewritten so that it is compatible with mesa\u0027s gbm platform. Modesetting doesn\u0027t belong in libGLES.",
      "parentUuid": "c6a6a7f8_40940fe4",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb66ba71_4becc072",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-24T21:52:21Z",
      "side": 1,
      "message": "BTW we\u0027re having a bit of a problem with terminology here. I said:\n\n * Display type meaning the type of EGLNativeDisplayType\n\nThis was probably the wrong term to use, sorry; I didn\u0027t mean what Chrome calls \"display type\" which seems to be the product of egl provider and aspects of its configuration. I should have said \"native display type\".\n\nThe platform type is closely related to native display type because platform types have specific requirements for the native display type as described in EXT_platform_base:\n\n  Any specification that does define a valid value for\n    \u003cplatform\u003e will also define requirements for the \u003cnative_display\u003e\n    parameter.\n\nClarifying and extending those requirements in the case of ANGLE are what we\u0027re talking about here. For ANGLE EGL on platform\u0027s EGL there may be two platform types:\n\nUpper:\n   chrome -\u003e ANGLE EGL\n      eglGetPlatformDisplay(upper \u003d\u003d EGL_PLATFORM_ANGLE_ANGLE, ....)\n\nLower:\n   ANGLE EGL -\u003e platform EGL\n      eglGetPlatformDisplay(lower \u003d\u003d EGL_PLATFORM_X11_EXT, ...)\n\nBut how do you tell ANGLE to use EGL_PLATFORM_X11_EXT instead of something else? That\u0027s what we\u0027re missing.\n\n(This is specific to EGL on EGL. It is obvious that EGL on GLX uses an X display).",
      "parentUuid": "f52ca972_4f5b3f93",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11a26a1a_684d0b17",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-25T07:40:19Z",
      "side": 1,
      "message": "I\u0027m confused now. EGL_GetPlatformDisplay doesn\u0027t support platform \u003d\u003d EGL_PLATFORM_X11_EXT [1]. It only supports EGL_PLATFORM_DEVICE_EXT (and it looks like it only supports D3D9/11 internally [2]) and EGL_PLATFORM_ANGLE_ANGLE. If you pass EGL_PLATFORM_X11_EXT, Angle will return \"eglGetPlatformDisplay: Bad platform type\". I believe we are trying to solve something outside of the scope of current effort. Probably... Also, you\u0027re referring to lower platform type as -\n\nLower:\n\n   ANGLE EGL -\u003e platform EGL\n      eglGetPlatformDisplay(lower \u003d\u003d EGL_PLATFORM_X11_EXT, ...)\n\nwhere and when exactly does that happen? I grepped ANGLE, and here what it shows - \n\n$ git grep -ni \"eglGetPlatformDisplay(\"\n\nextensions/EGL_ANGLE_feature_control.txt:92:        EGLDisplay eglGetPlatformDisplay(EGLenum platform, void\n\nsrc/libEGL/libEGL.cpp:341:EGLDisplay EGLAPIENTRY eglGetPlatformDisplay(EGLenum platform,\n\nsrc/tests/egl_tests/EGLFeatureControlTest.cpp:39:        mDisplay              \u003d eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,\n\nsrc/tests/egl_tests/EGLFeatureControlTest.cpp:174:    EGLDisplay dpy_override \u003d eglGetPlatformDisplay(\n\nutil/EGLWindow.cpp:232:        mDisplay \u003d eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,\n\n\nAs you can see, there is only one call to eglGetPlatformDisplay inside angle and uses EGL_PLATFORM_ANGLE_ANGLE platform type.\n\n\nThe only problem can be the EGL_getDisplay entry point [3], which doesn\u0027t have parameters that specify the platform and device type. It just calls GetDisplayFromNativeDisplay that internally calls \"display \u003d new Display(EGL_PLATFORM_ANGLE_ANGLE, nativeDisplay, nullptr);\" if Display doesn\u0027t exist, and then it chooses GLX on X11 (without this patch). That\u0027s the only problem I can see now. And it seems like the only way to figure out what kind of native display type was passed is by probing that.\n\nIn case of Ozone, it\u0027s simply impossible to choose between different display implementations without probing. EGL_getDisplay won\u0027t work at all.\n\n[1] http://source.chromium.org/chromium/chromium/src/+/master:third_party/angle/src/libGLESv2c/entry_points_egl.cpp;l\u003d987\n[2] https://source.chromium.org/chromium/chromium/src/+/master:third_party/angle/src/libANGLE/Display.cpp;l\u003d121;drc\u003d7f2a66319b71e1cd3be556aeaa50cd18d1be70c1?originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F\n[3] https://source.chromium.org/chromium/chromium/src/+/master:third_party/angle/src/libGLESv2/entry_points_egl.cpp;l\u003d72?q\u003dEGL_getDisplay\u0026ss\u003dchromium%2Fchromium%2Fsrc\u0026originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F\n\n\n1) To sum up, ANGLE\u0027s eglGetPlatformDisplay doesn\u0027t allow to pass EGL_PLATFORM_X11_EXT. If you do that, it returns \"eglGetPlatformDisplay: Bad platform type\".\n2) ANGLE\u0027s impl of eglGetDisplay gets broken with Ozone, because it doesn\u0027t have attributes parameters. Thus, the native display type has to be probed instead.",
      "parentUuid": "eb66ba71_4becc072",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b79a27c1_095c7d0d",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-25T16:25:44Z",
      "side": 1,
      "message": "I didn\u0027t say ANGLE was passing eglGetPlatformDisplay(). I said that it should be calling eglGetPlatformDisplay().\n\nThis is highly relevant to the current problem because that\u0027s how you select the native display type without probing through the pointer. Please don\u0027t say this is out of scope, we need to make sure the solution we adopt will solve these problems cleanly.",
      "parentUuid": "11a26a1a_684d0b17",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c013b3f5_f0fa777e",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-25T16:49:45Z",
      "side": 1,
      "message": "\u003e In case of Ozone, it\u0027s simply impossible to choose between different display implementations without probing. EGL_getDisplay won\u0027t work at all.\n\nIt is not impossible, it is simply not implemented.\n\n(I\u0027m not going to ask you to implement every missing feature of ANGLE for every ozone platform out there. The only thing I\u0027m asking is that we adopt as a solution that makes sense as part of a broader solution to those problems).",
      "parentUuid": "b79a27c1_095c7d0d",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d98d731d_73c4c617",
        "filename": "include/EGL/eglext_angle.h",
        "patchSetId": 2
      },
      "lineNbr": 115,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-20T15:39:49Z",
      "side": 1,
      "message": "I also wonder what\u0027s the procedure to choose next available enum",
      "range": {
        "startLine": 115,
        "startChar": 51,
        "endLine": 115,
        "endChar": 57
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}