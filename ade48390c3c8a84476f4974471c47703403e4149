{
  "comments": [
    {
      "key": {
        "uuid": "0bfb7785_db2fd279",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T21:20:21Z",
      "side": 1,
      "message": "It should be ANGLE_platform_angle_device_type_x11 and the definition would be to use either an GLX or X11 EGL display internally.",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79722c41_59a6fb69",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T23:16:22Z",
      "side": 1,
      "message": "Actually it seems like this should be another dimension entirely; I think all of these configurations are valid:\n\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d egl (*)\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d vulkan\n\n(*) This is what DisplayOzone implements. It should really be renamed to gbm, as unlike other build types ozone doesn\u0027t know what the display type is at compile time.\n\nDisplay type meaning the type of EGLNativeDisplayType which is not what we\u0027re specifying in ANGLE\u0027s \"device type\" attribute. ANGLE doesn\u0027t have its own definition of EGLNativeDisplayType, but it\u0027s taking up the parameter to eglGetPlatformDisplay that disambiguates this on Linux.\n\nEncoding both display type and renderer into one parameter looks like it would be limiting.",
      "parentUuid": "0bfb7785_db2fd279",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b433170f_99c04bfb",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T07:53:27Z",
      "side": 1,
      "message": "Do you mean something like this [1]?\n\nBut how will we identify if it is fuchsia? Does it also use gbm?\nFor wayland - I\u0027m not sure. It crashes with DisplayOzone atm.\n\n\n[1] https://github.com/intel/iotg-lin-gfx-mesa/blob/master/src/egl/main/egldisplay.c#L140",
      "parentUuid": "79722c41_59a6fb69",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac8ae49e_7f880ad7",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:03:10Z",
      "side": 1,
      "message": "We can identify Fuchsia at compile time with ANGLE_PLATFORM_FUCHSIA.\n\nWayland is not supported because there\u0027s no wl_display or wl_surface support in ANGLE right now.\n\nEven if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nOn Linux between X11 and GBM I\u0027d definitely agree we should identify the display type by passing in parameters eglGetPlatformDisplay, not by doing the probing that mesa does. ANGLE EGL should implement\n\n  eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR...)\n  eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,\n                        EGL_PLATFORM_ANGLE_DISPLAY_TYPE_ANGLE \u003d\u003d X11)\n\nChrome would do the latter but the former is what other apps should do if they are using X11 and don\u0027t care who\u0027s providing EGL.\n\nWe could use the existing device type param, but as I said this would be limiting.",
      "parentUuid": "b433170f_99c04bfb",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "325ef47d_f85695ad",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T13:22:45Z",
      "side": 1,
      "message": "\u003e Even if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nExactly, I expected DisplayOzone to work with wayland/gbm, but it crashed (that requires more investigations, but out of the scope of the currents tasks)..\n\nTwo questions just to make it clear:\n\n1) EGL_PLATFORM_X11_KHR should use opengl gl, right? And DisplayEgl impl will be used. We also have EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE display type that uses DisplayEgl impl.\n\n2) You\u0027re proposing to rename EGL_ANGLE_platform_angle_device_type_ozone_angle to EGL_ANGLE_platform_angle_device_type_x11_angle and use as the latter case you mentioned, right?",
      "parentUuid": "ac8ae49e_7f880ad7",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51fef617_8af0dfd6",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:37:54Z",
      "side": 1,
      "message": "Shouldn\u0027t it be DisplayGLX ?\n\nI\u0027m saying that you should likely be able to ask for\n  X11 on DisplayGLX on GLX or EGLGLES\n  X11 on DisplayEGL on swiftshader EGLGLES\n  X11 on DisplayVkXcb on vulkan\n  X11 on DisplayVkXcb on swiftshader vulkan\n\nDo we really want to add 4 new device types for every display type?\n\nSo I was saying that we really need two dimensions: renderer type (which is mostly what device type is doing now) and display type (which would be new, at least for ANGLE, but it is not really new because this is what the |platform| argument to eglGetPlatformDisplay was really for. We could even use those existing platform enums as the value).",
      "parentUuid": "325ef47d_f85695ad",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d98d731d_73c4c617",
        "filename": "include/EGL/eglext_angle.h",
        "patchSetId": 2
      },
      "lineNbr": 115,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-20T15:39:49Z",
      "side": 1,
      "message": "I also wonder what\u0027s the procedure to choose next available enum",
      "range": {
        "startLine": 115,
        "startChar": 51,
        "endLine": 115,
        "endChar": 57
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}