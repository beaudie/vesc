{
  "comments": [
    {
      "key": {
        "uuid": "0bfb7785_db2fd279",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T21:20:21Z",
      "side": 1,
      "message": "It should be ANGLE_platform_angle_device_type_x11 and the definition would be to use either an GLX or X11 EGL display internally.",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79722c41_59a6fb69",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-20T23:16:22Z",
      "side": 1,
      "message": "Actually it seems like this should be another dimension entirely; I think all of these configurations are valid:\n\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d x11, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d glx\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d egl swiftshader\nbuild type \u003d\u003d ozone, display type \u003d\u003d x11, renderer \u003d vulkan swiftshader\n\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d egl (*)\nbuild type \u003d\u003d ozone, display type \u003d\u003d gbm, device type \u003d\u003d vulkan\n\n(*) This is what DisplayOzone implements. It should really be renamed to gbm, as unlike other build types ozone doesn\u0027t know what the display type is at compile time.\n\nDisplay type meaning the type of EGLNativeDisplayType which is not what we\u0027re specifying in ANGLE\u0027s \"device type\" attribute. ANGLE doesn\u0027t have its own definition of EGLNativeDisplayType, but it\u0027s taking up the parameter to eglGetPlatformDisplay that disambiguates this on Linux.\n\nEncoding both display type and renderer into one parameter looks like it would be limiting.",
      "parentUuid": "0bfb7785_db2fd279",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b433170f_99c04bfb",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T07:53:27Z",
      "side": 1,
      "message": "Do you mean something like this [1]?\n\nBut how will we identify if it is fuchsia? Does it also use gbm?\nFor wayland - I\u0027m not sure. It crashes with DisplayOzone atm.\n\n\n[1] https://github.com/intel/iotg-lin-gfx-mesa/blob/master/src/egl/main/egldisplay.c#L140",
      "parentUuid": "79722c41_59a6fb69",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac8ae49e_7f880ad7",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:03:10Z",
      "side": 1,
      "message": "We can identify Fuchsia at compile time with ANGLE_PLATFORM_FUCHSIA.\n\nWayland is not supported because there\u0027s no wl_display or wl_surface support in ANGLE right now.\n\nEven if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nOn Linux between X11 and GBM I\u0027d definitely agree we should identify the display type by passing in parameters eglGetPlatformDisplay, not by doing the probing that mesa does. ANGLE EGL should implement\n\n  eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR...)\n  eglGetPlatformDisplay(EGL_PLATFORM_ANGLE_ANGLE,\n                        EGL_PLATFORM_ANGLE_DISPLAY_TYPE_ANGLE \u003d\u003d X11)\n\nChrome would do the latter but the former is what other apps should do if they are using X11 and don\u0027t care who\u0027s providing EGL.\n\nWe could use the existing device type param, but as I said this would be limiting.",
      "parentUuid": "b433170f_99c04bfb",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "325ef47d_f85695ad",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-21T13:22:45Z",
      "side": 1,
      "message": "\u003e Even if Wayland was supported, I\u0027m not sure if Chrome would be able to be able to pass the display to the GPU process to use it. For Wayland on GBM maybe the gbm platform could be used with modifications.\n\nExactly, I expected DisplayOzone to work with wayland/gbm, but it crashed (that requires more investigations, but out of the scope of the currents tasks)..\n\nTwo questions just to make it clear:\n\n1) EGL_PLATFORM_X11_KHR should use opengl gl, right? And DisplayEgl impl will be used. We also have EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE display type that uses DisplayEgl impl.\n\n2) You\u0027re proposing to rename EGL_ANGLE_platform_angle_device_type_ozone_angle to EGL_ANGLE_platform_angle_device_type_x11_angle and use as the latter case you mentioned, right?",
      "parentUuid": "ac8ae49e_7f880ad7",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51fef617_8af0dfd6",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1001794
      },
      "writtenOn": "2020-05-21T13:37:54Z",
      "side": 1,
      "message": "Shouldn\u0027t it be DisplayGLX ?\n\nI\u0027m saying that you should likely be able to ask for\n  X11 on DisplayGLX on GLX or EGLGLES\n  X11 on DisplayEGL on swiftshader EGLGLES\n  X11 on DisplayVkXcb on vulkan\n  X11 on DisplayVkXcb on swiftshader vulkan\n\nDo we really want to add 4 new device types for every display type?\n\nSo I was saying that we really need two dimensions: renderer type (which is mostly what device type is doing now) and display type (which would be new, at least for ANGLE, but it is not really new because this is what the |platform| argument to eglGetPlatformDisplay was really for. We could even use those existing platform enums as the value).",
      "parentUuid": "325ef47d_f85695ad",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87dd4b90_59573152",
        "filename": "extensions/EGL_ANGLE_platform_angle_device_type_ozone_angle.txt",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-22T07:15:36Z",
      "side": 1,
      "message": "Yes. GLX, sorry.\n\nThat\u0027s understandable for what we should ask for. However, I see one problem.\n\neglGetPlatformDisplay looks like\n\nEGL_GetPlatformDisplay(EGLenum platform,\n                       void *native_display,\n                       const EGLAttrib *attrib_list);\n\nwhere platform is EGL_PLATFORM_ANGLE_ANGLE if ANGLE should be used (if I\u0027m not mistaken).\nnative_display is the actual native display, and the attrib_list contains additional attributes including EGL_PLATFORM_ANGLE_TYPE_ANGLE display type attribute that (for linux can be EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE, EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE, or EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE). It also contains additional attribute - EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE, which can be EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE for Linux.\n\nThe CreateDisplayFromAttribs that is called from GetDisplayFromNativeDisplay, which is called by EGL_GetPlatformDisplay looks like\n\nCreateDisplayFromAttribs(EGLAttrib displayType,\n                         EGLAttrib deviceType,\n                         const DisplayState \u0026state);\n\nSo, if we add additional displayType EGL_PLATFORM_ANGLE_DISPLAY_TYPE_ANGLE \u003d\u003d X11, how will be able to choose between OPENGL and OPENGLES? I\u0027m not sure that\u0027s the correct way to do that as it looks like the displayType has already been used for OPENGL and OPENGLES displayTypes.\n\nInstead, we could add 2 new deviceTypes - EGL_ANGLE_platform_angle_device_type_gbm_angle and EGL_ANGLE_platform_angle_device_type_x11_angle (remember that we can compile ozone/x11/wayland/gbm at the same type. None of them should be a default impl if I understand right).\n\nThus,\n\nswitch(displayType) {\ncase EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE:\n  #if defined(ANGLE_USE_GBM)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_GBM_ANGLE) {\n    impl \u003d nullptr;\n    break;\n  }\n  #endif\n\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE) {\n    // This should be disallowed for GBM nativeDisplayType somehow...\n    impl \u003d new DisplayEGL(..);\n    break;\n  }\n\n  #if defined(ANGLE_USE_X11)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE) {\n    impl \u003d new DisplayGLX(..);\n    break;\n  }\n  #endif\n\n  impl \u003d nullptr; // No Display impl available.\n  break;\n\ncase EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE:\n  #if defined(ANGLE_USE_GBM)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_GBM_ANGLE) {\n    impl \u003d DisplayGbm(..);\n    break;\n  }\n  #endif\n\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_EGL_ANGLE) {\n    // This should be disallowed for GBM nativeDisplayType somehow...\n    impl \u003d new DisplayEGL(..);\n    break;\n  }\n\n  #if defined(ANGLE_USE_X11)\n  if (deviceType \u003d\u003d EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE) {\n    impl \u003d new DisplayGLX(..); // But \n    break;\n  }\n  #endif\n\n  impl \u003d nullptr; // No Display impl available.\n  break;\n}\n\nAdding EGL_PLATFORM_ANGLE_TYPE_X11_ANGLE as a new displayType will make it harder to choose between OPENGL and OPENGLES as it looks like EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE and EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE are used in other parts of Angle.\n\nWhy we need two exteensions? I feel like it\u0027s incorrect to allow to choose DisplayGbm by default if not deviceType is provided on Ozone/X11 for example.\n\nAlso, there is a problem with misuse of Angle if ozone/x11/wayland/gbm is compiled. A client can pass EGL_PLATFORM_ANGLE_DEVICE_TYPE_X11_ANGLE for Wayland or Gbm platforms. So it really looks like we have to do probing instead... Wdyt?\n\nPlease also refer to https://cs.chromium.org/chromium/src/ui/gl/gl_surface_egl.h?sq\u003dpackage:chromium\u0026dr\u003dC\u0026g\u003d0\u0026l\u003d55 and https://cs.chromium.org/chromium/src/third_party/angle/src/libANGLE/Display.cpp?q\u003ddisplay.cpp+file:%5Esrc/third_party/angle/+package:%5Echromium$\u0026dr\u003dC\u0026l\u003d231",
      "parentUuid": "51fef617_8af0dfd6",
      "range": {
        "startLine": 3,
        "startChar": 4,
        "endLine": 3,
        "endChar": 48
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d98d731d_73c4c617",
        "filename": "include/EGL/eglext_angle.h",
        "patchSetId": 2
      },
      "lineNbr": 115,
      "author": {
        "id": 1228974
      },
      "writtenOn": "2020-05-20T15:39:49Z",
      "side": 1,
      "message": "I also wonder what\u0027s the procedure to choose next available enum",
      "range": {
        "startLine": 115,
        "startChar": 51,
        "endLine": 115,
        "endChar": 57
      },
      "revId": "ade48390c3c8a84476f4974471c47703403e4149",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}