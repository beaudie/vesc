{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1eae8e63_dde1c134",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-10T17:24:50Z",
      "side": 1,
      "message": "Why not just add this:\n```\nVkResult SharedFence::waitUnlocked(VkDevice device, std::unique_lock\u003cstd::mutex\u003e *lock, uint64_t timeout) const\n{\n    if (mRefCountedFence !\u003d nullptr)\n    {\n        ASSERT(lock-\u003eowns_lock());\n        lock-\u003eunlock();\n        VkResult result \u003d mRefCountedFence-\u003eget().wait(device, timeout);\n        lock-\u003elock();\n        return result;\n    }\n    return VK_SUCCESS;\n}\n```\nThe ScopedUnlock is inherently risky. For ScopedLock, people tend to declare it at the entry of the block. ScopedUnlock is opposite, you want to declare as close to where you want to unlock as possible, why is counter intuitive, and that is why I am worried here.",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed0e775a_12d8f68d",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T17:37:51Z",
      "side": 1,
      "message": "I added `ScopedUnlock` for code reuse. One of my changes uses it to unlock Global mutex when do `vkAcquireNextImageKHR()`. With the Global mutex you do not have access to the `std::unique_lock\u003c\u003e` instance.\n\nSorry, but I do not see a problem with unlock. For me it is the same as lock, but opposite...\n\nI also have questions. Why add `if (mRefCountedFence !\u003d nullptr)` and why `SharedFence::wait()` also have check for `nullptr` but everywhere the is explicit check before calling this function? I would rather add `ASSERT()`.",
      "parentUuid": "1eae8e63_dde1c134",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "daf1e464_f4815647",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-10T18:15:45Z",
      "side": 1,
      "message": "`if (mRefCountedFence !\u003d nullptr)` check probably carried from old code. You can double check and turn to ASSERT if needed.\n\n\u003eFor me it is the same as lock, but opposite. \n\nMy point is that if you lock too early, usually it will still work. If you unlock too early, other local variables will construct/destruct without lock. ScopedLock is popular and people form the habit of do it at entry of block. In this example, if it is a scoped lock, typical code will look like this:\n```\n{\n    ScopedLock lock(mMutex);\n    const SharedFence localSharedFenceToWaitOn \u003d sharedFence;\n    ....\n}    \n```\n```\nBut with ScopedUnlock, you actually have to do the opposite\n{\n    const SharedFence localSharedFenceToWaitOn \u003d sharedFence;\n    ScopedUnlock unlock(mMutex);\n    ....\n}    \n```\nThis is why I am not feel comfortable here. But since you moved to a helper function now, the danger is reduced for now. It is more for other people use it in other places may want to watch for the tripping hazard. If you insist, use ScopedUnlock in SharedFence::waitUnlocked(), I will be okay with it.",
      "parentUuid": "ed0e775a_12d8f68d",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}