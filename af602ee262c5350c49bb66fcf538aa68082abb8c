{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1eae8e63_dde1c134",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-10T17:24:50Z",
      "side": 1,
      "message": "Why not just add this:\n```\nVkResult SharedFence::waitUnlocked(VkDevice device, std::unique_lock\u003cstd::mutex\u003e *lock, uint64_t timeout) const\n{\n    if (mRefCountedFence !\u003d nullptr)\n    {\n        ASSERT(lock-\u003eowns_lock());\n        lock-\u003eunlock();\n        VkResult result \u003d mRefCountedFence-\u003eget().wait(device, timeout);\n        lock-\u003elock();\n        return result;\n    }\n    return VK_SUCCESS;\n}\n```\nThe ScopedUnlock is inherently risky. For ScopedLock, people tend to declare it at the entry of the block. ScopedUnlock is opposite, you want to declare as close to where you want to unlock as possible, why is counter intuitive, and that is why I am worried here.",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed0e775a_12d8f68d",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T17:37:51Z",
      "side": 1,
      "message": "I added `ScopedUnlock` for code reuse. One of my changes uses it to unlock Global mutex when do `vkAcquireNextImageKHR()`. With the Global mutex you do not have access to the `std::unique_lock\u003c\u003e` instance.\n\nSorry, but I do not see a problem with unlock. For me it is the same as lock, but opposite...\n\nI also have questions. Why add `if (mRefCountedFence !\u003d nullptr)` and why `SharedFence::wait()` also have check for `nullptr` but everywhere the is explicit check before calling this function? I would rather add `ASSERT()`.",
      "parentUuid": "1eae8e63_dde1c134",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "daf1e464_f4815647",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-10T18:15:45Z",
      "side": 1,
      "message": "`if (mRefCountedFence !\u003d nullptr)` check probably carried from old code. You can double check and turn to ASSERT if needed.\n\n\u003eFor me it is the same as lock, but opposite. \n\nMy point is that if you lock too early, usually it will still work. If you unlock too early, other local variables will construct/destruct without lock. ScopedLock is popular and people form the habit of do it at entry of block. In this example, if it is a scoped lock, typical code will look like this:\n```\n{\n    ScopedLock lock(mMutex);\n    const SharedFence localSharedFenceToWaitOn \u003d sharedFence;\n    ....\n}    \n```\n```\nBut with ScopedUnlock, you actually have to do the opposite\n{\n    const SharedFence localSharedFenceToWaitOn \u003d sharedFence;\n    ScopedUnlock unlock(mMutex);\n    ....\n}    \n```\nThis is why I am not feel comfortable here. But since you moved to a helper function now, the danger is reduced for now. It is more for other people use it in other places may want to watch for the tripping hazard. If you insist, use ScopedUnlock in SharedFence::waitUnlocked(), I will be okay with it.",
      "parentUuid": "ed0e775a_12d8f68d",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a500e30_9dcfe760",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T18:39:09Z",
      "side": 1,
      "message": "I understand now.\nFor me the word \"unlock\"\u003d\u003d\"danger\", so it is not wise to apply same patterns as for the \"lock\".\n\nBut I also understand now, that unlocking should be used for small part of the code, and automatic locking is not that necessary.\n\nSo it is 1 vs 1.\n`ScopedUnlock` on the other hand, ensures that lock will be acquired again no matter what (this is my primary argument), but on the other hand - habit placing scoped object at the beginning of the scope.\n\nI\u0027m not insisting. Will abandon this CL.",
      "parentUuid": "daf1e464_f4815647",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dce6e1dd_4071b587",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1171,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-06T19:04:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5a500e30_9dcfe760",
      "range": {
        "startLine": 1170,
        "startChar": 8,
        "endLine": 1171,
        "endChar": 99
      },
      "revId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:approval_code-owners"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "Submit requirement for the \u0027Verified\u0027 label"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:false"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:true"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:false"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:true"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "af602ee262c5350c49bb66fcf538aa68082abb8c",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}