{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4bbc93b9_fd974ffc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 37,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T16:44:37Z",
      "side": 1,
      "message": "Thank you for detailing these. Please turn these into tests under `src/tests/egl_tests` so the fix can be verified by the bots, and we can be sure we won\u0027t regress these patterns.",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1297f379_4f19166d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 37,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T17:30:38Z",
      "side": 1,
      "message": "I do not know how to write such test.\nProblem is that result is only can be seen by a human on the screen, and it will also depend on device.\nIf I write the tests like described in the comment, they will probably just pass even without this fix.",
      "parentUuid": "4bbc93b9_fd974ffc",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d644ccd_a4c33d35",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 37,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:07:02Z",
      "side": 1,
      "message": "Understood. We do have a few tests like this, they still help verify things visually when necessary.\n\nIn this particular case, VVL would probably complain about the lack of synchronization so the test _can_ fail.",
      "parentUuid": "1297f379_4f19166d",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61cab957_a6b4b4a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 37,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:37:05Z",
      "side": 1,
      "message": "Ok. I will prepare the tests.",
      "parentUuid": "4d644ccd_a4c33d35",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e07e22b8_a3fba1dc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 39,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T16:44:51Z",
      "side": 1,
      "message": "nit: Bug tag",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7eb8b85c_8ffe5e05",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.h",
        "patchSetId": 2
      },
      "lineNbr": 405,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T16:44:37Z",
      "side": 1,
      "message": "This looks like an unrelated refactor, please split into its own CL.\n\nUltimately (one day) we should be using an enum class instead of bool, and use angle::PackedEnumMap (which would also let us expand this if necessary)",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b295c70_cd71b095",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.h",
        "patchSetId": 2
      },
      "lineNbr": 405,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T17:30:38Z",
      "side": 1,
      "message": "Did not like it either. Will make additional CL.",
      "parentUuid": "7eb8b85c_8ffe5e05",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2910af6_c736ee93",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T16:44:37Z",
      "side": 1,
      "message": "What do you think about getting the semaphore out of the window _here_ and add it to `mWaitSemaphores`? Then you would avoid the multiple calls to `flushAcquireImageSemaphore` in SurfaceVk.cpp (and risk missing a case in the future)",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "120d4192_c2ad09f8",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T17:30:38Z",
      "side": 1,
      "message": "I do not see problems. I think I just did not think about this. Thank you)\n\nThe only theoretical problem may be if there are repeated eglSwapBuffers() and no commands is recorded. But it should not be possible. Additionally there will be signalSemaphore that will force flushOutsideRenderPassCommands().",
      "parentUuid": "d2910af6_c736ee93",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a5bc653_e092fcd0",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-01-30T19:47:18Z",
      "side": 1,
      "message": "Actually is it possible? I can\u0027t think out what will prevent it, even though no real usage may do it this way.\n\nOr why not do it at the time VkAcuqireNextImage is called? i.e.\n\nWindowSurfaceVk::acquireNextSwapchainImage()\n{\n...\n   vkAcquireNextImageKHR();\n   contextVk-\u003eaddWaitSemaphore()               \n...\n}\n\nThis way it seems more robust: if you acquire the image, you should wait for the semaphore.",
      "parentUuid": "120d4192_c2ad09f8",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c0fa47c_48a63a00",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T20:12:05Z",
      "side": 1,
      "message": "\u003e Actually is it possible?\n\n```\nangle::Result WindowSurfaceVk::prepareSwapImpl(const gl::Context *context)\n{\n    ANGLE_TRACE_EVENT0(\"gpu.angle\", \"WindowSurfaceVk::prepareSwap\");\n    if (mNeedToAcquireNextSwapchainImage)\n    {\n        // Acquire the next image (previously deferred). The image may not have been already\n        // acquired if there was no rendering done at all to the default framebuffer in this frame,\n        // for example if all rendering was done to FBOs.\n        ANGLE_TRACE_EVENT0(\"gpu.angle\", \"Acquire Swap Image Before Swap\");\n        ANGLE_TRY(doDeferredAcquireNextImage(context, false));\n    }\n    if (mAcquireImageSemaphore)\n    {\n        flushAcquireImageSemaphore(context);\n    }\n    return angle::Result::Continue;\n}\n```\n\nThe comment above suggest it is possible.\nHowever, there should be commands recorded in the `prePresentSubmit()`.\nAnd even if there is no commands, `signalSemaphore` in the `flushImpl()` will enforce `flushOutsideRenderPassCommands()`.\n\n\u003e Or why not do it at the time VkAcuqireNextImage is called? i.e.\n\nBecause it takes `vk::Context *context` and not `ContextVk`.\nInitial images is acquired using `DisplayVk`. Also there is `lockSurface()`.",
      "parentUuid": "6a5bc653_e092fcd0",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4da8aa3_94e018a5",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-31T17:29:55Z",
      "side": 1,
      "message": "@syoussefi@chromium.org\n\u003e What do you think about getting the semaphore out of the window here and add it to mWaitSemaphores? Then you would avoid the multiple calls to flushAcquireImageSemaphore in SurfaceVk.cpp (and risk missing a case in the future)\n\nI checked this in details and I prefer the original solution. Problem will be fixed, however why it will work is not obvious. And, there is also a chance that bug may still happen, or will happen in the future.\n\nFirst I think that the problem might be with empty `eglSwapBuffers()` calls. I checked this, and there no commands recorded, nor RP started between these calls. But `flushOutsideRenderPassCommands()` still will called. There are 2 reasons:\n1. We have `signalSemaphore` in the `flushImpl()` (so that call will not be skipped)\n2. There are unconditional `flushOutsideRenderPassCommands()` that was added here\n[2168114](https://chromium-review.googlesource.com/c/angle/angle/+/2168114) and has nothing to to with our problem.\n\nAbove is not the only \"problem\". The problem **(1)** described in the *commit message* still may happen.\nHowever, I was not able to reproduce the issue. This is because, ANGLE always calls `flushOutsideRenderPassCommands()` before starting RP or any other access to the Windows Surface. I tried: `glClear()`, `glClearBufferfv()`, `glBlitFramebuffer()`, `glDrawArrays()`, and `glReadPixels()`. But maybe there is or will be a possibility to render into Window Surface without this `flushOutsideRenderPassCommands()` call.\n\nIn other words, `flushOutsideRenderPassCommands()` **MUST** be called **before any access** to the Window Surface. This guarantee is not obvious.\n\nAdditionally (not realistic), Windows Surface may used only as a *Read Buffer*, so the `mCurrentWindowSurface` will be NULL. Maybe this is also a problem and need to also track `mCurrentReadWindowSurface` for example.\n\nAnother point, is that there will be extra \"if\" in the `flushOutsideRenderPassCommands()` that will almost always be false.\n\nSo I like the original solution more. It does not depend on many indirect factors. It is encapsulated in the `WindowSurfaceVk` class. And in case we miss `flushAcquireImageSemaphore()` in the future - it may be easily detected with existing assert. But if it is not missed - semaphore will be added before any possible access.",
      "parentUuid": "4c0fa47c_48a63a00",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95c61a08_dad93316",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-01-31T17:45:00Z",
      "side": 1,
      "message": "My question is why we need it for outsideRPCommands? Can\u0027t we do it in \nContextVk::startRenderPass()\n{\n    ...\n    if(drawFramebufferVk-\u003egetBackbuffer()!\u003dnullptr)\n    {\n        addWaitSemaphore();\n    }\n    ...\n}\nIt is renderpass that uses image and this will reflect exact that. Is this not enough?",
      "parentUuid": "b4da8aa3_94e018a5",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4fc1268_41d94090",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-31T18:28:24Z",
      "side": 1,
      "message": "Not only a renderpass may use the image. It may be transfer command in the outside RP. We must ensure that we do not touch the image by any access before the semaphore signaled.\n\nI tested my original fix and it even works for `glReadPixels()`, when Windows Surface is used only as a *Read Buffer*. Also the does fix not require understanding how the rest of the code works, so less chance of breaking something (or the fix will be easier - all logic inside `WindowSurfaceVk`).",
      "parentUuid": "95c61a08_dad93316",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0c99c65_f5c49f43",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 7443,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-01-31T22:48:04Z",
      "side": 1,
      "message": "sounds good to me. I think what you did actually is similar to what I suggested above (\"do it at the time VkAcuqireNextImage is called?\"). I don\u0027t know if there is a cleaner way to do it. Will leave to shabi for determination.",
      "parentUuid": "e4fc1268_41d94090",
      "revId": "5aad424133b6e24b3fa345f833bb550e53937d06",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}