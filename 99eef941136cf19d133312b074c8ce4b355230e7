{
  "comments": [
    {
      "key": {
        "uuid": "4ef827c0_52e09654",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-26T23:01:23Z",
      "side": 1,
      "message": "Fixed some logic errors.  I still want to simplify this some more.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d78c1605_9509b02f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-27T03:57:00Z",
      "side": 1,
      "message": "This CL is NOT READY for a thorough review yet, but I have a question ...\n\nThere are 6 states (my original 3 x 2 for m*Enabled) that can enter endRP.  Patchset 3 uses both m*InvalidatedState and m*Enabled (where * is either Depth or Stencil).\n\nQUESTION: Would you rather I keep it as is OR use 6 states and eliminate m*Enabled?\n\nFYI ... A thorough state diagram allowed me to handle all states and transitions.  The Invalidated+Enabled state is key:\n\n- Any time entering Invalidated+Enabled, the number of draw commands must be recorded/saved\n\n- Any time leaving Invalidated+Enabled, the recorded \u0026 current number of draw commands must be compared to determine whether the attachment becomes NoLongerInvalidated.\n\nIn the morning, I\u0027ll address your answer(s), simplify the code (e.g. create 1/more helper(s)), and  thoroughly test this.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4af4e9c5_6720d367",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-27T14:27:55Z",
      "side": 1,
      "message": "Hey Ian, this shares some commonality with my idea but it has a lot more state tracking than I was imagining. I was thinking you record the command count at time of invalidate and at time of depth disabled. No tracking of if the depth is enabled or the invalidated state.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ff01d67_a2d32f8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-27T15:50:33Z",
      "side": 1,
      "message": "Hi Jamie.  I started implementing your idea, including both counts.  I ran into scenarios that I couldn\u0027t handle (cases with multiple permutations of enables, disables, invalidates, and draws).  \n\nFor example, your approach works well for the PUBG case of draw-invalidate-disable-draw-endRP.  At endRP, the second counter differentiates between whether the attachment was drawn to after invalidate and before disable.  \n\nWhat happens if the app enables the attachment again (like dEQP does), and either does or doesn\u0027t draw after enabling?  If I did endRP processing for that transition, I could see whether it had been drawn to while it was previously enabled (STORE no matter what future drawing occurs).  If not, I really needed to get the command count again in order to see if any draws occurred after being re-enabled.  The different scenarios continue.\n\nI started drawing state diagrams to articulate and handle every GLES-valid scenario.  After a while, I saw patterns that simplified it.  There are:\n\n- 6 states (not counting endRP)\n- 4 transitions from each state (enable, disable, invalidate, endRP).\n- Command counts are only essential when entering/leaving 1 state.\n- For endRP, I need to decide on:\n  - STORE vs. DONT_CARE for the current RP\n  - LOAD vs. DONT_CARE for a future RP\n\nI re-used my old states and m*Enabled values, but I can encode 5 of the states as special \"command count\" values, if you want.",
      "parentUuid": "4af4e9c5_6720d367",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd64f1bc_df6a0c90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-27T16:17:44Z",
      "side": 1,
      "message": "\u003e What happens if the app enables the attachment again (like dEQP does), and either does or doesn\u0027t draw after enabling?\n\nIf you re-enable depth, you clear the command count at time of depth disable. (e.g. set it to infinite)\n\nThen on endRP you check min(depth disable command count, rp command count) against invalidateCommandCount -\u003e if they match you invalidate.\n\nif there were no draws, min(disable, rp count) \u003d\u003d invalidate count\nif there were draws, min(disable, rp count) !\u003d invalidate count\n\nI didn\u0027t quite follow what you were saying after this so maybe we could catch up offline. I think this scheme works, just not sure if I missed some detail.",
      "parentUuid": "4ff01d67_a2d32f8e",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "196df8fa_fa5f292d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-27T18:57:36Z",
      "side": 1,
      "message": "\u003e If you re-enable depth, you clear the command count at time of depth disable. (e.g. set it to infinite)\n\nYou\u0027d make the \"invalidate count\" infinite?\n\n\u003e I didn\u0027t quite follow what you were saying after this so maybe we could catch up offline. I think this scheme works, just not sure if I missed some detail.\n\nI\u0027d like to chat with you, when convenient for you.  I updated the design doc (removed lots of old/obsolete stuff) with what I think your design is, and what mine is.  I tried to comment on where I think there are details that you are missing (if I understand correctly) because of not keeping track of the state.  Look below the paragraph with \"Regardless of whether the code tracks the state\" in it.\n\nSome example scenarios:\n\ndraw-invalidate-draw-disable-enable-endRP (correctly handled)\n\ndraw-invalidate-disable-enable-endRP (wrong if I understand you)",
      "parentUuid": "bd64f1bc_df6a0c90",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6b4865b_246ad385",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-28T00:54:50Z",
      "side": 1,
      "message": "Jamie and I videoconferenced.  He was referring to setting the disable count infinity.  We talked through a number of cases, and modified things so that they will hopefully handle all cases (I need to work through the details).\n\nAfter discussing the revert of the one mContentDefined CL, there\u0027s a bias to land this CL using the state-based approach, and try to move mConentDefined to ImageHandler sooner.  After rebasing this CL on top of the revert, I am reminded that there are cases where mContentDefined can only be accurate at endRP.  If I have time, I want to try the count-only-based approach.  But getting mContentDefined first seems best.",
      "parentUuid": "196df8fa_fa5f292d",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04351cca_184e2018",
        "filename": "src/libANGLE/renderer/vulkan/SecondaryCommandBuffer.h",
        "patchSetId": 3
      },
      "lineNbr": 696,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-28T00:54:50Z",
      "side": 1,
      "message": "Jamie\u0027s counsel was to use mCommands.size().  In my testing, mCommands.size() stays constant most of the time, since larger blocks are allocated, and multiple commands fit within an allocated block.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9660b5c5_fde142a8",
        "filename": "src/libANGLE/renderer/vulkan/SecondaryCommandBuffer.h",
        "patchSetId": 3
      },
      "lineNbr": 696,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-28T14:54:18Z",
      "side": 1,
      "message": "Ah, of course. We don\u0027t have an actual command count. I think mCommands.size() is just the number of blocks rather than the number of commands. We\u0027d either need to add a command count or use the pair of {mCommands.size(), write offset}",
      "parentUuid": "04351cca_184e2018",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f9b90bf_c71234ea",
        "filename": "src/libANGLE/renderer/vulkan/SecondaryCommandBuffer.h",
        "patchSetId": 3
      },
      "lineNbr": 696,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-28T15:01:08Z",
      "side": 1,
      "message": "What do you think of my new approach (in Patchset 4)?",
      "parentUuid": "9660b5c5_fde142a8",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0a76f06_293ecee5",
        "filename": "src/libANGLE/renderer/vulkan/SecondaryCommandBuffer.h",
        "patchSetId": 3
      },
      "lineNbr": 696,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-28T15:29:42Z",
      "side": 1,
      "message": "Looks good! Suggest you use uint32_t or uint64_t explicitly instead of size_t. Also it\u0027s not a count anymore so we should call it something else.",
      "parentUuid": "3f9b90bf_c71234ea",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30168c6b_93a8edc0",
        "filename": "src/libANGLE/renderer/vulkan/SecondaryCommandBuffer.h",
        "patchSetId": 3
      },
      "lineNbr": 696,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-28T18:23:33Z",
      "side": 1,
      "message": "We chatted offline, and decided to keep using count (since there wasn\u0027t a great alternative).",
      "parentUuid": "b0a76f06_293ecee5",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}