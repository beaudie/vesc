{
  "comments": [
    {
      "key": {
        "uuid": "4ef827c0_52e09654",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-26T23:01:23Z",
      "side": 1,
      "message": "Fixed some logic errors.  I still want to simplify this some more.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d78c1605_9509b02f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-27T03:57:00Z",
      "side": 1,
      "message": "This CL is NOT READY for a thorough review yet, but I have a question ...\n\nThere are 6 states (my original 3 x 2 for m*Enabled) that can enter endRP.  Patchset 3 uses both m*InvalidatedState and m*Enabled (where * is either Depth or Stencil).\n\nQUESTION: Would you rather I keep it as is OR use 6 states and eliminate m*Enabled?\n\nFYI ... A thorough state diagram allowed me to handle all states and transitions.  The Invalidated+Enabled state is key:\n\n- Any time entering Invalidated+Enabled, the number of draw commands must be recorded/saved\n\n- Any time leaving Invalidated+Enabled, the recorded \u0026 current number of draw commands must be compared to determine whether the attachment becomes NoLongerInvalidated.\n\nIn the morning, I\u0027ll address your answer(s), simplify the code (e.g. create 1/more helper(s)), and  thoroughly test this.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4af4e9c5_6720d367",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-27T14:27:55Z",
      "side": 1,
      "message": "Hey Ian, this shares some commonality with my idea but it has a lot more state tracking than I was imagining. I was thinking you record the command count at time of invalidate and at time of depth disabled. No tracking of if the depth is enabled or the invalidated state.",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ff01d67_a2d32f8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-08-27T15:50:33Z",
      "side": 1,
      "message": "Hi Jamie.  I started implementing your idea, including both counts.  I ran into scenarios that I couldn\u0027t handle (cases with multiple permutations of enables, disables, invalidates, and draws).  \n\nFor example, your approach works well for the PUBG case of draw-invalidate-disable-draw-endRP.  At endRP, the second counter differentiates between whether the attachment was drawn to after invalidate and before disable.  \n\nWhat happens if the app enables the attachment again (like dEQP does), and either does or doesn\u0027t draw after enabling?  If I did endRP processing for that transition, I could see whether it had been drawn to while it was previously enabled (STORE no matter what future drawing occurs).  If not, I really needed to get the command count again in order to see if any draws occurred after being re-enabled.  The different scenarios continue.\n\nI started drawing state diagrams to articulate and handle every GLES-valid scenario.  After a while, I saw patterns that simplified it.  There are:\n\n- 6 states (not counting endRP)\n- 4 transitions from each state (enable, disable, invalidate, endRP).\n- Command counts are only essential when entering/leaving 1 state.\n- For endRP, I need to decide on:\n  - STORE vs. DONT_CARE for the current RP\n  - LOAD vs. DONT_CARE for a future RP\n\nI re-used my old states and m*Enabled values, but I can encode 5 of the states as special \"command count\" values, if you want.",
      "parentUuid": "4af4e9c5_6720d367",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd64f1bc_df6a0c90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-27T16:17:44Z",
      "side": 1,
      "message": "\u003e What happens if the app enables the attachment again (like dEQP does), and either does or doesn\u0027t draw after enabling?\n\nIf you re-enable depth, you clear the command count at time of depth disable. (e.g. set it to infinite)\n\nThen on endRP you check min(depth disable command count, rp command count) against invalidateCommandCount -\u003e if they match you invalidate.\n\nif there were no draws, min(disable, rp count) \u003d\u003d invalidate count\nif there were draws, min(disable, rp count) !\u003d invalidate count\n\nI didn\u0027t quite follow what you were saying after this so maybe we could catch up offline. I think this scheme works, just not sure if I missed some detail.",
      "parentUuid": "4ff01d67_a2d32f8e",
      "revId": "99eef941136cf19d133312b074c8ce4b355230e7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}