{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1acdae20_4aff8ff7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-23T17:29:50Z",
      "side": 1,
      "message": "Heading offline - so going to pre-approve for when the bots are green. Tim can you handle the follow-ups?",
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7de2750_bf6596cb",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1742,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-07-23T17:29:50Z",
      "side": 1,
      "message": "nit: you don\u0027t need to cache the state, just use mState.",
      "range": {
        "startLine": 1742,
        "startChar": 8,
        "endLine": 1742,
        "endChar": 13
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53d7cf3d_6663a1a2",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1742,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T18:06:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7de2750_bf6596cb",
      "range": {
        "startLine": 1742,
        "startChar": 8,
        "endLine": 1742,
        "endChar": 13
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb5313b7_e88cddbb",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-07-23T16:37:29Z",
      "side": 1,
      "message": "Looks like these function calls are too conservative.   We\u0027ll need to get the values directly, since it\u0027s possible for to not have any attachments (so renderTarget remains null).   We should at least be able to add the valid() check once we know the pointer is good.\n\n    RenderTargetVk *renderTarget \u003d nullptr;\n    // Check the read render target first.\n    if (state.getReadBufferState() !\u003d GL_NONE \u0026\u0026 state.getReadIndex() \u003d\u003d colorIndexGL)\n    {\n        renderTarget \u003d mRenderTargetCache.getColorRead(mState);\n    }\n    // If that\u0027s not valid, then default to the draw render target.\n    if (renderTarget \u003d\u003d nullptr)\n    {\n        renderTarget \u003d mRenderTargetCache.getColorDraw(mState, colorIndexGL);\n    }\n\n    // No attachments bound, so nothing to do.\n    if (renderTarget \u003d\u003d nullptr)\n    {\n        return angle::Result::Continue;\n    }\n    ASSERT(renderTarget-\u003egetImageForRenderPass().valid());",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61ce5e22_d30a0122",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-07-23T17:47:00Z",
      "side": 1,
      "message": "+1. Except I would get the draw RT first (as I presume the FBO is more often synced for draw than read), and do the more complicated readRT check if drawRT is nullptr.",
      "parentUuid": "bb5313b7_e88cddbb",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bec95b3a_39e6a163",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T18:06:31Z",
      "side": 1,
      "message": "Getting the draw RT first makes the new test fail. Both \n\n```\nmRenderTargetCache.getColorRead(mState);\n```\n\n```\nmRenderTargetCache.getColorDraw(mState, colorIndexGL);\n```\n\nappear to be non-nullptr pointers.",
      "parentUuid": "61ce5e22_d30a0122",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "589df280_c7350a47",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-07-23T18:08:51Z",
      "side": 1,
      "message": "Hm, maybe we need to do both when both attachments exist?   I\u0027m not familiar enough with how things work in this area.",
      "parentUuid": "bec95b3a_39e6a163",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cca56f42_cd84b34a",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-07-23T18:11:55Z",
      "side": 1,
      "message": "But shouldn\u0027t they point to the same image? If they don\u0027t, then getting either first is wrong as Tim pointed out.\n\nCan you investigate a bit please and figure out how exactly the two RTs are different?",
      "parentUuid": "589df280_c7350a47",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36b3441_c8a4f53d",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-10T17:24:27Z",
      "side": 1,
      "message": "They are separate attachments[1].   I believe this is expected due to the test explicitly binding a different read and draw surface for the blit (to show the bug), but I\u0027m not an expert in how all the surface/attachment/binding stuff works.\n\nI\u0027ve put together a CL that flushes staged updates to both read and draw attachments (PS #2):\nhttps://chromium-review.googlesource.com/c/angle/angle/+/3078980/2\n\nNote that it fails several VulkanPerformanceCounterTest tests due to increasing the renderpass count.\n\nIt seems only doing read first (if it exists), otherwise doing write, \"works\", but I\u0027m not sure if that\u0027s actually correct.   Instead, I\u0027m wondering if the VulkanPerformanceCounterTest tests need to be updated with the new values so we can do both read/write if they exist.\n\n\n[1]: Here is the gdb data when breaking in FramebufferVk::flushColorAttachmentUpdates().   Note that getColorRead() and getColorDraw() return different pointers.\n\nStack:\n    rx::FramebufferVk::flushColorAttachmentUpdates FramebufferVk.cpp:1742\n    rx::FramebufferVk::syncState FramebufferVk.cpp:1906\n    gl::Framebuffer::syncState Framebuffer.cpp:2051\n    gl::State::syncReadFramebuffer State.cpp:3305\n    gl::State::syncDirtyObjects State.h:1185\n    gl::Context::syncDirtyObjects Context.inl.h:106\n    gl::Context::syncState Context.cpp:4086\n    gl::Context::syncStateForBlit Context.cpp:5283\n    gl::Context::blitFramebuffer Context.cpp:4146\n    GL_BlitFramebuffer entry_points_gles_3_0_autogen.cpp:227\n    (anonymous namespace)::EGLSurfaceTest_BlitBetweenSurfaces_Test::TestBody EGLSurfaceTest.cpp:1238\n\nLocal variables and parameters:\n    colorIndexGL \u003d {uint32_t} 0\n    context \u003d {const gl::Context * | 0x560b9cc3ca40} 0x560b9cc3ca40\n    contextVk \u003d {rx::ContextVk * | 0x560b9cc429f0} 0x560b9cc429f0\n    deferClears \u003d {bool} false\n    renderTarget \u003d {rx::RenderTargetVk * | 0x0} NULL\n    this \u003d {rx::FramebufferVk * | 0x560b9d9591b0} 0x560b9d9591b0\n\nEvaluate getColorRead():\n    mRenderTargetCache.getColorRead(mState)\n        result \u003d {rx::RenderTargetVk * | 0x560b9d5decb0} 0x560b9d5decb0\n             mImage \u003d {rx::vk::ImageHelper * | 0x560b9d5ded30} 0x560b9d5ded30\n             mImageViews \u003d {rx::vk::ImageViewHelper * | 0x560b9d5deee8} 0x560b9d5deee8\n             mLayerCount \u003d {uint32_t} 1\n             mLayerIndex \u003d {uint32_t} 0\n             mLevelIndexGL \u003d {gl::LevelIndex} \n             mResolveImage \u003d {rx::vk::ImageHelper * | 0x0} NULL\n             mResolveImageViews \u003d {rx::vk::ImageViewHelper * | 0x0} NULL\n             mTransience \u003d {rx::RenderTargetTransience} rx::RenderTargetTransience::Default\n             rx::FramebufferAttachmentRenderTarget \u003d {rx::FramebufferAttachmentRenderTarget} \n\nEvaluate getColorDraw():\n    mRenderTargetCache.getColorDraw(mState, colorIndexGL)\n        result \u003d {rx::RenderTargetVk * | 0x560b9d5e5650} 0x560b9d5e5650\n             mImage \u003d {rx::vk::ImageHelper * | 0x560b9d5e56d0} 0x560b9d5e56d0\n             mImageViews \u003d {rx::vk::ImageViewHelper * | 0x560b9d5e5888} 0x560b9d5e5888\n             mLayerCount \u003d {uint32_t} 1\n             mLayerIndex \u003d {uint32_t} 0\n             mLevelIndexGL \u003d {gl::LevelIndex} \n             mResolveImage \u003d {rx::vk::ImageHelper * | 0x0} NULL\n             mResolveImageViews \u003d {rx::vk::ImageViewHelper * | 0x0} NULL\n             mTransience \u003d {rx::RenderTargetTransience} rx::RenderTargetTransience::Default\n             rx::FramebufferAttachmentRenderTarget \u003d {rx::FramebufferAttachmentRenderTarget}",
      "parentUuid": "cca56f42_cd84b34a",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1313b81_fd529e81",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1754,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-10T17:28:14Z",
      "side": 1,
      "message": "There is no separate \"read attachment\" in GL. It\u0027s just a read buffer index, which is a pointer to one of the indexed draw attachments. Does that clear anything up?",
      "parentUuid": "a36b3441_c8a4f53d",
      "range": {
        "startLine": 1741,
        "startChar": 0,
        "endLine": 1754,
        "endChar": 5
      },
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cef175b4_d763ecbf",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1227,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-07-23T17:47:00Z",
      "side": 1,
      "message": "Comment should say \"clear surface1\"",
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6171a454_8f1e7898",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1227,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T18:06:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cef175b4_d763ecbf",
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af0ef89d_d30e83d9",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1233,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-07-23T17:47:00Z",
      "side": 1,
      "message": "This comment also needs updating",
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "794d7726_b867696c",
        "filename": "src/tests/egl_tests/EGLSurfaceTest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1233,
      "author": {
        "id": 1379716
      },
      "writtenOn": "2021-07-23T18:06:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "af0ef89d_d30e83d9",
      "revId": "aa1d8610167be06e0c30b6749100a1a9e93b10d9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}