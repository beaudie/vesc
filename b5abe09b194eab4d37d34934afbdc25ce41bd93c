{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0d24b295_0f502393",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-04-11T23:45:33Z",
      "side": 1,
      "message": "Some additional updates might be needed here per `EGL_KHR_mutable_render_buffer` spec:\n```\n    If surface is a single-buffered window, pixmap, or pbuffer surface for which\n    there is a pending change to the EGL_RENDER_BUFFER attribute, eglSwapBuffers\n    performs an implicit flush operation on the context and effects the\n    attribute change. If surface is a single-buffered window, pixmap, or pbuffer\n    surface for which there is no pending change to the EGL_RENDER_BUFFER\n    attribute, eglSwapBuffers has no effect.\n```\nI can see now `glFlush` is doing the right thing. Can we update `eglSwapBuffers` to follow the spec as well? I see some apps doing redundant `eglSwapBuffers` but ANGLE is still doing the `WindowSurfaceVk::present` there (hurts performance). That is better to be avoided I think.",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6dff10c_3a61bd0a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-04-11T23:47:06Z",
      "side": 1,
      "message": "I mean `WindowSurfaceVk::present` better to be switched with a hook to `ContextVk::flushImpl` with autorefresh mode.",
      "parentUuid": "0d24b295_0f502393",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "802cc3ad_ad233bb7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-04-12T03:18:24Z",
      "side": 1,
      "message": "The default behavior is demond_refresh, which is a more power efficient mode because SurfaceFlinger don’t need to wake itself up for each vsync.\n\neglSwapBuffers has to do both queueBuffer and dequeueBuffer for the shared buffer.\n\nauto_refresh is enabled by the platform with EGL_ANDROID_front_buffer_auto_refresh extension used. That’t an extension implemented in the platform EGL wrapper, and it shortcuts the EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID surface attribute…With that enabled, the queue and dequeue buffer calls will no longer be binder IPC calls but will both immediately return.\n\nFor angle, it’s tricky since the swapchain creation will reset the native window status. That should be fine since after window surface creation, the app can call eglSurfaceAttrib to set the auto_refresh mode on the surface. For Vulkan swapchain creation, angle just needs to create with demond_refresh.\n\nAnother way is to let platform pass through that attribute to angle, however, which requires platform changes…one more alternative is to always use auto_refresh for front rendering, but at the cost of more power consuming.",
      "tag": "mailMessageId\u003d\u003cCAKT\u003ddDkr9tcQRPoZZYMqL6ngpnFBWQHRdJHjZy6dr6JxL0smxw@mail.gmail.com\u003e",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62a054be_d0d2fea5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-04-12T14:57:14Z",
      "side": 1,
      "message": "I\u0027m not quite sure what you intend here. The default behavior of what? What\u0027s auto_refresh and how does that relate here?\n\n---\n\nThe EGL spec seems to be clear that eglSwapBuffers is not required for the normal operation of single-buffer rendering. In Vulkan, DEMAND_REFRESH does require ANI/QP while CONTINUOUS_REFRESH doesn\u0027t. It sounds to me like the EGL\u0027s single buffer is really CONTINUOUS_REFRESH.\n\nNo argument about which of DEMAND_REFRESH or CONTINUOUS_REFRESH is more optimal :)",
      "parentUuid": "802cc3ad_ad233bb7",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15b337c0_dbfecc85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-04-12T14:57:14Z",
      "side": 1,
      "message": "That quote is talking about when there\u0027s a switch to and from single-buffer. In that case, the spec says there should be a flush followed by the render buffer change. I believe that\u0027s correctly done.\n\nOtherwise the spec says eglSwapBuffers doesn\u0027t need to flush (even though ANGLE _does_ do that currently if I\u0027m reading the code right):\n\n```\n 9) Should an implicit flush occur when eglSwapBuffers is called on a\n    single-buffered surface?\n\n    RESOLVED: Only when there is a pending EGL_RENDER_BUFFER change which will\n    be affected by this eglSwapBuffers call. Contexts must be flushed when\n    changing render targets.\n```",
      "parentUuid": "e6dff10c_3a61bd0a",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d4bd831a_b912b04a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2022-04-12T16:12:34Z",
      "side": 1,
      "message": "Replies.",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e141b0fb_138a4cdf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2022-04-12T16:12:34Z",
      "side": 1,
      "message": "No action for Yiwei\u0027s comments? \nI pretty sure form testing we verified that SwapBuffers was used to transition into and from SINGLE_BUFFER mode. Its in dEQP-EGL.functional.mutable_render_buffer.basic",
      "parentUuid": "62a054be_d0d2fea5",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64da786e_158941a4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-04-12T17:54:54Z",
      "side": 1,
      "message": "\u003e The default behavior of what?\nThe default mode to create the swapchain with\n\n\u003e What\u0027s auto_refresh and how does that relate here?\nThat same thing. For swapchain mode, it\u0027s continunous_refresh. For EGL extension, it\u0027s `EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID`. Also auto_refresh is the ANativeWindow perform op corresponding to swapcahin continunous_refresh.\n\n\u003e The EGL spec seems to be clear that eglSwapBuffers is not required for the normal operation of single-buffer rendering.\nThat\u0027s where the driver (angle) is required to do the swap at glFlush instead.\n\nfunctional wise: without hooking up the swap at glFlush, an app creating a surface with single_buffer as well as setting surface to auto_refresh initially will end up not presenting to the correct buffer because the buffer was never queued to ANativeWindow. Here\u0027s a nice doc in mesa for implementing mutable render buffer: https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/third_party/mesa-freedreno/include/GL/internal/dri_interface.h;l\u003d2108\n\nperformance wise: defaulting to continuous_refresh for single_buffer is going to introduce power regressions for some app usecases where they actively switch the refresh mode with `EGL_ANDROID_front_buffer_auto_refresh` when detecing no/active user movements.",
      "parentUuid": "e141b0fb_138a4cdf",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c76e8980_be920f4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-04-12T17:54:54Z",
      "side": 1,
      "message": "You are right. That makes sense to me.",
      "parentUuid": "15b337c0_dbfecc85",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "564c4a84_74a2749c",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-04-12T02:39:54Z",
      "side": 1,
      "message": "This is incorrect. We don\u0027t want this unless render buffer is specifically EGL_SINGLE_BUFFER.\n\nIt seems to me otherwise that for swap interval 1 we\u0027ll now always pick DEMAND/CONTINUOUS instead of FIFO. That can\u0027t be right, can it?",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2042880e_7e74d086",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2022-04-12T16:12:34Z",
      "side": 1,
      "message": "Not sure what you see.\nFirst thing: (unchanged)\n    if (interval \u003e 0)\n    {\n        return VK_PRESENT_MODE_FIFO_KHR;\n    }\n\nAfter that it depends what presentModes are provided. I assume use interval 0 gets you to one of the other modes.",
      "parentUuid": "564c4a84_74a2749c",
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62e83ff8_4e08a82b",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1945,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-04-12T02:39:54Z",
      "side": 1,
      "message": "I think you can remove DEMAND_REFRESH. The current logic is not correct for it (IIUC, DEMAND_REFRESH is really more like the normal ones (like FIFO/IMMEDIATE/etc) in ANI/QP behavior. It\u0027s only CONTINUOUS_REFRESH that\u0027s special in that regard.\n\nI don\u0027t know if we ever need DEMAND_REFRESH, unless you know an EGL extension that maps to it?",
      "range": {
        "startLine": 1945,
        "startChar": 35,
        "endLine": 1945,
        "endChar": 76
      },
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "488635ee_8a3baaf5",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1945,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2022-04-12T16:12:34Z",
      "side": 1,
      "message": "I was just being complete, if somehow we ended up needing. Removed.",
      "parentUuid": "62e83ff8_4e08a82b",
      "range": {
        "startLine": 1945,
        "startChar": 35,
        "endLine": 1945,
        "endChar": 76
      },
      "revId": "b5abe09b194eab4d37d34934afbdc25ce41bd93c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}