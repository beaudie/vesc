{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7b278465_61ee769c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2022-05-10T14:53:27Z",
      "side": 1,
      "message": "ptal\n\nNo new code change from last time this landed. Just submitted crrev.com/c/3629611 on the chromium side. I\u0027ve added the android gpu bot that was failing to cq and it\u0027s passing now.",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1578fad5_42943c0e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2022-05-10T21:22:53Z",
      "side": 1,
      "message": "Hey I\u0027m catching up on this, sorry for the slow response. I have a couple questions and I want to make sure we get this right.\n\nIs there a reason this can\u0027t live in ANGLE, if we could configure the max texture size to something else? Putting workarounds like this in the passthrough command decoder is not ideal because it duplicates validation and bugs often arise from differences in ANGLE\u0027s state and what\u0027s exposed to the GPU process clients.\n\nI think the current emulation of this in the command decoder isn\u0027t enough, a bunch of validation relies on the max texture size (see references to max2DtextureSize in https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Caps.h).",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "242f23c5_7e40ee63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2022-05-10T21:48:57Z",
      "side": 1,
      "message": "Hey np.\n\nSo the problem is on android on some \"edge case\" devices, the frame buffer itself can be larger than 4096, which is causing problems due to this workaround. So the idea for the fix is apply the workaround to command buffer clients only which covers canvas/webgl, cc tile raster etc. In particular, shared image allocation and viz display are not command buffer clients, so the workaround would be removed for those and hopefully that covers all frame buffers usage. But you are right that it does mean doing a bunch of validation in the passthrough cb.\n\nMaybe we can discuss other options though.\n\nThe original bug the workaround was added for was that allocating a screen width x max texture size height (for cc tile) failed on one popular android device, but it was deemed easier at the time to apply the whole workaround to all of android in case the problem comes up again. So unfortunately it\u0027s not clear how safe it is to just remove the workaround entirely for android. Then linux was added for something else that I didn\u0027t chase down.\n\nAnother idea was just to arbitrarily double the size of the workaround, but that does feel a bit like pushing the problem down the road",
      "parentUuid": "1578fad5_42943c0e",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc2ee760_e768c616",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2022-05-11T17:57:08Z",
      "side": 1,
      "message": "Ok cool. There are a couple things we can do in ANGLE that may address this:\n\n- We can make this workaround apply only to WebGL contexts. This doesn\u0027t cover canvas but I suspect canvas has their own limits (and with OOP-C, canvases mostly don\u0027t go through the command decoder).\n- ANGLE could potentially query the screen size and dynamically adjust the limit.\n- We can add multiple workarounds for different sizes (4096, 8192, etc) and let chrome decide which one ANGLE should use.\n- If it needs to be fully configurable, we can pass an int to context creation so Chrome can supply the limit directly.\n\nI think what makes the most sense to me is having multiple workarounds (disabled by default) in ANGLE and let chrome choose which one to use. It lets us contain all the validation logic in ANGLE and still let Chrome make the decision.",
      "parentUuid": "242f23c5_7e40ee63",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d78e6146_65311ecc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1357502
      },
      "writtenOn": "2022-05-12T15:21:54Z",
      "side": 1,
      "message": "I think we still need update caps in decoder for canvas: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/graphics/canvas_resource_provider.cc;drc\u003d1d3aebb90c0e8a3b791fa309633de1308d0cc48f;l\u003d957\n\nBut besides that limiting only to webgl contexts sounds good to me.\n\nHaving multiple workaronds seems like a weird approach and adding limit to context seems like an overkill if we still will use it only for webgl contexts eventually.",
      "parentUuid": "cc2ee760_e768c616",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ecbe1740_18930f13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2022-05-12T16:19:44Z",
      "side": 1,
      "message": "Thanks for pointing out the canavas limit. Makes sense that we should apply this globally in ANGLE instead of WebGL-only.\n\nThe multiple workarounds is an artifact of ANGLE\u0027s workarounds being bools instead of integers, we need more than one to represent multiple caps. If the alternative to this is doing the workarounds in the command decoder level, I would prefer to just add a new limit_max_texture_size_to_8192 to handle these devices.",
      "parentUuid": "d78e6146_65311ecc",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54793486_0d8ca5fb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1357502
      },
      "writtenOn": "2022-05-12T16:26:33Z",
      "side": 1,
      "message": "Applying workaround globally affects the display compositor which we\u0027re trying to avoid. \n\nNote, for canvas I don\u0027t propose to affect any GL commands, only gpu::Capabilities that the decoder sends to the client. All gl commands are still passed through to angle, so the canvas won\u0027t have an extra texture limit from gl perspective, but won\u0027t allow \u003ccanvas\u003e tags larger than 4096.",
      "parentUuid": "ecbe1740_18930f13",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c2cc082_97b9d059",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1357502
      },
      "writtenOn": "2022-05-12T16:28:33Z",
      "side": 1,
      "message": "fwiw for canvas that capability really needs to be on SharedImageInterface as it\u0027s about \"can we create shared image of that size\", but we don\u0027t have any ways to do it yet.",
      "parentUuid": "54793486_0d8ca5fb",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee8a99a9_634a837e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002725
      },
      "writtenOn": "2022-05-18T20:53:00Z",
      "side": 1,
      "message": "(Coming back to this, 30min before I go on vacation for a week..)\n\n\u003e We can make this workaround apply only to WebGL contexts.\n\nThe original problem on android that motivated this workaround was not webgl. It was renderer cc picking tile sizes based on viewport (limited by max texture size), and webview having unreasonably large viewport so max texture actually applied. So limiting only webgl (and canvas) could make the original problem on android come back. But of course now that we\u0027ve had this workaround apply universally on android for so long, who knows what other issues it\u0027s hiding :(\n\n\u003e If it needs to be fully configurable, we can pass an int to context creation so Chrome can supply the limit directly.\n\nThinking out loud if we do this and use different limits for different angle context. Do we have clean split for different angle context for different use cases (cc, webgl, canvas, display compositor, raster, and whatever else I\u0027m forgetting)? I guess chromium side doesn\u0027t need to use virtual context with angle so I guess yes?\n\nBut how would something like shared image that specifically spans multiple context pick its limits? Highest one among all the different angle contexts? I hope we don\u0027t ever share textures created in display context to cc or webgl context that has lower limits? (Actually isn\u0027t this also a problem with the approach in this CL to limit only command buffer clients?)\n\n\u003e Note, for canvas I don\u0027t propose to affect any GL commands, only gpu::Capabilities that the decoder sends to the client.\n\nDoes that mean gpu::Capabilities exposes a limit that\u0027s different from GL_MAX_TEXTURE_SIZE? Feels like that way lies madness from all the confusion it would cause..",
      "parentUuid": "7c2cc082_97b9d059",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b998f84f_4f5a5729",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1357502
      },
      "writtenOn": "2022-05-19T16:59:50Z",
      "side": 1,
      "message": "\u003e (Coming back to this, 30min before I go on vacation for a week..)\n\u003e \n\u003e \u003e We can make this workaround apply only to WebGL contexts.\n\u003e \n\u003e The original problem on android that motivated this workaround was not webgl. It was renderer cc picking tile sizes based on viewport (limited by max texture size), and webview having unreasonably large viewport so max texture actually applied. So limiting only webgl (and canvas) could make the original problem on android come back. But of course now that we\u0027ve had this workaround apply universally on android for so long, who knows what other issues it\u0027s hiding :(\n\u003e \n\ncc should rely on RasterDecoder caps anyway, I think discussion here is more about do we want this workaround for webgl and if so, it\u0027s preferable to keep in in Angle because validation is complicated and reimplementing it in decoder is not what we want. \n\nSo the suggestion was that the angle workaround will be used only for webgl contexts because the client will issue arbitrary gl commands and require that validation. \n\nIt\u0027s not a problem for cc/canvas, so we just communicate the \"soft\" limit to them via caps. They still can allocate larger things, but normally they shouldn\u0027t and that\u0027s all we care about.\n\n\n\u003e \u003e If it needs to be fully configurable, we can pass an int to context creation so Chrome can supply the limit directly.\n\u003e \n\u003e Thinking out loud if we do this and use different limits for different angle context. Do we have clean split for different angle context for different use cases (cc, webgl, canvas, display compositor, raster, and whatever else I\u0027m forgetting)? I guess chromium side doesn\u0027t need to use virtual context with angle so I guess yes?\n\u003e \n\u003e But how would something like shared image that specifically spans multiple context pick its limits? Highest one among all the different angle contexts? I hope we don\u0027t ever share textures created in display context to cc or webgl context that has lower limits? (Actually isn\u0027t this also a problem with the approach in this CL to limit only command buffer clients?)\n\u003e \n\nThat\u0027s kinda tricky. Display compositor can create textures for CopyOutputRequests and ship to the client, I believe only CrOS uses it this way (and it\u0027s to the browser, but browser will use gles2 command decoder to work with it). That should have the same limits though.\n\nWhat makes it interesting is that there is stuff that can be imported to canvas/webgl. One of things canvas2d can be imported to webgl. But as long as we tell the canvas the right caps it should be within limits. The other thing is the video, but I guess it\u0027s a separate problem of how import large video in 4096 limited context.\n\n\n\u003e \u003e Note, for canvas I don\u0027t propose to affect any GL commands, only gpu::Capabilities that the decoder sends to the client.\n\u003e \n\u003e Does that mean gpu::Capabilities exposes a limit that\u0027s different from GL_MAX_TEXTURE_SIZE? Feels like that way lies madness from all the confusion it would cause..\n\nFor canvas2d, yeah. But canvas shouldn\u0027t rely on GL_MAX_TEXTURE_SIZE and with OOP-C this isn\u0027t a problem at all (it will go to the raster decoder). For WebGL they will match.",
      "parentUuid": "ee8a99a9_634a837e",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1c23cef2_2835b943",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1503927
      },
      "writtenOn": "2022-06-17T20:20:47Z",
      "side": 1,
      "message": "After chatting with vasiliy, I think we are all ok with limiting max texture size workaround to webgl context only?\n\nLooking into doing that for angle and probably need some help from geoff. So the workaround conditions is computed once per \"renderer\":\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/renderer/gl/RendererGL.cpp;drc\u003d169c6cc102b39295a5bfe2f2a176b42b1c2fe2c4;l\u003d156\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/renderer/gl/renderergl_utils.cpp;drc\u003d169c6cc102b39295a5bfe2f2a176b42b1c2fe2c4;l\u003d679\n\nwebgl is per \"context\" of course:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Context.h;drc\u003d7a85d114b5a37de93a0738491ffb7faf69b33469;l\u003d773\n\nAnd the validations will need to be different per-context as well. So the goal is to update limit the max sizes in Context\u0027s caps here:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Context.cpp;drc\u003d06ff0e3cb062d523390639a8011307f9c153eec3;l\u003d3807\n\nWhich means we need to pass up whether the workaround is enabled from renderer to context. Looking around existing code paths, I think most natural place is add like maxWebGLTextureSize4096 to gl::Limitations:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Caps.h;drc\u003d169c6cc102b39295a5bfe2f2a176b42b1c2fe2c4;l\u003d110\n\nNot sure if that\u0027s what gl::Limitations is for though.",
      "revId": "172e3411a8b91ba476ffc2aac00f450df3b2475d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}