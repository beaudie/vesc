{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b72d0f59_2cc2a470",
        "filename": "src/libANGLE/renderer/vulkan/VulkanSecondaryCommandBuffer.cpp",
        "patchSetId": 11
      },
      "lineNbr": 53,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-22T14:38:23Z",
      "side": 1,
      "message": "nit: `pool`\n\nIt\u0027s a bit weird to have `initialize` be called, but then _not_ initialize. I preferred when `initialize()` was not called at all if unnecessary.\n\nTo fix the `empty()` case, why not set `mAnyCommand \u003d false` when the command buffer is closed?",
      "range": {
        "startLine": 53,
        "startChar": 58,
        "endLine": 53,
        "endChar": 59
      },
      "revId": "036ba5189b4d5cde446e684b82d1c1fff496e042",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab20609d_571f7070",
        "filename": "src/libANGLE/renderer/vulkan/VulkanSecondaryCommandBuffer.cpp",
        "patchSetId": 11
      },
      "lineNbr": 53,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-22T16:00:39Z",
      "side": 1,
      "message": "\u003e nit: pool\n\nBuffer is correct (the above `!valid()`).\n\nMy logic is that when `VulkanSecondaryCommandBuffer::valid()` returns `false` - we still allow to call `empty()` (use object in invalid state).\n\n\u003e it\u0027s a bit weird to have initialize be called, but then not initialize. I preferred when initialize() was not called at all if unnecessary.\n\nAgree.\n\n\u003e To fix the empty() case, why not set mAnyCommand \u003d false when the command buffer is closed?\n\nCurrently `VulkanSecondaryCommandBuffer::close()` called only if enabled assertions. Also this will cause other asserts. Logic of close is to avoid writing but not making it empty. I do not like this.\n\n---\n\nCurrently `VulkanSecondaryCommandBuffer` does not have custom move constructor/assignment. Everything is left as is after `std::move()`. My assumption is that because after `std::move()` object is `!valid()` and other state does not matter (like `empty()`) and resetting state skipped for performance reasons.\n\nThere was no problem before this CL, since `OutsideRenderPassCommandBufferHelper::mCommandBuffer` always initialized after `reset()`. In this CL initialization is not possible if Pool detached.\n\nThere are many options how to fix this. Unfortunately, I do not know what will be accepted, because many cases are subjective.\n\nThe cleanest way is:\n1. implement move logic and reset necessary state (for safety).\n2. and even then, do not call `empty()` if `!valid()`.\n\nOriginally I decided to implement only (2) - just check `!valid()` and skip `empty()`.\nHowever, `RenderPassCommandBufferHelper::empty()` only checking `mRenderPassStarted`. This check will be skipped if buffer is `!valid()`. I think skipping is OK, because it is already a problem if buffer is `!valid()` but `mRenderPassStarted \u003d\u003d true`. In case such heppens - we will catch the error in `ASSERT(!mRenderPassStarted)` later in the `beginRenderPass()`.\n\nI also was thinking to implement additional method inside `RenderPassCommandBufferHelper` and `OutsideRenderPassCommandBufferHelper` instead of using `empty()`.\nThe `OutsideRenderPassCommandBufferHelper` will check `!mCommandBuffer.valid() || mCommandBuffer.empty()`.\nThe `RenderPassCommandBufferHelper` will check `!started()` or even `!started() \u0026\u0026 (!mCommandBuffer.valid() || mCommandBuffer.empty())`.\nBut how to name this method?\n\nAlso methods `isCommandPoolAttached()` and `hasAllocatorLinks()` only used for assertions. So decided to encapsulate all checks in a single method `checkCanBeRecycled()`. But this will cause a copy-paste logic (like in attach/detach). This copy-paste can be solved with template similarly to attach/detach. But you do not like my templates with attach/detach...\n\nI think I will go with the templated `checkCanBeRecycled`. IMO this is a least of all evils. Without template need to refactor the whole structure and I do not want to do that (or repeating code).\n\nSorry for a lot of text. But I\u0027m really struggling. I can choose anything and still do it wrong (unnecessary, complex or weird).",
      "parentUuid": "b72d0f59_2cc2a470",
      "range": {
        "startLine": 53,
        "startChar": 58,
        "endLine": 53,
        "endChar": 59
      },
      "revId": "036ba5189b4d5cde446e684b82d1c1fff496e042",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c97bcd0_f91828b2",
        "filename": "src/libANGLE/renderer/vulkan/VulkanSecondaryCommandBuffer.cpp",
        "patchSetId": 11
      },
      "lineNbr": 53,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-22T16:48:48Z",
      "side": 1,
      "message": "\u003e I can choose anything and still do it wrong (unnecessary, complex or weird).\n\nIt\u0027s not really wrong, you\u0027re doing amazing work! I know I\u0027m nitpicking a lot, it\u0027ll go down over time as you get more intimate with the code base ðŸ˜Š\n\nThat said, the template solution sounds like a good idea. Resetting the state in std move is perfectly fine, too. The one with additional methods sounds like it would check more stuff for correctness, so +1 from me there as well.",
      "parentUuid": "ab20609d_571f7070",
      "range": {
        "startLine": 53,
        "startChar": 58,
        "endLine": 53,
        "endChar": 59
      },
      "revId": "036ba5189b4d5cde446e684b82d1c1fff496e042",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9816497_fb55288c",
        "filename": "src/libANGLE/renderer/vulkan/VulkanSecondaryCommandBuffer.cpp",
        "patchSetId": 11
      },
      "lineNbr": 53,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-22T19:03:16Z",
      "side": 1,
      "message": "Decided to implement `assertCanBeRecycled()` methods using template `assertCanBeRecycledImpl\u003c\u003e()`.\n\nAdded `ASSERT(valid())` to `VulkanSecondaryCommandBuffer::empty()` and `getRenderPassWriteCommandCount()` methods. Then received the assert in the `empty()` when called from `detachAllocator()` method. However code that asserts will result in no-op. Decided to also add templates for `attach/detachAllocatorImpl\u003c\u003e()`.\n\nCurrently if enable `angle_enable_vulkan_shared_ring_buffer_cmd_alloc` it will force `ANGLE_USE_CUSTOM_VULKAN_*_CMD_BUFFERS`. With this change I think it will be possible to remove the enforcement (it will be possible to switch allocator type but still use Vulkan secondaries).",
      "parentUuid": "7c97bcd0_f91828b2",
      "range": {
        "startLine": 53,
        "startChar": 58,
        "endLine": 53,
        "endChar": 59
      },
      "revId": "036ba5189b4d5cde446e684b82d1c1fff496e042",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}