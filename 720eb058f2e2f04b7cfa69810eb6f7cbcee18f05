{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d245c941_5b3f5178",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-22T15:26:54Z",
      "side": 1,
      "message": "So we faced this problem in the past, and that\u0027s how `releaseImageFromShareContexts` was implemented.\n\nIsn\u0027t the bug here that the render pass image finalization code is referencing the released image? Then something similar (or likely identical) to `releaseImageFromShareContexts` would solve it.\n\nWhat that function does is to finalize the image early and remove its reference from the render pass.",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d04c670e_cd54c631",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-22T17:03:21Z",
      "side": 1,
      "message": "\u003e Isn\u0027t the bug here that the render pass image finalization code is referencing the released image? \n\nYes.\n\n\u003e Then something similar (or likely identical) to releaseImageFromShareContexts would solve it.\n\nMy old fix was add `finalizeImageLayoutInShareContexts()` and rewrite:\n```\nvoid ImageHelper::releaseImageFromShareContexts(RendererVk *renderer, ContextVk *contextVk)\n{\n    finalizeImageLayoutInShareContexts(renderer, contextVk);\n    releaseImage(renderer);\n}\n```\nThe `finalizeImageLayoutInShareContexts()` called when `mOwnsImage \u003d\u003d false` image is released.\n\nHowever, this fix also has bug.\nThe `finalizeImageLayoutInShareContexts()` may be called on a `source` texture that was not used in a RenderPass. Because `source` image uses same `ImageHelper` this will successfully finalize the RenderPass attachment. However, `target` texture will still be bound to the framebuffer. If continue to render into RenderPass with attachment finalized - different unexpected results may happen. From what I found, clearing the surface will optimize clear as loadOp, because nothing was rendered (attachment is finalized), but this is incorrect - previous draw commands will appear after clear.\n\nOne possibility to prevent above bug is change `finalizeImageLayoutInShareContexts()` to accept not `ImageHelper` but texture/renderbuffer. And add tracking texture/renderbuffer into RenderPass attachments. Or something similar. I do not know this code as much in order to make such changes.\n\n`releaseImageFromShareContexts()` works for `mOwnsImage \u003d\u003d true` because `ImageHelper` will be also released (framebuffer attachment previously was detached) and it is not possible to continue RenderPass (as far as I know).\n\nWith `mOwnsImage \u003d\u003d false`, `ImageHelper` may be destroyed any time after it is released from texture/renderbuffer. I did not find a better way, rather than flush RenderPass with that image attached. Side effect: will also flush if `source` texture released, but this should not happen in normal programs.",
      "parentUuid": "d245c941_5b3f5178",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6463fe1_12e22b33",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-23T12:21:22Z",
      "side": 1,
      "message": "Hmm... let\u0027s see if we can find the right way to deal with this. A couple of points before that:\n\n- Think of `namespace vk` as a separate layer underneath the Vulkan backend. Passing TextureVk/RenderbufferVk (which are \"GL objects\" in Vulkan context) would be a layering violation\n- If we really have to close the render pass, either these functions should be made to return `angle::Result`, or something should be called at the call site of these functions to deal with this. Usually in the form of `onFooHappened()`\n\nBut we can likely do better here. I read the EGL spec a bit and the code, and here are some observations:\n\n- The ImageHelper isn\u0027t released until all references to it are removed from all contexts\n- The release of the ImageHelper always happens through ImageVk. TextureVk and RenderbufferVk only drop references\n- TextureVk and RenderbufferVk create _views_ of the image separately. These views are local to the context.\n\nAnything I missed in the above? If not, it seems to me that:\n\n- Dropping a reference to the shared ImageHelper from TextureVk and RenderbufferVk doesn\u0027t need to do anything; the image will still stay alive\n- Releasing the ImageHelper is only necessary from ImageVk, at which point no other context should be holding a reference to it, so might as well finalize it in all contexts. Note that EGL images can cross share group boundaries, so this is really all contexts, not just contexts of some share group.\n  * There can only be one context in the end that is currently rendering to the ImageHelper, so there\u0027s no double-finalizing of the image\n\nWhat do you think?\n\n---\n\nAlso:\n\n\u003e From what I found, ...\n\nIs that finding covered by one of the tests you\u0027ve added here? If you add a test for every scenario you think could be problematic, we can be sure whatever solution we devise actually works ðŸ˜Š",
      "parentUuid": "d04c670e_cd54c631",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ddf4bab_1f8df06e",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-23T14:18:54Z",
      "side": 1,
      "message": "\u003e If we really have to close the render pass, either these functions should be made to return angle::Result, or something should be called at the call site of these functions to deal with this. Usually in the form of onFooHappened()\n\nDid not understand what \"these functions\" are...\n\n\u003e The release of the ImageHelper always happens through ImageVk. TextureVk and RenderbufferVk only drop references\n\nIt is more complicated. Owner of the `ImageHelper` changes:\n- Initially owner is *source* texture/buffer.\n- If *source* destroyed - ownership transfers to `ImageVk` - `releaseOwnershipOfImage()`\n- Target texture/buffer never owns `ImageHelper`.\n- Target texture/buffer holds reference to `egl::Image`.\n- `egl::Image` can\u0027t be destroyed while there are targets.\n\n\u003e Dropping a reference to the shared ImageHelper from TextureVk and RenderbufferVk doesn\u0027t need to do anything; the image will still stay alive\n\nYes, but may be dead any time later.\n\n\u003e Releasing the ImageHelper is only necessary from ImageVk\n\nWe may have either: owner *source* texture/buffer or, owner `EGLImage`.\nSo need also finalize across all contexts when owner *source* texture/buffer releases the image.\n\n\u003e at which point no other context should be holding a reference to it, so might as well finalize it in all contexts\n\nHow we can finalize in all contexts? For that we need a mutex for all contexts that connected by `EGLImage`.\nCurrently GlobalMutex is used only for Shared Contexts.\nI have CL that replaces GlobaMutex by separate mutexes for each Share Group. These mutexes will merge when `EGLImage` is used across groups.\nIn any case, we need to track all Contexts that are protected by the same mutex.\n\n---\n\n\u003e Is that finding covered by one of the tests you\u0027ve added here? If you add a test for every scenario you think could be problematic, we can be sure whatever solution we devise actually works ðŸ˜Š\n\nI guess no) But I was thinking about that. Will update/add more tests.",
      "parentUuid": "e6463fe1_12e22b33",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9acd7c3_50391279",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-23T14:52:37Z",
      "side": 1,
      "message": "\u003e Did not understand what \"these functions\" are...\n\nThe functions that currently do `(void)` to avoid `ANGLE_TRY`\n\n\u003e We may have either: owner source texture/buffer or, owner EGLImage.\n\nGot it. Let\u0027s consider them separately (ignore the problem of sharing across share groups for the moment).\n\n- When owner is EGLImage, it\u0027s ok to ignore release on targets, and only finalize image when EGLImage releases the ImageHelper. Agreed? If so, let\u0027s make that change, which would be a partial fix.\n- When owner is another texture/renderbuffer, we do call releaseImageFromShareContexts right? But it sounds like that is not correct because a target could have an open render pass with it, This change is not fixing that. For this, we should probably only finalize the image in the source context, and let EGLImage later deal with the other contexts\n\n\u003e How we can finalize in all contexts? For that we need a mutex for all contexts that connected by EGLImage.\n\nEGLImage\u0027s crossing context boundaries is actually a longstanding problem. Someone recently \"fixed\" something about that though. I don\u0027t remember if it was something like merging the share groups of contexts that share EGLImages, or maybe it was just about mutexes.\n\nHow about we focus on share groups for now, and I\u0027ll try to find out what we can do for the cross-share-group issue.",
      "parentUuid": "7ddf4bab_1f8df06e",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15fee44c_90d7cee0",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-23T15:41:25Z",
      "side": 1,
      "message": "\u003e The functions that currently do (void) to avoid ANGLE_TRY\n\n```\nvoid Texture::onDestroy(const Context *context)\n{\n    ...\n\n    egl::RefCountObjectReleaser\u003cegl::Image\u003e releaseImage;\n    (void)orphanImages(context, \u0026releaseImage);\n```\nCurrent code also does this.\nAnd old \"fix\" was to `flushImpl()` everything unconditionally. This CL is much better (but not the best...)\n\n\u003e When owner is EGLImage, it\u0027s ok to ignore release on targets, and only finalize image when EGLImage releases the ImageHelper. Agreed?\n\nWhen `EGLImage` destroyed there may be no Context current in a thread.\nSo we must go through all Contexts, but doing this without a mutex is adding problems.\nOther option is to bind Share Group to the `EGLImage` but Share Group of what Context (source or target, or both)? End if such Share Group does not use GlobalMutex (single Context) then we may access Context from other thread without mutex protection - also adding problems.\n\n\u003e When owner is another texture/renderbuffer, we do call releaseImageFromShareContexts right?\n\nYes.\n\n\u003e But it sounds like that is not correct because a target could have an open render pass with it, This change is not fixing that. For this, we should probably only finalize the image in the source context, and let `EGLImage` later deal with the other contexts\n\nThere will be no `EGLImage` already (as well as target).\nIf there was `EGLImage` than it is impossible to release owner texture/renderbuffer - they will release ownership to the `EGLImage` in `releaseOwnershipOfImage()` prio to destruction.\n\nSo if we have a case when texture/renderbuffer is owner - then it is as if there was no `EGLImage` at all - no problem). I did no think of that before.\n\nThe only problem left is when `EGLImage` owner releases `ImageHelper`.\n\n\u003e EGLImage\u0027s crossing context boundaries is actually a longstanding problem. Someone recently \"fixed\" something about that though. I don\u0027t remember if it was something like merging the share groups of contexts that share EGLImages, or maybe it was just about mutexes.\n\nOld fix was to mark context as shared so they use GlobalMutex. But later was reverted due to dead-lock. I think I may have a fix for that dead-lock too.\n\n\u003e How about we focus on share groups for now\n\nBut `EGLImage` usually used if there are no Share Groups. And such fix will fix nothing.\n\n\u003e and I\u0027ll try to find out what we can do for the cross-share-group issue.\n\nI have CL for this already.\nIt will protect `EGLImage` and all Contexts that used that image by a common mutex. We only need to add tracking of Share Groups where `EGLImage` was used (or that are protected by a common mutex).\nAfter that, it will be easy to just call `releaseImageFromShareContexts()` for each Share Group when `EGLImage` owner releases `ImageHelper`.\n\nUntil than, flushing RenderPass is the only way. We will remove this code once cross-share-group issue resolved.",
      "parentUuid": "d9acd7c3_50391279",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb94056f_9f2cb3c8",
        "filename": "src/libANGLE/renderer/vulkan/RenderbufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 325,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-24T16:53:42Z",
      "side": 1,
      "message": "\u003e So if we have a case when texture/renderbuffer is owner - then it is as if there was no EGLImage at all - no problem). I did no think of that before.\n\nThis is wrong. I was right the first time.\n\n\u003e is as if there was no EGLImage at all - no problem\n\nWrong, because `ImageHelper` is already in the RenderPass. When other non Shared Context destroy owner texture/renderbuffer - `ImageHelper` will be destroyed while pointer will be in the first Context\u0027s RenderPass attachment.\n\nI\u0027m modifying tests so they cover all discussed cases.",
      "parentUuid": "15fee44c_90d7cee0",
      "range": {
        "startLine": 325,
        "startChar": 12,
        "endLine": 325,
        "endChar": 18
      },
      "revId": "720eb058f2e2f04b7cfa69810eb6f7cbcee18f05",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}