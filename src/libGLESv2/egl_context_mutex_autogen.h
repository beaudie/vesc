// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from egl.xml and egl_angle_ext.xml.
//
// Copyright 2020 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// egl_context_mutex_autogen.h:
//   Context Lock functions for the EGL entry points.

#ifndef LIBGLESV2_EGL_CONTEXT_MUTEX_AUTOGEN_H_
#define LIBGLESV2_EGL_CONTEXT_MUTEX_AUTOGEN_H_

#include "libGLESv2/global_state.h"

namespace egl
{

// EGL 1.0
ANGLE_INLINE ContextMutex *GetContextMutex_ChooseConfig(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CopyBuffers(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreateContext(Thread *thread,
                                                         egl::Display *dpyPacked,
                                                         gl::ContextID share_contextPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePbufferSurface(Thread *thread,
                                                                egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePixmapSurface(Thread *thread,
                                                               egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreateWindowSurface(Thread *thread,
                                                               egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroyContext(Thread *thread,
                                                          egl::Display *dpyPacked,
                                                          gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroySurface(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetConfigAttrib(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetConfigs(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetCurrentDisplay(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_GetCurrentSurface(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_GetDisplay(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_GetError(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_GetProcAddress(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_Initialize(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_MakeCurrent(Thread *thread,
                                                       egl::Display *dpyPacked,
                                                       gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryContext(Thread *thread,
                                                        egl::Display *dpyPacked,
                                                        gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryString(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QuerySurface(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_SwapBuffers(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_Terminate(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_WaitGL(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_WaitNative(Thread *thread);

// EGL 1.1
ANGLE_INLINE ContextMutex *GetContextMutex_BindTexImage(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ReleaseTexImage(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_SurfaceAttrib(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_SwapInterval(Thread *thread, egl::Display *dpyPacked);

// EGL 1.2
ANGLE_INLINE ContextMutex *GetContextMutex_BindAPI(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePbufferFromClientBuffer(Thread *thread,
                                                                         egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryAPI(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_ReleaseThread(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_WaitClient(Thread *thread);

// EGL 1.4
ANGLE_INLINE ContextMutex *GetContextMutex_GetCurrentContext(Thread *thread);

// EGL 1.5
ANGLE_INLINE ContextMutex *GetContextMutex_ClientWaitSync(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreateImage(Thread *thread,
                                                       egl::Display *dpyPacked,
                                                       gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePlatformPixmapSurface(Thread *thread,
                                                                       egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePlatformWindowSurface(Thread *thread,
                                                                       egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreateSync(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroyImage(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroySync(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetPlatformDisplay(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_GetSyncAttrib(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_WaitSync(Thread *thread, egl::Display *dpyPacked);

// EGL_ANDROID_blob_cache
ANGLE_INLINE ContextMutex *GetContextMutex_SetBlobCacheFuncsANDROID(Thread *thread,
                                                                    egl::Display *dpyPacked);

// EGL_ANDROID_create_native_client_buffer
ANGLE_INLINE ContextMutex *GetContextMutex_CreateNativeClientBufferANDROID(Thread *thread);

// EGL_ANDROID_get_frame_timestamps
ANGLE_INLINE ContextMutex *GetContextMutex_GetCompositorTimingSupportedANDROID(
    Thread *thread,
    egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetCompositorTimingANDROID(Thread *thread,
                                                                      egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetNextFrameIdANDROID(Thread *thread,
                                                                 egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetFrameTimestampSupportedANDROID(
    Thread *thread,
    egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetFrameTimestampsANDROID(Thread *thread,
                                                                     egl::Display *dpyPacked);

// EGL_ANDROID_get_native_client_buffer
ANGLE_INLINE ContextMutex *GetContextMutex_GetNativeClientBufferANDROID(Thread *thread);

// EGL_ANDROID_native_fence_sync
ANGLE_INLINE ContextMutex *GetContextMutex_DupNativeFenceFDANDROID(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_ANDROID_presentation_time
ANGLE_INLINE ContextMutex *GetContextMutex_PresentationTimeANDROID(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_ANGLE_device_creation
ANGLE_INLINE ContextMutex *GetContextMutex_CreateDeviceANGLE(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_ReleaseDeviceANGLE(Thread *thread);

// EGL_ANGLE_feature_control
ANGLE_INLINE ContextMutex *GetContextMutex_QueryStringiANGLE(Thread *thread,
                                                             egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDisplayAttribANGLE(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_ANGLE_metal_shared_event_sync
ANGLE_INLINE ContextMutex *GetContextMutex_CopyMetalSharedEventANGLE(Thread *thread,
                                                                     egl::Display *dpyPacked);

// EGL_ANGLE_power_preference
ANGLE_INLINE ContextMutex *GetContextMutex_ReleaseHighPowerGPUANGLE(Thread *thread,
                                                                    egl::Display *dpyPacked,
                                                                    gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ReacquireHighPowerGPUANGLE(Thread *thread,
                                                                      egl::Display *dpyPacked,
                                                                      gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_HandleGPUSwitchANGLE(Thread *thread,
                                                                egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ForceGPUSwitchANGLE(Thread *thread,
                                                               egl::Display *dpyPacked);

// EGL_ANGLE_prepare_swap_buffers
ANGLE_INLINE ContextMutex *GetContextMutex_PrepareSwapBuffersANGLE(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_ANGLE_program_cache_control
ANGLE_INLINE ContextMutex *GetContextMutex_ProgramCacheGetAttribANGLE(Thread *thread,
                                                                      egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ProgramCacheQueryANGLE(Thread *thread,
                                                                  egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ProgramCachePopulateANGLE(Thread *thread,
                                                                     egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_ProgramCacheResizeANGLE(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_ANGLE_query_surface_pointer
ANGLE_INLINE ContextMutex *GetContextMutex_QuerySurfacePointerANGLE(Thread *thread,
                                                                    egl::Display *dpyPacked);

// EGL_ANGLE_stream_producer_d3d_texture
ANGLE_INLINE ContextMutex *GetContextMutex_CreateStreamProducerD3DTextureANGLE(
    Thread *thread,
    egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_StreamPostD3DTextureANGLE(Thread *thread,
                                                                     egl::Display *dpyPacked);

// EGL_ANGLE_swap_with_frame_token
ANGLE_INLINE ContextMutex *GetContextMutex_SwapBuffersWithFrameTokenANGLE(Thread *thread,
                                                                          egl::Display *dpyPacked);

// EGL_ANGLE_sync_control_rate
ANGLE_INLINE ContextMutex *GetContextMutex_GetMscRateANGLE(Thread *thread, egl::Display *dpyPacked);

// EGL_ANGLE_vulkan_image
ANGLE_INLINE ContextMutex *GetContextMutex_ExportVkImageANGLE(Thread *thread,
                                                              egl::Display *dpyPacked);

// EGL_ANGLE_wait_until_work_scheduled
ANGLE_INLINE ContextMutex *GetContextMutex_WaitUntilWorkScheduledANGLE(Thread *thread,
                                                                       egl::Display *dpyPacked);

// EGL_CHROMIUM_sync_control
ANGLE_INLINE ContextMutex *GetContextMutex_GetSyncValuesCHROMIUM(Thread *thread,
                                                                 egl::Display *dpyPacked);

// EGL_EXT_device_query
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDeviceAttribEXT(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDeviceStringEXT(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDisplayAttribEXT(Thread *thread,
                                                                 egl::Display *dpyPacked);

// EGL_EXT_image_dma_buf_import_modifiers
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDmaBufFormatsEXT(Thread *thread,
                                                                 egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDmaBufModifiersEXT(Thread *thread,
                                                                   egl::Display *dpyPacked);

// EGL_EXT_platform_base
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePlatformPixmapSurfaceEXT(Thread *thread,
                                                                          egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreatePlatformWindowSurfaceEXT(Thread *thread,
                                                                          egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetPlatformDisplayEXT(Thread *thread);

// EGL_KHR_debug
ANGLE_INLINE ContextMutex *GetContextMutex_DebugMessageControlKHR(Thread *thread);
ANGLE_INLINE ContextMutex *GetContextMutex_LabelObjectKHR(Thread *thread,
                                                          egl::Display *displayPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryDebugKHR(Thread *thread);

// EGL_KHR_fence_sync
ANGLE_INLINE ContextMutex *GetContextMutex_ClientWaitSyncKHR(Thread *thread,
                                                             egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_CreateSyncKHR(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroySyncKHR(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_GetSyncAttribKHR(Thread *thread,
                                                            egl::Display *dpyPacked);

// EGL_KHR_image
ANGLE_INLINE ContextMutex *GetContextMutex_CreateImageKHR(Thread *thread,
                                                          egl::Display *dpyPacked,
                                                          gl::ContextID ctxPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroyImageKHR(Thread *thread, egl::Display *dpyPacked);

// EGL_KHR_lock_surface3
ANGLE_INLINE ContextMutex *GetContextMutex_LockSurfaceKHR(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QuerySurface64KHR(Thread *thread,
                                                             egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_UnlockSurfaceKHR(Thread *thread,
                                                            egl::Display *dpyPacked);

// EGL_KHR_partial_update
ANGLE_INLINE ContextMutex *GetContextMutex_SetDamageRegionKHR(Thread *thread,
                                                              egl::Display *dpyPacked);

// EGL_KHR_reusable_sync
ANGLE_INLINE ContextMutex *GetContextMutex_SignalSyncKHR(Thread *thread, egl::Display *dpyPacked);

// EGL_KHR_stream
ANGLE_INLINE ContextMutex *GetContextMutex_CreateStreamKHR(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_DestroyStreamKHR(Thread *thread,
                                                            egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryStreamKHR(Thread *thread, egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_QueryStreamu64KHR(Thread *thread,
                                                             egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_StreamAttribKHR(Thread *thread, egl::Display *dpyPacked);

// EGL_KHR_stream_consumer_gltexture
ANGLE_INLINE ContextMutex *GetContextMutex_StreamConsumerAcquireKHR(Thread *thread,
                                                                    egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_StreamConsumerGLTextureExternalKHR(
    Thread *thread,
    egl::Display *dpyPacked);
ANGLE_INLINE ContextMutex *GetContextMutex_StreamConsumerReleaseKHR(Thread *thread,
                                                                    egl::Display *dpyPacked);

// EGL_KHR_swap_buffers_with_damage
ANGLE_INLINE ContextMutex *GetContextMutex_SwapBuffersWithDamageKHR(Thread *thread,
                                                                    egl::Display *dpyPacked);

// EGL_KHR_wait_sync
ANGLE_INLINE ContextMutex *GetContextMutex_WaitSyncKHR(Thread *thread, egl::Display *dpyPacked);

// EGL_NV_post_sub_buffer
ANGLE_INLINE ContextMutex *GetContextMutex_PostSubBufferNV(Thread *thread, egl::Display *dpyPacked);

// EGL_NV_stream_consumer_gltexture_yuv
ANGLE_INLINE ContextMutex *GetContextMutex_StreamConsumerGLTextureExternalAttribsNV(
    Thread *thread,
    egl::Display *dpyPacked);
}  // namespace egl

#endif  // LIBGLESV2_EGL_CONTEXT_MUTEX_AUTOGEN_H_
