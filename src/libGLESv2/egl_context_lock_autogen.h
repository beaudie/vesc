// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from egl.xml and egl_angle_ext.xml.
//
// Copyright 2020 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// egl_context_lock_autogen.h:
//   Context Lock functions for the EGL entry points.

#ifndef LIBANGLE_EGL_CONTEXT_LOCK_AUTOGEN_H_
#define LIBANGLE_EGL_CONTEXT_LOCK_AUTOGEN_H_

#include "libGLESv2/global_state.h"

namespace egl
{

// EGL 1.0
std::unique_lock<angle::GlobalMutex> GetContextLock_ChooseConfig(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CopyBuffers(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateContext(
    const Thread *thread,
    const gl::Context *share_contextPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePbufferSurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePixmapSurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateWindowSurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroyContext(const Thread *thread,
                                                                   const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroySurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetConfigAttrib(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetConfigs(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetCurrentDisplay(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetCurrentSurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetDisplay(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetError(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetProcAddress(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_Initialize(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_MakeCurrent(const Thread *thread,
                                                                const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryContext(const Thread *thread,
                                                                 const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryString(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QuerySurface(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_SwapBuffers(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_Terminate(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_WaitGL(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_WaitNative(const Thread *thread);

// EGL 1.1
std::unique_lock<angle::GlobalMutex> GetContextLock_BindTexImage(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ReleaseTexImage(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_SurfaceAttrib(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_SwapInterval(const Thread *thread);

// EGL 1.2
std::unique_lock<angle::GlobalMutex> GetContextLock_BindAPI(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePbufferFromClientBuffer(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryAPI(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ReleaseThread(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_WaitClient(const Thread *thread);

// EGL 1.4
std::unique_lock<angle::GlobalMutex> GetContextLock_GetCurrentContext(const Thread *thread);

// EGL 1.5
std::unique_lock<angle::GlobalMutex> GetContextLock_ClientWaitSync(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateImage(const Thread *thread,
                                                                const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePlatformPixmapSurface(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePlatformWindowSurface(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateSync(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroyImage(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroySync(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetPlatformDisplay(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetSyncAttrib(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_WaitSync(const Thread *thread);

// EGL_ANDROID_blob_cache
std::unique_lock<angle::GlobalMutex> GetContextLock_SetBlobCacheFuncsANDROID(const Thread *thread);

// EGL_ANDROID_create_native_client_buffer
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateNativeClientBufferANDROID(
    const Thread *thread);

// EGL_ANDROID_get_frame_timestamps
std::unique_lock<angle::GlobalMutex> GetContextLock_GetCompositorTimingSupportedANDROID(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetCompositorTimingANDROID(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetNextFrameIdANDROID(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetFrameTimestampSupportedANDROID(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetFrameTimestampsANDROID(const Thread *thread);

// EGL_ANDROID_get_native_client_buffer
std::unique_lock<angle::GlobalMutex> GetContextLock_GetNativeClientBufferANDROID(
    const Thread *thread);

// EGL_ANDROID_native_fence_sync
std::unique_lock<angle::GlobalMutex> GetContextLock_DupNativeFenceFDANDROID(const Thread *thread);

// EGL_ANDROID_presentation_time
std::unique_lock<angle::GlobalMutex> GetContextLock_PresentationTimeANDROID(const Thread *thread);

// EGL_ANGLE_device_creation
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateDeviceANGLE(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ReleaseDeviceANGLE(const Thread *thread);

// EGL_ANGLE_feature_control
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryStringiANGLE(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryDisplayAttribANGLE(const Thread *thread);

// EGL_ANGLE_power_preference
std::unique_lock<angle::GlobalMutex> GetContextLock_ReleaseHighPowerGPUANGLE(
    const Thread *thread,
    const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_ReacquireHighPowerGPUANGLE(
    const Thread *thread,
    const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_HandleGPUSwitchANGLE(const Thread *thread);

// EGL_ANGLE_program_cache_control
std::unique_lock<angle::GlobalMutex> GetContextLock_ProgramCacheGetAttribANGLE(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ProgramCacheQueryANGLE(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ProgramCachePopulateANGLE(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_ProgramCacheResizeANGLE(const Thread *thread);

// EGL_ANGLE_query_surface_pointer
std::unique_lock<angle::GlobalMutex> GetContextLock_QuerySurfacePointerANGLE(const Thread *thread);

// EGL_ANGLE_stream_producer_d3d_texture
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateStreamProducerD3DTextureANGLE(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamPostD3DTextureANGLE(const Thread *thread);

// EGL_ANGLE_swap_with_frame_token
std::unique_lock<angle::GlobalMutex> GetContextLock_SwapBuffersWithFrameTokenANGLE(
    const Thread *thread);

// EGL_ANGLE_sync_control_rate
std::unique_lock<angle::GlobalMutex> GetContextLock_GetMscRateANGLE(const Thread *thread);

// EGL_CHROMIUM_sync_control
std::unique_lock<angle::GlobalMutex> GetContextLock_GetSyncValuesCHROMIUM(const Thread *thread);

// EGL_EXT_device_query
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryDeviceAttribEXT(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryDeviceStringEXT(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryDisplayAttribEXT(const Thread *thread);

// EGL_EXT_platform_base
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePlatformPixmapSurfaceEXT(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreatePlatformWindowSurfaceEXT(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetPlatformDisplayEXT(const Thread *thread);

// EGL_KHR_debug
std::unique_lock<angle::GlobalMutex> GetContextLock_DebugMessageControlKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_LabelObjectKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryDebugKHR(const Thread *thread);

// EGL_KHR_fence_sync
std::unique_lock<angle::GlobalMutex> GetContextLock_ClientWaitSyncKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateSyncKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroySyncKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_GetSyncAttribKHR(const Thread *thread);

// EGL_KHR_image
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateImageKHR(const Thread *thread,
                                                                   const gl::Context *ctxPacked);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroyImageKHR(const Thread *thread);

// EGL_KHR_reusable_sync
std::unique_lock<angle::GlobalMutex> GetContextLock_SignalSyncKHR(const Thread *thread);

// EGL_KHR_stream
std::unique_lock<angle::GlobalMutex> GetContextLock_CreateStreamKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_DestroyStreamKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryStreamKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_QueryStreamu64KHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamAttribKHR(const Thread *thread);

// EGL_KHR_stream_consumer_gltexture
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamConsumerAcquireKHR(const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamConsumerGLTextureExternalKHR(
    const Thread *thread);
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamConsumerReleaseKHR(const Thread *thread);

// EGL_KHR_swap_buffers_with_damage
std::unique_lock<angle::GlobalMutex> GetContextLock_SwapBuffersWithDamageKHR(const Thread *thread);

// EGL_KHR_wait_sync
std::unique_lock<angle::GlobalMutex> GetContextLock_WaitSyncKHR(const Thread *thread);

// EGL_NV_post_sub_buffer
std::unique_lock<angle::GlobalMutex> GetContextLock_PostSubBufferNV(const Thread *thread);

// EGL_NV_stream_consumer_gltexture_yuv
std::unique_lock<angle::GlobalMutex> GetContextLock_StreamConsumerGLTextureExternalAttribsNV(
    const Thread *thread);
}  // namespace egl

#endif  // LIBANGLE_EGL_CONTEXT_LOCK_AUTOGEN_H_
