#line 17 "glslang.l"
// GENERATED FILE - DO NOT EDIT.
// Generated by generate_parser.py from glslang.l
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// glslang.l:
//   Lexer for the OpenGL shading language.

// Ignore errors in auto-generated code.
#if defined(__GNUC__)
#    pragma GCC diagnostic ignored "-Wswitch-enum"
#    pragma GCC diagnostic ignored "-Wunused-function"
#    pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#    pragma warning(disable : 4005)
#    pragma warning(disable : 4065)
#    pragma warning(disable : 4189)
#    pragma warning(disable : 4244)
#    pragma warning(disable : 4505)
#    pragma warning(disable : 4701)
#    pragma warning(disable : 4702)
#endif
#if defined(__clang__)
#    pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#    if defined(__APPLE__)
// Older clang versions don't have -Wextra-semi-stmt, and detecting Apple clang versions is
// difficult because they use different yet overlapping version numbers vs. regular clang.
#        pragma clang diagnostic ignored "-Wunknown-warning-option"
#    endif
// Flex isn't semi-colon clean.
#    pragma clang diagnostic ignored "-Wextra-semi-stmt"
#    pragma clang diagnostic ignored "-Wunreachable-code"
#endif

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#    define FLEX_BETA
#endif

#ifdef yyget_lval
#    define yyget_lval_ALREADY_DEFINED
#else
#    define yyget_lval yyget_lval
#endif

#ifdef yyset_lval
#    define yyset_lval_ALREADY_DEFINED
#else
#    define yyset_lval yyset_lval
#endif

#ifdef yyget_lloc
#    define yyget_lloc_ALREADY_DEFINED
#else
#    define yyget_lloc yyget_lloc
#endif

#ifdef yyset_lloc
#    define yyset_lloc_ALREADY_DEFINED
#else
#    define yyset_lloc yyset_lloc
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#    define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#    if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#        ifndef __STDC_LIMIT_MACROS
#            define __STDC_LIMIT_MACROS 1
#        endif

#        include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#    else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#        ifndef INT8_MIN
#            define INT8_MIN (-128)
#        endif
#        ifndef INT16_MIN
#            define INT16_MIN (-32767 - 1)
#        endif
#        ifndef INT32_MIN
#            define INT32_MIN (-2147483647 - 1)
#        endif
#        ifndef INT8_MAX
#            define INT8_MAX (127)
#        endif
#        ifndef INT16_MAX
#            define INT16_MAX (32767)
#        endif
#        ifndef INT32_MAX
#            define INT32_MAX (2147483647)
#        endif
#        ifndef UINT8_MAX
#            define UINT8_MAX (255U)
#        endif
#        ifndef UINT16_MAX
#            define UINT16_MAX (65535U)
#        endif
#        ifndef UINT32_MAX
#            define UINT32_MAX (4294967295U)
#        endif

#        ifndef SIZE_MAX
#            define SIZE_MAX (~(size_t)0)
#        endif

#    endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#    define yynoreturn __attribute__((__noreturn__))
#else
#    define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#    define YY_TYPEDEF_YY_SCANNER_T
typedef void *yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin, yyscanner)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#    ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#        define YY_BUF_SIZE 32768
#    else
#        define YY_BUF_SIZE 16384
#    endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#    define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#    define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                  \
    do                                     \
    {                                      \
        int yyl;                           \
        for (yyl = n; yyl < yyleng; ++yyl) \
            if (yytext[yyl] == '\n')       \
                --yylineno;                \
    } while (0)
#define YY_LINENO_REWIND_TO(dst)             \
    do                                       \
    {                                        \
        const char *p;                       \
        for (p = yy_cp - 1; p >= (dst); --p) \
            if (*p == '\n')                  \
                --yylineno;                  \
    } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                         \
    do                                                                    \
    {                                                                     \
        /* Undo effects of setting up yytext. */                          \
        int yyless_macro_arg = (n);                                       \
        YY_LESS_LINENO(yyless_macro_arg);                                 \
        *yy_cp = yyg->yy_hold_char;                                       \
        YY_RESTORE_YY_MORE_OFFSET                                         \
        yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */                    \
    } while (0)
#define unput(c) yyunput(c, yyg->yytext_ptr, yyscanner)

#ifndef YY_STRUCT_YY_BUFFER_STATE
#    define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
    FILE *yy_input_file;

    char *yy_ch_buf;  /* input buffer */
    char *yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    int yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;

#    define YY_BUFFER_NEW 0
#    define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#    define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER \
    (yyg->yy_buffer_stack ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void yyrestart(FILE *input_file, yyscan_t yyscanner);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner);
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size, yyscan_t yyscanner);
void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner);
void yypop_buffer_state(yyscan_t yyscanner);

static void yyensure_buffer_stack(yyscan_t yyscanner);
static void yy_load_buffer_state(yyscan_t yyscanner);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file, yyscan_t yyscanner);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER, yyscanner)

YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size, yyscan_t yyscanner);
YY_BUFFER_STATE yy_scan_string(const char *yy_str, yyscan_t yyscanner);
YY_BUFFER_STATE yy_scan_bytes(const char *bytes, int len, yyscan_t yyscanner);

void *yyalloc(yy_size_t, yyscan_t yyscanner);
void *yyrealloc(void *, yy_size_t, yyscan_t yyscanner);
void yyfree(void *, yyscan_t yyscanner);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                             \
    {                                                                                  \
        if (!YY_CURRENT_BUFFER)                                                        \
        {                                                                              \
            yyensure_buffer_stack(yyscanner);                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner); \
        }                                                                              \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                  \
    }
#define yy_set_bol(at_bol)                                                             \
    {                                                                                  \
        if (!YY_CURRENT_BUFFER)                                                        \
        {                                                                              \
            yyensure_buffer_stack(yyscanner);                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner); \
        }                                                                              \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                  \
    }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap(yyscanner) (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state(yyscan_t yyscanner);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state, yyscan_t yyscanner);
static int yy_get_next_buffer(yyscan_t yyscanner);
static void yynoreturn yy_fatal_error(const char *msg, yyscan_t yyscanner);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                   \
    yyg->yytext_ptr   = yy_bp;                \
    yyleng            = (int)(yy_cp - yy_bp); \
    yyg->yy_hold_char = *yy_cp;               \
    *yy_cp            = '\0';                 \
    yyg->yy_c_buf_p   = yy_cp;
#define YY_NUM_RULES 257
#define YY_END_OF_BUFFER 258
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
    flex_int32_t yy_verify;
    flex_int32_t yy_nxt;
};
static const flex_int16_t yy_accept[948] = {
    0,   0,   0,   0,   0,   258, 256, 255, 255, 239, 245, 250, 234, 235, 243, 242, 231,
    240, 238, 244, 197, 197, 232, 228, 246, 233, 247, 251, 194, 236, 237, 249, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 229, 248, 230, 241, 254, 253, 257, 252, 225, 211, 230, 219, 214, 209,
    217, 207, 218, 208, 203, 210, 202, 196, 197, 0,   200, 0,   237, 229, 236, 226, 222,
    224, 223, 227, 194, 215, 221, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,

    194, 194, 194, 194, 13,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 16,  194, 194, 26,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 216, 220, 252, 0,   206, 202, 0,   205, 199, 0,   201,
    195, 212, 213, 194, 194, 154, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 14,  194,

    194, 194, 194, 194, 194, 194, 194, 194, 194, 31,  194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 27,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 0,   203, 0,   202, 204, 198, 194, 194, 194,
    194, 34,  194, 194, 194, 19,  191, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    17,  157, 194, 194, 194, 194, 22,  194, 194, 161, 172, 194, 194, 194, 194,

    194, 194, 194, 194, 194, 194, 194, 194, 194, 169, 4,   39,  40,  41,  194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 160, 35,  194, 194, 32,  194, 194, 194, 194, 194, 194, 194,
    51,  52,  53,  33,  194, 194, 194, 194, 194, 194, 194, 194, 11,  194, 57,  58,  59,
    194, 155, 194, 194, 7,   194, 194, 194, 194, 181, 182, 183, 194, 36,  194, 173, 30,
    184, 185, 186, 2,   178, 179, 180, 194, 194, 194, 28,  176, 194, 194, 194,

    194, 194, 54,  55,  56,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 25,
    194, 194, 194, 194, 194, 194, 194, 194, 170, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 156, 194, 194, 193, 60,  61,  62,  194, 194, 15,  194, 194, 194, 133,
    194, 194, 9,   194, 194, 131, 194, 194, 194, 171, 166, 134, 194, 194, 194, 194, 194,
    194, 162, 194, 194, 194, 194, 194, 98,  42,  45,  47,  46,  43,  49,  48,  50,  44,
    194, 194, 194, 194, 177, 153, 194, 194, 164, 194, 194, 194, 38,  127, 29,

    190, 23,  165, 97,  194, 175, 18,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 20,  37,  194, 194, 194, 194, 194, 194, 135, 103, 109,
    194, 194, 194, 194, 194, 100, 102, 3,   194, 194, 194, 194, 128, 194, 194, 194, 194,
    194, 194, 194, 158, 194, 194, 194, 194, 194, 8,   194, 194, 10,  194, 194, 194, 194,
    194, 194, 21,  123, 12,  167, 136, 104, 111, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 163, 194, 194, 194, 121, 129, 124, 194, 194, 194,

    194, 194, 194, 194, 194, 159, 137, 105, 110, 194, 194, 174, 194, 125, 194, 194, 194,
    194, 6,   194, 194, 194, 194, 194, 194, 194, 194, 194, 114, 168, 1,   194, 194, 194,
    194, 194, 194, 192, 194, 132, 5,   187, 63,  66,  194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 122, 194, 194, 194, 194, 194, 194, 112, 194, 194,
    194, 194, 194, 194, 147, 71,  72,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 130, 194, 194, 194, 113, 149, 76,  77,  194, 194,

    194, 194, 126, 194, 194, 194, 194, 194, 194, 194, 194, 118, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 70,  194, 194, 194, 194, 64,  194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 119, 194, 138, 194, 106,
    194, 194, 194, 194, 75,  194, 194, 73,  194, 194, 194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 194, 194, 194, 120, 194, 194, 194, 80,  194, 194, 78,  194, 194,
    139, 107, 194, 194, 141, 194, 142, 194, 194, 194, 194, 194, 194, 194, 194,

    24,  194, 194, 194, 194, 68,  194, 67,  89,  194, 194, 194, 194, 194, 140, 108, 194,
    194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 115, 194, 194, 194, 151, 92,
    194, 194, 145, 194, 69,  194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194,
    152, 94,  194, 194, 194, 116, 194, 194, 148, 74,  194, 194, 194, 194, 188, 194, 194,
    194, 81,  194, 194, 194, 194, 194, 117, 150, 79,  194, 194, 194, 194, 194, 194, 194,
    194, 194, 194, 194, 85,  194, 88,  194, 194, 194, 194, 194, 194, 194, 194,

    194, 194, 86,  91,  194, 194, 194, 194, 194, 82,  194, 194, 95,  87,  93,  99,  194,
    143, 144, 101, 194, 194, 194, 194, 65,  194, 194, 194, 194, 189, 194, 194, 194, 146,
    83,  194, 194, 194, 194, 194, 194, 90,  96,  194, 194, 84,  0};

static const YY_CHAR yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  2,  2,  2,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  4,  1,  1,  1,  5,  6,  1,  7,  8,
    9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
    30, 1,  31, 32, 33, 34, 35, 36, 37, 38, 38, 38, 38, 39, 40, 38, 41, 38, 38, 42, 43,
    44, 45, 46, 47, 48, 49, 38, 50, 1,  51, 52, 53, 1,  54, 55, 56, 57,

    58, 59, 60, 61, 62, 38, 63, 64, 65, 66, 67, 68, 38, 69, 70, 71, 72, 73, 74, 75, 76,
    77, 78, 79, 80, 81, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static const YY_CHAR yy_meta[82] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 3, 3, 3, 3, 3, 3,
                                    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 3, 5, 6, 6, 6, 6, 6,
                                    6, 6, 6, 7, 6, 6, 6, 6, 1, 1, 1, 6, 4, 4, 4, 4, 3, 5, 6, 6, 6,
                                    6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 1, 1, 1, 1};

static const flex_int16_t yy_base[954] = {
    0,    0,    0,    81,   0,    1201, 1202, 1202, 1202, 1172, 135,  159,  1202, 1202, 1171,
    156,  1202, 155,  153,  1170, 175,  166,  1168, 1202, 175,  1168, 153,  1202, 0,    1202,
    1202, 157,  1142, 148,  158,  168,  178,  141,  175,  1127, 187,  193,  154,  159,  161,
    1121, 199,  1134, 208,  185,  215,  220,  117,  1119, 1202, 178,  1202, 1202, 1202, 1202,
    1202, 0,    1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202, 240,  1202, 248,
    241,  259,  317,  1202, 0,    1202, 1202, 1202, 1162, 1202, 1202, 1202, 1161, 0,    1202,
    1202, 1118, 1116, 1121, 224,  1118, 1126, 1124, 1124, 1111, 1114,

    1125, 231,  1119, 1107, 1104, 1117, 1104, 1101, 1101, 1107, 192,  236,  1101, 1111, 1097,
    1103, 1106, 1107, 0,    1099, 1109, 241,  1108, 1089, 1102, 1083, 227,  1087, 1100, 1091,
    253,  1084, 254,  1096, 1098, 248,  1087, 257,  1074, 1083, 274,  287,  1087, 1083, 1085,
    1074, 1077, 279,  260,  292,  1086, 1074, 1086, 150,  1079, 1078, 1066, 1202, 1202, 0,
    341,  1202, 312,  357,  1202, 1202, 367,  377,  357,  1202, 1202, 1084, 1075, 0,    1071,
    1066, 1070, 1079, 1073, 1075, 345,  1059, 1059, 1070, 1062, 279,  1072, 1069, 1069, 1067,
    1064, 1056, 1062, 1049, 1047, 1059, 1045, 1061, 0,    1058,

    1046, 1053, 1050, 1054, 1055, 1048, 1045, 1034, 1033, 1046, 1049, 1037, 1048, 1044, 1032,
    1038, 1029, 387,  1034, 1037, 1028, 1035, 1024, 1028, 1019, 1033, 1032, 1023, 1029, 340,
    1013, 1016, 1014, 1013, 1023, 1013, 1008, 1006, 1008, 1018, 1004, 1006, 1003, 1014, 1013,
    1016, 998,  350,  1006, 1002, 1000, 1009, 988,  401,  1006, 1008, 997,  989,  1026, 422,
    432,  442,  454,  1202, 1202, 993,  984,  994,  993,  0,    991,  995,  404,  0,    0,
    983,  981,  981,  982,  977,  985,  974,  991,  980,  407,  0,    0,    974,  984,  983,
    983,  0,    968,  413,  0,    0,    970,  416,  977,  978,

    969,  963,  962,  963,  962,  962,  393,  462,  957,  0,    0,    953,  952,  951,  953,
    954,  959,  953,  949,  962,  957,  957,  955,  954,  948,  942,  944,  943,  947,  952,
    938,  941,  936,  944,  949,  937,  934,  946,  937,  0,    0,    943,  939,  0,    931,
    931,  936,  927,  934,  465,  931,  0,    0,    0,    0,    921,  933,  932,  919,  920,
    929,  930,  930,  0,    915,  0,    0,    0,    916,  0,    924,  915,  0,    914,  915,
    909,  919,  0,    0,    0,    910,  0,    906,  0,    0,    0,    0,    0,    0,    0,
    0,    0,    916,  469,  915,  0,    0,    913,  909,  906,

    954,  953,  0,    0,    0,    896,  475,  478,  481,  901,  897,  902,  893,  891,  904,
    889,  0,    889,  902,  891,  887,  893,  888,  895,  895,  0,    892,  889,  893,  877,
    875,  878,  884,  890,  885,  884,  872,  0,    874,  875,  0,    0,    0,    0,    872,
    875,  0,    869,  879,  870,  0,    880,  860,  0,    869,  864,  0,    857,  857,  870,
    0,    872,  0,    487,  891,  890,  889,  850,  849,  0,    866,  865,  860,  901,  892,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    847,  860,  847,  844,  0,
    0,    849,  350,  0,    846,  853,  852,  0,    838,  0,

    0,    0,    0,    0,    835,  0,    0,    834,  845,  490,  838,  844,  843,  840,  835,
    832,  854,  838,  823,  823,  836,  821,  833,  0,    0,    826,  855,  854,  853,  814,
    813,  478,  481,  0,    825,  828,  826,  815,  811,  826,  0,    0,    822,  819,  818,
    808,  0,    807,  797,  814,  800,  498,  808,  811,  0,    834,  833,  832,  793,  792,
    0,    806,  793,  0,    803,  796,  788,  789,  795,  798,  0,    0,    0,    0,    824,
    823,  0,    794,  797,  782,  789,  780,  787,  788,  788,  787,  773,  509,  784,  784,
    0,    785,  774,  773,  0,    0,    0,    804,  803,  802,

    763,  762,  758,  770,  765,  0,    799,  798,  0,    769,  772,  0,    518,  0,    750,
    771,  789,  757,  0,    753,  752,  761,  761,  749,  763,  747,  761,  756,  782,  0,
    0,    778,  777,  776,  737,  736,  735,  0,    735,  0,    0,    486,  497,  763,  745,
    748,  731,  744,  742,  730,  729,  738,  738,  761,  760,  759,  720,  719,  0,    724,
    714,  717,  718,  717,  727,  753,  729,  725,  727,  723,  710,  709,  746,  507,  0,
    717,  720,  710,  711,  703,  710,  701,  726,  710,  706,  708,  706,  706,  705,  704,
    0,    692,  691,  701,  727,  726,  512,  0,    697,  700,

    697,  682,  0,    698,  697,  681,  680,  672,  680,  670,  678,  0,    675,  674,  673,
    698,  682,  680,  680,  673,  663,  666,  680,  664,  701,  675,  676,  673,  670,  514,
    658,  659,  671,  670,  654,  653,  652,  651,  676,  660,  658,  658,  661,  656,  637,
    636,  0,    642,  667,  635,  665,  629,  646,  618,  617,  654,  133,  176,  213,  212,
    242,  266,  269,  298,  297,  297,  353,  356,  359,  398,  427,  423,  512,  434,  435,
    0,    449,  463,  477,  522,  499,  498,  527,  491,  492,  0,    0,    508,  502,  0,
    503,  0,    489,  512,  513,  499,  498,  501,  502,  503,

    0,    497,  507,  499,  507,  534,  511,  0,    0,    510,  526,  527,  513,  548,  0,
    0,    530,  531,  532,  518,  517,  520,  521,  534,  526,  517,  540,  541,  0,    520,
    521,  529,  0,    0,    530,  546,  558,  528,  560,  550,  544,  532,  553,  551,  545,
    556,  579,  536,  537,  538,  546,  0,    0,    547,  582,  564,  0,    562,  563,  0,
    0,    567,  568,  557,  563,  0,    564,  550,  573,  0,    552,  562,  589,  566,  595,
    0,    0,    0,    579,  580,  587,  572,  570,  571,  563,  564,  581,  588,  589,  0,
    587,  602,  572,  612,  590,  610,  574,  575,  608,  636,

    580,  581,  0,    0,    598,  600,  601,  592,  599,  0,    618,  615,  0,    0,    0,
    0,    629,  0,    0,    0,    597,  598,  592,  613,  0,    633,  620,  596,  597,  0,
    615,  641,  657,  0,    0,    608,  639,  628,  604,  640,  645,  0,    0,    633,  638,
    0,    1202, 681,  686,  691,  696,  699,  702};

static const flex_int16_t yy_def[954] = {
    0,   947, 1,   947, 3,   947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 948, 947, 947, 947, 947, 947, 947, 949, 947, 947, 947, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    947, 947, 947, 947, 947, 947, 947, 950, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    951, 947, 952, 20,  948, 947, 947, 953, 947, 947, 947, 947, 947, 947, 947, 947, 949, 947,
    947, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 947, 947, 950, 947, 947, 952, 947, 947, 947, 947, 947, 953, 947, 947, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 947, 947, 947, 947, 947, 947, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949,

    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 949,
    949, 949, 949, 949, 949, 949, 949, 949, 949, 949, 0,   947, 947, 947, 947, 947, 947};

static const flex_int16_t yy_nxt[1284] = {
    0,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  22,  23,  24,  25,  26,  27,  28,  28,  28,
    28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,
    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  28,  42,  43,  44,  45,
    46,  47,  48,  49,  50,  51,  52,  28,  53,  28,  54,  55,  56,  57,  58,  59,  60,
    58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,

    58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,  61,  61,  61,  61,  61,  61,
    61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  58,  58,  58,  61,
    61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
    61,  61,  61,  61,  61,  61,  61,  58,  58,  58,  58,  63,  64,  65,  68,  70,  72,
    72,  72,  72,  72,  72,  72,  72,  72,  72,  155, 74,  81,  86,  87,  71,  69,  89,
    156, 66,  74,  797, 75,  75,  75,  75,  75,  75,  75,  75,  76,  76,  82,

    77,  83,  84,  92,  107, 158, 108, 126, 90,  77,  78,  255, 128, 256, 130, 109, 129,
    93,  94,  78,  127, 99,  79,  77,  95,  100, 96,  131, 110, 97,  98,  101, 77,  798,
    102, 103, 111, 78,  112, 104, 116, 113, 144, 799, 105, 145, 78,  114, 117, 79,  106,
    119, 133, 146, 120, 195, 159, 121, 122, 118, 147, 137, 123, 124, 800, 125, 196, 134,
    138, 139, 135, 74,  140, 152, 161, 162, 148, 153, 141, 142, 149, 143, 164, 165, 150,
    166, 154, 151, 947, 197, 175, 184, 216, 77,  176, 185, 186, 161, 162, 801,

    217, 229, 198, 78,  207, 164, 165, 208, 209, 224, 233, 210, 166, 211, 221, 947, 77,
    230, 231, 802, 222, 248, 225, 234, 226, 803, 167, 237, 167, 249, 78,  168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 239, 238, 246, 247, 250, 164, 165, 280, 281, 260,
    804, 260, 251, 240, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 805, 262, 806,
    262, 164, 165, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168,

    168, 265, 274, 312, 313, 314, 326, 547, 345, 807, 327, 548, 264, 401, 402, 275, 346,
    352, 353, 354, 366, 367, 368, 378, 379, 380, 808, 809, 265, 386, 387, 388, 390, 391,
    392, 264, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261,
    261, 261, 261, 261, 261, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 810, 162,
    263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 403, 404, 405, 442, 443, 444, 465,
    466, 467, 811, 812, 165, 162, 477, 478, 479, 480, 481, 482, 483, 484, 485,

    468, 469, 527, 528, 529, 556, 557, 558, 580, 815, 816, 582, 165, 598, 599, 600, 680,
    817, 530, 531, 581, 559, 560, 583, 632, 633, 634, 682, 681, 601, 602, 818, 603, 654,
    655, 656, 683, 715, 684, 685, 635, 636, 738, 604, 770, 819, 716, 813, 717, 657, 658,
    739, 820, 740, 821, 822, 771, 823, 814, 824, 825, 826, 827, 828, 829, 830, 831, 832,
    833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849,
    850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864,

    865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881,
    882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898,
    899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915,
    916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932,
    933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 76,  76,  796,
    795, 794, 76,  88,  88,  88,  88,  88,  160, 160, 160, 160, 160, 72,  793,

    72,  163, 792, 163, 169, 169, 169, 791, 790, 789, 788, 787, 786, 785, 784, 783, 782,
    781, 780, 779, 778, 777, 776, 775, 774, 773, 772, 769, 768, 767, 766, 765, 764, 763,
    762, 761, 760, 759, 758, 757, 756, 755, 754, 753, 752, 751, 750, 749, 748, 747, 746,
    745, 744, 743, 742, 741, 737, 736, 735, 734, 733, 732, 731, 730, 729, 728, 727, 726,
    725, 724, 723, 722, 721, 720, 719, 718, 714, 713, 712, 711, 710, 709, 708, 707, 706,
    705, 704, 703, 702, 701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691,

    690, 689, 688, 687, 686, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668,
    667, 666, 665, 664, 663, 662, 661, 660, 659, 653, 652, 651, 650, 649, 648, 647, 646,
    645, 644, 643, 642, 641, 640, 639, 638, 637, 631, 630, 629, 628, 627, 626, 625, 624,
    623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607,
    606, 605, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585, 584, 579,
    578, 577, 576, 575, 574, 573, 572, 571, 570, 569, 568, 567, 566, 565, 564,

    563, 562, 561, 555, 554, 553, 552, 551, 550, 549, 546, 545, 544, 543, 542, 541, 540,
    539, 538, 537, 536, 535, 534, 533, 532, 526, 525, 524, 523, 522, 521, 520, 519, 518,
    517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501,
    500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 476, 475,
    474, 473, 472, 471, 470, 464, 463, 462, 461, 460, 459, 458, 457, 456, 455, 454, 453,
    452, 451, 450, 449, 448, 447, 446, 445, 441, 440, 439, 438, 437, 436, 435,

    434, 433, 432, 431, 430, 429, 428, 427, 426, 425, 424, 423, 422, 421, 420, 419, 418,
    417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406, 400, 399, 398, 397, 396,
    395, 394, 393, 389, 385, 384, 383, 382, 381, 377, 376, 375, 374, 373, 372, 371, 370,
    369, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 355, 351, 350, 349, 348, 347,
    344, 343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328,
    325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 311, 310, 309, 308,

    307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291,
    290, 289, 288, 287, 286, 285, 284, 283, 282, 279, 278, 277, 276, 273, 272, 271, 270,
    269, 268, 267, 266, 259, 258, 257, 254, 253, 252, 245, 244, 243, 242, 241, 236, 235,
    232, 228, 227, 223, 220, 219, 218, 215, 214, 213, 212, 206, 205, 204, 203, 202, 201,
    200, 199, 194, 193, 192, 191, 190, 189, 188, 187, 183, 182, 181, 180, 179, 178, 177,
    174, 173, 172, 171, 170, 157, 136, 132, 115, 91,  85,  80,  73,  67,  62,

    947, 5,   947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947};

static const flex_int16_t yy_chk[1284] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,

    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   10,  10,  11,  15,  17,  18,
    18,  18,  18,  18,  18,  18,  18,  18,  18,  52,  21,  24,  26,  26,  17,  15,  31,
    52,  11,  20,  757, 20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  24,

    21,  24,  24,  33,  37,  55,  37,  42,  31,  20,  21,  154, 43,  154, 44,  37,  43,
    33,  33,  20,  42,  35,  20,  21,  34,  35,  34,  44,  38,  34,  34,  35,  20,  758,
    35,  36,  38,  21,  38,  36,  40,  38,  49,  759, 36,  49,  20,  38,  40,  20,  36,
    41,  46,  49,  41,  111, 55,  41,  41,  40,  49,  48,  41,  41,  760, 41,  111, 46,
    48,  48,  46,  76,  48,  51,  72,  72,  50,  51,  48,  48,  50,  48,  74,  74,  50,
    75,  51,  50,  75,  112, 94,  102, 127, 76,  94,  102, 102, 72,  72,  761,

    127, 136, 112, 76,  122, 74,  74,  122, 122, 133, 138, 122, 75,  122, 131, 75,  76,
    136, 136, 762, 131, 149, 133, 138, 133, 763, 77,  141, 77,  149, 76,  77,  77,  77,
    77,  77,  77,  77,  77,  77,  77,  142, 141, 148, 148, 150, 163, 163, 186, 186, 161,
    764, 161, 150, 142, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 765, 164, 766,
    164, 163, 163, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 167, 167, 167, 167,
    167, 167, 167, 167, 167, 167, 168, 168, 168, 168, 168, 168, 168, 168, 168,

    168, 169, 181, 218, 218, 218, 230, 493, 248, 767, 230, 493, 168, 307, 307, 181, 248,
    254, 254, 254, 273, 273, 273, 285, 285, 285, 768, 769, 169, 294, 294, 294, 298, 298,
    298, 168, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 261, 261, 261, 261, 261,
    261, 261, 261, 261, 261, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 770, 261,
    263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 308, 308, 308, 350, 350, 350, 394,
    394, 394, 771, 772, 263, 261, 407, 407, 407, 408, 408, 408, 409, 409, 409,

    394, 394, 464, 464, 464, 510, 510, 510, 532, 774, 775, 533, 263, 552, 552, 552, 642,
    777, 464, 464, 532, 510, 510, 533, 588, 588, 588, 643, 642, 552, 552, 778, 552, 613,
    613, 613, 643, 674, 643, 643, 588, 588, 697, 552, 730, 779, 674, 773, 674, 613, 613,
    697, 780, 697, 781, 782, 730, 783, 773, 784, 785, 788, 789, 791, 793, 794, 795, 796,
    797, 798, 799, 800, 802, 803, 804, 805, 806, 807, 810, 811, 812, 813, 814, 817, 818,
    819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 830, 831, 832, 835, 836,

    837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 854, 855,
    856, 858, 859, 862, 863, 864, 865, 867, 868, 869, 871, 872, 873, 874, 875, 879, 880,
    881, 882, 883, 884, 885, 886, 887, 888, 889, 891, 892, 893, 894, 895, 896, 897, 898,
    899, 900, 901, 902, 905, 906, 907, 908, 909, 911, 912, 917, 921, 922, 923, 924, 926,
    927, 928, 929, 931, 932, 933, 936, 937, 938, 939, 940, 941, 944, 945, 948, 948, 756,
    755, 754, 948, 949, 949, 949, 949, 949, 950, 950, 950, 950, 950, 951, 753,

    951, 952, 752, 952, 953, 953, 953, 751, 750, 749, 748, 746, 745, 744, 743, 742, 741,
    740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 729, 728, 727, 726, 725, 724, 723,
    722, 721, 720, 719, 718, 717, 716, 715, 714, 713, 711, 710, 709, 708, 707, 706, 705,
    704, 702, 701, 700, 699, 696, 695, 694, 693, 692, 690, 689, 688, 687, 686, 685, 684,
    683, 682, 681, 680, 679, 678, 677, 676, 673, 672, 671, 670, 669, 668, 667, 666, 665,
    664, 663, 662, 661, 660, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649,

    648, 647, 646, 645, 644, 639, 637, 636, 635, 634, 633, 632, 629, 628, 627, 626, 625,
    624, 623, 622, 621, 620, 618, 617, 616, 615, 611, 610, 608, 607, 605, 604, 603, 602,
    601, 600, 599, 598, 594, 593, 592, 590, 589, 587, 586, 585, 584, 583, 582, 581, 580,
    579, 578, 576, 575, 570, 569, 568, 567, 566, 565, 563, 562, 560, 559, 558, 557, 556,
    554, 553, 551, 550, 549, 548, 546, 545, 544, 543, 540, 539, 538, 537, 536, 535, 531,
    530, 529, 528, 527, 526, 523, 522, 521, 520, 519, 518, 517, 516, 515, 514,

    513, 512, 511, 509, 508, 505, 499, 497, 496, 495, 492, 489, 488, 487, 486, 475, 474,
    473, 472, 471, 469, 468, 467, 466, 465, 462, 460, 459, 458, 456, 455, 453, 452, 450,
    449, 448, 446, 445, 440, 439, 437, 436, 435, 434, 433, 432, 431, 430, 429, 428, 427,
    425, 424, 423, 422, 421, 420, 419, 418, 416, 415, 414, 413, 412, 411, 410, 406, 402,
    401, 400, 399, 398, 395, 393, 383, 381, 377, 376, 375, 374, 372, 371, 369, 365, 363,
    362, 361, 360, 359, 358, 357, 356, 351, 349, 348, 347, 346, 345, 343, 342,

    339, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323,
    322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 309, 306, 305, 304, 303, 302,
    301, 300, 299, 297, 293, 291, 290, 289, 288, 284, 283, 282, 281, 280, 279, 278, 277,
    276, 272, 271, 269, 268, 267, 266, 259, 258, 257, 256, 255, 253, 252, 251, 250, 249,
    247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231,
    229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 217, 216, 215, 214,

    213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 198, 197, 196,
    195, 194, 193, 192, 191, 190, 189, 188, 187, 185, 184, 183, 182, 180, 179, 178, 177,
    176, 175, 173, 172, 157, 156, 155, 153, 152, 151, 147, 146, 145, 144, 143, 140, 139,
    137, 135, 134, 132, 130, 129, 128, 126, 125, 124, 123, 121, 120, 118, 117, 116, 115,
    114, 113, 110, 109, 108, 107, 106, 105, 104, 103, 101, 100, 99,  98,  97,  96,  95,
    93,  92,  91,  87,  83,  53,  47,  45,  39,  32,  25,  22,  19,  14,  9,

    5,   947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947,
    947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947};

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[258] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
/*
//
// Copyright 2002 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

This file contains the Lex specification for GLSL ES.
Based on ANSI C grammar, Lex specification:
http://www.lysator.liu.se/c/ANSI-C-grammar-l.html

IF YOU MODIFY THIS FILE YOU ALSO NEED TO RUN scripts/run_code_generation.py
WHICH GENERATES THE GLSL ES LEXER (glslang_lex_autogen.cpp).
*/

#include "compiler/preprocessor/Token.h"
#include "compiler/translator/ParseContext.h"
#include "compiler/translator/glslang.h"
#include "compiler/translator/length_limits.h"
#include "compiler/translator/util.h"

using namespace sh;

#include "glslang_tab_autogen.h"

/* windows only pragma */
#ifdef _MSC_VER
#    pragma warning(disable : 4102)
#endif

// Workaround for flex using the register keyword, deprecated in C++11.
#ifdef __cplusplus
#    if __cplusplus > 199711L
#        define register
#    endif
#endif

#define YY_NO_INPUT
#define YY_USER_ACTION                                 \
    yylloc->first_file = yylloc->last_file = yycolumn; \
    yylloc->first_line = yylloc->last_line = yylineno;

#define YY_INPUT(buf, result, max_size) result = string_input(buf, max_size, yyscanner);

static yy_size_t string_input(char *buf, yy_size_t max_size, yyscan_t yyscanner);
static int check_type(yyscan_t yyscanner);
static int reserved_word(yyscan_t yyscanner);
// Tests if an extension is enabled.  If the extension is promoted to core, this function returns
// true.
static bool is_extension_enabled_or_is_core(TParseContext *context,
                                            int extension_version,
                                            TExtension extension,
                                            int promotion_version);
// Helpers to determine if a symbol is reserved, keyword in extension or core, or identifier.
// Formatted as:
//
//    [V1_reserved_][V2_extension_][V3_keyword]
//
// which means in version V1, the symbol is reserved, and remains reserved until V3.  From versions
// V2 until V3, it's a keyword if the extension is enabled.  From version V3 on, it's a keyword in
// the spec itself.  Prior to V1, the symbol can be used as identifier.
static int ES2_reserved_ES3_keyword(TParseContext *context, int token);
static int ES2_keyword_ES3_reserved(TParseContext *context, int token);
static int ES3_keyword(TParseContext *context, int token);
static int ES3_reserved_ES3_1_keyword(TParseContext *context, int token);
static int ES2_reserved_ES3_1_keyword(TParseContext *context, int token);
static int ES3_1_keyword(TParseContext *context, int token);
static int ES2_reserved_ES2_extension_ES3_keyword(TParseContext *context,
                                                  TExtension extension,
                                                  int token);
static int ES3_extension(TParseContext *context, TExtension extension, int token);
static int ES3_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                      TExtension extension,
                                                      int token);
static int ES3_reserved_ES3_extension(TParseContext *context, TExtension extension, int token);
static int ES3_reserved_ES3_extension_ES3_1_keyword(TParseContext *context,
                                                    TExtension extension,
                                                    int token);
static int ES3_reserved_ES3_extension_ES3_2_keyword(TParseContext *context,
                                                    TExtension extension,
                                                    int token);
static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                        TExtension extension,
                                                        int token);
static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                          TExtension extension1,
                                                          TExtension extension2,
                                                          int token1,
                                                          int token2);
static int ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                                TExtension extension1,
                                                                TExtension extension2,
                                                                int token1,
                                                                int token2);
static int WEBGL_video_texture_extension(TParseContext *context, int token);
static int ANGLE_webgl_video_frame_extension(TParseContext *context, int token);
static int uint_constant(TParseContext *context);
static int int_constant(TParseContext *context);
static int float_constant(yyscan_t yyscanner);
static int floatsuffix_check(TParseContext *context);
static int yuvcscstandardext_constant(TParseContext *context);

#define INITIAL 0
#define FIELDS 1

#define YY_EXTRA_TYPE TParseContext *

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
{

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top;       /**< index of top of stack. */
    size_t yy_buffer_stack_max;       /**< capacity of stack. */
    YY_BUFFER_STATE *yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char *yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    YYSTYPE *yylval_r;

    YYLTYPE *yylloc_r;

}; /* end struct yyguts_t */

static int yy_init_globals(yyscan_t yyscanner);

/* This must go here because YYSTYPE and YYLTYPE are included
 * from bison output in section 1.*/
#define yylval yyg->yylval_r

#define yylloc yyg->yylloc_r

int yylex_init(yyscan_t *scanner);

int yylex_init_extra(YY_EXTRA_TYPE user_defined, yyscan_t *scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(yyscan_t yyscanner);

int yyget_debug(yyscan_t yyscanner);

void yyset_debug(int debug_flag, yyscan_t yyscanner);

YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner);

void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner);

FILE *yyget_in(yyscan_t yyscanner);

void yyset_in(FILE *_in_str, yyscan_t yyscanner);

FILE *yyget_out(yyscan_t yyscanner);

void yyset_out(FILE *_out_str, yyscan_t yyscanner);

int yyget_leng(yyscan_t yyscanner);

char *yyget_text(yyscan_t yyscanner);

int yyget_lineno(yyscan_t yyscanner);

void yyset_lineno(int _line_number, yyscan_t yyscanner);

int yyget_column(yyscan_t yyscanner);

void yyset_column(int _column_no, yyscan_t yyscanner);

YYSTYPE *yyget_lval(yyscan_t yyscanner);

void yyset_lval(YYSTYPE *yylval_param, yyscan_t yyscanner);

YYLTYPE *yyget_lloc(yyscan_t yyscanner);

void yyset_lloc(YYLTYPE *yylloc_param, yyscan_t yyscanner);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#    ifdef __cplusplus
extern "C" int yywrap(yyscan_t yyscanner);
#    else
extern int yywrap(yyscan_t yyscanner);
#    endif
#endif

#ifndef YY_NO_UNPUT

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, const char *, int, yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *, yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT
#    ifdef __cplusplus
static int yyinput(yyscan_t yyscanner);
#    else
static int input(yyscan_t yyscanner);
#    endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#    ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#        define YY_READ_BUF_SIZE 16384
#    else
#        define YY_READ_BUF_SIZE 8192
#    endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#    define ECHO                                          \
        do                                                \
        {                                                 \
            if (fwrite(yytext, (size_t)yyleng, 1, yyout)) \
            {                                             \
            }                                             \
        } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#    define YY_INPUT(buf, result, max_size)                                                       \
        if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                          \
        {                                                                                         \
            int c = '*';                                                                          \
            int n;                                                                                \
            for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                \
                buf[n] = (char)c;                                                                 \
            if (c == '\n')                                                                        \
                buf[n++] = (char)c;                                                               \
            if (c == EOF && ferror(yyin))                                                         \
                YY_FATAL_ERROR("input in flex scanner failed");                                   \
            result = n;                                                                           \
        }                                                                                         \
        else                                                                                      \
        {                                                                                         \
            errno = 0;                                                                            \
            while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin)) \
            {                                                                                     \
                if (errno != EINTR)                                                               \
                {                                                                                 \
                    YY_FATAL_ERROR("input in flex scanner failed");                               \
                    break;                                                                        \
                }                                                                                 \
                errno = 0;                                                                        \
                clearerr(yyin);                                                                   \
            }                                                                                     \
        }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#    define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#    define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#    define YY_FATAL_ERROR(msg) yy_fatal_error(msg, yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#    define YY_DECL_IS_OURS 1

extern int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner);

#    define YY_DECL int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#    define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#    define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yylval = yylval_param;

    yylloc = yylloc_param;

    if (!yyg->yy_init)
    {
        yyg->yy_init = 1;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if (!yyg->yy_start)
            yyg->yy_start = 1; /* first start state */

        if (!yyin)
            yyin = stdin;

        if (!yyout)
            yyout = stdout;

        if (!YY_CURRENT_BUFFER)
        {
            yyensure_buffer_stack(yyscanner);
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
        }

        yy_load_buffer_state(yyscanner);
    }

    {

        TParseContext *context = yyextra;

        while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
        {
            yy_cp = yyg->yy_c_buf_p;

            /* Support of yytext. */
            *yy_cp = yyg->yy_hold_char;

            /* yy_bp points to the position in yy_ch_buf of the start of
             * the current run.
             */
            yy_bp = yy_cp;

            yy_current_state = yyg->yy_start;
        yy_match:
            do
            {
                YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                if (yy_accept[yy_current_state])
                {
                    yyg->yy_last_accepting_state = yy_current_state;
                    yyg->yy_last_accepting_cpos  = yy_cp;
                }
                while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
                {
                    yy_current_state = (int)yy_def[yy_current_state];
                    if (yy_current_state >= 948)
                        yy_c = yy_meta[yy_c];
                }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
                ++yy_cp;
            } while (yy_current_state != 947);
            yy_cp            = yyg->yy_last_accepting_cpos;
            yy_current_state = yyg->yy_last_accepting_state;

        yy_find_action:
            yy_act = yy_accept[yy_current_state];

            YY_DO_BEFORE_ACTION;

            if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
            {
                int yyl;
                for (yyl = 0; yyl < yyleng; ++yyl)
                    if (yytext[yyl] == '\n')

                        do
                        {
                            yylineno++;
                            yycolumn = 0;
                        } while (0);
            }

        do_action: /* This label is used only to access EOF actions. */

            switch (yy_act)
            {           /* beginning of action switch */
                case 0: /* must back up */
                    /* undo the effects of YY_DO_BEFORE_ACTION */
                    *yy_cp           = yyg->yy_hold_char;
                    yy_cp            = yyg->yy_last_accepting_cpos;
                    yy_current_state = yyg->yy_last_accepting_state;
                    goto yy_find_action;

                case 1:
                    YY_RULE_SETUP { return INVARIANT; }
                    YY_BREAK
                case 2:
                    YY_RULE_SETUP { return HIGH_PRECISION; }
                    YY_BREAK
                case 3:
                    YY_RULE_SETUP { return MEDIUM_PRECISION; }
                    YY_BREAK
                case 4:
                    YY_RULE_SETUP { return LOW_PRECISION; }
                    YY_BREAK
                case 5:
                    YY_RULE_SETUP { return PRECISION; }
                    YY_BREAK
                case 6:
                    YY_RULE_SETUP { return ES2_keyword_ES3_reserved(context, ATTRIBUTE); }
                    YY_BREAK
                case 7:
                    YY_RULE_SETUP { return CONST_QUAL; }
                    YY_BREAK
                case 8:
                    YY_RULE_SETUP { return UNIFORM; }
                    YY_BREAK
                case 9:
                    YY_RULE_SETUP { return ES3_1_keyword(context, BUFFER); }
                    YY_BREAK
                case 10:
                    YY_RULE_SETUP { return ES2_keyword_ES3_reserved(context, VARYING); }
                    YY_BREAK
                case 11:
                    YY_RULE_SETUP { return BREAK; }
                    YY_BREAK
                case 12:
                    YY_RULE_SETUP { return CONTINUE; }
                    YY_BREAK
                case 13:
                    YY_RULE_SETUP { return DO; }
                    YY_BREAK
                case 14:
                    YY_RULE_SETUP { return FOR; }
                    YY_BREAK
                case 15:
                    YY_RULE_SETUP { return WHILE; }
                    YY_BREAK
                case 16:
                    YY_RULE_SETUP { return IF; }
                    YY_BREAK
                case 17:
                    YY_RULE_SETUP { return ELSE; }
                    YY_BREAK
                case 18:
                    YY_RULE_SETUP { return ES2_reserved_ES3_keyword(context, SWITCH); }
                    YY_BREAK
                case 19:
                    YY_RULE_SETUP { return ES3_keyword(context, CASE); }
                    YY_BREAK
                case 20:
                    YY_RULE_SETUP { return ES2_reserved_ES3_keyword(context, DEFAULT); }
                    YY_BREAK
                case 21:
                    YY_RULE_SETUP { return ES3_keyword(context, CENTROID); }
                    YY_BREAK
                case 22:
                    YY_RULE_SETUP { return ES2_reserved_ES3_keyword(context, FLAT); }
                    YY_BREAK
                case 23:
                    YY_RULE_SETUP { return ES3_keyword(context, SMOOTH); }
                    YY_BREAK
                case 24:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension(
                            context, TExtension::NV_shader_noperspective_interpolation,
                            NOPERSPECTIVE);
                    }
                    YY_BREAK
                case 25:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::EXT_tessellation_shader, PATCH);
                    }
                    YY_BREAK
                case 26:
                    YY_RULE_SETUP { return IN_QUAL; }
                    YY_BREAK
                case 27:
                    YY_RULE_SETUP { return OUT_QUAL; }
                    YY_BREAK
                case 28:
                    YY_RULE_SETUP { return INOUT_QUAL; }
                    YY_BREAK
                case 29:
                    YY_RULE_SETUP { return ES3_1_keyword(context, SHARED); }
                    YY_BREAK
                case 30:
                    YY_RULE_SETUP { return FLOAT_TYPE; }
                    YY_BREAK
                case 31:
                    YY_RULE_SETUP { return INT_TYPE; }
                    YY_BREAK
                case 32:
                    YY_RULE_SETUP { return ES3_keyword(context, UINT_TYPE); }
                    YY_BREAK
                case 33:
                    YY_RULE_SETUP { return VOID_TYPE; }
                    YY_BREAK
                case 34:
                    YY_RULE_SETUP { return BOOL_TYPE; }
                    YY_BREAK
                case 35:
                    YY_RULE_SETUP
                    {
                        yylval->lex.b = true;
                        return BOOLCONSTANT;
                    }
                    YY_BREAK
                case 36:
                    YY_RULE_SETUP
                    {
                        yylval->lex.b = false;
                        return BOOLCONSTANT;
                    }
                    YY_BREAK
                case 37:
                    YY_RULE_SETUP { return DISCARD; }
                    YY_BREAK
                case 38:
                    YY_RULE_SETUP { return RETURN; }
                    YY_BREAK
                case 39:
                    YY_RULE_SETUP { return MATRIX2; }
                    YY_BREAK
                case 40:
                    YY_RULE_SETUP { return MATRIX3; }
                    YY_BREAK
                case 41:
                    YY_RULE_SETUP { return MATRIX4; }
                    YY_BREAK
                case 42:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX2); }
                    YY_BREAK
                case 43:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX3); }
                    YY_BREAK
                case 44:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX4); }
                    YY_BREAK
                case 45:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX2x3); }
                    YY_BREAK
                case 46:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX3x2); }
                    YY_BREAK
                case 47:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX2x4); }
                    YY_BREAK
                case 48:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX4x2); }
                    YY_BREAK
                case 49:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX3x4); }
                    YY_BREAK
                case 50:
                    YY_RULE_SETUP { return ES3_keyword(context, MATRIX4x3); }
                    YY_BREAK
                case 51:
                    YY_RULE_SETUP { return VEC2; }
                    YY_BREAK
                case 52:
                    YY_RULE_SETUP { return VEC3; }
                    YY_BREAK
                case 53:
                    YY_RULE_SETUP { return VEC4; }
                    YY_BREAK
                case 54:
                    YY_RULE_SETUP { return IVEC2; }
                    YY_BREAK
                case 55:
                    YY_RULE_SETUP { return IVEC3; }
                    YY_BREAK
                case 56:
                    YY_RULE_SETUP { return IVEC4; }
                    YY_BREAK
                case 57:
                    YY_RULE_SETUP { return BVEC2; }
                    YY_BREAK
                case 58:
                    YY_RULE_SETUP { return BVEC3; }
                    YY_BREAK
                case 59:
                    YY_RULE_SETUP { return BVEC4; }
                    YY_BREAK
                case 60:
                    YY_RULE_SETUP { return ES3_keyword(context, UVEC2); }
                    YY_BREAK
                case 61:
                    YY_RULE_SETUP { return ES3_keyword(context, UVEC3); }
                    YY_BREAK
                case 62:
                    YY_RULE_SETUP { return ES3_keyword(context, UVEC4); }
                    YY_BREAK
                case 63:
                    YY_RULE_SETUP { return SAMPLER2D; }
                    YY_BREAK
                case 64:
                    YY_RULE_SETUP { return SAMPLERCUBE; }
                    YY_BREAK
                case 65:
                    YY_RULE_SETUP { return SAMPLER_EXTERNAL_OES; }
                    YY_BREAK
                case 66:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES2_extension_ES3_keyword(
                            context, TExtension::OES_texture_3D, SAMPLER3D);
                    }
                    YY_BREAK
                case 67:
                    YY_RULE_SETUP { return ES2_reserved_ES3_keyword(context, SAMPLER3DRECT); }
                    YY_BREAK
                case 68:
                    YY_RULE_SETUP { return SAMPLER2DRECT; }
                    YY_BREAK
                case 69:
                    YY_RULE_SETUP { return ES3_keyword(context, SAMPLER2DARRAY); }
                    YY_BREAK
                case 70:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, SAMPLER2DMS);
                    }
                    YY_BREAK
                case 71:
                    YY_RULE_SETUP { return ES3_keyword(context, ISAMPLER2D); }
                    YY_BREAK
                case 72:
                    YY_RULE_SETUP { return ES3_keyword(context, ISAMPLER3D); }
                    YY_BREAK
                case 73:
                    YY_RULE_SETUP { return ES3_keyword(context, ISAMPLERCUBE); }
                    YY_BREAK
                case 74:
                    YY_RULE_SETUP { return ES3_keyword(context, ISAMPLER2DARRAY); }
                    YY_BREAK
                case 75:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, ISAMPLER2DMS);
                    }
                    YY_BREAK
                case 76:
                    YY_RULE_SETUP { return ES3_keyword(context, USAMPLER2D); }
                    YY_BREAK
                case 77:
                    YY_RULE_SETUP { return ES3_keyword(context, USAMPLER3D); }
                    YY_BREAK
                case 78:
                    YY_RULE_SETUP { return ES3_keyword(context, USAMPLERCUBE); }
                    YY_BREAK
                case 79:
                    YY_RULE_SETUP { return ES3_keyword(context, USAMPLER2DARRAY); }
                    YY_BREAK
                case 80:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_1_keyword(
                            context, TExtension::ANGLE_texture_multisample, USAMPLER2DMS);
                    }
                    YY_BREAK
                case 81:
                    YY_RULE_SETUP
                    {
                        return ES2_reserved_ES2_extension_ES3_keyword(
                            context, TExtension::EXT_shadow_samplers, SAMPLER2DSHADOW);
                    }
                    YY_BREAK
                case 82:
                    YY_RULE_SETUP { return ES3_keyword(context, SAMPLERCUBESHADOW); }
                    YY_BREAK
                case 83:
                    YY_RULE_SETUP { return ES3_keyword(context, SAMPLER2DARRAYSHADOW); }
                    YY_BREAK
                case 84:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::EXT_YUV_target,
                                             SAMPLEREXTERNAL2DY2YEXT);
                    }
                    YY_BREAK
                case 85:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            SAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 86:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            ISAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 87:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::OES_texture_storage_multisample_2d_array,
                            USAMPLER2DMSARRAY);
                    }
                    YY_BREAK
                case 88:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, SAMPLERCUBEARRAYOES,
                            SAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 89:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            SAMPLERBUFFER, SAMPLERBUFFER);
                    }
                    YY_BREAK
                case 90:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, SAMPLERCUBEARRAYSHADOWOES,
                            SAMPLERCUBEARRAYSHADOWEXT);
                    }
                    YY_BREAK
                case 91:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, ISAMPLERCUBEARRAYOES,
                            ISAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 92:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            ISAMPLERBUFFER, ISAMPLERBUFFER);
                    }
                    YY_BREAK
                case 93:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, USAMPLERCUBEARRAYOES,
                            USAMPLERCUBEARRAYEXT);
                    }
                    YY_BREAK
                case 94:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            USAMPLERBUFFER, USAMPLERBUFFER);
                    }
                    YY_BREAK
                case 95:
                    YY_RULE_SETUP
                    {
                        return WEBGL_video_texture_extension(context, SAMPLERVIDEOWEBGL);
                    }
                    YY_BREAK
                case 96:
                    YY_RULE_SETUP
                    {
                        return ANGLE_webgl_video_frame_extension(context, SAMPLERVIDEOFRAMEWEBGL);
                    }
                    YY_BREAK
                case 97:
                    YY_RULE_SETUP { return STRUCT; }
                    YY_BREAK
                case 98:
                    YY_RULE_SETUP { return ES3_keyword(context, LAYOUT); }
                    YY_BREAK
                case 99:
                    YY_RULE_SETUP
                    {
                        return ES3_extension(context, TExtension::EXT_YUV_target,
                                             YUVCSCSTANDARDEXT);
                    }
                    YY_BREAK
                case 100:
                    YY_RULE_SETUP { return yuvcscstandardext_constant(context); }
                    YY_BREAK
                case 101:
                    YY_RULE_SETUP { return yuvcscstandardext_constant(context); }
                    YY_BREAK
                case 102:
                    YY_RULE_SETUP { return yuvcscstandardext_constant(context); }
                    YY_BREAK
                case 103:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IMAGE2D); }
                    YY_BREAK
                case 104:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IIMAGE2D); }
                    YY_BREAK
                case 105:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, UIMAGE2D); }
                    YY_BREAK
                case 106:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IMAGE2DARRAY); }
                    YY_BREAK
                case 107:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IIMAGE2DARRAY); }
                    YY_BREAK
                case 108:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, UIMAGE2DARRAY); }
                    YY_BREAK
                case 109:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IMAGE3D); }
                    YY_BREAK
                case 110:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, UIMAGE3D); }
                    YY_BREAK
                case 111:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IIMAGE3D); }
                    YY_BREAK
                case 112:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IIMAGECUBE); }
                    YY_BREAK
                case 113:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, UIMAGECUBE); }
                    YY_BREAK
                case 114:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, IMAGECUBE); }
                    YY_BREAK
                case 115:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, IMAGECUBEARRAYOES,
                            IMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 116:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, IIMAGECUBEARRAYOES,
                            IIMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 117:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_cube_map_array,
                            TExtension::EXT_texture_cube_map_array, UIMAGECUBEARRAYOES,
                            UIMAGECUBEARRAYEXT);
                    }
                    YY_BREAK
                case 118:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            IMAGEBUFFER, IMAGEBUFFER);
                    }
                    YY_BREAK
                case 119:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            IIMAGEBUFFER, IIMAGEBUFFER);
                    }
                    YY_BREAK
                case 120:
                    YY_RULE_SETUP
                    {
                        return ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(
                            context, TExtension::OES_texture_buffer, TExtension::EXT_texture_buffer,
                            UIMAGEBUFFER, UIMAGEBUFFER);
                    }
                    YY_BREAK
                case 121:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, READONLY); }
                    YY_BREAK
                case 122:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, WRITEONLY); }
                    YY_BREAK
                case 123:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, COHERENT); }
                    YY_BREAK
                case 124:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, RESTRICT); }
                    YY_BREAK
                case 125:
                    YY_RULE_SETUP { return ES2_reserved_ES3_1_keyword(context, VOLATILE); }
                    YY_BREAK
                case 126:
                    YY_RULE_SETUP { return ES3_reserved_ES3_1_keyword(context, ATOMICUINT); }
                    YY_BREAK
                case 127:
                    YY_RULE_SETUP
                    {
                        return ES3_reserved_ES3_extension_ES3_2_keyword(
                            context, TExtension::OES_shader_multisample_interpolation, SAMPLE);
                    }
                    YY_BREAK
                case 128:
                    YY_RULE_SETUP
                    {
                        return ES3_1_reserved_ES3_1_extension_ES3_2_keyword(
                            context, TExtension::EXT_gpu_shader5, PRECISE);
                    }
                    YY_BREAK
                /* Reserved keywords for GLSL ES 3.00 that are not reserved for GLSL ES 1.00 */
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                    YY_RULE_SETUP
                    {
                        if (context->getShaderVersion() < 300)
                        {
                            yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                            return check_type(yyscanner);
                        }
                        return reserved_word(yyscanner);
                    }
                    YY_BREAK
                /* Reserved keywords in GLSL ES 1.00 that are not reserved in GLSL ES 3.00 */
                case 153:
                    YY_RULE_SETUP
                    {
                        if (context->getShaderVersion() >= 300)
                        {
                            yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                            return check_type(yyscanner);
                        }

                        return reserved_word(yyscanner);
                    }
                    YY_BREAK
                /* Reserved keywords */
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                case 164:
                case 165:
                case 166:
                case 167:
                case 168:
                case 169:
                case 170:
                case 171:
                case 172:
                case 173:
                case 174:
                case 175:
                case 176:
                case 177:
                case 178:
                case 179:
                case 180:
                case 181:
                case 182:
                case 183:
                case 184:
                case 185:
                case 186:
                case 187:
                case 188:
                case 189:
                case 190:
                case 191:
                case 192:
                case 193:
                    YY_RULE_SETUP { return reserved_word(yyscanner); }
                    YY_BREAK
                case 194:
                    YY_RULE_SETUP
                    {
                        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                        return check_type(yyscanner);
                    }
                    YY_BREAK
                case 195:
                    YY_RULE_SETUP { return int_constant(context); }
                    YY_BREAK
                case 196:
                    YY_RULE_SETUP { return int_constant(context); }
                    YY_BREAK
                case 197:
                    YY_RULE_SETUP { return int_constant(context); }
                    YY_BREAK
                case 198:
                    YY_RULE_SETUP { return uint_constant(context); }
                    YY_BREAK
                case 199:
                    YY_RULE_SETUP { return uint_constant(context); }
                    YY_BREAK
                case 200:
                    YY_RULE_SETUP { return uint_constant(context); }
                    YY_BREAK
                case 201:
                    YY_RULE_SETUP { return float_constant(yyscanner); }
                    YY_BREAK
                case 202:
                    YY_RULE_SETUP { return float_constant(yyscanner); }
                    YY_BREAK
                case 203:
                    YY_RULE_SETUP { return float_constant(yyscanner); }
                    YY_BREAK
                case 204:
                    YY_RULE_SETUP { return floatsuffix_check(context); }
                    YY_BREAK
                case 205:
                    YY_RULE_SETUP { return floatsuffix_check(context); }
                    YY_BREAK
                case 206:
                    YY_RULE_SETUP { return floatsuffix_check(context); }
                    YY_BREAK
                case 207:
                    YY_RULE_SETUP { return ADD_ASSIGN; }
                    YY_BREAK
                case 208:
                    YY_RULE_SETUP { return SUB_ASSIGN; }
                    YY_BREAK
                case 209:
                    YY_RULE_SETUP { return MUL_ASSIGN; }
                    YY_BREAK
                case 210:
                    YY_RULE_SETUP { return DIV_ASSIGN; }
                    YY_BREAK
                case 211:
                    YY_RULE_SETUP { return MOD_ASSIGN; }
                    YY_BREAK
                case 212:
                    YY_RULE_SETUP { return LEFT_ASSIGN; }
                    YY_BREAK
                case 213:
                    YY_RULE_SETUP { return RIGHT_ASSIGN; }
                    YY_BREAK
                case 214:
                    YY_RULE_SETUP { return AND_ASSIGN; }
                    YY_BREAK
                case 215:
                    YY_RULE_SETUP { return XOR_ASSIGN; }
                    YY_BREAK
                case 216:
                    YY_RULE_SETUP { return OR_ASSIGN; }
                    YY_BREAK
                case 217:
                    YY_RULE_SETUP { return INC_OP; }
                    YY_BREAK
                case 218:
                    YY_RULE_SETUP { return DEC_OP; }
                    YY_BREAK
                case 219:
                    YY_RULE_SETUP { return AND_OP; }
                    YY_BREAK
                case 220:
                    YY_RULE_SETUP { return OR_OP; }
                    YY_BREAK
                case 221:
                    YY_RULE_SETUP { return XOR_OP; }
                    YY_BREAK
                case 222:
                    YY_RULE_SETUP { return LE_OP; }
                    YY_BREAK
                case 223:
                    YY_RULE_SETUP { return GE_OP; }
                    YY_BREAK
                case 224:
                    YY_RULE_SETUP { return EQ_OP; }
                    YY_BREAK
                case 225:
                    YY_RULE_SETUP { return NE_OP; }
                    YY_BREAK
                case 226:
                    YY_RULE_SETUP { return LEFT_OP; }
                    YY_BREAK
                case 227:
                    YY_RULE_SETUP { return RIGHT_OP; }
                    YY_BREAK
                case 228:
                    YY_RULE_SETUP { return SEMICOLON; }
                    YY_BREAK
                case 229:
                    YY_RULE_SETUP { return LEFT_BRACE; }
                    YY_BREAK
                case 230:
                    YY_RULE_SETUP { return RIGHT_BRACE; }
                    YY_BREAK
                case 231:
                    YY_RULE_SETUP { return COMMA; }
                    YY_BREAK
                case 232:
                    YY_RULE_SETUP { return COLON; }
                    YY_BREAK
                case 233:
                    YY_RULE_SETUP { return EQUAL; }
                    YY_BREAK
                case 234:
                    YY_RULE_SETUP { return LEFT_PAREN; }
                    YY_BREAK
                case 235:
                    YY_RULE_SETUP { return RIGHT_PAREN; }
                    YY_BREAK
                case 236:
                    YY_RULE_SETUP { return LEFT_BRACKET; }
                    YY_BREAK
                case 237:
                    YY_RULE_SETUP { return RIGHT_BRACKET; }
                    YY_BREAK
                case 238:
                    YY_RULE_SETUP
                    {
                        BEGIN(FIELDS);
                        return DOT;
                    }
                    YY_BREAK
                case 239:
                    YY_RULE_SETUP { return BANG; }
                    YY_BREAK
                case 240:
                    YY_RULE_SETUP { return DASH; }
                    YY_BREAK
                case 241:
                    YY_RULE_SETUP { return TILDE; }
                    YY_BREAK
                case 242:
                    YY_RULE_SETUP { return PLUS; }
                    YY_BREAK
                case 243:
                    YY_RULE_SETUP { return STAR; }
                    YY_BREAK
                case 244:
                    YY_RULE_SETUP { return SLASH; }
                    YY_BREAK
                case 245:
                    YY_RULE_SETUP { return PERCENT; }
                    YY_BREAK
                case 246:
                    YY_RULE_SETUP { return LEFT_ANGLE; }
                    YY_BREAK
                case 247:
                    YY_RULE_SETUP { return RIGHT_ANGLE; }
                    YY_BREAK
                case 248:
                    YY_RULE_SETUP { return VERTICAL_BAR; }
                    YY_BREAK
                case 249:
                    YY_RULE_SETUP { return CARET; }
                    YY_BREAK
                case 250:
                    YY_RULE_SETUP { return AMPERSAND; }
                    YY_BREAK
                case 251:
                    YY_RULE_SETUP { return QUESTION; }
                    YY_BREAK
                case 252:
                    YY_RULE_SETUP
                    {
                        BEGIN(INITIAL);
                        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
                        return FIELD_SELECTION;
                    }
                    YY_BREAK
                case 253:
                    YY_RULE_SETUP {}
                    YY_BREAK
                case 254:
                    YY_RULE_SETUP
                    {
                        yyextra->error(*yylloc, "Illegal character at fieldname start", yytext);
                        return 0;
                    }
                    YY_BREAK
                case 255:
                    /* rule 255 can match eol */
                    YY_RULE_SETUP {}
                    YY_BREAK
                case YY_STATE_EOF(INITIAL):
                case YY_STATE_EOF(FIELDS):
                {
                    yyterminate();
                }
                    YY_BREAK
                case 256:
                    YY_RULE_SETUP
                    {
                        assert(false);
                        return 0;
                    }
                    YY_BREAK
                case 257:
                    YY_RULE_SETUP
                    ECHO;
                    YY_BREAK

                case YY_END_OF_BUFFER:
                {
                    /* Amount of text matched not including the EOB char. */
                    int yy_amount_of_matched_text = (int)(yy_cp - yyg->yytext_ptr) - 1;

                    /* Undo the effects of YY_DO_BEFORE_ACTION. */
                    *yy_cp = yyg->yy_hold_char;
                    YY_RESTORE_YY_MORE_OFFSET

                    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
                    {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file    = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                    }

                    /* Note that here we test for yy_c_buf_p "<=" to the position
                     * of the first EOB in the buffer, since yy_c_buf_p will
                     * already have been incremented past the NUL character
                     * (since all states make transitions on EOB to the
                     * end-of-buffer state).  Contrast this with the test
                     * in input().
                     */
                    if (yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars])
                    { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state(yyscanner);

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if (yy_next_state)
                        {
                            /* Consume the NUL. */
                            yy_cp            = ++yyg->yy_c_buf_p;
                            yy_current_state = yy_next_state;
                            goto yy_match;
                        }

                        else
                        {
                            yy_cp            = yyg->yy_last_accepting_cpos;
                            yy_current_state = yyg->yy_last_accepting_state;
                            goto yy_find_action;
                        }
                    }

                    else
                        switch (yy_get_next_buffer(yyscanner))
                        {
                            case EOB_ACT_END_OF_FILE:
                            {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if (yywrap(yyscanner))
                                {
                                    /* Note: because we've taken care in
                                     * yy_get_next_buffer() to have set up
                                     * yytext, we can now set up
                                     * yy_c_buf_p so that if some total
                                     * hoser (like flex itself) wants to
                                     * call the scanner after we return the
                                     * YY_NULL, it'll still work - another
                                     * YY_NULL will get returned.
                                     */
                                    yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                    yy_act = YY_STATE_EOF(YY_START);
                                    goto do_action;
                                }

                                else
                                {
                                    if (!yyg->yy_did_buffer_switch_on_eof)
                                        YY_NEW_FILE;
                                }
                                break;
                            }

                            case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state(yyscanner);

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                            case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                    &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state(yyscanner);

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                    break;
                }

                default:
                    YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
            } /* end of action switch */
        }     /* end of scanning one token */
    }         /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *    EOB_ACT_LAST_MATCH -
 *    EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *    EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    char *dest           = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char *source         = yyg->yytext_ptr;
    int number_to_move, i;
    int ret_val;

    if (yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1])
        YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
    { /* Don't try to fill the buffer, so this is an EOF. */
        if (yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1)
        {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else
        {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr - 1);

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

    else
    {
        int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        while (num_to_read <= 0)
        { /* Not enough room in the buffer - grow it. */

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

            int yy_c_buf_p_offset = (int)(yyg->yy_c_buf_p - b->yy_ch_buf);

            if (b->yy_is_our_buffer)
            {
                int new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yyrealloc((void *)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2), yyscanner);
            }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = NULL;

            if (!b->yy_ch_buf)
                YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

            yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        yy_size_t ret = 0;
        YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), ret, num_to_read);
        yyg->yy_n_chars = static_cast<int>(ret);

        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    if (yyg->yy_n_chars == 0)
    {
        if (number_to_move == YY_MORE_ADJ)
        {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart(yyin, yyscanner);
        }

        else
        {
            ret_val                                    = EOB_ACT_LAST_MATCH;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
    {
        /* Extend the array by 50%, plus the number we really need. */
        int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *)yyrealloc(
            (void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size, yyscanner);
        if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
        /* "- 2" to take care of EOB's */
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
    }

    yyg->yy_n_chars += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars]     = YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(yyscan_t yyscanner)
{
    yy_state_type yy_current_state;
    char *yy_cp;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yy_current_state = yyg->yy_start;

    for (yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp)
    {
        YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if (yy_accept[yy_current_state])
        {
            yyg->yy_last_accepting_state = yy_current_state;
            yyg->yy_last_accepting_cpos  = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
            yy_current_state = (int)yy_def[yy_current_state];
            if (yy_current_state >= 948)
                yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }

    return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *    next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state, yyscan_t yyscanner)
{
    int yy_is_jam;
    struct yyguts_t *yyg =
        (struct yyguts_t *)yyscanner; /* This var may be unused depending upon options. */
    char *yy_cp = yyg->yy_c_buf_p;

    YY_CHAR yy_c = 1;
    if (yy_accept[yy_current_state])
    {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos  = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 948)
            yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam        = (yy_current_state == 947);

    (void)yyg;
    return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#    ifdef __cplusplus
static int yyinput(yyscan_t yyscanner)
#    else
static int input(yyscan_t yyscanner)
#    endif

{
    int c;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    *yyg->yy_c_buf_p = yyg->yy_hold_char;

    if (*yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR)
    {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if (yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars])
            /* This was really a NUL. */
            *yyg->yy_c_buf_p = '\0';

        else
        { /* need more input */
            int offset = (int)(yyg->yy_c_buf_p - yyg->yytext_ptr);
            ++yyg->yy_c_buf_p;

            switch (yy_get_next_buffer(yyscanner))
            {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    yyrestart(yyin, yyscanner);

                    /*FALLTHROUGH*/

                case EOB_ACT_END_OF_FILE:
                {
                    if (yywrap(yyscanner))
                        return 0;

                    if (!yyg->yy_did_buffer_switch_on_eof)
                        YY_NEW_FILE;
#    ifdef __cplusplus
                    return yyinput(yyscanner);
#    else
                    return input(yyscanner);
#    endif
                }

                case EOB_ACT_CONTINUE_SCAN:
                    yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
                    break;
            }
        }
    }

    c                 = *(unsigned char *)yyg->yy_c_buf_p; /* cast for 8-bit char's */
    *yyg->yy_c_buf_p  = '\0';                              /* preserve yytext */
    yyg->yy_hold_char = *++yyg->yy_c_buf_p;

    if (c == '\n')

        do
        {
            yylineno++;
            yycolumn = 0;
        } while (0);

    return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE *input_file, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
    {
        yyensure_buffer_stack(yyscanner);
        YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner);
    }

    yy_init_buffer(YY_CURRENT_BUFFER, input_file, yyscanner);
    yy_load_buffer_state(yyscanner);
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* TODO. We should be able to replace this entire function body
     * with
     *        yypop_buffer_state();
     *        yypush_buffer_state(new_buffer);
     */
    yyensure_buffer_stack(yyscanner);
    if (YY_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *yyg->yy_c_buf_p                     = yyg->yy_hold_char;
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    YY_CURRENT_BUFFER_LVALUE = new_buffer;
    yy_load_buffer_state(yyscanner);

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yyg->yy_did_buffer_switch_on_eof = 1;
}

static void yy_load_buffer_state(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyg->yy_n_chars      = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    yyin                              = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    yyg->yy_hold_char                 = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *)yyalloc((yy_size_t)(b->yy_buf_size + 2), yyscanner);
    if (!b->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer(b, file, yyscanner);

    return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
void yy_delete_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!b)
        return;

    if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
        YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer)
        yyfree((void *)b->yy_ch_buf, yyscanner);

    yyfree((void *)b, yyscanner);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file, yyscan_t yyscanner)

{
    int oerrno           = errno;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yy_flush_buffer(b, yyscanner);

    b->yy_input_file  = file;
    b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER)
    {
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

    b->yy_is_interactive = 0;

    errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
void yy_flush_buffer(YY_BUFFER_STATE b, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (!b)
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol        = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == YY_CURRENT_BUFFER)
        yy_load_buffer_state(yyscanner);
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (new_buffer == NULL)
        return;

    yyensure_buffer_stack(yyscanner);

    /* This block is copied from yy_switch_to_buffer. */
    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *yyg->yy_c_buf_p                     = yyg->yy_hold_char;
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

    /* Only push if top exists. Otherwise, replace top. */
    if (YY_CURRENT_BUFFER)
        yyg->yy_buffer_stack_top++;
    YY_CURRENT_BUFFER_LVALUE = new_buffer;

    /* copied from yy_switch_to_buffer. */
    yy_load_buffer_state(yyscanner);
    yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    if (!YY_CURRENT_BUFFER)
        return;

    yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    if (yyg->yy_buffer_stack_top > 0)
        --yyg->yy_buffer_stack_top;

    if (YY_CURRENT_BUFFER)
    {
        yy_load_buffer_state(yyscanner);
        yyg->yy_did_buffer_switch_on_eof = 1;
    }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(yyscan_t yyscanner)
{
    yy_size_t num_to_alloc;
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!yyg->yy_buffer_stack)
    {

        /* First allocation is just for 2 elements, since we don't know if this
         * scanner will even need a stack. We use 2 instead of 1 to avoid an
         * immediate realloc on the next call.
         */
        num_to_alloc         = 1; /* After all that talk, this was set to 1 anyways... */
        yyg->yy_buffer_stack = (struct yy_buffer_state **)yyalloc(
            num_to_alloc * sizeof(struct yy_buffer_state *), yyscanner);
        if (!yyg->yy_buffer_stack)
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));

        yyg->yy_buffer_stack_max = num_to_alloc;
        yyg->yy_buffer_stack_top = 0;
        return;
    }

    if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1)
    {

        /* Increase the buffer to prepare for a possible push. */
        yy_size_t grow_size = 8 /* arbitrary grow size */;

        num_to_alloc         = yyg->yy_buffer_stack_max + grow_size;
        yyg->yy_buffer_stack = (struct yy_buffer_state **)yyrealloc(
            yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *), yyscanner);
        if (!yyg->yy_buffer_stack)
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        /* zero only the new slots.*/
        memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0,
               grow_size * sizeof(struct yy_buffer_state *));
        yyg->yy_buffer_stack_max = num_to_alloc;
    }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
        base[size - 1] != YY_END_OF_BUFFER_CHAR)
        /* They forgot to leave room for the EOB's. */
        return NULL;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state), yyscanner);
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer          = 0;
    b->yy_input_file             = NULL;
    b->yy_n_chars                = b->yy_buf_size;
    b->yy_is_interactive         = 0;
    b->yy_at_bol                 = 1;
    b->yy_fill_buffer            = 0;
    b->yy_buffer_status          = YY_BUFFER_NEW;

    yy_switch_to_buffer(b, yyscanner);

    return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char *yystr, yyscan_t yyscanner)
{

    return yy_scan_bytes(yystr, (int)strlen(yystr), yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char *yybytes, int _yybytes_len, yyscan_t yyscanner)
{
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n   = (yy_size_t)(_yybytes_len + 2);
    buf = (char *)yyalloc(n, yyscanner);
    if (!buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < _yybytes_len; ++i)
        buf[i] = yybytes[i];

    buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer(buf, n, yyscanner);
    if (!b)
        YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}

#ifndef YY_EXIT_FAILURE
#    define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char *msg, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    fprintf(stderr, "%s\n", msg);
    exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                      \
    do                                                 \
    {                                                  \
        /* Undo effects of setting up yytext. */       \
        int yyless_macro_arg = (n);                    \
        YY_LESS_LINENO(yyless_macro_arg);              \
        yytext[yyleng]    = yyg->yy_hold_char;         \
        yyg->yy_c_buf_p   = yytext + yyless_macro_arg; \
        yyg->yy_hold_char = *yyg->yy_c_buf_p;          \
        *yyg->yy_c_buf_p  = '\0';                      \
        yyleng            = yyless_macro_arg;          \
    } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE yyget_extra(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
        return 0;

    return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!YY_CURRENT_BUFFER)
        return 0;

    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *yyget_text(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra(YY_EXTRA_TYPE user_defined, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyextra              = user_defined;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno(int _line_number, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* lineno is only valid if an input buffer exists. */
    if (!YY_CURRENT_BUFFER)
        YY_FATAL_ERROR("yyset_lineno called with no buffer");

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column(int _column_no, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* column is only valid if an input buffer exists. */
    if (!YY_CURRENT_BUFFER)
        YY_FATAL_ERROR("yyset_column called with no buffer");

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE *_in_str, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyin                 = _in_str;
}

void yyset_out(FILE *_out_str, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yyout                = _out_str;
}

int yyget_debug(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yy_flex_debug;
}

void yyset_debug(int _bdebug, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yy_flex_debug        = _bdebug;
}

/* Accessor methods for yylval and yylloc */

YYSTYPE *yyget_lval(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yylval;
}

void yyset_lval(YYSTYPE *yylval_param, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yylval               = yylval_param;
}

YYLTYPE *yyget_lloc(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    return yylloc;
}

void yyset_lloc(YYLTYPE *yylloc_param, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    yylloc               = yylloc_param;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(yyscan_t *ptr_yy_globals)
{
    if (ptr_yy_globals == NULL)
    {
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), NULL);

    if (*ptr_yy_globals == NULL)
    {
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

    return yy_init_globals(*ptr_yy_globals);
}

/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined, yyscan_t *ptr_yy_globals)
{
    struct yyguts_t dummy_yyguts;

    yyset_extra(yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL)
    {
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t)yyalloc(sizeof(struct yyguts_t), &dummy_yyguts);

    if (*ptr_yy_globals == NULL)
    {
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals, 0x00, sizeof(struct yyguts_t));

    yyset_extra(yy_user_defined, *ptr_yy_globals);

    return yy_init_globals(*ptr_yy_globals);
}

static int yy_init_globals(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack     = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p          = NULL;
    yyg->yy_init             = 0;
    yyg->yy_start            = 0;

    yyg->yy_start_stack_ptr   = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack       = NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin  = stdin;
    yyout = stdout;
#else
    yyin  = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    /* Pop the buffer stack, destroying each element. */
    while (YY_CURRENT_BUFFER)
    {
        yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        yypop_buffer_state(yyscanner);
    }

    /* Destroy the stack itself. */
    yyfree(yyg->yy_buffer_stack, yyscanner);
    yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
    yyfree(yyg->yy_start_stack, yyscanner);
    yyg->yy_start_stack = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals(yyscanner);

    /* Destroy the main struct (reentrant only). */
    yyfree(yyscanner, yyscanner);
    yyscanner = NULL;
    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, const char *s2, int n, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;

    int i;
    for (i = 0; i < n; ++i)
        s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *s, yyscan_t yyscanner)
{
    int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif

void *yyalloc(yy_size_t size, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    return malloc(size);
}

void *yyrealloc(void *ptr, yy_size_t size, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;

    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return realloc(ptr, size);
}

void yyfree(void *ptr, yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;
    (void)yyg;
    free((char *)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

yy_size_t string_input(char *buf, yy_size_t max_size, yyscan_t yyscanner)
{
    angle::pp::Token token;
    yyget_extra(yyscanner)->getPreprocessor().lex(&token);
    yy_size_t len = token.type == angle::pp::Token::LAST ? 0 : token.text.size();
    if (len < max_size)
        memcpy(buf, token.text.c_str(), len);
    yyset_column(token.location.file, yyscanner);
    yyset_lineno(token.location.line, yyscanner);

    if (len >= max_size)
        YY_FATAL_ERROR("Input buffer overflow");
    else if (len > 0)
        buf[len++] = ' ';
    return len;
}

int check_type(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    int token = IDENTIFIER;
    // Note that the ImmutableString used here isn't static or pool allocated - but it's fine since
    // yytext is valid for the duration of its use.
    const TSymbol *symbol =
        yyextra->symbolTable.find(ImmutableString(yytext, yyleng), yyextra->getShaderVersion());
    if (symbol && symbol->isStruct())
    {
        token = TYPE_NAME;
    }
    yylval->lex.symbol = symbol;
    return token;
}

int reserved_word(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    yyextra->error(*yylloc, "Illegal use of reserved word", yytext);
    return 0;
}

static bool is_extension_enabled_or_is_core(TParseContext *context,
                                            int extension_version,
                                            TExtension extension,
                                            int promotion_version)
{
    int version = context->getShaderVersion();

    // If version is at least promotion_version, symbol is definitely keyword.  Otherwise it's a
    // keyword if version is at least extension_version (where the extension was introduced) and
    // the extension is enabled.
    return version >= promotion_version ||
           (version >= extension_version && context->isExtensionEnabled(extension));
}

int ES2_reserved_ES3_keyword(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES2_keyword_ES3_reserved(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_reserved_ES3_1_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return check_type(yyscanner);
    }
    else if (context->getShaderVersion() == 300)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // not a reserved word in GLSL ES 1.00, so could be used as an identifier/type name
    if (context->getShaderVersion() < 300)
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return check_type(yyscanner);
    }

    return token;
}

int ES2_reserved_ES3_1_keyword(TParseContext *context, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() < 310)
    {
        return reserved_word(yyscanner);
    }

    return token;
}

int ES3_1_keyword(TParseContext *context, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.10.
    if (context->getShaderVersion() >= 310)
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int WEBGL_video_texture_extension(TParseContext *context, int token)
{
    // Available with WEBGL_video_texture_extension
    if (context->isExtensionEnabled(TExtension::WEBGL_video_texture))
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ANGLE_webgl_video_frame_extension(TParseContext *context, int token)
{
    // Available with ANGLE_webgl_video_frame extension
    if (context->isExtensionEnabled(TExtension::ANGLE_webgl_video_frame))
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES2_reserved_ES2_extension_ES3_keyword(TParseContext *context, TExtension extension, int token)
{
    yyscan_t yyscanner = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 or GLSL ES 1.00 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 100, extension, 300))
    {
        return token;
    }

    // Reserved otherwise.
    return reserved_word(yyscanner);
}

int ES3_extension(TParseContext *context, TExtension extension, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a keyword word in GLSL ES 3.00 with enabled extension.
    if (context->getShaderVersion() >= 300 && context->isExtensionEnabled(extension))
    {
        return token;
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                               TExtension extension,
                                               int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a keyword in GLSL ES 3.10 with enabled extension
    if (is_extension_enabled_or_is_core(context, 310, extension, 320))
    {
        return token;
    }
    // a reserved word in GLSL ES 3.00+
    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    // Otherwise can be used as an identifier/type name
    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension(TParseContext *context, TExtension extension, int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    if (context->getShaderVersion() >= 300)
    {
        if (context->isExtensionEnabled(extension))
        {
            return token;
        }
        else
        {
            return reserved_word(yyscanner);
        }
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension_ES3_1_keyword(TParseContext *context,
                                             TExtension extension,
                                             int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 with enabled extension or in GLSL ES 3.10
    if (is_extension_enabled_or_is_core(context, 300, extension, 310))
    {
        return token;
    }

    if (context->getShaderVersion() == 300)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int ES3_reserved_ES3_extension_ES3_2_keyword(TParseContext *context,
                                             TExtension extension,
                                             int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.00 with enabled extension or in GLSL ES 3.20
    if (is_extension_enabled_or_is_core(context, 300, extension, 320))
    {
        return token;
    }

    if (context->getShaderVersion() == 300 || context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword(TParseContext *context,
                                                        TExtension extension,
                                                        int token)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension, 320))
    {
        return token;
    }

    // A reserved word in GLSL ES 3.10
    if (context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                          TExtension extension1,
                                                          TExtension extension2,
                                                          int token1,
                                                          int token2)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension1, 320))
    {
        return token1;
    }
    else if (is_extension_enabled_or_is_core(context, 310, extension2, 320))
    {
        return token2;
    }

    // A reserved word in GLSL ES 3.10
    if (context->getShaderVersion() == 310)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

static int ES3_and_3_1_reserved_ES3_1_extension_ES3_2_keyword_2(TParseContext *context,
                                                                TExtension extension1,
                                                                TExtension extension2,
                                                                int token1,
                                                                int token2)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // A keyword in GLSL ES 3.20 or GLSL ES 3.10 with enabled extension.
    if (is_extension_enabled_or_is_core(context, 310, extension1, 320))
    {
        return token1;
    }
    else if (is_extension_enabled_or_is_core(context, 310, extension2, 320))
    {
        return token2;
    }

    // A reserved word in GLSL ES 3.00 and 3.10
    if (context->getShaderVersion() >= 300)
    {
        return reserved_word(yyscanner);
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int uint_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        context->error(*yylloc, "Unsigned integers are unsupported prior to GLSL ES 3.00", yytext);
        return 0;
    }

    if (!atoi_clamp(yytext, &(yylval->lex.u)))
        yyextra->error(*yylloc, "Integer overflow", yytext);

    return UINTCONSTANT;
}

int floatsuffix_check(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    if (context->getShaderVersion() < 300)
    {
        context->error(*yylloc, "Floating-point suffix unsupported prior to GLSL ES 3.00", yytext);
        return 0;
    }

    std::string text = yytext;
    text.resize(text.size() - 1);
    if (!strtof_clamp(text, &(yylval->lex.f)))
        yyextra->warning(*yylloc, "Float overflow", yytext);

    return (FLOATCONSTANT);
}

void yyerror(YYLTYPE *lloc, TParseContext *context, void *scanner, const char *reason)
{
    context->error(*lloc, reason, yyget_text(scanner));
}

int int_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();

    unsigned int u;
    if (!atoi_clamp(yytext, &u))
    {
        if (context->getShaderVersion() >= 300)
            yyextra->error(*yylloc, "Integer overflow", yytext);
        else
            yyextra->warning(*yylloc, "Integer overflow", yytext);
    }
    yylval->lex.i = static_cast<int>(u);
    return INTCONSTANT;
}

int float_constant(yyscan_t yyscanner)
{
    struct yyguts_t *yyg = (struct yyguts_t *)yyscanner;

    if (!strtof_clamp(yytext, &(yylval->lex.f)))
        yyextra->warning(*yylloc, "Float overflow", yytext);
    return FLOATCONSTANT;
}

int yuvcscstandardext_constant(TParseContext *context)
{
    struct yyguts_t *yyg = (struct yyguts_t *)context->getScanner();
    yyscan_t yyscanner   = (yyscan_t)context->getScanner();

    // a reserved word in GLSL ES 3.00 with enabled extension, otherwise could be used as an
    // identifier/type name
    if (context->getShaderVersion() >= 300 &&
        context->isExtensionEnabled(TExtension::EXT_YUV_target))
    {
        yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
        return YUVCSCSTANDARDEXTCONSTANT;
    }

    yylval->lex.string = AllocatePoolCharArray(yytext, yyleng);
    return check_type(yyscanner);
}

int glslang_initialize(TParseContext *context)
{
    yyscan_t scanner = NULL;
    if (yylex_init_extra(context, &scanner))
        return 1;

    context->setScanner(scanner);
    return 0;
}

int glslang_finalize(TParseContext *context)
{
    yyscan_t scanner = context->getScanner();
    if (scanner == NULL)
        return 0;

    context->setScanner(NULL);
    yylex_destroy(scanner);

    return 0;
}

int glslang_scan(size_t count,
                 const char *const string[],
                 const int length[],
                 TParseContext *context)
{
    yyrestart(NULL, context->getScanner());
    yyset_column(0, context->getScanner());
    yyset_lineno(1, context->getScanner());

    // Initialize preprocessor.
    angle::pp::Preprocessor *preprocessor = &context->getPreprocessor();

    if (!preprocessor->init(count, string, length))
        return 1;

    // Define extension macros.
    const TExtensionBehavior &extBehavior = context->extensionBehavior();
    for (TExtensionBehavior::const_iterator iter = extBehavior.begin(); iter != extBehavior.end();
         ++iter)
    {
        // OVR_multiview should not be defined for WebGL spec'ed shaders.
        if (sh::IsWebGLBasedSpec(context->getShaderSpec()) &&
            iter->first == TExtension::OVR_multiview)
        {
            continue;
        }
        preprocessor->predefineMacro(GetExtensionNameString(iter->first), 1);
    }
    if (context->getFragmentPrecisionHigh())
        preprocessor->predefineMacro("GL_FRAGMENT_PRECISION_HIGH", 1);

    preprocessor->setMaxTokenSize(sh::GetGlobalMaxTokenSize(context->getShaderSpec()));

    return 0;
}
