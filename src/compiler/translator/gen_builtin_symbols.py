#!/usr/bin/python
# Copyright 2018 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_builtin_symbols.py:
#  Code generation for the built-in symbol tables.

from collections import OrderedDict
from datetime import date
import json
import os
import sys

def set_working_dir():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

set_working_dir()

template_builtin_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// BuiltIn_autogen.h:
//   Compile-time initialized built-ins.

#ifndef COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_
#define COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

#include "compiler/translator/ImmutableString.h"
#include "compiler/translator/StaticType.h"
#include "compiler/translator/Symbol.h"
#include "compiler/translator/SymbolUniqueId.h"

namespace sh
{{

// This is a class instead of a namespace so that we can restrict access to TSymbolUniqueId
// constructor taking an integer to here.
class BuiltInId
{{
  public:

{builtin_id_declarations}

}};

constexpr const int kLastStaticBuiltInId = {last_static_builtin_id};

namespace BuiltInName
{{

{name_declarations}

}}  // namespace BuiltInName

// TODO: Would be nice to make this a class instead of a namespace so that we could friend this
// from TVariable. Now symbol constructors taking an id have to be public even though they're not
// supposed to be accessible from outside of here.
namespace BuiltInVariable
{{

{variable_declarations}

}};  // namespace BuiltInVariable

}}  // namespace sh

#endif  // COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_
"""

template_symboltable_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// SymbolTable_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/SymbolTable.h"

#include "angle_gl.h"
#include "compiler/translator/BuiltIn_autogen.h"

namespace sh
{{

void TSymbolTable::insertStaticBuiltInVariables(sh::GLenum shaderType,
                                                ShShaderSpec spec,
                                                const ShBuiltInResources &resources)
{{
{insert_variables}
}}

}}  // namespace sh
"""

parsed_variables = None

variables_json_filename = 'builtin_variables.json'

with open(variables_json_filename) as f:
    parsed_variables = json.load(f, object_pairs_hook=OrderedDict)


builtin_id_declarations = []
name_declarations = set()
variable_declarations = []
insert_variables = []

id_counter = 0

def process_group(group_name, group):
    global id_counter
    #print group
    if 'condition' in group:
        insert_variables.append('  if ({condition})'.format(condition = group['condition']))
        insert_variables.append('  {')
    if 'variables' in group:
        for variable_name, props in group['variables'].iteritems():
            variable_id = id_counter

            # The name suffix makes the variable name unique in case it otherwise isn't.
            name_suffix = ''
            if 'suffix' in props:
                name_suffix = props['suffix']

            template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {name}{suffix} = TSymbolUniqueId({id});'
            builtin_id_declarations.append(template_builtin_id_declaration.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_name_declaration = 'constexpr const ImmutableString {name}("{name}");'
            name_declarations.add(template_name_declaration.format(name = variable_name))

            template_type = 'Ebt{basic}, Ebp{precision}, Evq{qualifier}, {primarySize}, {secondarySize}'
            if 'vecSize' in props['type']:
                props['type']['primarySize'] = props['type']['vecSize']
                props['type']['secondarySize'] = 1
            elif 'columns' in props['type']:
                props['type']['primarySize'] = props['type']['columns']
                props['type']['secondarySize'] = props['type']['rows']
            elif 'primarySize' not in props['type']:
                props['type']['primarySize'] = 1
                props['type']['secondarySize'] = 1
            if 'precision' not in props['type']:
                if props['type']['basic'] != 'Bool':
                    raise Exception('Undefined precision for a non-bool variable')
                props['type']['precision'] = 'Undefined'
            type = template_type.format(**props['type'])

            extension = 'UNDEFINED'
            if 'extension' in props:
                extension = props['extension']

            template_variable_declaration = 'constexpr const TVariable {name}{suffix}(BuiltInId::{name}{suffix}, BuiltInName::{name}, SymbolType::BuiltIn, TExtension::{extension}, StaticType::Get<{type}>());'
            variable_declarations.append(template_variable_declaration.format(id = variable_id, name = variable_name, suffix = name_suffix, extension = extension, type = type))

            template_insert_variable = '    insertBuiltIn({level}, &BuiltInVariable::{name}{suffix});'
            insert_variables.append(template_insert_variable.format(level = props['level'], name = variable_name, suffix = name_suffix))
            id_counter += 1
    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_group(subgroup_name, subgroup)
    if 'condition' in group:
        insert_variables.append('  }')

for group_name, group in parsed_variables.iteritems():
    process_group(group_name, group)

builtin_id_declarations = '\n'.join(builtin_id_declarations)
name_declarations = '\n'.join(name_declarations)
variable_declarations = '\n'.join(variable_declarations)
insert_variables = '\n'.join(insert_variables)

with open('BuiltIn_autogen.h', 'wt') as outfile_header:
    output_header = template_builtin_header.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        builtin_id_declarations = builtin_id_declarations,
        name_declarations = name_declarations,
        variable_declarations = variable_declarations,
        last_static_builtin_id = id_counter - 1
        )
    outfile_header.write(output_header)

with open('SymbolTable_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_symboltable_cpp.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        insert_variables = insert_variables
        )
    outfile_cpp.write(output_cpp)

