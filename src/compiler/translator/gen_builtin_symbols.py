#!/usr/bin/python
# Copyright 2018 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_builtin_symbols.py:
#  Code generation for the built-in symbol tables.

from collections import OrderedDict
from datetime import date
import json
import re
import os

def set_working_dir():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

set_working_dir()

# By having the variables defined in a cpp file we ensure that there's just one instance of each of the declared variables.
# Note that we don't currently include get_function_definitions, as they are unused.
template_symboltable_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {function_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// SymbolTable_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/SymbolTable.h"

#include "angle_gl.h"
#include "compiler/translator/ImmutableString.h"
#include "compiler/translator/StaticType.h"
#include "compiler/translator/Symbol.h"
#include "compiler/translator/SymbolUniqueId.h"
#include "compiler/translator/SymbolTable.h"

namespace sh
{{

// This is a class instead of a namespace so that we can restrict access to TSymbolUniqueId
// constructor taking an integer to here.
class BuiltInId
{{
  public:

{builtin_id_declarations}

}};

const int TSymbolTable::kLastStaticBuiltInId = {last_static_builtin_id};

namespace BuiltInName
{{

{name_declarations}

}}  // namespace BuiltInName

namespace BuiltInParameters
{{

{parameter_declarations}

}}

namespace UnmangledBuiltIns
{{

{unmangled_builtin_declarations}

}}

// TODO: Would be nice to make this a class instead of a namespace so that we could friend this
// from TFunction. Now symbol constructors taking an id have to be public even though they're not
// supposed to be accessible from outside of here.
namespace BuiltInFunction
{{

{function_declarations}

}};

void TSymbolTable::insertStaticBuiltInFunctions(sh::GLenum shaderType)
{{
{insert_functions}
}}

const UnmangledBuiltIn *TSymbolTable::getUnmangledBuiltInForShaderVersion(const ImmutableString &name, int shaderVersion)
{{
    uint32_t nameHash = name.hash32();
{get_unmangled_builtin}
}}

}}  // namespace sh
"""

functions_txt_filename = 'builtin_function_declarations.txt'

basic_mangled_names = {
    'Float': 'f',
    'Int': 'i',
    'UInt': 'u',
    'Bool': 'b',
    'YuvCscStandardEXT': 'ycs',
    'Sampler2D': 's2',
    'Sampler3D': 's3',
    'SamplerCube': 'sC',
    'Sampler2DArray': 's2a',
    'SamplerExternalOES': 'sext',
    'SamplerExternal2DY2YEXT': 'sext2y2y',
    'Sampler2DRect': 's2r',
    'Sampler2DMS': 's2ms',
    'ISampler2D': 'is2',
    'ISampler3D': 'is3',
    'ISamplerCube': 'isC',
    'ISampler2DArray': 'is2a',
    'ISampler2DMS': 'is2ms',
    'USampler2D': 'us2',
    'USampler3D': 'us3',
    'USamplerCube': 'usC',
    'USampler2DArray': 'us2a',
    'USampler2DMS': 'us2ms',
    'Sampler2DShadow': 's2s',
    'SamplerCubeShadow': 'sCs',
    'Sampler2DArrayShadow': 's2as',
    'Image2D': 'im2',
    'IImage2D': 'iim2',
    'UImage2D': 'uim2',
    'Image3D': 'im3',
    'IImage3D': 'iim3',
    'UImage3D': 'uim3',
    'Image2DArray': 'im2a',
    'IImage2DArray': 'iim2a',
    'UImage2DArray': 'uim2a',
    'ImageCube': 'imc',
    'IImageCube': 'iimc',
    'UImageCube': 'uimc',
    'AtomicCounter': 'ac'
}

class TType:
    def __init__(self, glsl_header_type):
        if isinstance(glsl_header_type, basestring):
            self.data = self.parse_type(glsl_header_type)
        else:
            self.data = glsl_header_type
        self.normalize()

    def normalize(self):
        if 'vecSize' in self.data:
            self.data['primarySize'] = self.data['vecSize']
            self.data['secondarySize'] = 1
            self.data.pop('vecSize')
        elif 'columns' in self.data:
            self.data['primarySize'] = self.data['columns']
            self.data['secondarySize'] = self.data['rows']
            self.data.pop('columns')
            self.data.pop('rows')
        if 'genType' not in self.data or self.data['genType'] == 'sampler_or_image':
            if 'primarySize' not in self.data:
                if ('secondarySize' in self.data):
                    raise Exception('Unexpected secondarySize on type that does not have primarySize set')
                self.data['primarySize'] = 1
            if 'secondarySize' not in self.data:
                self.data['secondarySize'] = 1
        if 'precision' not in self.data:
            self.data['precision'] = 'Undefined'
        if 'qualifier' not in self.data:
            self.data['qualifier'] = 'Global'

    def get_statictype_string(self):
        template_type = 'StaticType::Get<Ebt{basic}, Ebp{precision}, Evq{qualifier}, {primarySize}, {secondarySize}>()'
        return template_type.format(**self.data)

    def get_mangled_name(self, separator = ';'):
        # This sets primarySize, secondarySize etc default values on the type object.
        mangled_name = ''

        if self.is_matrix():
            mangled_name += 'm'
        elif self.is_vector():
            mangled_name += 'v'
        mangled_name += basic_mangled_names[self.data['basic']]

        if self.is_matrix():
            mangled_name += str(self.data['primarySize'])
            mangled_name += 'x'
            mangled_name += str(self.data['secondarySize'])
        else:
            mangled_name += str(self.data['primarySize'])

        mangled_name += separator
        return mangled_name

    def is_vector(self):
        return self.data['primarySize'] > 1 and self.data['secondarySize'] == 1

    def is_matrix(self):
        return self.data['secondarySize'] > 1

    def specific_sampler_or_image_type(self, basic_type_prefix):
        if 'genType' in self.data:
            type = OrderedDict()
            if 'basic' not in self.data:
                type['basic'] = {'': 'Float', 'I': 'Int', 'U': 'UInt'}[basic_type_prefix]
                type['primarySize'] = self.data['primarySize']
            else:
                type['basic'] = basic_type_prefix + self.data['basic']
                type['primarySize'] = 1
            type['precision'] = 'Undefined'
            return TType(type)
        return self

    def specific_type(self, vec_size):
        type = OrderedDict()
        if 'genType' in self.data:
            type['basic'] = self.data['basic']
            type['precision'] = self.data['precision']
            type['qualifier'] = self.data['qualifier']
            type['primarySize'] = vec_size
            type['secondarySize'] = 1
            return TType(type)
        return self

    def parse_type(self, glsl_header_type):
        if glsl_header_type.startswith('out '):
            type_obj = self.parse_type(glsl_header_type[4:])
            type_obj['qualifier'] = 'Out'
            return type_obj
        if glsl_header_type.startswith('inout '):
            type_obj = self.parse_type(glsl_header_type[6:])
            type_obj['qualifier'] = 'InOut'
            return type_obj

        basic_types = ['float', 'int', 'uint', 'bool', 'void']

        basic_type_map = {'f': 'Float', 'i': 'Int', 'u': 'UInt', 'b': 'Bool', 'v': 'Void'}

        if glsl_header_type in basic_types:
            return OrderedDict([('basic', basic_type_map[glsl_header_type[0].lower()])])

        if glsl_header_type == 'atomic_uint':
            return OrderedDict([('basic', 'AtomicCounter')])
        if glsl_header_type == 'yuvCscStandardEXT':
            return OrderedDict([('basic', 'YuvCscStandardEXT')])

        type_obj = OrderedDict()

        vec_re = re.compile(r'^[iub]?vec([234]?)$')
        vec_match = vec_re.match(glsl_header_type)
        if vec_match:
            if glsl_header_type.startswith('vec'):
                type_obj['basic'] = 'Float'
            else:
                type_obj['basic'] = basic_type_map[glsl_header_type[0]]

            if glsl_header_type.endswith('vec'):
                # Type like "ivec" that represents either ivec2, ivec3 or ivec4
                type_obj['genType'] = 'vec'
            else:
                # vec with specific size
                type_obj['vecSize'] = int(glsl_header_type[-1])
            return type_obj

        mat_re = re.compile(r'^mat[234](x[234])?$')
        mat_match = mat_re.match(glsl_header_type)
        if mat_match:
            type_obj['basic'] = 'Float'
            if len(glsl_header_type) == 4:
                mat_size = int(glsl_header_type[-1])
                type_obj['columns'] = mat_size
                type_obj['rows'] = mat_size
            else:
                type_obj['columns'] = int(glsl_header_type[-3])
                type_obj['rows'] = int(glsl_header_type[-1])
            return type_obj

        gen_re = re.compile(r'^gen[IUB]?Type$')
        gen_match = gen_re.match(glsl_header_type)
        if gen_match:
            if glsl_header_type == 'genType':
                type_obj['basic'] = 'Float'
            else:
                type_obj['basic'] = basic_type_map[glsl_header_type[3].lower()]
            type_obj['genType'] = 'yes'
            return type_obj

        if glsl_header_type.startswith('sampler'):
            type_obj['basic'] = glsl_header_type[0].upper() + glsl_header_type[1:]
            return type_obj

        if glsl_header_type.startswith('gsampler') or glsl_header_type.startswith('gimage'):
            type_obj['basic'] = glsl_header_type[1].upper() + glsl_header_type[2:]
            type_obj['genType'] = 'sampler_or_image'
            return type_obj

        if glsl_header_type == 'gvec4':
            return OrderedDict([('vecSize', 4), ('genType', 'sampler_or_image')])
        if glsl_header_type == 'gvec3':
            return OrderedDict([('vecSize', 3), ('genType', 'sampler_or_image')])

        raise Exception('Unrecognized type: ' + str(glsl_header_type))

def get_parsed_functions():

    def parse_function_parameters(parameters):
        if parameters == '':
            return []
        parametersOut = []
        parameters = parameters.split(', ')
        for parameter in parameters:
            parametersOut.append(TType(parameter.strip()))
        return parametersOut

    lines = []
    with open(functions_txt_filename) as f:
        lines = f.readlines()
    lines = [line.strip() for line in lines if line.strip() != '']

    fun_re = re.compile(r'(\w+) (\w+)\((.*)\);(.*)')

    parsed_functions = OrderedDict()
    group_functions = []
    group_name = None
    group_metadata = {}

    level = 'COMMON_BUILTINS'
    op = 'auto'

    for line in lines:
        fun_match = fun_re.search(line)
        if line.startswith('GROUP'):
            if line.startswith('GROUP END'):
                group = {'functions': group_functions}
                group.update(group_metadata)
                parsed_functions[group_name] = group
                group_functions = []
            elif line.startswith('GROUP BEGIN '):
                # TODO: Handle group metadata
                group_rest = line[12:].strip()
                group_parts = group_rest.split(' ', 1)
                group_name = group_parts[0]
                group_metadata = {}
                if len(group_parts) > 1:
                    group_metadata = json.loads(group_parts[1])
        elif fun_match:
            return_type = fun_match.group(1)
            name = fun_match.group(2)
            parameters = fun_match.group(3)
            metadata = fun_match.groups()[-1].strip()

            function_props = OrderedDict([
                ('name', name),
                ('level', level),
                ('op', op),
                ('returnType', TType(return_type)),
                ('parameters', parse_function_parameters(parameters))
            ])
            if metadata != '':
                metadata = json.loads(metadata)
                function_props.update(metadata)
            group_functions.append(function_props)
        else:
            (level, op) = line.split(', ')

    return parsed_functions

parsed_functions = get_parsed_functions()

# TODO: Add an option to dump intermediate json
#with open('builtin_functions.json', 'w') as outfile:
#    json.dump(parsed_functions, outfile, indent=4, separators=(',', ': '))

# Declarations of symbol unique ids
builtin_id_declarations = []

# Declarations of name string variables
name_declarations = set()

# Declarations of parameter arrays for builtin TFunctions
parameter_declarations = set()

# Declarations of builtin TFunctions
function_declarations = []

# Functions for querying the pointer to a specific TFunction.
get_function_declarations = []
get_function_definitions = []

# Code for inserting builtin TFunctions to the symbol table. Grouped by condition.
insert_functions_by_condition = OrderedDict()

# Declarations of UnmangledBuiltIn objects
unmangled_builtin_declarations = set()

# Code for querying builtin function names. Grouped by condition and level.
unmangled_functions_by_condition = OrderedDict()

id_counter = 0

def hash32(str):
    fnvOffsetBasis = 0x811c9dc5
    fnvPrime = 16777619
    hash = fnvOffsetBasis
    for c in str:
        hash = hash ^ ord(c)
        hash = hash * fnvPrime & 0xffffffff
    return hash

def get_suffix(props):
    if 'suffix' in props:
        return props['suffix']
    return ''

def get_extension(props):
    if 'extension' in props:
        return props['extension']
    return 'UNDEFINED'

def get_op(name, function_props):
    if 'op' in function_props:
        if function_props['op'] == 'auto':
            return name[0].upper() + name[1:]
        return function_props['op']
    return 'CallBuiltInFunction'

def get_known_to_not_have_side_effects(function_props):
    if 'op' in function_props and function_props['op'] != 'CallBuiltInFunction':
        if 'hasSideEffects' in function_props:
            return 'false'
        else:
            for param in get_parameters(function_props):
                if 'qualifier' in param.data and param.data['qualifier'] == 'Out':
                    return 'false'
            return 'true'
    return 'false'

def get_parameters(function_props):
    if 'parameters' in function_props:
        return function_props['parameters']
    return []

def get_function_mangled_name(function_name, parameters):
    mangled_name = function_name + '('
    for param in parameters:
        mangled_name += param.get_mangled_name()
    return mangled_name

def get_unique_identifier_name(function_name, parameters):
    unique_name = function_name + '_'
    for param in parameters:
        unique_name += param.get_mangled_name('_')
    return unique_name

def get_parameters_name(parameters):
    if len(parameters) == 0:
        return 'empty'
    unique_name = ''
    for param in parameters:
        if 'qualifier' in param.data:
            if param.data['qualifier'] == 'Out':
                unique_name += 'o_'
            if param.data['qualifier'] == 'InOut':
                unique_name += 'io_'
        unique_name += param.get_mangled_name('_')
    return unique_name

def gen_function_variants(function_name, function_props):
    function_variants = []
    parameters = get_parameters(function_props)
    function_is_gen_type = False
    gsampler_or_image = False
    gvec = False
    for param in parameters:
        if 'genType' in param.data:
            function_is_gen_type = True
            if param.data['genType'] == 'sampler_or_image':
                gsampler_or_image = True
            elif param.data['genType'] == 'vec':
                gvec = True
            elif param.data['genType'] != 'yes':
                raise Exception('Unexpected value of genType "' + str(param.data['genType']) + '" should be "sampler_or_image", "vec", or "yes"')
    if not function_is_gen_type:
        function_variants.append(function_props)
        return function_variants

    if gsampler_or_image:
        types = ['', 'I', 'U']
        for type in types:
            variant_props = function_props.copy()
            variant_parameters = []
            for param in parameters:
                variant_parameters.append(param.specific_sampler_or_image_type(type))
            variant_props['parameters'] = variant_parameters
            variant_props['returnType'] = function_props['returnType'].specific_sampler_or_image_type(type)
            function_variants.append(variant_props)
    else:
        sizes = range(1, 5)
        if gvec:
            sizes = range(2, 5)
        for size in sizes:
            variant_props = function_props.copy()
            variant_parameters = []
            for param in parameters:
                variant_parameters.append(param.specific_type(size))
            variant_props['parameters'] = variant_parameters
            variant_props['returnType'] = function_props['returnType'].specific_type(size)
            function_variants.append(variant_props)

    return function_variants

defined_function_variants = set()

def process_function_group(group_name, group):
    global id_counter
    condition = 'NO_CONDITION'
    if 'condition' in group:
        condition = group['condition']
    if condition not in insert_functions_by_condition:
        insert_functions_by_condition[condition] = []
        unmangled_functions_by_condition[condition] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL3_1_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL3_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL1_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['COMMON_BUILTINS'] = OrderedDict()
    if 'functions' in group:
        for function_props in group['functions']:
            function_name = function_props['name']
            level = function_props['level']
            name_suffix = get_suffix(function_props)
            extension = get_extension(function_props)
            op = get_op(function_name, function_props)
            known_to_not_have_side_effects = get_known_to_not_have_side_effects(function_props)

            function_variants = gen_function_variants(function_name, function_props)

            template_name_declaration = 'constexpr const ImmutableString {name}{suffix}("{name}");'
            name_declaration = template_name_declaration.format(name = function_name, suffix = name_suffix)

            if not name_declaration in name_declarations:
                name_declarations.add(name_declaration)

            template_unmangled = """if (name == BuiltInName::{name}{suffix})
{{
    return &UnmangledBuiltIns::{extension};
}}"""
            unmangled = template_unmangled.format(name = function_name, suffix = name_suffix, extension = extension, length = len(function_name))
            if function_name not in unmangled_functions_by_condition[condition][level] or extension == 'UNDEFINED':
                unmangled_functions_by_condition[condition][level][function_name] = unmangled

            for function_props in function_variants:
                function_id = id_counter

                parameters = get_parameters(function_props)
                param_count = len(parameters)
                return_type = function_props['returnType'].get_statictype_string()
                mangled_name = get_function_mangled_name(function_name, parameters)

                unique_name = get_unique_identifier_name(function_name + name_suffix, parameters)

                if unique_name in defined_function_variants:
                    continue
                defined_function_variants.add(unique_name)

                template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {unique_name} = TSymbolUniqueId({id});'
                builtin_id_declarations.append(template_builtin_id_declaration.format(id = function_id, unique_name = unique_name))

                template_mangled_name_declaration = 'constexpr const ImmutableString {unique_name}("{mangled_name}");'
                name_declarations.add(template_mangled_name_declaration.format(unique_name = unique_name, mangled_name = mangled_name))

                parameters_list = []
                for param in parameters:
                    template_parameter = 'TConstParameter({param_type})'
                    parameters_list.append(template_parameter.format(param_type = param.get_statictype_string()))
                template_parameter_list_declaration = 'constexpr const TConstParameter {parameters_name}[{param_count}] = {{ {parameters} }};'
                parameters_name = get_parameters_name(parameters)
                parameter_declarations.add(template_parameter_list_declaration.format(param_count = param_count, parameters_name = parameters_name, parameters = ', '.join(parameters_list)))

                template_function_declaration = 'constexpr const TFunction kFunction_{unique_name}(BuiltInId::{unique_name}, BuiltInName::{name}{suffix}, TExtension::{extension}, BuiltInParameters::{parameters_name}, {param_count}, {return_type}, BuiltInName::{unique_name}, EOp{op}, {known_to_not_have_side_effects});'
                function_declarations.append(template_function_declaration.format(name = function_name,
                                                                                  suffix = name_suffix,
                                                                                  unique_name = unique_name,
                                                                                  extension = extension,
                                                                                  parameters_name = parameters_name,
                                                                                  param_count = param_count,
                                                                                  return_type = return_type,
                                                                                  op = op,
                                                                                  known_to_not_have_side_effects = known_to_not_have_side_effects))

                template_insert_function = '    insertBuiltIn({level}, &BuiltInFunction::kFunction_{unique_name});'
                insert_functions_by_condition[condition].append(template_insert_function.format(level = level, unique_name = unique_name))

                template_get_function_declaration = 'const TFunction *{unique_name}();'
                get_function_declarations.append(template_get_function_declaration.format(unique_name = unique_name))

                template_get_function_definition = """const TFunction *{unique_name}()
{{
    return &kFunction_{unique_name};
}}
"""
                get_function_definitions.append(template_get_function_definition.format(unique_name = unique_name))

                id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_function_group(subgroup_name, subgroup)

for group_name, group in parsed_functions.iteritems():
    process_function_group(group_name, group)

output_strings = {}

output_strings['script_name'] = os.path.basename(__file__)
output_strings['copyright_year'] = date.today().year

output_strings['builtin_id_declarations'] = '\n'.join(builtin_id_declarations)
output_strings['last_static_builtin_id'] = id_counter - 1
output_strings['name_declarations'] = '\n'.join(sorted(list(name_declarations)))

output_strings['function_data_source_name'] = functions_txt_filename
output_strings['function_declarations'] = '\n'.join(function_declarations)
output_strings['get_function_declarations'] = '\n'.join(get_function_declarations)
output_strings['get_function_definitions'] = '\n'.join(get_function_definitions)
output_strings['parameter_declarations'] = '\n'.join(sorted(parameter_declarations))

insert_functions = []
get_unmangled_builtin = []

def get_shader_version_condition_for_level(level):
    if level == 'ESSL3_1_BUILTINS':
        return 'shaderVersion >= 310'
    elif level == 'ESSL3_BUILTINS':
        return 'shaderVersion >= 300'
    elif level == 'ESSL1_BUILTINS':
        return 'shaderVersion == 100'
    elif level == 'COMMON_BUILTINS':
        return ''
    else:
        raise Exception('Unsupported symbol table level')

for condition in insert_functions_by_condition:
    if condition != 'NO_CONDITION':
        condition_header = '  if ({condition})\n {{'.format(condition = condition)
        insert_functions.append(condition_header)
        get_unmangled_builtin.append(condition_header.replace('shaderType', 'mShaderType'))

    for insert_function in insert_functions_by_condition[condition]:
        insert_functions.append(insert_function)
    for level, functions in unmangled_functions_by_condition[condition].iteritems():
        if len(functions) > 0:
            level_condition = get_shader_version_condition_for_level(level)
            if level_condition != '':
                get_unmangled_builtin.append('if ({condition})\n {{'.format(condition = level_condition))

            get_unmangled_builtin_switch = {}
            for function_name, get_unmangled_case in functions.iteritems():
                builtin_required_re = re.compile(r'UnmangledBuiltIns::(\w+)')
                mo = builtin_required_re.search(get_unmangled_case)
                ext = mo.group(1)
                unmangled_builtin_declarations.add('constexpr const UnmangledBuiltIn {extension}(TExtension::{extension});'.format(extension = ext))

                name_hash = hash32(function_name)
                if name_hash not in get_unmangled_builtin_switch:
                    get_unmangled_builtin_switch[name_hash] = []
                get_unmangled_builtin_switch[name_hash].append(get_unmangled_case)

            get_unmangled_builtin.append('switch(nameHash) {')
            for name_hash, get_unmangled_cases in sorted(get_unmangled_builtin_switch.iteritems()):
                get_unmangled_builtin.append('case ' + hex(name_hash) + 'u:\n{')
                get_unmangled_builtin += get_unmangled_cases
                get_unmangled_builtin.append('break;\n}')
            get_unmangled_builtin.append('}')

            if level_condition != '':
                get_unmangled_builtin.append('}')

    if condition != 'NO_CONDITION':
        insert_functions.append('}')
        get_unmangled_builtin.append('}')

get_unmangled_builtin.append('return nullptr;')

output_strings['insert_functions'] = '\n'.join(insert_functions)
output_strings['unmangled_builtin_declarations'] = '\n'.join(sorted(unmangled_builtin_declarations))
output_strings['get_unmangled_builtin'] = '\n'.join(get_unmangled_builtin)

with open('SymbolTable_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_symboltable_cpp.format(**output_strings)
    outfile_cpp.write(output_cpp)

