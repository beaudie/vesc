#!/usr/bin/python
# Copyright 2018 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_builtin_symbols.py:
#  Code generation for the built-in symbol tables.

from collections import OrderedDict
from datetime import date
import json
import os

def set_working_dir():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

set_working_dir()

# The header file has a "get" function for each variable. They are used in traversers.
template_builtin_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// BuiltIn_autogen.h:
//   Compile-time initialized built-ins.

#ifndef COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_
#define COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

namespace sh
{{

class TVariable;

namespace BuiltInVariable
{{

{get_variable_declarations}

}}  // namespace BuiltInVariable

}}  // namespace sh

#endif  // COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

"""

# By having the variables defined in a cpp file we ensure that there's just one instance of each of the declared variables.
template_symboltable_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// SymbolTable_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/SymbolTable.h"

#include "angle_gl.h"
#include "compiler/translator/BuiltIn_autogen.h"
#include "compiler/translator/ImmutableString.h"
#include "compiler/translator/StaticType.h"
#include "compiler/translator/Symbol.h"
#include "compiler/translator/SymbolUniqueId.h"

namespace sh
{{

// This is a class instead of a namespace so that we can restrict access to TSymbolUniqueId
// constructor taking an integer to here.
class BuiltInId
{{
  public:

{builtin_id_declarations}

}};

const int TSymbolTable::kLastStaticBuiltInId = {last_static_builtin_id};

namespace BuiltInName
{{

{name_declarations}

}}  // namespace BuiltInName

// TODO: Would be nice to make this a class instead of a namespace so that we could friend this
// from TVariable. Now symbol constructors taking an id have to be public even though they're not
// supposed to be accessible from outside of here.
namespace BuiltInVariable
{{

{variable_declarations}

{get_variable_definitions}

}};  // namespace BuiltInVariable

void TSymbolTable::insertStaticBuiltInVariables(sh::GLenum shaderType,
                                                ShShaderSpec spec,
                                                const ShBuiltInResources &resources)
{{
{insert_variables}
}}

}}  // namespace sh
"""

parsed_variables = None

variables_json_filename = 'builtin_variables.json'

with open(variables_json_filename) as f:
    parsed_variables = json.load(f, object_pairs_hook=OrderedDict)


# Declarations of symbol unique ids
builtin_id_declarations = []

# Declarations of name string variables
name_declarations = set()

# Declarations of builtin TVariables
variable_declarations = []

# Functions for querying the pointer to a specific TVariable.
get_variable_declarations = []
get_variable_definitions = []

# Code for inserting builtin TVariables to the symbol table.
insert_variables = []

id_counter = 0

def get_type_string(type_obj):
    if 'vecSize' in type_obj:
        type_obj['primarySize'] = type_obj['vecSize']
        type_obj['secondarySize'] = 1
    elif 'columns' in type_obj:
        type_obj['primarySize'] = type_obj['columns']
        type_obj['secondarySize'] = type_obj['rows']
    elif 'primarySize' not in type_obj:
        type_obj['primarySize'] = 1
        type_obj['secondarySize'] = 1
    if 'precision' not in type_obj:
        if type_obj['basic'] != 'Bool':
            raise Exception('Undefined precision for a non-bool variable')
        type_obj['precision'] = 'Undefined'
    template_type = 'StaticType::Get<Ebt{basic}, Ebp{precision}, Evq{qualifier}, {primarySize}, {secondarySize}>()'
    return template_type.format(**type_obj)

def get_suffix(props):
    if 'suffix' in props:
        return props['suffix']
    return ''

def get_extension(props):
    if 'extension' in props:
        return props['extension']
    return 'UNDEFINED'

def process_variable_group(group_name, group):
    global id_counter
    if 'condition' in group:
        insert_variables.append('  if ({condition})'.format(condition = group['condition']))
        insert_variables.append('  {')

    if 'variables' in group:
        for variable_name, props in group['variables'].iteritems():
            variable_id = id_counter

            # The name suffix makes the variable name unique in case it otherwise isn't.
            name_suffix = get_suffix(props)
            type = get_type_string(props['type'])
            extension = get_extension(props)

            template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {name}{suffix} = TSymbolUniqueId({id});'
            builtin_id_declarations.append(template_builtin_id_declaration.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_name_declaration = 'constexpr const ImmutableString {name}("{name}");'
            name_declarations.add(template_name_declaration.format(name = variable_name))

            template_variable_declaration = 'constexpr const TVariable kVar_{name}{suffix}(BuiltInId::{name}{suffix}, BuiltInName::{name}, SymbolType::BuiltIn, TExtension::{extension}, {type});'
            variable_declarations.append(template_variable_declaration.format(name = variable_name, suffix = name_suffix, extension = extension, type = type))

            template_get_variable_declaration = 'const TVariable *{name}{suffix}();'
            get_variable_declarations.append(template_get_variable_declaration.format(name = variable_name, suffix = name_suffix))

            template_get_variable_definition = """const TVariable *{name}{suffix}()
{{
    return &kVar_{name}{suffix};
}}
"""
            get_variable_definitions.append(template_get_variable_definition.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_insert_variable = '    insertBuiltIn({level}, &BuiltInVariable::kVar_{name}{suffix});'
            insert_variables.append(template_insert_variable.format(level = props['level'], name = variable_name, suffix = name_suffix))

            id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_variable_group(subgroup_name, subgroup)

    if 'condition' in group:
        insert_variables.append('  }')

for group_name, group in parsed_variables.iteritems():
    process_variable_group(group_name, group)

builtin_id_declarations = '\n'.join(builtin_id_declarations)
name_declarations = '\n'.join(sorted(list(name_declarations)))
variable_declarations = '\n'.join(sorted(variable_declarations))
get_variable_declarations = '\n'.join(sorted(get_variable_declarations))
get_variable_definitions = '\n'.join(sorted(get_variable_definitions))
insert_variables = '\n'.join(insert_variables)

with open('BuiltIn_autogen.h', 'wt') as outfile_header:
    output_header = template_builtin_header.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        get_variable_declarations = get_variable_declarations
        )
    outfile_header.write(output_header)

with open('SymbolTable_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_symboltable_cpp.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        builtin_id_declarations = builtin_id_declarations,
        last_static_builtin_id = id_counter - 1,
        name_declarations = name_declarations,
        get_variable_definitions = get_variable_definitions,
        variable_declarations = variable_declarations,
        insert_variables = insert_variables
        )
    outfile_cpp.write(output_cpp)

