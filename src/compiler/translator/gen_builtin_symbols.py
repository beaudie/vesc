#!/usr/bin/python
# Copyright 2018 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_builtin_symbols.py:
#  Code generation for the built-in symbol tables.

from collections import OrderedDict
from datetime import date
import json
import re
import os

def set_working_dir():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

set_working_dir()

# The header file has a "get" function for each variable. They are used in traversers.
# Note that we don't currently include get_function_declarations, as they are unused.
template_builtin_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name} and
// {function_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// BuiltIn_autogen.h:
//   Compile-time initialized built-ins.

#ifndef COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_
#define COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

namespace sh
{{

class TVariable;

constexpr const int kLastStaticBuiltInId = {last_static_builtin_id};

namespace BuiltInVariable
{{

{get_variable_declarations}

}}  // namespace BuiltInVariable

}}  // namespace sh

#endif  // COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

"""

# By having the variables defined in a cpp file we ensure that there's just one instance of each of the declared variables.
# Note that we don't currently include get_function_definitions, as they are unused.
template_symboltable_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name} and
// {function_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// SymbolTable_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/SymbolTable.h"

#include "angle_gl.h"
#include "compiler/translator/BuiltIn_autogen.h"
#include "compiler/translator/ImmutableString.h"
#include "compiler/translator/StaticType.h"
#include "compiler/translator/Symbol.h"
#include "compiler/translator/SymbolUniqueId.h"
#include "compiler/translator/SymbolTable.h"

namespace sh
{{

// This is a class instead of a namespace so that we can restrict access to TSymbolUniqueId
// constructor taking an integer to here.
class BuiltInId
{{
  public:

{builtin_id_declarations}

}};

namespace BuiltInName
{{

{name_declarations}

}}  // namespace BuiltInName

namespace BuiltInParameters
{{

{parameter_declarations}

}}

namespace UnmangledBuiltIns
{{

{unmangled_builtin_declarations}

}}

// TODO: Would be nice to make this a class instead of a namespace so that we could friend this
// from TVariable. Now symbol constructors taking an id have to be public even though they're not
// supposed to be accessible from outside of here.
namespace BuiltInVariable
{{

{variable_declarations}

{get_variable_definitions}

}};  // namespace BuiltInVariable

namespace BuiltInFunction
{{

{function_declarations}

}};

void TSymbolTable::insertStaticBuiltInVariables(sh::GLenum shaderType,
                                                ShShaderSpec spec,
                                                const ShBuiltInResources &resources)
{{
{insert_variables}
}}

void TSymbolTable::insertStaticBuiltInFunctions(sh::GLenum shaderType)
{{
{insert_functions}
}}

const UnmangledBuiltIn *TSymbolTable::getUnmangledBuiltInForShaderVersion(const ImmutableString &name, int shaderVersion)
{{
{get_unmangled_builtin}
}}

}}  // namespace sh
"""

parsed_variables = None

variables_json_filename = 'builtin_variables.json'
functions_txt_filename = 'builtin_function_declarations.txt'

with open(variables_json_filename) as f:
    parsed_variables = json.load(f, object_pairs_hook=OrderedDict)

def parse_type(type):
    if type.startswith('out '):
        type_obj = parse_type(type[4:])
        type_obj['qualifier'] = 'Out'
        return type_obj
    if type.startswith('inout '):
        type_obj = parse_type(type[6:])
        type_obj['qualifier'] = 'InOut'
        return type_obj
    if type == 'float':
        return OrderedDict([('basic', 'Float')])
    if type == 'int':
        return OrderedDict([('basic', 'Int')])
    if type == 'uint':
        return OrderedDict([('basic', 'UInt')])
    if type == 'bool':
        return OrderedDict([('basic', 'Bool')])

    if type == 'void':
        return OrderedDict([('basic', 'Void')])

    if type == 'atomic_uint':
        return OrderedDict([('basic', 'AtomicCounter')])

    if type == 'yuvCscStandardEXT':
        return OrderedDict([('basic', 'YuvCscStandardEXT')])

    if type == 'vec2':
        return OrderedDict([('basic', 'Float'), ('vecSize', 2)])
    if type == 'vec3':
        return OrderedDict([('basic', 'Float'), ('vecSize', 3)])
    if type == 'vec4':
        return OrderedDict([('basic', 'Float'), ('vecSize', 4)])

    if type == 'ivec2':
        return OrderedDict([('basic', 'Int'), ('vecSize', 2)])
    if type == 'ivec3':
        return OrderedDict([('basic', 'Int'), ('vecSize', 3)])
    if type == 'ivec4':
        return OrderedDict([('basic', 'Int'), ('vecSize', 4)])

    if type == 'uvec2':
        return OrderedDict([('basic', 'UInt'), ('vecSize', 2)])
    if type == 'uvec3':
        return OrderedDict([('basic', 'UInt'), ('vecSize', 3)])
    if type == 'uvec4':
        return OrderedDict([('basic', 'UInt'), ('vecSize', 4)])

    if type == 'bvec2':
        return OrderedDict([('basic', 'Bool'), ('vecSize', 2)])
    if type == 'bvec3':
        return OrderedDict([('basic', 'Bool'), ('vecSize', 3)])
    if type == 'bvec4':
        return OrderedDict([('basic', 'Bool'), ('vecSize', 4)])

    if type == 'mat2':
        return OrderedDict([('basic', 'Float'), ('columns', 2), ('rows', 2)])
    if type == 'mat3':
        return OrderedDict([('basic', 'Float'), ('columns', 3), ('rows', 3)])
    if type == 'mat4':
        return OrderedDict([('basic', 'Float'), ('columns', 4), ('rows', 4)])

    if type == 'mat2x3':
        return OrderedDict([('basic', 'Float'), ('columns', 2), ('rows', 3)])
    if type == 'mat2x4':
        return OrderedDict([('basic', 'Float'), ('columns', 2), ('rows', 4)])
    if type == 'mat3x2':
        return OrderedDict([('basic', 'Float'), ('columns', 3), ('rows', 2)])
    if type == 'mat3x4':
        return OrderedDict([('basic', 'Float'), ('columns', 3), ('rows', 4)])
    if type == 'mat4x2':
        return OrderedDict([('basic', 'Float'), ('columns', 4), ('rows', 2)])
    if type == 'mat4x3':
        return OrderedDict([('basic', 'Float'), ('columns', 4), ('rows', 3)])

    if type == 'genType':
        return OrderedDict([('basic', 'Float'), ('genType', 'yes')])
    if type == 'genIType':
        return OrderedDict([('basic', 'Int'), ('genType', 'yes')])
    if type == 'genUType':
        return OrderedDict([('basic', 'UInt'), ('genType', 'yes')])
    if type == 'genBType':
        return OrderedDict([('basic', 'Bool'), ('genType', 'yes')])

    if type == 'vec':
        return OrderedDict([('basic', 'Float'), ('genType', 'vec')])
    if type == 'ivec':
        return OrderedDict([('basic', 'Int'), ('genType', 'vec')])
    if type == 'uvec':
        return OrderedDict([('basic', 'UInt'), ('genType', 'vec')])
    if type == 'bvec':
        return OrderedDict([('basic', 'Bool'), ('genType', 'vec')])

    if type == 'sampler2D':
        return OrderedDict([('basic', 'Sampler2D')])
    if type == 'sampler3D':
        return OrderedDict([('basic', 'Sampler3D')])
    if type == 'samplerCube':
        return OrderedDict([('basic', 'SamplerCube')])
    if type == 'sampler2DMS':
        return OrderedDict([('basic', 'Sampler2DMS')])
    if type == 'sampler2DArray':
        return OrderedDict([('basic', 'Sampler2DArray')])

    if type == 'samplerExternalOES':
        return OrderedDict([('basic', 'SamplerExternalOES')])
    if type == 'sampler2DRect':
        return OrderedDict([('basic', 'Sampler2DRect')])
    if type == 'samplerExternal2DY2YEXT':
        return OrderedDict([('basic', 'SamplerExternal2DY2YEXT')])

    if type == 'samplerCubeShadow':
        return OrderedDict([('basic', 'SamplerCubeShadow')])
    if type == 'sampler2DShadow':
        return OrderedDict([('basic', 'SamplerCubeShadow')])
    if type == 'sampler2DArrayShadow':
        return OrderedDict([('basic', 'Sampler2DArrayShadow')])

    if type == 'gsampler2D':
        return OrderedDict([('basic', 'Sampler2D'), ('genType', 'sampler')])
    if type == 'gsampler3D':
        return OrderedDict([('basic', 'Sampler3D'), ('genType', 'sampler')])
    if type == 'gsamplerCube':
        return OrderedDict([('basic', 'SamplerCube'), ('genType', 'sampler')])
    if type == 'gsampler2DMS':
        return OrderedDict([('basic', 'Sampler2DMS'), ('genType', 'sampler')])
    if type == 'gsampler2DArray':
        return OrderedDict([('basic', 'Sampler2DArray'), ('genType', 'sampler')])

    if type == 'gvec4':
        return OrderedDict([('vecSize', 4), ('genType', 'sampler')])
    if type == 'gvec3':
        return OrderedDict([('vecSize', 3), ('genType', 'sampler')])

    if type == 'gimage2D':
        return OrderedDict([('basic', 'Image2D'), ('genType', 'image')])
    if type == 'gimage3D':
        return OrderedDict([('basic', 'Image3D'), ('genType', 'image')])
    if type == 'gimageCube':
        return OrderedDict([('basic', 'ImageCube'), ('genType', 'image')])
    if type == 'gimage2DArray':
        return OrderedDict([('basic', 'Image2DArray'), ('genType', 'image')])

    raise Exception('Unrecognized type: ' + str(type))

def get_parsed_functions():

    def parse_function_parameters(parameters):
        if parameters == '':
            return []
        parametersOut = []
        parameters = parameters.split(', ')
        for parameter in parameters:
            parametersOut.append(parse_type(parameter.strip()))
        return parametersOut

    lines = []
    with open(functions_txt_filename) as f:
        lines = f.readlines()
    lines = [line.strip() for line in lines if line.strip() != '']

    fun_re = re.compile(r'(\w+) (\w+)\((.*)\);(.*)')

    parsed_functions = OrderedDict()
    group_functions = []
    group_name = None
    group_metadata = {}

    level = 'COMMON_BUILTINS'
    op = 'auto'

    for line in lines:
        fun_match = fun_re.search(line)
        if line.startswith('GROUP'):
            if line.startswith('GROUP END'):
                group = {'functions': group_functions}
                group.update(group_metadata)
                parsed_functions[group_name] = group
                group_functions = []
            elif line.startswith('GROUP BEGIN '):
                # TODO: Handle group metadata
                group_rest = line[12:].strip()
                group_parts = group_rest.split(' ', 1)
                group_name = group_parts[0]
                group_metadata = {}
                if len(group_parts) > 1:
                    group_metadata = json.loads(group_parts[1])
        elif fun_match:
            return_type = fun_match.group(1)
            name = fun_match.group(2)
            parameters = fun_match.group(3)
            metadata = fun_match.groups()[-1].strip()

            function_props = OrderedDict([
                ('name', name),
                ('level', level),
                ('op', op),
                ('returnType', parse_type(return_type)),
                ('parameters', parse_function_parameters(parameters))
            ])
            if metadata != '':
                metadata = json.loads(metadata)
                function_props.update(metadata)
            group_functions.append(function_props)
        else:
            (level, op) = line.split(', ')

    return parsed_functions

parsed_functions = get_parsed_functions()

# TODO: Add an option to dump intermediate json
#with open('builtin_functions.json', 'w') as outfile:
#    json.dump(parsed_functions, outfile, indent=4, separators=(',', ': '))

# Declarations of symbol unique ids
builtin_id_declarations = []

# Declarations of name string variables
name_declarations = set()

# Declarations of builtin TVariables
variable_declarations = []

# Declarations of parameter arrays for builtin TFunctions
parameter_declarations = set()

# Declarations of builtin TFunctions
function_declarations = []

# Functions for querying the pointer to a specific TVariable.
get_variable_declarations = []
get_variable_definitions = []

# Functions for querying the pointer to a specific TFunction.
get_function_declarations = []
get_function_definitions = []

# Code for inserting builtin TVariables to the symbol table.
insert_variables = []

# Code for inserting builtin TFunctions to the symbol table. Grouped by condition.
insert_functions_by_condition = OrderedDict()

# Declarations of UnmangledBuiltIn objects
unmangled_builtin_declarations = set()

# Code for querying builtin function names. Grouped by condition and level.
unmangled_functions_by_condition = OrderedDict()

id_counter = 0

def is_matrix(type_obj):
    return type_obj['secondarySize'] > 1

def is_vector(type_obj):
    return type_obj['secondarySize'] == 1 and type_obj['primarySize'] > 1

def get_type_string(type_obj, allow_undefined_precision=True):
    if 'vecSize' in type_obj:
        type_obj['primarySize'] = type_obj['vecSize']
        type_obj['secondarySize'] = 1
    elif 'columns' in type_obj:
        type_obj['primarySize'] = type_obj['columns']
        type_obj['secondarySize'] = type_obj['rows']
    elif 'primarySize' not in type_obj:
        type_obj['primarySize'] = 1
        type_obj['secondarySize'] = 1
    if 'secondarySize' not in type_obj:
        type_obj['secondarySize'] = 1
    if 'precision' not in type_obj:
        if type_obj['basic'] != 'Bool' and not allow_undefined_precision:
            raise Exception('Undefined precision for a non-bool variable')
        type_obj['precision'] = 'Undefined'
    if 'qualifier' not in type_obj:
        type_obj['qualifier'] = 'Global'
    template_type = 'StaticType::Get<Ebt{basic}, Ebp{precision}, Evq{qualifier}, {primarySize}, {secondarySize}>()'
    return template_type.format(**type_obj)

def get_suffix(props):
    if 'suffix' in props:
        return props['suffix']
    return ''

def get_extension(props):
    if 'extension' in props:
        return props['extension']
    return 'UNDEFINED'

def get_op(name, function_props):
    if 'op' in function_props:
        if function_props['op'] == 'auto':
            return name[0].upper() + name[1:]
        return function_props['op']
    return 'CallBuiltInFunction'

def get_known_to_not_have_side_effects(function_props):
    if 'op' in function_props and function_props['op'] != 'CallBuiltInFunction':
        if 'hasSideEffects' in function_props:
            return 'false'
        else:
            for param in get_parameters(function_props):
                if 'qualifier' in param and param['qualifier'] == 'Out':
                    return 'false'
            return 'true'
    return 'false'

def get_parameters(function_props):
    if 'parameters' in function_props:
        return function_props['parameters']
    return []

basic_mangled_names = {
    'Float': 'f',
    'Int': 'i',
    'UInt': 'u',
    'Bool': 'b',
    'YuvCscStandardEXT': 'ycs',
    'Sampler2D': 's2',
    'Sampler3D': 's3',
    'SamplerCube': 'sC',
    'Sampler2DArray': 's2a',
    'SamplerExternalOES': 'sext',
    'SamplerExternal2DY2YEXT': 'sext2y2y',
    'Sampler2DRect': 's2r',
    'Sampler2DMS': 's2ms',
    'ISampler2D': 'is2',
    'ISampler3D': 'is3',
    'ISamplerCube': 'isC',
    'ISampler2DArray': 'is2a',
    'ISampler2DMS': 'is2ms',
    'USampler2D': 'us2',
    'USampler3D': 'us3',
    'USamplerCube': 'usC',
    'USampler2DArray': 'us2a',
    'USampler2DMS': 'us2ms',
    'Sampler2DShadow': 's2s',
    'SamplerCubeShadow': 'sCs',
    'Sampler2DArrayShadow': 's2as',
    'Image2D': 'im2',
    'IImage2D': 'iim2',
    'UImage2D': 'uim2',
    'Image3D': 'im3',
    'IImage3D': 'iim3',
    'UImage3D': 'uim3',
    'Image2DArray': 'im2a',
    'IImage2DArray': 'iim2a',
    'UImage2DArray': 'uim2a',
    'ImageCube': 'imc',
    'IImageCube': 'iimc',
    'UImageCube': 'uimc',
    'AtomicCounter': 'ac'
}

def get_mangled_type_name(type, separator = ';'):
    # This sets primarySize, secondarySize etc default values on the type object.
    get_type_string(type)

    mangled_name = ''

    if is_matrix(type):
        mangled_name += 'm'
    elif is_vector(type):
        mangled_name += 'v'
    mangled_name += basic_mangled_names[type['basic']]

    if is_matrix(type):
        mangled_name += str(type['primarySize'])
        mangled_name += 'x'
        mangled_name += str(type['secondarySize'])
    else:
        mangled_name += str(type['primarySize'])

    mangled_name += separator
    return mangled_name

def get_mangled_name(function_name, parameters):
    mangled_name = function_name + '('
    for param in parameters:
        mangled_name += get_mangled_type_name(param)
    return mangled_name

def get_unique_identifier_name(function_name, parameters):
    unique_name = function_name + '_'
    for param in parameters:
        unique_name += get_mangled_type_name(param, '_')
    return unique_name

def get_parameters_name(parameters):
    if len(parameters) == 0:
        return 'empty'
    unique_name = ''
    for param in parameters:
        if 'qualifier' in param:
            if param['qualifier'] == 'Out':
                unique_name += 'o_'
            if param['qualifier'] == 'InOut':
                unique_name += 'io_'
        unique_name += get_mangled_type_name(param, '_')
    return unique_name

def process_variable_group(group_name, group):
    global id_counter
    if 'condition' in group:
        insert_variables.append('  if ({condition})'.format(condition = group['condition']))
        insert_variables.append('  {')

    if 'variables' in group:
        for variable_name, props in group['variables'].iteritems():
            variable_id = id_counter

            # The name suffix makes the variable name unique in case it otherwise isn't.
            name_suffix = get_suffix(props)
            type = get_type_string(props['type'], False)
            extension = get_extension(props)

            template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {name}{suffix} = TSymbolUniqueId({id});'
            builtin_id_declarations.append(template_builtin_id_declaration.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_name_declaration = 'constexpr const ImmutableString {name}("{name}");'
            name_declarations.add(template_name_declaration.format(name = variable_name))

            template_variable_declaration = 'constexpr const TVariable kVar_{name}{suffix}(BuiltInId::{name}{suffix}, BuiltInName::{name}, SymbolType::BuiltIn, TExtension::{extension}, {type});'
            variable_declarations.append(template_variable_declaration.format(name = variable_name, suffix = name_suffix, extension = extension, type = type))

            template_get_variable_declaration = 'const TVariable *{name}{suffix}();'
            get_variable_declarations.append(template_get_variable_declaration.format(name = variable_name, suffix = name_suffix))

            template_get_variable_definition = """const TVariable *{name}{suffix}()
{{
    return &kVar_{name}{suffix};
}}
"""
            get_variable_definitions.append(template_get_variable_definition.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_insert_variable = '    insertBuiltIn({level}, &BuiltInVariable::kVar_{name}{suffix});'
            insert_variables.append(template_insert_variable.format(level = props['level'], name = variable_name, suffix = name_suffix))

            id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_variable_group(subgroup_name, subgroup)

    if 'condition' in group:
        insert_variables.append('  }')

for group_name, group in parsed_variables.iteritems():
    process_variable_group(group_name, group)

def specific_type(gen_type, vec_size):
    if 'genType' in gen_type:
        specific_type = {}
        if gen_type['genType'] == 'sampler' or gen_type['genType'] == 'image':
            type = vec_size
            if 'vecSize' in gen_type:
                specific_type['basic'] = {'': 'Float', 'I': 'Int', 'U': 'UInt'}[type]
                specific_type['primarySize'] = gen_type['vecSize']
            elif 'basic' in gen_type:
                specific_type['basic'] = type + gen_type['basic']
                specific_type['primarySize'] = 1
            else:
                raise Exception('Unrecognized gsampler type: ' + str(gen_type))
            specific_type['precision'] = 'Undefined'
            specific_type['qualifier'] = 'Global'
            specific_type['secondarySize'] = 1
        else:
            get_type_string(gen_type)
            specific_type['basic'] = gen_type['basic']
            specific_type['precision'] = gen_type['precision']
            specific_type['qualifier'] = gen_type['qualifier']
            specific_type['primarySize'] = vec_size
            specific_type['secondarySize'] = 1
        return specific_type
    return gen_type

def gen_function_variants(function_name, function_props):
    function_variants = []
    parameters = get_parameters(function_props)
    function_is_gen_type = False
    gsampler = False
    gimage = False
    gvec = False
    for param in parameters:
        if 'genType' in param:
            function_is_gen_type = True
            if param['genType'] == 'sampler':
                gsampler = True
            elif param['genType'] == 'image':
                gimage = True
            elif param['genType'] == 'vec':
                gvec = True
            elif param['genType'] != 'yes':
                raise Exception('Unexpected value of genType "' + str(param['genType']) + '" should be "sampler", "vec", or "yes"')
    if not function_is_gen_type:
        function_variants.append(function_props)
        return function_variants

    if gsampler or gimage:
        types = ['', 'I', 'U']
        for type in types:
            variant_props = function_props.copy()
            variant_parameters = []
            for param in parameters:
                variant_parameters.append(specific_type(param, type))
            variant_props['parameters'] = variant_parameters
            variant_props['returnType'] = specific_type(function_props['returnType'], type)
            function_variants.append(variant_props)
    else:
        sizes = range(1, 5)
        if gvec:
            sizes = range(2, 5)
        for size in sizes:
            variant_props = function_props.copy()
            variant_parameters = []
            for param in parameters:
                variant_parameters.append(specific_type(param, size))
            variant_props['parameters'] = variant_parameters
            variant_props['returnType'] = specific_type(function_props['returnType'], size)
            function_variants.append(variant_props)

    return function_variants

defined_function_variants = set()

def process_function_group(group_name, group):
    global id_counter
    condition = 'NO_CONDITION'
    if 'condition' in group:
        condition = group['condition']
    if condition not in insert_functions_by_condition:
        insert_functions_by_condition[condition] = []
        unmangled_functions_by_condition[condition] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL3_1_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL3_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['ESSL1_BUILTINS'] = OrderedDict()
        unmangled_functions_by_condition[condition]['COMMON_BUILTINS'] = OrderedDict()
    if 'functions' in group:
        for function_props in group['functions']:
            function_name = function_props['name']
            level = function_props['level']
            name_suffix = get_suffix(function_props)
            extension = get_extension(function_props)
            op = get_op(function_name, function_props)
            known_to_not_have_side_effects = get_known_to_not_have_side_effects(function_props)

            function_variants = gen_function_variants(function_name, function_props)

            template_name_declaration = 'constexpr const ImmutableString {name}{suffix}("{name}");'
            name_declaration = template_name_declaration.format(name = function_name, suffix = name_suffix)

            if not name_declaration in name_declarations:
                name_declarations.add(name_declaration)

            template_unmangled = """if (name == BuiltInName::{name}{suffix})
{{
    return &UnmangledBuiltIns::{extension};
}}"""
            unmangled = template_unmangled.format(name = function_name, suffix = name_suffix, extension = extension)
            if function_name not in unmangled_functions_by_condition[condition][level] or extension == 'UNDEFINED':
                unmangled_functions_by_condition[condition][level][function_name] = unmangled

            for function_props in function_variants:
                function_id = id_counter

                parameters = get_parameters(function_props)
                param_count = len(parameters)
                return_type = get_type_string(function_props['returnType'])
                mangled_name = get_mangled_name(function_name, parameters)

                unique_name = get_unique_identifier_name(function_name + name_suffix, parameters)

                if unique_name in defined_function_variants:
                    continue
                defined_function_variants.add(unique_name)

                template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {unique_name} = TSymbolUniqueId({id});'
                builtin_id_declarations.append(template_builtin_id_declaration.format(id = function_id, unique_name = unique_name))

                template_mangled_name_declaration = 'constexpr const ImmutableString {unique_name}("{mangled_name}");'
                name_declarations.add(template_mangled_name_declaration.format(unique_name = unique_name, mangled_name = mangled_name))

                parameters_list = []
                for param in parameters:
                    template_parameter = 'TConstParameter({param_type})'
                    parameters_list.append(template_parameter.format(param_type = get_type_string(param)))
                template_parameter_list_declaration = 'constexpr const TConstParameter {parameters_name}[{param_count}] = {{ {parameters} }};'
                parameters_name = get_parameters_name(parameters)
                parameter_declarations.add(template_parameter_list_declaration.format(param_count = param_count, parameters_name = parameters_name, parameters = ', '.join(parameters_list)))

                template_function_declaration = 'constexpr const TFunction kFunction_{unique_name}(BuiltInId::{unique_name}, BuiltInName::{name}{suffix}, TExtension::{extension}, BuiltInParameters::{parameters_name}, {param_count}, {return_type}, BuiltInName::{unique_name}, EOp{op}, {known_to_not_have_side_effects});'
                function_declarations.append(template_function_declaration.format(name = function_name,
                                                                                  suffix = name_suffix,
                                                                                  unique_name = unique_name,
                                                                                  extension = extension,
                                                                                  parameters_name = parameters_name,
                                                                                  param_count = param_count,
                                                                                  return_type = return_type,
                                                                                  op = op,
                                                                                  known_to_not_have_side_effects = known_to_not_have_side_effects))

                template_insert_function = '    insertBuiltIn({level}, &BuiltInFunction::kFunction_{unique_name});'
                insert_functions_by_condition[condition].append(template_insert_function.format(level = level, unique_name = unique_name))

                template_get_function_declaration = 'const TFunction *{unique_name}();'
                get_function_declarations.append(template_get_function_declaration.format(unique_name = unique_name))

                template_get_function_definition = """const TFunction *{unique_name}()
{{
    return &kFunction_{unique_name};
}}
"""
                get_function_definitions.append(template_get_function_definition.format(unique_name = unique_name))

                id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_function_group(subgroup_name, subgroup)

for group_name, group in parsed_functions.iteritems():
    process_function_group(group_name, group)

builtin_id_declarations = '\n'.join(builtin_id_declarations)
name_declarations = '\n'.join(sorted(list(name_declarations)))
variable_declarations = '\n'.join(sorted(variable_declarations))
function_declarations = '\n'.join(function_declarations)
get_variable_declarations = '\n'.join(sorted(get_variable_declarations))
get_variable_definitions = '\n'.join(sorted(get_variable_definitions))
get_function_declarations = '\n'.join(get_function_declarations)
get_function_definitions = '\n'.join(get_function_definitions)
insert_variables = '\n'.join(insert_variables)
parameter_declarations = '\n'.join(sorted(parameter_declarations))

insert_functions = []
get_unmangled_builtin = []

def get_shader_version_condition_for_level(level):
    if level == 'ESSL3_1_BUILTINS':
        return 'shaderVersion >= 310'
    elif level == 'ESSL3_BUILTINS':
        return 'shaderVersion >= 300'
    elif level == 'ESSL1_BUILTINS':
        return 'shaderVersion == 100'
    elif level == 'COMMON_BUILTINS':
        return ''
    else:
        raise Exception('Unsupported symbol table level')

for condition in insert_functions_by_condition:
    if condition != 'NO_CONDITION':
        condition_header = '  if ({condition})\n {{'.format(condition = condition)
        insert_functions.append(condition_header)
        get_unmangled_builtin.append(condition_header.replace('shaderType', 'mShaderType'))

    for insert_function in insert_functions_by_condition[condition]:
        insert_functions.append(insert_function)
    for level, functions in unmangled_functions_by_condition[condition].iteritems():
        if len(functions) > 0:
            level_condition = get_shader_version_condition_for_level(level)
            if level_condition != '':
                get_unmangled_builtin.append('if ({condition})\n {{'.format(condition = level_condition))
            for function_name, get_unmangled_case in functions.iteritems():
                builtin_required_re = re.compile(r'UnmangledBuiltIns::(\w+)')
                mo = builtin_required_re.search(get_unmangled_case)
                ext = mo.group(1)
                unmangled_builtin_declarations.add('constexpr const UnmangledBuiltIn {extension}(TExtension::{extension});'.format(extension = ext))

                get_unmangled_builtin.append(get_unmangled_case)
            if level_condition != '':
                get_unmangled_builtin.append('}')

    if condition != 'NO_CONDITION':
        insert_functions.append('}')
        get_unmangled_builtin.append('}')

get_unmangled_builtin.append('return nullptr;')

unmangled_builtin_declarations = '\n'.join(sorted(unmangled_builtin_declarations))

insert_functions = '\n'.join(insert_functions)
get_unmangled_builtin = '\n'.join(get_unmangled_builtin)

with open('BuiltIn_autogen.h', 'wt') as outfile_header:
    output_header = template_builtin_header.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        function_data_source_name = functions_txt_filename,
        copyright_year = date.today().year,
        get_variable_declarations = get_variable_declarations,
        get_function_declarations = get_function_declarations,
        last_static_builtin_id = id_counter - 1
        )
    outfile_header.write(output_header)

with open('SymbolTable_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_symboltable_cpp.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        function_data_source_name = functions_txt_filename,
        copyright_year = date.today().year,
        builtin_id_declarations = builtin_id_declarations,
        name_declarations = name_declarations,
        get_variable_definitions = get_variable_definitions,
        get_function_definitions = get_function_definitions,
        parameter_declarations = parameter_declarations,
        variable_declarations = variable_declarations,
        insert_variables = insert_variables,
        insert_functions = insert_functions,
        function_declarations = function_declarations,
        unmangled_builtin_declarations = unmangled_builtin_declarations,
        get_unmangled_builtin = get_unmangled_builtin
        )
    outfile_cpp.write(output_cpp)
