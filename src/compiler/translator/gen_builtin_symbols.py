#!/usr/bin/python
# Copyright 2018 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_builtin_symbols.py:
#  Code generation for the built-in symbol tables.

from collections import OrderedDict
from datetime import date
import json
import os
import sys

def set_working_dir():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

set_working_dir()

# The header file has a "get" function for each variable. They are used in symbol table init and in traversers.
template_builtin_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// BuiltIn_autogen.h:
//   Compile-time initialized built-ins.

#ifndef COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_
#define COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

namespace sh
{{

class TFunction;
class TVariable;

constexpr const int kLastStaticBuiltInId = {last_static_builtin_id};

namespace BuiltInVariable
{{

{get_variable_declarations}

}}  // namespace BuiltInVariable

namespace BuiltInFunction
{{

{get_function_declarations}

}}  // namespace BuiltInFunction


}}  // namespace sh

#endif  // COMPILER_TRANSLATOR_BUILTIN_AUTOGEN_H_

"""

# By having the variables defined in a cpp file we ensure that there's just one instance of each of the declared variables.
template_builtin_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// BuiltIn_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/ImmutableString.h"
#include "compiler/translator/StaticType.h"
#include "compiler/translator/Symbol.h"
#include "compiler/translator/SymbolUniqueId.h"

namespace sh
{{

// This is a class instead of a namespace so that we can restrict access to TSymbolUniqueId
// constructor taking an integer to here.
class BuiltInId
{{
  public:

{builtin_id_declarations}

}};

namespace BuiltInName
{{

{name_declarations}

}}  // namespace BuiltInName

namespace BuiltInParameters
{{

{parameter_declarations}

}}

// TODO: Would be nice to make this a class instead of a namespace so that we could friend this
// from TVariable. Now symbol constructors taking an id have to be public even though they're not
// supposed to be accessible from outside of here.
namespace BuiltInVariable
{{

{variable_declarations}

{get_variable_definitions}

}};  // namespace BuiltInVariable

namespace BuiltInFunction
{{

{function_declarations}

{get_function_definitions}

}};

}}  // namespace sh

"""

template_symboltable_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {variable_data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// SymbolTable_autogen.cpp:
//   Compile-time initialized built-ins.

#include "compiler/translator/SymbolTable.h"

#include "angle_gl.h"
#include "compiler/translator/BuiltIn_autogen.h"

namespace sh
{{

void TSymbolTable::insertStaticBuiltInVariables(sh::GLenum shaderType,
                                                ShShaderSpec spec,
                                                const ShBuiltInResources &resources)
{{
{insert_variables}
}}

void TSymbolTable::insertStaticBuiltInFunctions(sh::GLenum shaderType,
                                                ShShaderSpec spec,
                                                const ShBuiltInResources &resources)
{{
{insert_functions}
}}

}}  // namespace sh
"""

parsed_variables = None

variables_json_filename = 'builtin_variables.json'

with open(variables_json_filename) as f:
    parsed_variables = json.load(f, object_pairs_hook=OrderedDict)

parsed_functions = None

functions_json_filename = 'builtin_functions.json'

with open(functions_json_filename) as f:
    parsed_functions = json.load(f, object_pairs_hook=OrderedDict)

# Declarations of symbol unique ids
builtin_id_declarations = []

# Declarations of name string variables
name_declarations = set()

# Declarations of builtin TVariables
variable_declarations = []

# Declarations of parameter arrays for builtin TFunctions
parameter_declarations = []

# Declarations of builtin TFunctions
function_declarations = []

# Functions for querying the pointer to a specific TVariable.
get_variable_declarations = []
get_variable_definitions = []

# Functions for querying the pointer to a specific TFunction.
get_function_declarations = []
get_function_definitions = []

# Code for inserting builtin TVariables to the symbol table.
insert_variables = []

# Code for inserting builtin TFunctions to the symbol table.
insert_functions = []

id_counter = 0

def is_matrix(typeObj):
    return typeObj['secondarySize'] > 1

def is_vector(typeObj):
    return typeObj['secondarySize'] == 1 and typeObj['primarySize'] > 1

def get_type_string(typeObj, allowUndefinedPrecision=True):
    if 'vecSize' in typeObj:
        typeObj['primarySize'] = typeObj['vecSize']
        typeObj['secondarySize'] = 1
    elif 'columns' in typeObj:
        typeObj['primarySize'] = typeObj['columns']
        typeObj['secondarySize'] = typeObj['rows']
    elif 'primarySize' not in typeObj:
        typeObj['primarySize'] = 1
        typeObj['secondarySize'] = 1
    if 'precision' not in typeObj:
        if typeObj['basic'] != 'Bool' and not allowUndefinedPrecision:
            raise Exception('Undefined precision for a non-bool variable')
        typeObj['precision'] = 'Undefined'
    if 'qualifier' not in typeObj:
        typeObj['qualifier'] = 'Global'
    template_type = 'StaticType::Get<Ebt{basic}, Ebp{precision}, Evq{qualifier}, {primarySize}, {secondarySize}>()'
    return template_type.format(**typeObj)

def get_suffix(props):
    if 'suffix' in props:
        return props['suffix']
    return ''

def get_extension(props):
    if 'extension' in props:
        return props['extension']
    return 'UNDEFINED'

def get_op(name, props):
    if 'op' in props:
        if props['op'] == 'auto':
            return name.capitalize()
        return props['op']
    return 'CallBuiltInFunction'

def get_known_to_not_have_side_effects(props):
    if 'op' in props:
        if 'hasSideEffects' in props:
            return 'false'
        else:
            return 'true'
    return 'false'

def get_parameters(function_props):
    if 'parameters' in function_props:
        return function_props['parameters']
    return []

basic_mangled_names = {
    'Float': 'f',
    'Int': 'i',
    'UInt': 'u',
    'Bool': 'b',
    'YuvCscStandardEXT': 'ycs',
    'Sampler2D': 's2',
    'Sampler3D': 's3',
    'SamplerCube': 'sC',
    'Sampler2DArray': 's2a',
    'SamplerExternalOES': 'sext',
    'SamplerExternal2DY2YEXT': 'sext2y2y',
    'Sampler2DRect': 's2r',
    'Sampler2DMS': 's2ms',
    'ISampler2D': 'is2',
    'ISampler3D': 'is3',
    'ISamplerCube': 'isC',
    'ISampler2DArray': 'is2a',
    'ISampler2DMS': 'is2ms',
    'USampler2D': 'us2',
    'USampler3D': 'us3',
    'USamplerCube': 'usC',
    'USampler2DArray': 'us2a',
    'USampler2DMS': 'us2ms',
    'Sampler2DShadow': 's2s',
    'SamplerCubeShadow': 'sCs',
    'Sampler2DArrayShadow': 's2as',
    'Image2D': 'im2',
    'IImage2D': 'iim2',
    'UImage2D': 'uim2',
    'Image3D': 'im3',
    'IImage3D': 'iim3',
    'UImage3D': 'uim3',
    'Image2DArray': 'im2a',
    'IImage2DArray': 'iim2a',
    'UImage2DArray': 'uim2a',
    'ImageCube': 'imc',
    'IImageCube': 'iimc',
    'UImageCube': 'uimc',
    'AtomicCounter': 'ac'
}

def get_mangled_type_name(type, separator = ';'):
    # This sets primarySize, secondarySize etc default values on the type object.
    get_type_string(type)

    mangled_name = ''

    if is_matrix(type):
        mangled_name += 'm'
    elif is_vector(type):
        mangled_name += 'v'
    mangled_name += basic_mangled_names[type['basic']]

    if is_matrix(type):
        mangled_name += str(type['primarySize'])
        mangled_name += 'x'
        mangled_name += str(type['secondarySize'])
    else:
        mangled_name += str(type['primarySize'])

    mangled_name += separator
    return mangled_name

def get_mangled_name(function_name, parameters):
    mangled_name = function_name + '('
    for param in parameters:
        mangled_name += get_mangled_type_name(param)
    return mangled_name

def get_unique_identifier_name(function_name, parameters):
    unique_name = function_name + '_'
    for param in parameters:
        unique_name += get_mangled_type_name(param, '_')
    return unique_name

def process_variable_group(group_name, group):
    global id_counter
    if 'condition' in group:
        insert_variables.append('  if ({condition})'.format(condition = group['condition']))
        insert_variables.append('  {')

    if 'variables' in group:
        for variable_name, props in group['variables'].iteritems():
            variable_id = id_counter

            # The name suffix makes the variable name unique in case it otherwise isn't.
            name_suffix = get_suffix(props)
            type = get_type_string(props['type'], False)
            extension = get_extension(props)

            template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {name}{suffix} = TSymbolUniqueId({id});'
            builtin_id_declarations.append(template_builtin_id_declaration.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_name_declaration = 'constexpr const ImmutableString {name}("{name}");'
            name_declarations.add(template_name_declaration.format(name = variable_name))

            template_variable_declaration = 'constexpr const TVariable kVar_{name}{suffix}(BuiltInId::{name}{suffix}, BuiltInName::{name}, SymbolType::BuiltIn, TExtension::{extension}, {type});'
            variable_declarations.append(template_variable_declaration.format(name = variable_name, suffix = name_suffix, extension = extension, type = type))

            template_get_variable_declaration = 'const TVariable *{name}{suffix}();'
            get_variable_declarations.append(template_get_variable_declaration.format(name = variable_name, suffix = name_suffix))

            template_get_variable_definition = """const TVariable *{name}{suffix}()
{{
    return &kVar_{name}{suffix};
}}
"""
            get_variable_definitions.append(template_get_variable_definition.format(id = variable_id, name = variable_name, suffix = name_suffix))

            template_insert_variable = '    insertBuiltIn({level}, BuiltInVariable::{name}{suffix}());'
            insert_variables.append(template_insert_variable.format(level = props['level'], name = variable_name, suffix = name_suffix))

            id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_variable_group(subgroup_name, subgroup)

    if 'condition' in group:
        insert_variables.append('  }')

for group_name, group in parsed_variables.iteritems():
    process_variable_group(group_name, group)

def specific_type(gen_type, vec_size):
    get_type_string(gen_type)
    if 'genType' in gen_type:
        specific_type = {}
        specific_type['basic'] = gen_type['basic']
        specific_type['precision'] = gen_type['precision']
        specific_type['qualifier'] = gen_type['qualifier']
        specific_type['primarySize'] = vec_size
        specific_type['secondarySize'] = 1
        return specific_type
    return gen_type

def gen_function_variants(function_name, props):
    function_variants = []
    parameters = get_parameters(props)
    function_is_gen_type = False
    gsampler = False
    gvec = False
    for param in parameters:
        if 'genType' in param:
            function_is_gen_type = True
            if param['genType'] == 'sampler':
                gsampler = True
            elif param['genType'] == 'vec':
                gvec = True
            elif param['genType'] != 'yes':
                raise Exception('Unexpected value of genType "' + str(param['genType']) + '" should be "sampler", "vec", or "yes"')
    if not function_is_gen_type:
        function_variants.append(props)
        return function_variants

    if gsampler:
        pass
    else:
        sizes = range(1, 5)
        if gvec:
            sizes = range(2, 5)
        for size in sizes:
            variant_props = props.copy()
            variant_parameters = []
            for param in parameters:
                variant_parameters.append(specific_type(param, size))
            variant_props['parameters'] = variant_parameters
            variant_props['returnType'] = specific_type(props['returnType'], size)
            function_variants.append(variant_props)

    return function_variants

def process_function_group(group_name, group):
    global id_counter
    if 'condition' in group:
        insert_functions.append('  if ({condition})'.format(condition = group['condition']))
        insert_functions.append('  {')
    if 'functions' in group:
        for function_name, props in group['functions'].iteritems():
            name_suffix = get_suffix(props)
            extension = get_extension(props)
            op = get_op(function_name, props)
            known_to_not_have_side_effects = get_known_to_not_have_side_effects(props)

            function_variants = gen_function_variants(function_name, props)

            template_name_declaration = 'constexpr const ImmutableString {name}("{name}");'
            name_declarations.add(template_name_declaration.format(name = function_name))

            for props in function_variants:
                function_id = id_counter

                parameters = get_parameters(props)
                param_count = len(parameters)
                return_type = get_type_string(props['returnType'])
                mangled_name = get_mangled_name(function_name, parameters)

                unique_name = get_unique_identifier_name(function_name + name_suffix, parameters)

                template_builtin_id_declaration = '    static constexpr const TSymbolUniqueId {name} = TSymbolUniqueId({id});'
                builtin_id_declarations.append(template_builtin_id_declaration.format(id = function_id, name = unique_name))

                template_mangled_name_declaration = 'constexpr const ImmutableString {unique_name}("{mangled_name}");'
                name_declarations.add(template_mangled_name_declaration.format(unique_name = unique_name, mangled_name = mangled_name))

                parameters_list = []
                for param in parameters:
                    template_parameter = 'TConstParameter({param_type})'
                    parameters_list.append(template_parameter.format(param_type = get_type_string(param)))
                template_parameter_list_declaration = 'constexpr const TConstParameter {unique_name}[{param_count}] = {{ {parameters} }};'
                parameter_declarations.append(template_parameter_list_declaration.format(param_count = param_count, unique_name = unique_name, parameters = ', '.join(parameters_list)))

                template_function_declaration = 'constexpr const TFunction kFunction_{unique_name}(BuiltInId::{unique_name}, BuiltInName::{name}, TExtension::{extension}, BuiltInParameters::{unique_name}, {param_count}, {return_type}, BuiltInName::{unique_name}, EOp{op}, {known_to_not_have_side_effects});'
                function_declarations.append(template_function_declaration.format(name = function_name, unique_name = unique_name, extension = extension, param_count = param_count, return_type = return_type, op = op, known_to_not_have_side_effects = known_to_not_have_side_effects))

                template_insert_function = '    insertBuiltIn({level}, BuiltInFunction::{unique_name}());'
                insert_functions.append(template_insert_function.format(level = props['level'], unique_name = unique_name))

                template_get_function_declaration = 'const TFunction *{unique_name}();'
                get_function_declarations.append(template_get_function_declaration.format(unique_name = unique_name))

                template_get_function_definition = """const TFunction *{unique_name}()
{{
    return &kFunction_{unique_name};
}}
"""
                get_function_definitions.append(template_get_function_definition.format(unique_name = unique_name))

                id_counter += 1

    if 'subgroups' in group:
        for subgroup_name, subgroup in group['subgroups'].iteritems():
            process_function_group(subgroup_name, subgroup)
    if 'condition' in group:
        insert_functions.append('  }')

for group_name, group in parsed_functions.iteritems():
    process_function_group(group_name, group)

builtin_id_declarations = '\n'.join(builtin_id_declarations)
name_declarations = '\n'.join(sorted(list(name_declarations)))
variable_declarations = '\n'.join(sorted(variable_declarations))
function_declarations = '\n'.join(function_declarations)
get_variable_declarations = '\n'.join(sorted(get_variable_declarations))
get_variable_definitions = '\n'.join(sorted(get_variable_definitions))
get_function_declarations = '\n'.join(get_function_declarations)
get_function_definitions = '\n'.join(get_function_definitions)
insert_variables = '\n'.join(insert_variables)
insert_functions = '\n'.join(insert_functions)
parameter_declarations = '\n'.join(parameter_declarations)

with open('BuiltIn_autogen.h', 'wt') as outfile_header:
    output_header = template_builtin_header.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        get_variable_declarations = get_variable_declarations,
        get_function_declarations = get_function_declarations,
        last_static_builtin_id = id_counter - 1
        )
    outfile_header.write(output_header)

with open('BuiltIn_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_builtin_cpp.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        builtin_id_declarations = builtin_id_declarations,
        name_declarations = name_declarations,
        get_variable_definitions = get_variable_definitions,
        get_function_definitions = get_function_definitions,
        parameter_declarations = parameter_declarations,
        variable_declarations = variable_declarations,
        function_declarations = function_declarations
        )
    outfile_cpp.write(output_cpp)

with open('SymbolTable_autogen.cpp', 'wt') as outfile_cpp:
    output_cpp = template_symboltable_cpp.format(
        script_name = os.path.basename(__file__),
        variable_data_source_name = variables_json_filename,
        copyright_year = date.today().year,
        insert_variables = insert_variables,
        insert_functions = insert_functions
        )
    outfile_cpp.write(output_cpp)

