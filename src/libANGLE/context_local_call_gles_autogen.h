// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml and gl_angle_ext.xml.
//
// Copyright 2023 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// context_local_call_gles_autogen.h:
//   Helpers that set/get state that is entirely locally accessed by the context.

#ifndef LIBANGLE_CONTEXT_LOCAL_CALL_gles_AUTOGEN_H_
#define LIBANGLE_CONTEXT_LOCAL_CALL_gles_AUTOGEN_H_

#include "libANGLE/Context.h"

namespace gl
{
void ContextLocalActiveTexture(Context *context, GLenum texture);
void ContextLocalBlendColor(Context *context,
                            GLfloat red,
                            GLfloat green,
                            GLfloat blue,
                            GLfloat alpha);
void ContextLocalBlendEquation(Context *context, GLenum mode);
void ContextLocalBlendEquationSeparate(Context *context, GLenum modeRGB, GLenum modeAlpha);
void ContextLocalBlendFunc(Context *context, GLenum sfactor, GLenum dfactor);
void ContextLocalBlendFuncSeparate(Context *context,
                                   GLenum sfactorRGB,
                                   GLenum dfactorRGB,
                                   GLenum sfactorAlpha,
                                   GLenum dfactorAlpha);
void ContextLocalClearColor(Context *context,
                            GLfloat red,
                            GLfloat green,
                            GLfloat blue,
                            GLfloat alpha);
void ContextLocalClearDepthf(Context *context, GLfloat d);
void ContextLocalClearStencil(Context *context, GLint s);
void ContextLocalColorMask(Context *context,
                           GLboolean red,
                           GLboolean green,
                           GLboolean blue,
                           GLboolean alpha);
void ContextLocalCullFace(Context *context, CullFaceMode modePacked);
void ContextLocalDepthFunc(Context *context, GLenum func);
void ContextLocalDepthMask(Context *context, GLboolean flag);
void ContextLocalDepthRangef(Context *context, GLfloat n, GLfloat f);
void ContextLocalDisable(Context *context, GLenum cap);
void ContextLocalEnable(Context *context, GLenum cap);
void ContextLocalFrontFace(Context *context, GLenum mode);
void ContextLocalLineWidth(Context *context, GLfloat width);
void ContextLocalPolygonOffset(Context *context, GLfloat factor, GLfloat units);
void ContextLocalSampleCoverage(Context *context, GLfloat value, GLboolean invert);
void ContextLocalScissor(Context *context, GLint x, GLint y, GLsizei width, GLsizei height);
void ContextLocalVertexAttrib1f(Context *context, GLuint index, GLfloat x);
void ContextLocalVertexAttrib1fv(Context *context, GLuint index, const GLfloat *v);
void ContextLocalVertexAttrib2f(Context *context, GLuint index, GLfloat x, GLfloat y);
void ContextLocalVertexAttrib2fv(Context *context, GLuint index, const GLfloat *v);
void ContextLocalVertexAttrib3f(Context *context, GLuint index, GLfloat x, GLfloat y, GLfloat z);
void ContextLocalVertexAttrib3fv(Context *context, GLuint index, const GLfloat *v);
void ContextLocalVertexAttrib4f(Context *context,
                                GLuint index,
                                GLfloat x,
                                GLfloat y,
                                GLfloat z,
                                GLfloat w);
void ContextLocalVertexAttrib4fv(Context *context, GLuint index, const GLfloat *v);
void ContextLocalViewport(Context *context, GLint x, GLint y, GLsizei width, GLsizei height);
void ContextLocalVertexAttribI4i(Context *context,
                                 GLuint index,
                                 GLint x,
                                 GLint y,
                                 GLint z,
                                 GLint w);
void ContextLocalVertexAttribI4iv(Context *context, GLuint index, const GLint *v);
void ContextLocalVertexAttribI4ui(Context *context,
                                  GLuint index,
                                  GLuint x,
                                  GLuint y,
                                  GLuint z,
                                  GLuint w);
void ContextLocalVertexAttribI4uiv(Context *context, GLuint index, const GLuint *v);
void ContextLocalSampleMaski(Context *context, GLuint maskNumber, GLbitfield mask);
void ContextLocalBlendEquationSeparatei(Context *context,
                                        GLuint buf,
                                        GLenum modeRGB,
                                        GLenum modeAlpha);
void ContextLocalBlendEquationi(Context *context, GLuint buf, GLenum mode);
void ContextLocalBlendFuncSeparatei(Context *context,
                                    GLuint buf,
                                    GLenum srcRGB,
                                    GLenum dstRGB,
                                    GLenum srcAlpha,
                                    GLenum dstAlpha);
void ContextLocalBlendFunci(Context *context, GLuint buf, GLenum src, GLenum dst);
void ContextLocalColorMaski(Context *context,
                            GLuint index,
                            GLboolean r,
                            GLboolean g,
                            GLboolean b,
                            GLboolean a);
void ContextLocalDisablei(Context *context, GLenum target, GLuint index);
void ContextLocalEnablei(Context *context, GLenum target, GLuint index);
void ContextLocalMinSampleShading(Context *context, GLfloat value);
void ContextLocalPrimitiveBoundingBox(Context *context,
                                      GLfloat minX,
                                      GLfloat minY,
                                      GLfloat minZ,
                                      GLfloat minW,
                                      GLfloat maxX,
                                      GLfloat maxY,
                                      GLfloat maxZ,
                                      GLfloat maxW);
void ContextLocalClearColorx(Context *context,
                             GLfixed red,
                             GLfixed green,
                             GLfixed blue,
                             GLfixed alpha);
void ContextLocalClearDepthx(Context *context, GLfixed depth);
void ContextLocalDepthRangex(Context *context, GLfixed n, GLfixed f);
void ContextLocalLineWidthx(Context *context, GLfixed width);
void ContextLocalLogicOp(Context *context, LogicalOperation opcodePacked);
void ContextLocalPolygonOffsetx(Context *context, GLfixed factor, GLfixed units);
void ContextLocalSampleCoveragex(Context *context, GLclampx value, GLboolean invert);

// GL_AMD_performance_monitor

// GL_ANDROID_extension_pack_es31a

// GL_ANGLE_base_vertex_base_instance

// GL_ANGLE_clip_cull_distance

// GL_ANGLE_copy_texture_3d

// GL_ANGLE_depth_texture

// GL_ANGLE_framebuffer_blit

// GL_ANGLE_framebuffer_multisample

// GL_ANGLE_get_image

// GL_ANGLE_get_tex_level_parameter

// GL_ANGLE_instanced_arrays

// GL_ANGLE_logic_op
void ContextLocalLogicOpANGLE(Context *context, LogicalOperation opcodePacked);

// GL_ANGLE_memory_object_flags

// GL_ANGLE_memory_object_fuchsia

// GL_ANGLE_multi_draw

// GL_ANGLE_pack_reverse_row_order

// GL_ANGLE_polygon_mode
void ContextLocalPolygonMode(Context *context, GLenum face, PolygonMode modePacked);

// GL_ANGLE_program_binary

// GL_ANGLE_provoking_vertex
void ContextLocalProvokingVertex(Context *context, ProvokingVertexConvention provokeModePacked);

// GL_ANGLE_renderability_validation

// GL_ANGLE_request_extension

// GL_ANGLE_robust_client_memory

// GL_ANGLE_robust_resource_initialization

// GL_ANGLE_semaphore_fuchsia

// GL_ANGLE_shader_pixel_local_storage

// GL_ANGLE_stencil_texturing

// GL_ANGLE_texture_compression_dxt3

// GL_ANGLE_texture_compression_dxt5

// GL_ANGLE_texture_external_update

// GL_ANGLE_texture_multisample

// GL_ANGLE_texture_usage

// GL_ANGLE_translated_shader_source

// GL_ANGLE_vulkan_image

// GL_APPLE_clip_distance

// GL_ARB_sync

// GL_ARM_shader_framebuffer_fetch

// GL_CHROMIUM_bind_uniform_location

// GL_CHROMIUM_copy_compressed_texture

// GL_CHROMIUM_copy_texture

// GL_CHROMIUM_framebuffer_mixed_samples
void ContextLocalCoverageModulation(Context *context, GLenum components);

// GL_CHROMIUM_lose_context

// GL_EXT_EGL_image_array

// GL_EXT_EGL_image_storage

// GL_EXT_YUV_target

// GL_EXT_base_instance

// GL_EXT_blend_func_extended

// GL_EXT_blend_minmax

// GL_EXT_buffer_storage

// GL_EXT_clip_control
void ContextLocalClipControl(Context *context, ClipOrigin originPacked, ClipDepthMode depthPacked);

// GL_EXT_clip_cull_distance

// GL_EXT_color_buffer_float

// GL_EXT_color_buffer_half_float

// GL_EXT_conservative_depth

// GL_EXT_copy_image

// GL_EXT_debug_label

// GL_EXT_debug_marker

// GL_EXT_depth_clamp

// GL_EXT_discard_framebuffer

// GL_EXT_disjoint_timer_query

// GL_EXT_draw_buffers

// GL_EXT_draw_buffers_indexed

// GL_EXT_draw_elements_base_vertex

// GL_EXT_external_buffer

// GL_EXT_float_blend

// GL_EXT_geometry_shader

// GL_EXT_gpu_shader5

// GL_EXT_instanced_arrays

// GL_EXT_map_buffer_range

// GL_EXT_memory_object

// GL_EXT_memory_object_fd

// GL_EXT_multi_draw_indirect

// GL_EXT_multisampled_render_to_texture

// GL_EXT_multisampled_render_to_texture2

// GL_EXT_occlusion_query_boolean

// GL_EXT_polygon_offset_clamp
void ContextLocalPolygonOffsetClamp(Context *context, GLfloat factor, GLfloat units, GLfloat clamp);

// GL_EXT_primitive_bounding_box

// GL_EXT_protected_textures

// GL_EXT_pvrtc_sRGB

// GL_EXT_read_format_bgra

// GL_EXT_render_snorm

// GL_EXT_robustness

// GL_EXT_sRGB

// GL_EXT_sRGB_write_control

// GL_EXT_semaphore

// GL_EXT_semaphore_fd

// GL_EXT_separate_shader_objects

// GL_EXT_shader_framebuffer_fetch

// GL_EXT_shader_framebuffer_fetch_non_coherent

// GL_EXT_shader_io_blocks

// GL_EXT_shader_non_constant_global_initializers

// GL_EXT_shader_texture_lod

// GL_EXT_shadow_samplers

// GL_EXT_tessellation_shader

// GL_EXT_texture_border_clamp

// GL_EXT_texture_buffer

// GL_EXT_texture_compression_bptc

// GL_EXT_texture_compression_dxt1

// GL_EXT_texture_compression_rgtc

// GL_EXT_texture_compression_s3tc

// GL_EXT_texture_compression_s3tc_srgb

// GL_EXT_texture_cube_map_array

// GL_EXT_texture_filter_anisotropic

// GL_EXT_texture_filter_minmax

// GL_EXT_texture_format_BGRA8888

// GL_EXT_texture_format_sRGB_override

// GL_EXT_texture_mirror_clamp_to_edge

// GL_EXT_texture_norm16

// GL_EXT_texture_rg

// GL_EXT_texture_sRGB_R8

// GL_EXT_texture_sRGB_RG8

// GL_EXT_texture_sRGB_decode

// GL_EXT_texture_storage

// GL_EXT_texture_type_2_10_10_10_REV

// GL_EXT_unpack_subimage

// GL_IMG_texture_compression_pvrtc

// GL_IMG_texture_compression_pvrtc2

// GL_KHR_blend_equation_advanced

// GL_KHR_debug

// GL_KHR_no_error

// GL_KHR_parallel_shader_compile

// GL_KHR_robust_buffer_access_behavior

// GL_KHR_texture_compression_astc_hdr

// GL_KHR_texture_compression_astc_ldr

// GL_KHR_texture_compression_astc_sliced_3d

// GL_MESA_framebuffer_flip_y

// GL_NV_fence

// GL_NV_framebuffer_blit

// GL_NV_pixel_buffer_object

// GL_NV_polygon_mode
void ContextLocalPolygonModeNV(Context *context, GLenum face, PolygonMode modePacked);

// GL_NV_read_depth

// GL_NV_read_depth_stencil

// GL_NV_read_stencil

// GL_NV_robustness_video_memory_purge

// GL_NV_shader_noperspective_interpolation

// GL_OES_EGL_image

// GL_OES_EGL_image_external

// GL_OES_EGL_image_external_essl3

// GL_OES_compressed_ETC1_RGB8_texture

// GL_OES_compressed_paletted_texture

// GL_OES_copy_image

// GL_OES_depth24

// GL_OES_depth32

// GL_OES_depth_texture

// GL_OES_draw_buffers_indexed

// GL_OES_draw_elements_base_vertex

// GL_OES_draw_texture

// GL_OES_element_index_uint

// GL_OES_fbo_render_mipmap

// GL_OES_framebuffer_object

// GL_OES_geometry_shader

// GL_OES_get_program_binary

// GL_OES_mapbuffer

// GL_OES_matrix_palette

// GL_OES_packed_depth_stencil

// GL_OES_point_size_array

// GL_OES_point_sprite

// GL_OES_primitive_bounding_box

// GL_OES_query_matrix

// GL_OES_rgb8_rgba8

// GL_OES_sample_shading

// GL_OES_sample_variables

// GL_OES_shader_image_atomic

// GL_OES_shader_io_blocks

// GL_OES_shader_multisample_interpolation

// GL_OES_standard_derivatives

// GL_OES_surfaceless_context

// GL_OES_texture_3D

// GL_OES_texture_border_clamp

// GL_OES_texture_buffer

// GL_OES_texture_compression_astc

// GL_OES_texture_cube_map

// GL_OES_texture_cube_map_array

// GL_OES_texture_float

// GL_OES_texture_float_linear

// GL_OES_texture_half_float

// GL_OES_texture_half_float_linear

// GL_OES_texture_npot

// GL_OES_texture_stencil8

// GL_OES_texture_storage_multisample_2d_array

// GL_OES_vertex_array_object

// GL_OES_vertex_half_float

// GL_OES_vertex_type_10_10_10_2

// GL_OVR_multiview

// GL_OVR_multiview2

// GL_QCOM_render_shared_exponent

// GL_QCOM_shading_rate
void ContextLocalShadingRate(Context *context, GLenum rate);
}  // namespace gl

#endif  // LIBANGLE_CONTEXT_LOCAL_CALL_gles_AUTOGEN_H_
