// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml and gl_angle_ext.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// capture_gles_2_0_autogen.cpp:
//   Capture functions for the OpenGL ES 2.0 entry points.

#include "libANGLE/capture_gles_2_0_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/FrameCapture.h"
#include "libANGLE/validationES2.h"

using namespace angle;

namespace gl
{

void CaptureActiveTexture(Context *context, GLenum texture)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateActiveTexture(context, texture);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("texture", ParamType::TGLenum, texture);

    frameCapture->captureCall(context, "glActiveTexture", std::move(paramBuffer), isCallValid);
}

void CaptureAttachShader(Context *context, GLuint program, GLuint shader)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateAttachShader(context, program, shader);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);

    frameCapture->captureCall(context, "glAttachShader", std::move(paramBuffer), isCallValid);
}

void CaptureBindAttribLocation(Context *context, GLuint program, GLuint index, const GLchar *name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBindAttribLocation(context, program, index, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    ParamCapture nameParam("name", ParamType::TGLcharConstPointer);
    InitParamValue(ParamType::TGLcharConstPointer, name, &nameParam.value);
    CaptureBindAttribLocation_name(context, program, index, name, isCallValid, &nameParam);
    paramBuffer.addParam(std::move(nameParam));

    frameCapture->captureCall(context, "glBindAttribLocation", std::move(paramBuffer), isCallValid);
}

void CaptureBindBuffer(Context *context, BufferBinding targetPacked, GLuint buffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBindBuffer(context, targetPacked, buffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TBufferBinding, targetPacked);
    paramBuffer.addValueParam("buffer", ParamType::TGLuint, buffer);

    frameCapture->captureCall(context, "glBindBuffer", std::move(paramBuffer), isCallValid);
}

void CaptureBindFramebuffer(Context *context, GLenum target, GLuint framebuffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBindFramebuffer(context, target, framebuffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("framebuffer", ParamType::TGLuint, framebuffer);

    frameCapture->captureCall(context, "glBindFramebuffer", std::move(paramBuffer), isCallValid);
}

void CaptureBindRenderbuffer(Context *context, GLenum target, GLuint renderbuffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBindRenderbuffer(context, target, renderbuffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("renderbuffer", ParamType::TGLuint, renderbuffer);

    frameCapture->captureCall(context, "glBindRenderbuffer", std::move(paramBuffer), isCallValid);
}

void CaptureBindTexture(Context *context, TextureType targetPacked, GLuint texture)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBindTexture(context, targetPacked, texture);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("texture", ParamType::TGLuint, texture);

    frameCapture->captureCall(context, "glBindTexture", std::move(paramBuffer), isCallValid);
}

void CaptureBlendColor(Context *context, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBlendColor(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLfloat, red);
    paramBuffer.addValueParam("green", ParamType::TGLfloat, green);
    paramBuffer.addValueParam("blue", ParamType::TGLfloat, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLfloat, alpha);

    frameCapture->captureCall(context, "glBlendColor", std::move(paramBuffer), isCallValid);
}

void CaptureBlendEquation(Context *context, GLenum mode)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBlendEquation(context, mode);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("mode", ParamType::TGLenum, mode);

    frameCapture->captureCall(context, "glBlendEquation", std::move(paramBuffer), isCallValid);
}

void CaptureBlendEquationSeparate(Context *context, GLenum modeRGB, GLenum modeAlpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBlendEquationSeparate(context, modeRGB, modeAlpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modeRGB", ParamType::TGLenum, modeRGB);
    paramBuffer.addValueParam("modeAlpha", ParamType::TGLenum, modeAlpha);

    frameCapture->captureCall(context, "glBlendEquationSeparate", std::move(paramBuffer),
                              isCallValid);
}

void CaptureBlendFunc(Context *context, GLenum sfactor, GLenum dfactor)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBlendFunc(context, sfactor, dfactor);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("sfactor", ParamType::TGLenum, sfactor);
    paramBuffer.addValueParam("dfactor", ParamType::TGLenum, dfactor);

    frameCapture->captureCall(context, "glBlendFunc", std::move(paramBuffer), isCallValid);
}

void CaptureBlendFuncSeparate(Context *context,
                              GLenum sfactorRGB,
                              GLenum dfactorRGB,
                              GLenum sfactorAlpha,
                              GLenum dfactorAlpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateBlendFuncSeparate(context, sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("sfactorRGB", ParamType::TGLenum, sfactorRGB);
    paramBuffer.addValueParam("dfactorRGB", ParamType::TGLenum, dfactorRGB);
    paramBuffer.addValueParam("sfactorAlpha", ParamType::TGLenum, sfactorAlpha);
    paramBuffer.addValueParam("dfactorAlpha", ParamType::TGLenum, dfactorAlpha);

    frameCapture->captureCall(context, "glBlendFuncSeparate", std::move(paramBuffer), isCallValid);
}

void CaptureBufferData(Context *context,
                       BufferBinding targetPacked,
                       GLsizeiptr size,
                       const void *data,
                       BufferUsage usagePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBufferData(context, targetPacked, size, data, usagePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TBufferBinding, targetPacked);
    paramBuffer.addValueParam("size", ParamType::TGLsizeiptr, size);

    ParamCapture dataParam("data", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, data, &dataParam.value);
    CaptureBufferData_data(context, targetPacked, size, data, usagePacked, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    paramBuffer.addValueParam("usagePacked", ParamType::TBufferUsage, usagePacked);

    frameCapture->captureCall(context, "glBufferData", std::move(paramBuffer), isCallValid);
}

void CaptureBufferSubData(Context *context,
                          BufferBinding targetPacked,
                          GLintptr offset,
                          GLsizeiptr size,
                          const void *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateBufferSubData(context, targetPacked, offset, size, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TBufferBinding, targetPacked);
    paramBuffer.addValueParam("offset", ParamType::TGLintptr, offset);
    paramBuffer.addValueParam("size", ParamType::TGLsizeiptr, size);

    ParamCapture dataParam("data", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, data, &dataParam.value);
    CaptureBufferSubData_data(context, targetPacked, offset, size, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glBufferSubData", std::move(paramBuffer), isCallValid);
}

void CaptureCheckFramebufferStatus(Context *context, GLenum target)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCheckFramebufferStatus(context, target);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);

    frameCapture->captureCall(context, "glCheckFramebufferStatus", std::move(paramBuffer),
                              isCallValid);
}

void CaptureClear(Context *context, GLbitfield mask)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClear(context, mask);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("mask", ParamType::TGLbitfield, mask);

    frameCapture->captureCall(context, "glClear", std::move(paramBuffer), isCallValid);
}

void CaptureClearColor(Context *context, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClearColor(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLfloat, red);
    paramBuffer.addValueParam("green", ParamType::TGLfloat, green);
    paramBuffer.addValueParam("blue", ParamType::TGLfloat, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLfloat, alpha);

    frameCapture->captureCall(context, "glClearColor", std::move(paramBuffer), isCallValid);
}

void CaptureClearDepthf(Context *context, GLfloat d)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClearDepthf(context, d);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("d", ParamType::TGLfloat, d);

    frameCapture->captureCall(context, "glClearDepthf", std::move(paramBuffer), isCallValid);
}

void CaptureClearStencil(Context *context, GLint s)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClearStencil(context, s);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("s", ParamType::TGLint, s);

    frameCapture->captureCall(context, "glClearStencil", std::move(paramBuffer), isCallValid);
}

void CaptureColorMask(Context *context,
                      GLboolean red,
                      GLboolean green,
                      GLboolean blue,
                      GLboolean alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateColorMask(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLboolean, red);
    paramBuffer.addValueParam("green", ParamType::TGLboolean, green);
    paramBuffer.addValueParam("blue", ParamType::TGLboolean, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLboolean, alpha);

    frameCapture->captureCall(context, "glColorMask", std::move(paramBuffer), isCallValid);
}

void CaptureCompileShader(Context *context, GLuint shader)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCompileShader(context, shader);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);

    frameCapture->captureCall(context, "glCompileShader", std::move(paramBuffer), isCallValid);
}

void CaptureCompressedTexImage2D(Context *context,
                                 TextureTarget targetPacked,
                                 GLint level,
                                 GLenum internalformat,
                                 GLsizei width,
                                 GLsizei height,
                                 GLint border,
                                 GLsizei imageSize,
                                 const void *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCompressedTexImage2D(context, targetPacked, level, internalformat,
                                                    width, height, border, imageSize, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("internalformat", ParamType::TGLenum, internalformat);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("border", ParamType::TGLint, border);
    paramBuffer.addValueParam("imageSize", ParamType::TGLsizei, imageSize);

    ParamCapture dataParam("data", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, data, &dataParam.value);
    CaptureCompressedTexImage2D_data(context, targetPacked, level, internalformat, width, height,
                                     border, imageSize, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glCompressedTexImage2D", std::move(paramBuffer),
                              isCallValid);
}

void CaptureCompressedTexSubImage2D(Context *context,
                                    TextureTarget targetPacked,
                                    GLint level,
                                    GLint xoffset,
                                    GLint yoffset,
                                    GLsizei width,
                                    GLsizei height,
                                    GLenum format,
                                    GLsizei imageSize,
                                    const void *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCompressedTexSubImage2D(
        context, targetPacked, level, xoffset, yoffset, width, height, format, imageSize, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("xoffset", ParamType::TGLint, xoffset);
    paramBuffer.addValueParam("yoffset", ParamType::TGLint, yoffset);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("format", ParamType::TGLenum, format);
    paramBuffer.addValueParam("imageSize", ParamType::TGLsizei, imageSize);

    ParamCapture dataParam("data", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, data, &dataParam.value);
    CaptureCompressedTexSubImage2D_data(context, targetPacked, level, xoffset, yoffset, width,
                                        height, format, imageSize, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glCompressedTexSubImage2D", std::move(paramBuffer),
                              isCallValid);
}

void CaptureCopyTexImage2D(Context *context,
                           TextureTarget targetPacked,
                           GLint level,
                           GLenum internalformat,
                           GLint x,
                           GLint y,
                           GLsizei width,
                           GLsizei height,
                           GLint border)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCopyTexImage2D(context, targetPacked, level, internalformat, x, y,
                                              width, height, border);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("internalformat", ParamType::TGLenum, internalformat);
    paramBuffer.addValueParam("x", ParamType::TGLint, x);
    paramBuffer.addValueParam("y", ParamType::TGLint, y);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("border", ParamType::TGLint, border);

    frameCapture->captureCall(context, "glCopyTexImage2D", std::move(paramBuffer), isCallValid);
}

void CaptureCopyTexSubImage2D(Context *context,
                              TextureTarget targetPacked,
                              GLint level,
                              GLint xoffset,
                              GLint yoffset,
                              GLint x,
                              GLint y,
                              GLsizei width,
                              GLsizei height)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCopyTexSubImage2D(context, targetPacked, level, xoffset, yoffset, x,
                                                 y, width, height);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("xoffset", ParamType::TGLint, xoffset);
    paramBuffer.addValueParam("yoffset", ParamType::TGLint, yoffset);
    paramBuffer.addValueParam("x", ParamType::TGLint, x);
    paramBuffer.addValueParam("y", ParamType::TGLint, y);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);

    frameCapture->captureCall(context, "glCopyTexSubImage2D", std::move(paramBuffer), isCallValid);
}

void CaptureCreateProgram(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCreateProgram(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glCreateProgram", std::move(paramBuffer), isCallValid);
}

void CaptureCreateShader(Context *context, ShaderType typePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCreateShader(context, typePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("typePacked", ParamType::TShaderType, typePacked);

    frameCapture->captureCall(context, "glCreateShader", std::move(paramBuffer), isCallValid);
}

void CaptureCullFace(Context *context, CullFaceMode modePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateCullFace(context, modePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modePacked", ParamType::TCullFaceMode, modePacked);

    frameCapture->captureCall(context, "glCullFace", std::move(paramBuffer), isCallValid);
}

void CaptureDeleteBuffers(Context *context, GLsizei n, const GLuint *buffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteBuffers(context, n, buffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture buffersParam("buffers", ParamType::TGLuintConstPointer);
    InitParamValue(ParamType::TGLuintConstPointer, buffers, &buffersParam.value);
    CaptureDeleteBuffers_buffers(context, n, buffers, isCallValid, &buffersParam);
    paramBuffer.addParam(std::move(buffersParam));

    frameCapture->captureCall(context, "glDeleteBuffers", std::move(paramBuffer), isCallValid);
}

void CaptureDeleteFramebuffers(Context *context, GLsizei n, const GLuint *framebuffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteFramebuffers(context, n, framebuffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture framebuffersParam("framebuffers", ParamType::TGLuintConstPointer);
    InitParamValue(ParamType::TGLuintConstPointer, framebuffers, &framebuffersParam.value);
    CaptureDeleteFramebuffers_framebuffers(context, n, framebuffers, isCallValid,
                                           &framebuffersParam);
    paramBuffer.addParam(std::move(framebuffersParam));

    frameCapture->captureCall(context, "glDeleteFramebuffers", std::move(paramBuffer), isCallValid);
}

void CaptureDeleteProgram(Context *context, GLuint program)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteProgram(context, program);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    frameCapture->captureCall(context, "glDeleteProgram", std::move(paramBuffer), isCallValid);
}

void CaptureDeleteRenderbuffers(Context *context, GLsizei n, const GLuint *renderbuffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteRenderbuffers(context, n, renderbuffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture renderbuffersParam("renderbuffers", ParamType::TGLuintConstPointer);
    InitParamValue(ParamType::TGLuintConstPointer, renderbuffers, &renderbuffersParam.value);
    CaptureDeleteRenderbuffers_renderbuffers(context, n, renderbuffers, isCallValid,
                                             &renderbuffersParam);
    paramBuffer.addParam(std::move(renderbuffersParam));

    frameCapture->captureCall(context, "glDeleteRenderbuffers", std::move(paramBuffer),
                              isCallValid);
}

void CaptureDeleteShader(Context *context, GLuint shader)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteShader(context, shader);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);

    frameCapture->captureCall(context, "glDeleteShader", std::move(paramBuffer), isCallValid);
}

void CaptureDeleteTextures(Context *context, GLsizei n, const GLuint *textures)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDeleteTextures(context, n, textures);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture texturesParam("textures", ParamType::TGLuintConstPointer);
    InitParamValue(ParamType::TGLuintConstPointer, textures, &texturesParam.value);
    CaptureDeleteTextures_textures(context, n, textures, isCallValid, &texturesParam);
    paramBuffer.addParam(std::move(texturesParam));

    frameCapture->captureCall(context, "glDeleteTextures", std::move(paramBuffer), isCallValid);
}

void CaptureDepthFunc(Context *context, GLenum func)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDepthFunc(context, func);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("func", ParamType::TGLenum, func);

    frameCapture->captureCall(context, "glDepthFunc", std::move(paramBuffer), isCallValid);
}

void CaptureDepthMask(Context *context, GLboolean flag)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDepthMask(context, flag);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("flag", ParamType::TGLboolean, flag);

    frameCapture->captureCall(context, "glDepthMask", std::move(paramBuffer), isCallValid);
}

void CaptureDepthRangef(Context *context, GLfloat n, GLfloat f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDepthRangef(context, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLfloat, n);
    paramBuffer.addValueParam("f", ParamType::TGLfloat, f);

    frameCapture->captureCall(context, "glDepthRangef", std::move(paramBuffer), isCallValid);
}

void CaptureDetachShader(Context *context, GLuint program, GLuint shader)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDetachShader(context, program, shader);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);

    frameCapture->captureCall(context, "glDetachShader", std::move(paramBuffer), isCallValid);
}

void CaptureDisable(Context *context, GLenum cap)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDisable(context, cap);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("cap", ParamType::TGLenum, cap);

    frameCapture->captureCall(context, "glDisable", std::move(paramBuffer), isCallValid);
}

void CaptureDisableVertexAttribArray(Context *context, GLuint index)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDisableVertexAttribArray(context, index);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    frameCapture->captureCall(context, "glDisableVertexAttribArray", std::move(paramBuffer),
                              isCallValid);
}

void CaptureDrawArrays(Context *context, PrimitiveMode modePacked, GLint first, GLsizei count)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDrawArrays(context, modePacked, first, count);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modePacked", ParamType::TPrimitiveMode, modePacked);
    paramBuffer.addValueParam("first", ParamType::TGLint, first);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    frameCapture->captureCall(context, "glDrawArrays", std::move(paramBuffer), isCallValid);
}

void CaptureDrawElements(Context *context,
                         PrimitiveMode modePacked,
                         GLsizei count,
                         DrawElementsType typePacked,
                         const void *indices)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDrawElements(context, modePacked, count, typePacked, indices);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modePacked", ParamType::TPrimitiveMode, modePacked);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);
    paramBuffer.addValueParam("typePacked", ParamType::TDrawElementsType, typePacked);

    ParamCapture indicesParam("indices", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, indices, &indicesParam.value);
    CaptureDrawElements_indices(context, modePacked, count, typePacked, indices, isCallValid,
                                &indicesParam);
    paramBuffer.addParam(std::move(indicesParam));

    frameCapture->captureCall(context, "glDrawElements", std::move(paramBuffer), isCallValid);
}

void CaptureEnable(Context *context, GLenum cap)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateEnable(context, cap);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("cap", ParamType::TGLenum, cap);

    frameCapture->captureCall(context, "glEnable", std::move(paramBuffer), isCallValid);
}

void CaptureEnableVertexAttribArray(Context *context, GLuint index)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateEnableVertexAttribArray(context, index);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    frameCapture->captureCall(context, "glEnableVertexAttribArray", std::move(paramBuffer),
                              isCallValid);
}

void CaptureFinish(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFinish(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glFinish", std::move(paramBuffer), isCallValid);
}

void CaptureFlush(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFlush(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glFlush", std::move(paramBuffer), isCallValid);
}

void CaptureFramebufferRenderbuffer(Context *context,
                                    GLenum target,
                                    GLenum attachment,
                                    GLenum renderbuffertarget,
                                    GLuint renderbuffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFramebufferRenderbuffer(context, target, attachment,
                                                       renderbuffertarget, renderbuffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("attachment", ParamType::TGLenum, attachment);
    paramBuffer.addValueParam("renderbuffertarget", ParamType::TGLenum, renderbuffertarget);
    paramBuffer.addValueParam("renderbuffer", ParamType::TGLuint, renderbuffer);

    frameCapture->captureCall(context, "glFramebufferRenderbuffer", std::move(paramBuffer),
                              isCallValid);
}

void CaptureFramebufferTexture2D(Context *context,
                                 GLenum target,
                                 GLenum attachment,
                                 TextureTarget textargetPacked,
                                 GLuint texture,
                                 GLint level)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateFramebufferTexture2D(context, target, attachment, textargetPacked, texture, level);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("attachment", ParamType::TGLenum, attachment);
    paramBuffer.addValueParam("textargetPacked", ParamType::TTextureTarget, textargetPacked);
    paramBuffer.addValueParam("texture", ParamType::TGLuint, texture);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);

    frameCapture->captureCall(context, "glFramebufferTexture2D", std::move(paramBuffer),
                              isCallValid);
}

void CaptureFrontFace(Context *context, GLenum mode)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFrontFace(context, mode);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("mode", ParamType::TGLenum, mode);

    frameCapture->captureCall(context, "glFrontFace", std::move(paramBuffer), isCallValid);
}

void CaptureGenBuffers(Context *context, GLsizei n, GLuint *buffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGenBuffers(context, n, buffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture buffersParam("buffers", ParamType::TGLuintPointer);
    InitParamValue(ParamType::TGLuintPointer, buffers, &buffersParam.value);
    CaptureGenBuffers_buffers(context, n, buffers, isCallValid, &buffersParam);
    paramBuffer.addParam(std::move(buffersParam));

    frameCapture->captureCall(context, "glGenBuffers", std::move(paramBuffer), isCallValid);
}

void CaptureGenFramebuffers(Context *context, GLsizei n, GLuint *framebuffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGenFramebuffers(context, n, framebuffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture framebuffersParam("framebuffers", ParamType::TGLuintPointer);
    InitParamValue(ParamType::TGLuintPointer, framebuffers, &framebuffersParam.value);
    CaptureGenFramebuffers_framebuffers(context, n, framebuffers, isCallValid, &framebuffersParam);
    paramBuffer.addParam(std::move(framebuffersParam));

    frameCapture->captureCall(context, "glGenFramebuffers", std::move(paramBuffer), isCallValid);
}

void CaptureGenRenderbuffers(Context *context, GLsizei n, GLuint *renderbuffers)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGenRenderbuffers(context, n, renderbuffers);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture renderbuffersParam("renderbuffers", ParamType::TGLuintPointer);
    InitParamValue(ParamType::TGLuintPointer, renderbuffers, &renderbuffersParam.value);
    CaptureGenRenderbuffers_renderbuffers(context, n, renderbuffers, isCallValid,
                                          &renderbuffersParam);
    paramBuffer.addParam(std::move(renderbuffersParam));

    frameCapture->captureCall(context, "glGenRenderbuffers", std::move(paramBuffer), isCallValid);
}

void CaptureGenTextures(Context *context, GLsizei n, GLuint *textures)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGenTextures(context, n, textures);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLsizei, n);

    ParamCapture texturesParam("textures", ParamType::TGLuintPointer);
    InitParamValue(ParamType::TGLuintPointer, textures, &texturesParam.value);
    CaptureGenTextures_textures(context, n, textures, isCallValid, &texturesParam);
    paramBuffer.addParam(std::move(texturesParam));

    frameCapture->captureCall(context, "glGenTextures", std::move(paramBuffer), isCallValid);
}

void CaptureGenerateMipmap(Context *context, TextureType targetPacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGenerateMipmap(context, targetPacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);

    frameCapture->captureCall(context, "glGenerateMipmap", std::move(paramBuffer), isCallValid);
}

void CaptureGetActiveAttrib(Context *context,
                            GLuint program,
                            GLuint index,
                            GLsizei bufSize,
                            GLsizei *length,
                            GLint *size,
                            GLenum *type,
                            GLchar *name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateGetActiveAttrib(context, program, index, bufSize, length, size, type, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("bufSize", ParamType::TGLsizei, bufSize);

    ParamCapture lengthParam("length", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, length, &lengthParam.value);
    CaptureGetActiveAttrib_length(context, program, index, bufSize, length, size, type, name,
                                  isCallValid, &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    ParamCapture sizeParam("size", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, size, &sizeParam.value);
    CaptureGetActiveAttrib_size(context, program, index, bufSize, length, size, type, name,
                                isCallValid, &sizeParam);
    paramBuffer.addParam(std::move(sizeParam));

    ParamCapture typeParam("type", ParamType::TGLenumPointer);
    InitParamValue(ParamType::TGLenumPointer, type, &typeParam.value);
    CaptureGetActiveAttrib_type(context, program, index, bufSize, length, size, type, name,
                                isCallValid, &typeParam);
    paramBuffer.addParam(std::move(typeParam));

    ParamCapture nameParam("name", ParamType::TGLcharPointer);
    InitParamValue(ParamType::TGLcharPointer, name, &nameParam.value);
    CaptureGetActiveAttrib_name(context, program, index, bufSize, length, size, type, name,
                                isCallValid, &nameParam);
    paramBuffer.addParam(std::move(nameParam));

    frameCapture->captureCall(context, "glGetActiveAttrib", std::move(paramBuffer), isCallValid);
}

void CaptureGetActiveUniform(Context *context,
                             GLuint program,
                             GLuint index,
                             GLsizei bufSize,
                             GLsizei *length,
                             GLint *size,
                             GLenum *type,
                             GLchar *name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateGetActiveUniform(context, program, index, bufSize, length, size, type, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("bufSize", ParamType::TGLsizei, bufSize);

    ParamCapture lengthParam("length", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, length, &lengthParam.value);
    CaptureGetActiveUniform_length(context, program, index, bufSize, length, size, type, name,
                                   isCallValid, &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    ParamCapture sizeParam("size", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, size, &sizeParam.value);
    CaptureGetActiveUniform_size(context, program, index, bufSize, length, size, type, name,
                                 isCallValid, &sizeParam);
    paramBuffer.addParam(std::move(sizeParam));

    ParamCapture typeParam("type", ParamType::TGLenumPointer);
    InitParamValue(ParamType::TGLenumPointer, type, &typeParam.value);
    CaptureGetActiveUniform_type(context, program, index, bufSize, length, size, type, name,
                                 isCallValid, &typeParam);
    paramBuffer.addParam(std::move(typeParam));

    ParamCapture nameParam("name", ParamType::TGLcharPointer);
    InitParamValue(ParamType::TGLcharPointer, name, &nameParam.value);
    CaptureGetActiveUniform_name(context, program, index, bufSize, length, size, type, name,
                                 isCallValid, &nameParam);
    paramBuffer.addParam(std::move(nameParam));

    frameCapture->captureCall(context, "glGetActiveUniform", std::move(paramBuffer), isCallValid);
}

void CaptureGetAttachedShaders(Context *context,
                               GLuint program,
                               GLsizei maxCount,
                               GLsizei *count,
                               GLuint *shaders)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetAttachedShaders(context, program, maxCount, count, shaders);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("maxCount", ParamType::TGLsizei, maxCount);

    ParamCapture countParam("count", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, count, &countParam.value);
    CaptureGetAttachedShaders_count(context, program, maxCount, count, shaders, isCallValid,
                                    &countParam);
    paramBuffer.addParam(std::move(countParam));

    ParamCapture shadersParam("shaders", ParamType::TGLuintPointer);
    InitParamValue(ParamType::TGLuintPointer, shaders, &shadersParam.value);
    CaptureGetAttachedShaders_shaders(context, program, maxCount, count, shaders, isCallValid,
                                      &shadersParam);
    paramBuffer.addParam(std::move(shadersParam));

    frameCapture->captureCall(context, "glGetAttachedShaders", std::move(paramBuffer), isCallValid);
}

void CaptureGetAttribLocation(Context *context, GLuint program, const GLchar *name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetAttribLocation(context, program, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    ParamCapture nameParam("name", ParamType::TGLcharConstPointer);
    InitParamValue(ParamType::TGLcharConstPointer, name, &nameParam.value);
    CaptureGetAttribLocation_name(context, program, name, isCallValid, &nameParam);
    paramBuffer.addParam(std::move(nameParam));

    frameCapture->captureCall(context, "glGetAttribLocation", std::move(paramBuffer), isCallValid);
}

void CaptureGetBooleanv(Context *context, GLenum pname, GLboolean *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetBooleanv(context, pname, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture dataParam("data", ParamType::TGLbooleanPointer);
    InitParamValue(ParamType::TGLbooleanPointer, data, &dataParam.value);
    CaptureGetBooleanv_data(context, pname, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glGetBooleanv", std::move(paramBuffer), isCallValid);
}

void CaptureGetBufferParameteriv(Context *context,
                                 BufferBinding targetPacked,
                                 GLenum pname,
                                 GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetBufferParameteriv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TBufferBinding, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetBufferParameteriv_params(context, targetPacked, pname, params, isCallValid,
                                       &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetBufferParameteriv", std::move(paramBuffer),
                              isCallValid);
}

void CaptureGetError(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetError(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glGetError", std::move(paramBuffer), isCallValid);
}

void CaptureGetFloatv(Context *context, GLenum pname, GLfloat *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetFloatv(context, pname, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture dataParam("data", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, data, &dataParam.value);
    CaptureGetFloatv_data(context, pname, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glGetFloatv", std::move(paramBuffer), isCallValid);
}

void CaptureGetFramebufferAttachmentParameteriv(Context *context,
                                                GLenum target,
                                                GLenum attachment,
                                                GLenum pname,
                                                GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateGetFramebufferAttachmentParameteriv(context, target, attachment, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("attachment", ParamType::TGLenum, attachment);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetFramebufferAttachmentParameteriv_params(context, target, attachment, pname, params,
                                                      isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetFramebufferAttachmentParameteriv",
                              std::move(paramBuffer), isCallValid);
}

void CaptureGetIntegerv(Context *context, GLenum pname, GLint *data)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetIntegerv(context, pname, data);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture dataParam("data", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, data, &dataParam.value);
    CaptureGetIntegerv_data(context, pname, data, isCallValid, &dataParam);
    paramBuffer.addParam(std::move(dataParam));

    frameCapture->captureCall(context, "glGetIntegerv", std::move(paramBuffer), isCallValid);
}

void CaptureGetProgramInfoLog(Context *context,
                              GLuint program,
                              GLsizei bufSize,
                              GLsizei *length,
                              GLchar *infoLog)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetProgramInfoLog(context, program, bufSize, length, infoLog);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("bufSize", ParamType::TGLsizei, bufSize);

    ParamCapture lengthParam("length", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, length, &lengthParam.value);
    CaptureGetProgramInfoLog_length(context, program, bufSize, length, infoLog, isCallValid,
                                    &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    ParamCapture infoLogParam("infoLog", ParamType::TGLcharPointer);
    InitParamValue(ParamType::TGLcharPointer, infoLog, &infoLogParam.value);
    CaptureGetProgramInfoLog_infoLog(context, program, bufSize, length, infoLog, isCallValid,
                                     &infoLogParam);
    paramBuffer.addParam(std::move(infoLogParam));

    frameCapture->captureCall(context, "glGetProgramInfoLog", std::move(paramBuffer), isCallValid);
}

void CaptureGetProgramiv(Context *context, GLuint program, GLenum pname, GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetProgramiv(context, program, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetProgramiv_params(context, program, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetProgramiv", std::move(paramBuffer), isCallValid);
}

void CaptureGetRenderbufferParameteriv(Context *context, GLenum target, GLenum pname, GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetRenderbufferParameteriv(context, target, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetRenderbufferParameteriv_params(context, target, pname, params, isCallValid,
                                             &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetRenderbufferParameteriv", std::move(paramBuffer),
                              isCallValid);
}

void CaptureGetShaderInfoLog(Context *context,
                             GLuint shader,
                             GLsizei bufSize,
                             GLsizei *length,
                             GLchar *infoLog)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetShaderInfoLog(context, shader, bufSize, length, infoLog);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);
    paramBuffer.addValueParam("bufSize", ParamType::TGLsizei, bufSize);

    ParamCapture lengthParam("length", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, length, &lengthParam.value);
    CaptureGetShaderInfoLog_length(context, shader, bufSize, length, infoLog, isCallValid,
                                   &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    ParamCapture infoLogParam("infoLog", ParamType::TGLcharPointer);
    InitParamValue(ParamType::TGLcharPointer, infoLog, &infoLogParam.value);
    CaptureGetShaderInfoLog_infoLog(context, shader, bufSize, length, infoLog, isCallValid,
                                    &infoLogParam);
    paramBuffer.addParam(std::move(infoLogParam));

    frameCapture->captureCall(context, "glGetShaderInfoLog", std::move(paramBuffer), isCallValid);
}

void CaptureGetShaderPrecisionFormat(Context *context,
                                     GLenum shadertype,
                                     GLenum precisiontype,
                                     GLint *range,
                                     GLint *precision)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateGetShaderPrecisionFormat(context, shadertype, precisiontype, range, precision);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shadertype", ParamType::TGLenum, shadertype);
    paramBuffer.addValueParam("precisiontype", ParamType::TGLenum, precisiontype);

    ParamCapture rangeParam("range", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, range, &rangeParam.value);
    CaptureGetShaderPrecisionFormat_range(context, shadertype, precisiontype, range, precision,
                                          isCallValid, &rangeParam);
    paramBuffer.addParam(std::move(rangeParam));

    ParamCapture precisionParam("precision", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, precision, &precisionParam.value);
    CaptureGetShaderPrecisionFormat_precision(context, shadertype, precisiontype, range, precision,
                                              isCallValid, &precisionParam);
    paramBuffer.addParam(std::move(precisionParam));

    frameCapture->captureCall(context, "glGetShaderPrecisionFormat", std::move(paramBuffer),
                              isCallValid);
}

void CaptureGetShaderSource(Context *context,
                            GLuint shader,
                            GLsizei bufSize,
                            GLsizei *length,
                            GLchar *source)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetShaderSource(context, shader, bufSize, length, source);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);
    paramBuffer.addValueParam("bufSize", ParamType::TGLsizei, bufSize);

    ParamCapture lengthParam("length", ParamType::TGLsizeiPointer);
    InitParamValue(ParamType::TGLsizeiPointer, length, &lengthParam.value);
    CaptureGetShaderSource_length(context, shader, bufSize, length, source, isCallValid,
                                  &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    ParamCapture sourceParam("source", ParamType::TGLcharPointer);
    InitParamValue(ParamType::TGLcharPointer, source, &sourceParam.value);
    CaptureGetShaderSource_source(context, shader, bufSize, length, source, isCallValid,
                                  &sourceParam);
    paramBuffer.addParam(std::move(sourceParam));

    frameCapture->captureCall(context, "glGetShaderSource", std::move(paramBuffer), isCallValid);
}

void CaptureGetShaderiv(Context *context, GLuint shader, GLenum pname, GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetShaderiv(context, shader, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetShaderiv_params(context, shader, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetShaderiv", std::move(paramBuffer), isCallValid);
}

void CaptureGetString(Context *context, GLenum name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetString(context, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("name", ParamType::TGLenum, name);

    frameCapture->captureCall(context, "glGetString", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexParameterfv(Context *context,
                              TextureType targetPacked,
                              GLenum pname,
                              GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexParameterfv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetTexParameterfv_params(context, targetPacked, pname, params, isCallValid,
                                    &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexParameterfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexParameteriv(Context *context,
                              TextureType targetPacked,
                              GLenum pname,
                              GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexParameteriv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetTexParameteriv_params(context, targetPacked, pname, params, isCallValid,
                                    &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexParameteriv", std::move(paramBuffer), isCallValid);
}

void CaptureGetUniformLocation(Context *context, GLuint program, const GLchar *name)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetUniformLocation(context, program, name);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    ParamCapture nameParam("name", ParamType::TGLcharConstPointer);
    InitParamValue(ParamType::TGLcharConstPointer, name, &nameParam.value);
    CaptureGetUniformLocation_name(context, program, name, isCallValid, &nameParam);
    paramBuffer.addParam(std::move(nameParam));

    frameCapture->captureCall(context, "glGetUniformLocation", std::move(paramBuffer), isCallValid);
}

void CaptureGetUniformfv(Context *context, GLuint program, GLint location, GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetUniformfv(context, program, location, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("location", ParamType::TGLint, location);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetUniformfv_params(context, program, location, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetUniformfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetUniformiv(Context *context, GLuint program, GLint location, GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetUniformiv(context, program, location, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);
    paramBuffer.addValueParam("location", ParamType::TGLint, location);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetUniformiv_params(context, program, location, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetUniformiv", std::move(paramBuffer), isCallValid);
}

void CaptureGetVertexAttribPointerv(Context *context, GLuint index, GLenum pname, void **pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetVertexAttribPointerv(context, index, pname, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture pointerParam("pointer", ParamType::TvoidPointerPointer);
    InitParamValue(ParamType::TvoidPointerPointer, pointer, &pointerParam.value);
    CaptureGetVertexAttribPointerv_pointer(context, index, pname, pointer, isCallValid,
                                           &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glGetVertexAttribPointerv", std::move(paramBuffer),
                              isCallValid);
}

void CaptureGetVertexAttribfv(Context *context, GLuint index, GLenum pname, GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetVertexAttribfv(context, index, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetVertexAttribfv_params(context, index, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetVertexAttribfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetVertexAttribiv(Context *context, GLuint index, GLenum pname, GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetVertexAttribiv(context, index, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetVertexAttribiv_params(context, index, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetVertexAttribiv", std::move(paramBuffer), isCallValid);
}

void CaptureHint(Context *context, GLenum target, GLenum mode)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateHint(context, target, mode);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("mode", ParamType::TGLenum, mode);

    frameCapture->captureCall(context, "glHint", std::move(paramBuffer), isCallValid);
}

void CaptureIsBuffer(Context *context, GLuint buffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsBuffer(context, buffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("buffer", ParamType::TGLuint, buffer);

    frameCapture->captureCall(context, "glIsBuffer", std::move(paramBuffer), isCallValid);
}

void CaptureIsEnabled(Context *context, GLenum cap)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsEnabled(context, cap);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("cap", ParamType::TGLenum, cap);

    frameCapture->captureCall(context, "glIsEnabled", std::move(paramBuffer), isCallValid);
}

void CaptureIsFramebuffer(Context *context, GLuint framebuffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsFramebuffer(context, framebuffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("framebuffer", ParamType::TGLuint, framebuffer);

    frameCapture->captureCall(context, "glIsFramebuffer", std::move(paramBuffer), isCallValid);
}

void CaptureIsProgram(Context *context, GLuint program)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsProgram(context, program);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    frameCapture->captureCall(context, "glIsProgram", std::move(paramBuffer), isCallValid);
}

void CaptureIsRenderbuffer(Context *context, GLuint renderbuffer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsRenderbuffer(context, renderbuffer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("renderbuffer", ParamType::TGLuint, renderbuffer);

    frameCapture->captureCall(context, "glIsRenderbuffer", std::move(paramBuffer), isCallValid);
}

void CaptureIsShader(Context *context, GLuint shader)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsShader(context, shader);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);

    frameCapture->captureCall(context, "glIsShader", std::move(paramBuffer), isCallValid);
}

void CaptureIsTexture(Context *context, GLuint texture)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateIsTexture(context, texture);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("texture", ParamType::TGLuint, texture);

    frameCapture->captureCall(context, "glIsTexture", std::move(paramBuffer), isCallValid);
}

void CaptureLineWidth(Context *context, GLfloat width)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLineWidth(context, width);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("width", ParamType::TGLfloat, width);

    frameCapture->captureCall(context, "glLineWidth", std::move(paramBuffer), isCallValid);
}

void CaptureLinkProgram(Context *context, GLuint program)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLinkProgram(context, program);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    frameCapture->captureCall(context, "glLinkProgram", std::move(paramBuffer), isCallValid);
}

void CapturePixelStorei(Context *context, GLenum pname, GLint param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePixelStorei(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLint, param);

    frameCapture->captureCall(context, "glPixelStorei", std::move(paramBuffer), isCallValid);
}

void CapturePolygonOffset(Context *context, GLfloat factor, GLfloat units)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePolygonOffset(context, factor, units);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("factor", ParamType::TGLfloat, factor);
    paramBuffer.addValueParam("units", ParamType::TGLfloat, units);

    frameCapture->captureCall(context, "glPolygonOffset", std::move(paramBuffer), isCallValid);
}

void CaptureReadPixels(Context *context,
                       GLint x,
                       GLint y,
                       GLsizei width,
                       GLsizei height,
                       GLenum format,
                       GLenum type,
                       void *pixels)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateReadPixels(context, x, y, width, height, format, type, pixels);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLint, x);
    paramBuffer.addValueParam("y", ParamType::TGLint, y);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("format", ParamType::TGLenum, format);
    paramBuffer.addValueParam("type", ParamType::TGLenum, type);

    ParamCapture pixelsParam("pixels", ParamType::TvoidPointer);
    InitParamValue(ParamType::TvoidPointer, pixels, &pixelsParam.value);
    CaptureReadPixels_pixels(context, x, y, width, height, format, type, pixels, isCallValid,
                             &pixelsParam);
    paramBuffer.addParam(std::move(pixelsParam));

    frameCapture->captureCall(context, "glReadPixels", std::move(paramBuffer), isCallValid);
}

void CaptureReleaseShaderCompiler(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateReleaseShaderCompiler(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glReleaseShaderCompiler", std::move(paramBuffer),
                              isCallValid);
}

void CaptureRenderbufferStorage(Context *context,
                                GLenum target,
                                GLenum internalformat,
                                GLsizei width,
                                GLsizei height)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateRenderbufferStorage(context, target, internalformat, width, height);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("internalformat", ParamType::TGLenum, internalformat);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);

    frameCapture->captureCall(context, "glRenderbufferStorage", std::move(paramBuffer),
                              isCallValid);
}

void CaptureSampleCoverage(Context *context, GLfloat value, GLboolean invert)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateSampleCoverage(context, value, invert);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("value", ParamType::TGLfloat, value);
    paramBuffer.addValueParam("invert", ParamType::TGLboolean, invert);

    frameCapture->captureCall(context, "glSampleCoverage", std::move(paramBuffer), isCallValid);
}

void CaptureScissor(Context *context, GLint x, GLint y, GLsizei width, GLsizei height)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateScissor(context, x, y, width, height);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLint, x);
    paramBuffer.addValueParam("y", ParamType::TGLint, y);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);

    frameCapture->captureCall(context, "glScissor", std::move(paramBuffer), isCallValid);
}

void CaptureShaderBinary(Context *context,
                         GLsizei count,
                         const GLuint *shaders,
                         GLenum binaryformat,
                         const void *binary,
                         GLsizei length)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateShaderBinary(context, count, shaders, binaryformat, binary, length);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture shadersParam("shaders", ParamType::TGLuintConstPointer);
    InitParamValue(ParamType::TGLuintConstPointer, shaders, &shadersParam.value);
    CaptureShaderBinary_shaders(context, count, shaders, binaryformat, binary, length, isCallValid,
                                &shadersParam);
    paramBuffer.addParam(std::move(shadersParam));

    paramBuffer.addValueParam("binaryformat", ParamType::TGLenum, binaryformat);

    ParamCapture binaryParam("binary", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, binary, &binaryParam.value);
    CaptureShaderBinary_binary(context, count, shaders, binaryformat, binary, length, isCallValid,
                               &binaryParam);
    paramBuffer.addParam(std::move(binaryParam));

    paramBuffer.addValueParam("length", ParamType::TGLsizei, length);

    frameCapture->captureCall(context, "glShaderBinary", std::move(paramBuffer), isCallValid);
}

void CaptureShaderSource(Context *context,
                         GLuint shader,
                         GLsizei count,
                         const GLchar *const *string,
                         const GLint *length)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateShaderSource(context, shader, count, string, length);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("shader", ParamType::TGLuint, shader);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture stringParam("string", ParamType::TGLcharConstPointerPointer);
    InitParamValue(ParamType::TGLcharConstPointerPointer, string, &stringParam.value);
    CaptureShaderSource_string(context, shader, count, string, length, isCallValid, &stringParam);
    paramBuffer.addParam(std::move(stringParam));

    ParamCapture lengthParam("length", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, length, &lengthParam.value);
    CaptureShaderSource_length(context, shader, count, string, length, isCallValid, &lengthParam);
    paramBuffer.addParam(std::move(lengthParam));

    frameCapture->captureCall(context, "glShaderSource", std::move(paramBuffer), isCallValid);
}

void CaptureStencilFunc(Context *context, GLenum func, GLint ref, GLuint mask)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilFunc(context, func, ref, mask);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("func", ParamType::TGLenum, func);
    paramBuffer.addValueParam("ref", ParamType::TGLint, ref);
    paramBuffer.addValueParam("mask", ParamType::TGLuint, mask);

    frameCapture->captureCall(context, "glStencilFunc", std::move(paramBuffer), isCallValid);
}

void CaptureStencilFuncSeparate(Context *context, GLenum face, GLenum func, GLint ref, GLuint mask)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilFuncSeparate(context, face, func, ref, mask);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("func", ParamType::TGLenum, func);
    paramBuffer.addValueParam("ref", ParamType::TGLint, ref);
    paramBuffer.addValueParam("mask", ParamType::TGLuint, mask);

    frameCapture->captureCall(context, "glStencilFuncSeparate", std::move(paramBuffer),
                              isCallValid);
}

void CaptureStencilMask(Context *context, GLuint mask)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilMask(context, mask);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("mask", ParamType::TGLuint, mask);

    frameCapture->captureCall(context, "glStencilMask", std::move(paramBuffer), isCallValid);
}

void CaptureStencilMaskSeparate(Context *context, GLenum face, GLuint mask)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilMaskSeparate(context, face, mask);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("mask", ParamType::TGLuint, mask);

    frameCapture->captureCall(context, "glStencilMaskSeparate", std::move(paramBuffer),
                              isCallValid);
}

void CaptureStencilOp(Context *context, GLenum fail, GLenum zfail, GLenum zpass)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilOp(context, fail, zfail, zpass);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("fail", ParamType::TGLenum, fail);
    paramBuffer.addValueParam("zfail", ParamType::TGLenum, zfail);
    paramBuffer.addValueParam("zpass", ParamType::TGLenum, zpass);

    frameCapture->captureCall(context, "glStencilOp", std::move(paramBuffer), isCallValid);
}

void CaptureStencilOpSeparate(Context *context,
                              GLenum face,
                              GLenum sfail,
                              GLenum dpfail,
                              GLenum dppass)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateStencilOpSeparate(context, face, sfail, dpfail, dppass);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("sfail", ParamType::TGLenum, sfail);
    paramBuffer.addValueParam("dpfail", ParamType::TGLenum, dpfail);
    paramBuffer.addValueParam("dppass", ParamType::TGLenum, dppass);

    frameCapture->captureCall(context, "glStencilOpSeparate", std::move(paramBuffer), isCallValid);
}

void CaptureTexImage2D(Context *context,
                       TextureTarget targetPacked,
                       GLint level,
                       GLint internalformat,
                       GLsizei width,
                       GLsizei height,
                       GLint border,
                       GLenum format,
                       GLenum type,
                       const void *pixels)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexImage2D(context, targetPacked, level, internalformat, width,
                                          height, border, format, type, pixels);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("internalformat", ParamType::TGLint, internalformat);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("border", ParamType::TGLint, border);
    paramBuffer.addValueParam("format", ParamType::TGLenum, format);
    paramBuffer.addValueParam("type", ParamType::TGLenum, type);

    ParamCapture pixelsParam("pixels", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pixels, &pixelsParam.value);
    CaptureTexImage2D_pixels(context, targetPacked, level, internalformat, width, height, border,
                             format, type, pixels, isCallValid, &pixelsParam);
    paramBuffer.addParam(std::move(pixelsParam));

    frameCapture->captureCall(context, "glTexImage2D", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameterf(Context *context, TextureType targetPacked, GLenum pname, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameterf(context, targetPacked, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glTexParameterf", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameterfv(Context *context,
                           TextureType targetPacked,
                           GLenum pname,
                           const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameterfv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureTexParameterfv_params(context, targetPacked, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexParameterfv", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameteri(Context *context, TextureType targetPacked, GLenum pname, GLint param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameteri(context, targetPacked, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLint, param);

    frameCapture->captureCall(context, "glTexParameteri", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameteriv(Context *context,
                           TextureType targetPacked,
                           GLenum pname,
                           const GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameteriv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, params, &paramsParam.value);
    CaptureTexParameteriv_params(context, targetPacked, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexParameteriv", std::move(paramBuffer), isCallValid);
}

void CaptureTexSubImage2D(Context *context,
                          TextureTarget targetPacked,
                          GLint level,
                          GLint xoffset,
                          GLint yoffset,
                          GLsizei width,
                          GLsizei height,
                          GLenum format,
                          GLenum type,
                          const void *pixels)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexSubImage2D(context, targetPacked, level, xoffset, yoffset, width,
                                             height, format, type, pixels);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureTarget, targetPacked);
    paramBuffer.addValueParam("level", ParamType::TGLint, level);
    paramBuffer.addValueParam("xoffset", ParamType::TGLint, xoffset);
    paramBuffer.addValueParam("yoffset", ParamType::TGLint, yoffset);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);
    paramBuffer.addValueParam("format", ParamType::TGLenum, format);
    paramBuffer.addValueParam("type", ParamType::TGLenum, type);

    ParamCapture pixelsParam("pixels", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pixels, &pixelsParam.value);
    CaptureTexSubImage2D_pixels(context, targetPacked, level, xoffset, yoffset, width, height,
                                format, type, pixels, isCallValid, &pixelsParam);
    paramBuffer.addParam(std::move(pixelsParam));

    frameCapture->captureCall(context, "glTexSubImage2D", std::move(paramBuffer), isCallValid);
}

void CaptureUniform1f(Context *context, GLint location, GLfloat v0)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform1f(context, location, v0);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLfloat, v0);

    frameCapture->captureCall(context, "glUniform1f", std::move(paramBuffer), isCallValid);
}

void CaptureUniform1fv(Context *context, GLint location, GLsizei count, const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform1fv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniform1fv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform1fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform1i(Context *context, GLint location, GLint v0)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform1i(context, location, v0);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLint, v0);

    frameCapture->captureCall(context, "glUniform1i", std::move(paramBuffer), isCallValid);
}

void CaptureUniform1iv(Context *context, GLint location, GLsizei count, const GLint *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform1iv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, value, &valueParam.value);
    CaptureUniform1iv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform1iv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform2f(Context *context, GLint location, GLfloat v0, GLfloat v1)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform2f(context, location, v0, v1);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLfloat, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLfloat, v1);

    frameCapture->captureCall(context, "glUniform2f", std::move(paramBuffer), isCallValid);
}

void CaptureUniform2fv(Context *context, GLint location, GLsizei count, const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform2fv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniform2fv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform2fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform2i(Context *context, GLint location, GLint v0, GLint v1)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform2i(context, location, v0, v1);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLint, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLint, v1);

    frameCapture->captureCall(context, "glUniform2i", std::move(paramBuffer), isCallValid);
}

void CaptureUniform2iv(Context *context, GLint location, GLsizei count, const GLint *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform2iv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, value, &valueParam.value);
    CaptureUniform2iv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform2iv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform3f(Context *context, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform3f(context, location, v0, v1, v2);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLfloat, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLfloat, v1);
    paramBuffer.addValueParam("v2", ParamType::TGLfloat, v2);

    frameCapture->captureCall(context, "glUniform3f", std::move(paramBuffer), isCallValid);
}

void CaptureUniform3fv(Context *context, GLint location, GLsizei count, const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform3fv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniform3fv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform3fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform3i(Context *context, GLint location, GLint v0, GLint v1, GLint v2)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform3i(context, location, v0, v1, v2);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLint, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLint, v1);
    paramBuffer.addValueParam("v2", ParamType::TGLint, v2);

    frameCapture->captureCall(context, "glUniform3i", std::move(paramBuffer), isCallValid);
}

void CaptureUniform3iv(Context *context, GLint location, GLsizei count, const GLint *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform3iv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, value, &valueParam.value);
    CaptureUniform3iv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform3iv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform4f(Context *context,
                      GLint location,
                      GLfloat v0,
                      GLfloat v1,
                      GLfloat v2,
                      GLfloat v3)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform4f(context, location, v0, v1, v2, v3);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLfloat, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLfloat, v1);
    paramBuffer.addValueParam("v2", ParamType::TGLfloat, v2);
    paramBuffer.addValueParam("v3", ParamType::TGLfloat, v3);

    frameCapture->captureCall(context, "glUniform4f", std::move(paramBuffer), isCallValid);
}

void CaptureUniform4fv(Context *context, GLint location, GLsizei count, const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform4fv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniform4fv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform4fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniform4i(Context *context, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform4i(context, location, v0, v1, v2, v3);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("v0", ParamType::TGLint, v0);
    paramBuffer.addValueParam("v1", ParamType::TGLint, v1);
    paramBuffer.addValueParam("v2", ParamType::TGLint, v2);
    paramBuffer.addValueParam("v3", ParamType::TGLint, v3);

    frameCapture->captureCall(context, "glUniform4i", std::move(paramBuffer), isCallValid);
}

void CaptureUniform4iv(Context *context, GLint location, GLsizei count, const GLint *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniform4iv(context, location, count, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);

    ParamCapture valueParam("value", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, value, &valueParam.value);
    CaptureUniform4iv_value(context, location, count, value, isCallValid, &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniform4iv", std::move(paramBuffer), isCallValid);
}

void CaptureUniformMatrix2fv(Context *context,
                             GLint location,
                             GLsizei count,
                             GLboolean transpose,
                             const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniformMatrix2fv(context, location, count, transpose, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);
    paramBuffer.addValueParam("transpose", ParamType::TGLboolean, transpose);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniformMatrix2fv_value(context, location, count, transpose, value, isCallValid,
                                  &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniformMatrix2fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniformMatrix3fv(Context *context,
                             GLint location,
                             GLsizei count,
                             GLboolean transpose,
                             const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniformMatrix3fv(context, location, count, transpose, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);
    paramBuffer.addValueParam("transpose", ParamType::TGLboolean, transpose);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniformMatrix3fv_value(context, location, count, transpose, value, isCallValid,
                                  &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniformMatrix3fv", std::move(paramBuffer), isCallValid);
}

void CaptureUniformMatrix4fv(Context *context,
                             GLint location,
                             GLsizei count,
                             GLboolean transpose,
                             const GLfloat *value)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUniformMatrix4fv(context, location, count, transpose, value);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("location", ParamType::TGLint, location);
    paramBuffer.addValueParam("count", ParamType::TGLsizei, count);
    paramBuffer.addValueParam("transpose", ParamType::TGLboolean, transpose);

    ParamCapture valueParam("value", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, value, &valueParam.value);
    CaptureUniformMatrix4fv_value(context, location, count, transpose, value, isCallValid,
                                  &valueParam);
    paramBuffer.addParam(std::move(valueParam));

    frameCapture->captureCall(context, "glUniformMatrix4fv", std::move(paramBuffer), isCallValid);
}

void CaptureUseProgram(Context *context, GLuint program)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateUseProgram(context, program);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    frameCapture->captureCall(context, "glUseProgram", std::move(paramBuffer), isCallValid);
}

void CaptureValidateProgram(Context *context, GLuint program)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateValidateProgram(context, program);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("program", ParamType::TGLuint, program);

    frameCapture->captureCall(context, "glValidateProgram", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib1f(Context *context, GLuint index, GLfloat x)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib1f(context, index, x);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);

    frameCapture->captureCall(context, "glVertexAttrib1f", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib1fv(Context *context, GLuint index, const GLfloat *v)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib1fv(context, index, v);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    ParamCapture vParam("v", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, v, &vParam.value);
    CaptureVertexAttrib1fv_v(context, index, v, isCallValid, &vParam);
    paramBuffer.addParam(std::move(vParam));

    frameCapture->captureCall(context, "glVertexAttrib1fv", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib2f(Context *context, GLuint index, GLfloat x, GLfloat y)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib2f(context, index, x, y);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);

    frameCapture->captureCall(context, "glVertexAttrib2f", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib2fv(Context *context, GLuint index, const GLfloat *v)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib2fv(context, index, v);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    ParamCapture vParam("v", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, v, &vParam.value);
    CaptureVertexAttrib2fv_v(context, index, v, isCallValid, &vParam);
    paramBuffer.addParam(std::move(vParam));

    frameCapture->captureCall(context, "glVertexAttrib2fv", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib3f(Context *context, GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib3f(context, index, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);
    paramBuffer.addValueParam("z", ParamType::TGLfloat, z);

    frameCapture->captureCall(context, "glVertexAttrib3f", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib3fv(Context *context, GLuint index, const GLfloat *v)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib3fv(context, index, v);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    ParamCapture vParam("v", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, v, &vParam.value);
    CaptureVertexAttrib3fv_v(context, index, v, isCallValid, &vParam);
    paramBuffer.addParam(std::move(vParam));

    frameCapture->captureCall(context, "glVertexAttrib3fv", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib4f(Context *context,
                           GLuint index,
                           GLfloat x,
                           GLfloat y,
                           GLfloat z,
                           GLfloat w)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib4f(context, index, x, y, z, w);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);
    paramBuffer.addValueParam("z", ParamType::TGLfloat, z);
    paramBuffer.addValueParam("w", ParamType::TGLfloat, w);

    frameCapture->captureCall(context, "glVertexAttrib4f", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttrib4fv(Context *context, GLuint index, const GLfloat *v)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexAttrib4fv(context, index, v);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);

    ParamCapture vParam("v", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, v, &vParam.value);
    CaptureVertexAttrib4fv_v(context, index, v, isCallValid, &vParam);
    paramBuffer.addParam(std::move(vParam));

    frameCapture->captureCall(context, "glVertexAttrib4fv", std::move(paramBuffer), isCallValid);
}

void CaptureVertexAttribPointer(Context *context,
                                GLuint index,
                                GLint size,
                                VertexAttribType typePacked,
                                GLboolean normalized,
                                GLsizei stride,
                                const void *pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid =
        ValidateVertexAttribPointer(context, index, size, typePacked, normalized, stride, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("index", ParamType::TGLuint, index);
    paramBuffer.addValueParam("size", ParamType::TGLint, size);
    paramBuffer.addValueParam("typePacked", ParamType::TVertexAttribType, typePacked);
    paramBuffer.addValueParam("normalized", ParamType::TGLboolean, normalized);
    paramBuffer.addValueParam("stride", ParamType::TGLsizei, stride);

    ParamCapture pointerParam("pointer", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pointer, &pointerParam.value);
    CaptureVertexAttribPointer_pointer(context, index, size, typePacked, normalized, stride,
                                       pointer, isCallValid, &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glVertexAttribPointer", std::move(paramBuffer),
                              isCallValid);
}

void CaptureViewport(Context *context, GLint x, GLint y, GLsizei width, GLsizei height)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateViewport(context, x, y, width, height);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLint, x);
    paramBuffer.addValueParam("y", ParamType::TGLint, y);
    paramBuffer.addValueParam("width", ParamType::TGLsizei, width);
    paramBuffer.addValueParam("height", ParamType::TGLsizei, height);

    frameCapture->captureCall(context, "glViewport", std::move(paramBuffer), isCallValid);
}

}  // namespace gl
