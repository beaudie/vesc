// GENERATED FILE - DO NOT EDIT.
// Generated by gen_mtl_internal_shaders.py
//
// Copyright 2020 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

// Combined Metal default shaders.

# 1 "temp_master_source.metal"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 483 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "temp_master_source.metal" 2
# 1 "./vertex_pulling.metal" 1

#if __METAL_VERSION__ >= 240

# 1 "./common.h" 1
# 13 "./common.h"
# include <simd/simd.h>
# include <metal_stdlib>


# 1 "./constants.h" 1
# 11 "./constants.h"
namespace rx
{
namespace mtl_shader
{

enum
{
    kTextureType2D = 0,
    kTextureType2DMultisample = 1,
    kTextureType2DArray = 2,
    kTextureTypeCube = 3,
    kTextureType3D = 4,
    kTextureTypeCount = 5,
};

enum
{
    kVertexTypeFloat = 0,
    kVertexTypeFixed = 1,
    kVertexTypeHalf = 2,
    kVertexTypeXYZW1010102Int = 3,
    kVertexTypeXYZW1010102UInt = 4,
    kVertexTypeByte = 5,
    kVertexTypeUByte = 6,
    kVertexTypeShort = 7,
    kVertexTypeUShort = 8,
    kVertexTypeInt = 9,
    kVertexTypeUInt = 10,
    kVertexTypeInvalid = 11,
};

enum
{
    kVertexConvertModeNone = 0,
    kVertexConvertModeNormalize = 1,
    kVertexConvertModeToFloat = 2,
};




}
}
# 18 "./common.h" 2







using namespace metal;



constant uint32_t kNumColorOutputs [[function_constant(0)]];
constant bool kColorOutputAvailable0 = kNumColorOutputs > 0;
constant bool kColorOutputAvailable1 = kNumColorOutputs > 1;
constant bool kColorOutputAvailable2 = kNumColorOutputs > 2;
constant bool kColorOutputAvailable3 = kNumColorOutputs > 3;
constant bool kColorOutputAvailable4 = kNumColorOutputs > 4;
constant bool kColorOutputAvailable5 = kNumColorOutputs > 5;
constant bool kColorOutputAvailable6 = kNumColorOutputs > 6;
constant bool kColorOutputAvailable7 = kNumColorOutputs > 7;

namespace rx
{
namespace mtl_shader
{


constant float2 gCorners[3] = {float2(-1.0f, -1.0f), float2(3.0f, -1.0f), float2(-1.0f, 3.0f)};

template <typename T>
struct MultipleColorOutputs
{
    vec<T, 4> color0 [[color(0), function_constant(kColorOutputAvailable0)]];
    vec<T, 4> color1 [[color(1), function_constant(kColorOutputAvailable1)]];
    vec<T, 4> color2 [[color(2), function_constant(kColorOutputAvailable2)]];
    vec<T, 4> color3 [[color(3), function_constant(kColorOutputAvailable3)]];
    vec<T, 4> color4 [[color(4), function_constant(kColorOutputAvailable4)]];
    vec<T, 4> color5 [[color(5), function_constant(kColorOutputAvailable5)]];
    vec<T, 4> color6 [[color(6), function_constant(kColorOutputAvailable6)]];
    vec<T, 4> color7 [[color(7), function_constant(kColorOutputAvailable7)]];
};
# 69 "./common.h"
template <typename T>
static inline MultipleColorOutputs<T> toMultipleColorOutputs(vec<T, 4> color)
{
    MultipleColorOutputs<T> re;

    do { if (kColorOutputAvailable0) { re.color0 = color; } } while (0);
    do { if (kColorOutputAvailable1) { re.color1 = color; } } while (0);
    do { if (kColorOutputAvailable2) { re.color2 = color; } } while (0);
    do { if (kColorOutputAvailable3) { re.color3 = color; } } while (0);
    do { if (kColorOutputAvailable4) { re.color4 = color; } } while (0);
    do { if (kColorOutputAvailable5) { re.color5 = color; } } while (0);
    do { if (kColorOutputAvailable6) { re.color6 = color; } } while (0);
    do { if (kColorOutputAvailable7) { re.color7 = color; } } while (0);

    return re;
}

static inline float3 cubeTexcoords(float2 texcoords, int face)
{
    texcoords = 2.0 * texcoords - 1.0;
    switch (face)
    {
        case 0:
            return float3(1.0, -texcoords.y, -texcoords.x);
        case 1:
            return float3(-1.0, -texcoords.y, texcoords.x);
        case 2:
            return float3(texcoords.x, 1.0, texcoords.y);
        case 3:
            return float3(texcoords.x, -1.0, -texcoords.y);
        case 4:
            return float3(texcoords.x, -texcoords.y, 1.0);
        case 5:
            return float3(-texcoords.x, -texcoords.y, -1.0);
    }
    return float3(texcoords, 0);
}

template <typename T>
static inline vec<T, 4> resolveTextureMS(texture2d_ms<T> srcTexture, uint2 coords)
{
    uint samples = srcTexture.get_num_samples();

    vec<T, 4> output(0);

    for (uint sample = 0; sample < samples; ++sample)
    {
        output += srcTexture.read(coords, sample);
    }

    output = output / samples;

    return output;
}

static inline float4 sRGBtoLinear(float4 color)
{
    float3 linear1 = color.rgb / 12.92;
    float3 linear2 = pow((color.rgb + float3(0.055)) / 1.055, 2.4);
    float3 factor = float3(color.rgb <= float3(0.04045));
    float4 linear = float4(factor * linear1 + float3(1.0 - factor) * linear2, color.a);

    return linear;
}

static inline float linearToSRGB(float color)
{
    if (color <= 0.0f)
        return 0.0f;
    else if (color < 0.0031308f)
        return 12.92f * color;
    else if (color < 1.0f)
        return 1.055f * pow(color, 0.41666f) - 0.055f;
    else
        return 1.0f;
}

static inline float4 linearToSRGB(float4 color)
{
    return float4(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b), color.a);
}

template <typename Short>
static inline Short bytesToShort(constant uchar *input, uint offset)
{
    Short inputLo = input[offset];
    Short inputHi = input[offset + 1];

    return inputLo | (inputHi << 8);
}

template <typename Int>
static inline Int bytesToInt(constant uchar *input, uint offset)
{
    Int input0 = input[offset];
    Int input1 = input[offset + 1];
    Int input2 = input[offset + 2];
    Int input3 = input[offset + 3];

    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
}

template <typename Short>
static inline void shortToBytes(Short val, uint offset, device uchar *output)
{
    ushort valUnsigned = as_type<ushort>(val);
    output[offset] = valUnsigned & 0xff;
    output[offset + 1] = (valUnsigned >> 8) & 0xff;
}

template <typename Int>
static inline void intToBytes(Int val, uint offset, device uchar *output)
{
    uint valUnsigned = as_type<uint>(val);
    output[offset] = valUnsigned & 0xff;
    output[offset + 1] = (valUnsigned >> 8) & 0xff;
    output[offset + 2] = (valUnsigned >> 16) & 0xff;
    output[offset + 3] = (valUnsigned >> 24) & 0xff;
}

static inline void floatToBytes(float val, uint offset, device uchar *output)
{
    intToBytes(as_type<uint>(val), offset, output);
}

static inline void int24bitToBytes(uint val, uint offset, device uchar *output)
{
    output[offset] = val & 0xff;
    output[offset + 1] = (val >> 8) & 0xff;
    output[offset + 2] = (val >> 16) & 0xff;
}

template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
static inline T getShiftedData(T input)
{
    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
                  "T must have at least as many bits as inputBitCount + inputBitStart.");
    const T mask = (1 << inputBitCount) - 1;
    return (input >> inputBitStart) & mask;
}

template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
static inline T shiftData(T input)
{
    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
                  "T must have at least as many bits as inputBitCount + inputBitStart.");
    const T mask = (1 << inputBitCount) - 1;
    return (input & mask) << inputBitStart;
}

template <unsigned int inputBitCount, typename T>
static inline float normalizedToFloat(T input)
{
    static_assert(inputBitCount <= (sizeof(T) * 8),
                  "T must have more bits than or same bits as inputBitCount.");
    static_assert(inputBitCount <= 23, "Only single precision is supported");

    constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);
    return input * inverseMax;
}

template <typename T>
static inline float normalizedToFloat(T input)
{
    return normalizedToFloat<sizeof(T) * 8, T>(input);
}

template <>
inline float normalizedToFloat(short input)
{
    constexpr float inverseMax = 1.0f / 0x7fff;
    return static_cast<float>(input) * inverseMax;
}

template <>
inline float normalizedToFloat(int input)
{
    constexpr float inverseMax = 1.0f / 0x7fffffff;
    return static_cast<float>(input) * inverseMax;
}

template <>
inline float normalizedToFloat(uint input)
{
    constexpr float inverseMax = 1.0f / 0xffffffff;
    return static_cast<float>(input) * inverseMax;
}

template <unsigned int outputBitCount, typename T>
static inline T floatToNormalized(float input)
{
    static_assert(outputBitCount <= (sizeof(T) * 8),
                  "T must have more bits than or same bits as inputBitCount.");
    static_assert(outputBitCount <= 23, "Only single precision is supported");

    return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);
}

template <typename T>
static inline T floatToNormalized(float input)
{
    return floatToNormalized<sizeof(T) * 8, T>(input);
}

}
}
# 5 "./vertex_pulling.metal" 2
# 30 "./vertex_pulling.metal"
using namespace metal;
using namespace rx::mtl_shader;

constant uint kVertexPullingType [[function_constant(2100)]];
constant uint kVertexPullingComponentCount [[function_constant(2101)]];
constant uint kVertexPullingOffset [[function_constant(2102)]];
constant uint kVertexPullingStride [[function_constant(2103)]];
constant uint kVertexPullingDivisor [[function_constant(2104)]];
constant bool kVertexPullingUseDefaultAttribs [[function_constant(2105)]];
constant bool kVertexPullingOffsetIsAligned [[function_constant(2106)]];
constant uint kVertexPullingConvertMode [[function_constant(2107)]];

constant bool kVertexPullingNormalize = kVertexPullingConvertMode == kVertexConvertModeNormalize;
constant bool kVertexPullingConvertToFloat = kVertexPullingConvertMode == kVertexConvertModeToFloat;

template <typename Short>
static inline Short fetchShortFromBytes(const device uchar *input, uint offset)
{
    Short inputLo = input[offset];
    Short inputHi = input[offset + 1];

    return inputLo | (inputHi << 8);
}

template <typename Int>
static inline Int fetchIntFromBytes(const device uchar *input, uint offset)
{
    Int input0 = input[offset];
    Int input1 = input[offset + 1];
    Int input2 = input[offset + 2];
    Int input3 = input[offset + 3];

    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
}

template <typename T1, typename T2>
static inline T1 fixedToFloat(T2 fixed)
{
    constexpr float divisor = 1.0 / static_cast<float>(1 << 16);
    return static_cast<T1>(fixed) * divisor;
}


template <bool isSigned, bool normalized>
static inline float packedXYZ101010ToFloat(uint32_t data)
{
    const uint32_t rgbSignMask = 0x200;
    const uint32_t negativeMask = 0xFFFFFC00;

    float finalValue = static_cast<float>(data);
    if (isSigned)
    {
        if (data & rgbSignMask)
        {
            int negativeNumber = data | negativeMask;
            finalValue = static_cast<float>(negativeNumber);
        }

        if (normalized)
        {
            const int32_t maxValue = 0x1FF;
            const int32_t minValue = 0xFFFFFE01;




            if (finalValue < minValue)
            {
                finalValue = minValue;
            }

            const int32_t halfRange = (maxValue - minValue) >> 1;
            finalValue = ((finalValue - minValue) / halfRange) - 1.0f;
        }
    }
    else
    {
        if (normalized)
        {
            const uint32_t maxValue = 0x3FF;
            finalValue /= static_cast<float>(maxValue);
        }
    }

    return finalValue;
}

template <bool isSigned, bool normalized>
inline float packedW2ToFloat(uint32_t data)
{
    float finalValue = 0;
    if (isSigned)
    {
        if (normalized)
        {
            switch (data)
            {
                case 0x0:
                    finalValue = 0.0f;
                    break;
                case 0x1:
                    finalValue = 1.0f;
                    break;
                case 0x2:
                    finalValue = -1.0f;
                    break;
                case 0x3:
                    finalValue = -1.0f;
                    break;
            }
        }
        else
        {
            switch (data)
            {
                case 0x0:
                    finalValue = 0.0f;
                    break;
                case 0x1:
                    finalValue = 1.0f;
                    break;
                case 0x2:
                    finalValue = -2.0f;
                    break;
                case 0x3:
                    finalValue = -1.0f;
                    break;
            }
        }
    }
    else
    {
        if (normalized)
        {
            finalValue = data / 3.0f;
        }
        else
        {
            finalValue = static_cast<float>(data);
        }
    }

    return finalValue;
}

template <bool isSigned, bool normalized>
static inline float4 packedXYZW1010102ToFloat(uint packedValue)
{
    const uint32_t rgbMask = 0x3FF;
    const size_t redShift = 0;
    const size_t greenShift = 10;
    const size_t blueShift = 20;

    const uint32_t alphaMask = 0x3;
    const size_t alphaShift = 30;

    float4 re;
    re.x = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> redShift) & rgbMask);
    re.y = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> greenShift) & rgbMask);
    re.z = packedXYZ101010ToFloat<isSigned, normalized>((packedValue >> blueShift) & rgbMask);
    re.w = packedW2ToFloat<isSigned, normalized>((packedValue >> alphaShift) & alphaMask);
    return re;
}

template <unsigned int inputBitCount, typename T1, typename T2>
static inline T1 normalizedToFloat(T2 input)
{
    static_assert(inputBitCount <= (sizeof(T2) * 8),
                  "T2 must have more bits than or same bits as inputBitCount.");

    if (inputBitCount < 32)
    {
        const float inverseMax = 1.0f / (static_cast<uint>(0x1 << inputBitCount) - 1);
        return max(static_cast<T1>(input) * inverseMax, T1(-1.0));
    }
    else
    {
        constexpr float inverseMax32 = 1.0f / 0xffffffff;
        return max(static_cast<T1>(input) * inverseMax32, T1(-1.0));
    }
}


static inline uchar4 fetchUByte(const device uchar *input,
                                int offset,
                                int stride,
                                int index,
                                uint components,
                                uchar defaultAlpha = 1)
{
    uchar4 re = uchar4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = input[offset + stride * index + i];
    }
    return re;
}


static inline float4 fetchUByteNorm(const device uchar *input,
                                    int offset,
                                    int stride,
                                    int index,
                                    uint components)
{
    uchar4 re = fetchUByte(input, offset, stride, index, components, 255);
    return normalizedToFloat<8, float4>(re);
}


static inline char4 fetchByte(const device uchar *input,
                              int offset,
                              int stride,
                              int index,
                              uint components)
{
    return as_type<char4>(fetchUByte(input, offset, stride, index, components));
}


static inline float4 fetchByteNorm(const device uchar *input,
                                   int offset,
                                   int stride,
                                   int index,
                                   uint components)
{
    char4 re = as_type<char4>(fetchUByte(input, offset, stride, index, components, 127));
    return normalizedToFloat<7, float4>(re);
}


static inline ushort4 fetchUShort(const device uchar *input,
                                  int offset,
                                  int stride,
                                  int index,
                                  uint components,
                                  ushort defaultAlpha = 1)
{
    ushort4 re = ushort4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = fetchShortFromBytes<ushort>(input, offset + stride * index + i * 2);
    }
    return re;
}


static inline float4 fetchUShortNorm(const device uchar *input,
                                     int offset,
                                     int stride,
                                     int index,
                                     uint components)
{
    ushort4 re = fetchUShort(input, offset, stride, index, components, 0xffff);
    return normalizedToFloat<16, float4>(re);
}


static inline short4 fetchShort(const device uchar *input,
                                int offset,
                                int stride,
                                int index,
                                uint components)
{
    return as_type<short4>(fetchUShort(input, offset, stride, index, components));
}


static inline float4 fetchShortNorm(const device uchar *input,
                                    int offset,
                                    int stride,
                                    int index,
                                    uint components)
{
    short4 re = as_type<short4>(fetchUShort(input, offset, stride, index, components, 0x7fff));
    return normalizedToFloat<15, float4>(re);
}


static inline uint4 fetchUInt(const device uchar *input,
                              int offset,
                              int stride,
                              int index,
                              uint components,
                              uint defaultAlpha = 1)
{
    uint4 re = uint4(0, 0, 0, defaultAlpha);
    for (uint i = 0; i < components; ++i)
    {
        re[i] = fetchIntFromBytes<uint>(input, offset + stride * index + i * 4);
    }
    return re;
}


static inline float4 fetchUIntNorm(const device uchar *input,
                                   int offset,
                                   int stride,
                                   int index,
                                   uint components)
{
    uint4 re = fetchUInt(input, offset, stride, index, components, 0xffffffff);
    return normalizedToFloat<32, float4>(re);
}


static inline int4 fetchInt(const device uchar *input,
                            int offset,
                            int stride,
                            int index,
                            uint components)
{
    return as_type<int4>(fetchUInt(input, offset, stride, index, components));
}


static inline float4 fetchIntNorm(const device uchar *input,
                                  int offset,
                                  int stride,
                                  int index,
                                  uint components)
{
    int4 re = as_type<int4>(fetchUInt(input, offset, stride, index, components, 0x7fffffff));
    return normalizedToFloat<31, float4>(re);
}


static inline half4 fetchHalf(const device uchar *input,
                              int offset,
                              int stride,
                              int index,
                              uint components)
{
    constexpr half defaultAlpha = 1.0;
    return as_type<half4>(
        fetchUShort(input, offset, stride, index, components, as_type<ushort>(defaultAlpha)));
}


static inline float4 fetchFloat(const device uchar *input,
                                int offset,
                                int stride,
                                int index,
                                uint components)
{
    constexpr float defaultAlpha = 1.0;
    return as_type<float4>(
        fetchUInt(input, offset, stride, index, components, as_type<uint>(defaultAlpha)));
}


static inline float4 fetchFixed(const device uchar *input,
                                int offset,
                                int stride,
                                int index,
                                uint components)
{
    float4 re = float4(0, 0, 0, 1);
    float4 convertedWithPadding =
        fixedToFloat<float4>(fetchInt(input, offset, stride, index, components));
    for (uint i = 0; i < components; ++i)
    {
        re[i] = convertedWithPadding[i];
    }
    return re;
}


template <bool isSigned, bool normalized>
static inline float4 fetchPackedXYZW1010102(const device uchar *input,
                                            int offset,
                                            int stride,
                                            int index)
{
    uint packedValue = fetchIntFromBytes<uint>(input, offset + stride * index);
    return packedXYZW1010102ToFloat<isSigned, normalized>(packedValue);
}

template <bool isSigned, bool normalized>
static inline float4 fetchPackedXYZW1010102(const device uchar *input,
                                            int offset,
                                            int stride,
                                            int index,
                                            int components )
{
    return fetchPackedXYZW1010102<isSigned, normalized>(input, offset, stride, index);
}
# 425 "./vertex_pulling.metal"
static inline uint4 asUInt4(uint4 src)
{
    return src;
}
static inline uint4 asUInt4(float4 src)
{
    return as_type<uint4>(src);
}
static inline uint4 asUInt4(int4 src)
{
    return as_type<uint4>(src);
}


static inline uint4 asUInt4(half4 src)
{
    return asUInt4(static_cast<float4>(src));
}


static inline uint4 asUInt4(uchar4 src)
{
    return static_cast<uint4>(src);
}
static inline uint4 asUInt4(ushort4 src)
{
    return static_cast<uint4>(src);
}


static inline uint4 asUInt4(char4 src)
{
    return asUInt4(static_cast<int4>(src));
}
static inline uint4 asUInt4(short4 src)
{
    return asUInt4(static_cast<int4>(src));
}
# 551 "./vertex_pulling.metal"
[[stitchable]] uint4 ANGLE_pullVertexAsUInt4(const device uchar *inputUnaligned,
                                             const device uchar *defaultAttribs,
                                             int gl_VertexIndex,
                                             int gl_InstanceIndex)
{
    uint4 re;

    if (kVertexPullingUseDefaultAttribs)
    {
        { uint vertexFinalIndex; if (kVertexPullingDivisor == 0) { vertexFinalIndex = gl_VertexIndex; } else { vertexFinalIndex = gl_InstanceIndex / kVertexPullingDivisor; } switch (kVertexPullingType) { case kVertexTypeByte: if (kVertexPullingNormalize) { re = asUInt4(fetchByteNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchByte(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchByte(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUByte: if (kVertexPullingNormalize) { re = asUInt4(fetchUByteNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUByte(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUByte(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeShort: if (kVertexPullingNormalize) { re = asUInt4(fetchShortNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchShort(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchShort(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUShort: if (kVertexPullingNormalize) { re = asUInt4(fetchUShortNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUShort(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUShort(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeInt: if (kVertexPullingNormalize) { re = asUInt4(fetchIntNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchInt(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchInt(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUInt: if (kVertexPullingNormalize) { re = asUInt4(fetchUIntNorm(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUInt(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUInt(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeXYZW1010102Int: if (kVertexPullingNormalize) { re = asUInt4(fetchPackedXYZW1010102<true, true>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchPackedXYZW1010102<true, false>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0))); } else { re = asUInt4(fetchPackedXYZW1010102<true, false>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } break; case kVertexTypeXYZW1010102UInt: if (kVertexPullingNormalize) { re = asUInt4(fetchPackedXYZW1010102<false, true>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchPackedXYZW1010102<false, false>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0))); } else { re = asUInt4(fetchPackedXYZW1010102<false, false>(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } break; case kVertexTypeFloat: re = asUInt4(static_cast<float4>(fetchFloat(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; case kVertexTypeHalf: re = asUInt4(static_cast<float4>(fetchHalf(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; case kVertexTypeFixed: re = asUInt4(static_cast<float4>(fetchFixed(defaultAttribs, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; break; } };
    }
    else
    {
        { uint vertexFinalIndex; if (kVertexPullingDivisor == 0) { vertexFinalIndex = gl_VertexIndex; } else { vertexFinalIndex = gl_InstanceIndex / kVertexPullingDivisor; } switch (kVertexPullingType) { case kVertexTypeByte: if (kVertexPullingNormalize) { re = asUInt4(fetchByteNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchByte(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchByte(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUByte: if (kVertexPullingNormalize) { re = asUInt4(fetchUByteNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUByte(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUByte(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeShort: if (kVertexPullingNormalize) { re = asUInt4(fetchShortNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchShort(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchShort(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUShort: if (kVertexPullingNormalize) { re = asUInt4(fetchUShortNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUShort(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUShort(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeInt: if (kVertexPullingNormalize) { re = asUInt4(fetchIntNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchInt(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchInt(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeUInt: if (kVertexPullingNormalize) { re = asUInt4(fetchUIntNorm(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchUInt(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount))); } else { re = asUInt4(fetchUInt(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)); }; break; case kVertexTypeXYZW1010102Int: if (kVertexPullingNormalize) { re = asUInt4(fetchPackedXYZW1010102<true, true>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchPackedXYZW1010102<true, false>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0))); } else { re = asUInt4(fetchPackedXYZW1010102<true, false>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } break; case kVertexTypeXYZW1010102UInt: if (kVertexPullingNormalize) { re = asUInt4(fetchPackedXYZW1010102<false, true>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } else if (kVertexPullingConvertToFloat) { re = asUInt4(static_cast<float4>(fetchPackedXYZW1010102<false, false>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0))); } else { re = asUInt4(fetchPackedXYZW1010102<false, false>(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, 0)); } break; case kVertexTypeFloat: re = asUInt4(static_cast<float4>(fetchFloat(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; case kVertexTypeHalf: re = asUInt4(static_cast<float4>(fetchHalf(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; case kVertexTypeFixed: re = asUInt4(static_cast<float4>(fetchFixed(inputUnaligned, kVertexPullingOffset, kVertexPullingStride, vertexFinalIndex, kVertexPullingComponentCount)));; break; break; } };
    }

    return re;
}

#endif
# 2 "temp_master_source.metal" 2


