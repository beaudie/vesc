#!/usr/bin/python
# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_mtl_format_table.py:
#  Code generation for Metal format map.
#  NOTE: don't run this script directly. Run scripts/run_code_generation.py.
#

from datetime import date
import json
import math
import pprint
import re
import sys

sys.path.append('..')
import angle_format

template_autogen_inl = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Metal Format table:
//   Conversion from ANGLE format to Metal format.

#import <Metal/Metal.h>
#include <TargetConditionals.h>

#include "libANGLE/renderer/Format.h"
#include "libANGLE/renderer/metal/DisplayMtl.h"
#include "libANGLE/renderer/metal/mtl_format_utils.h"

namespace rx
{{
namespace mtl
{{

void Format::init(const DisplayMtl *display, angle::FormatID intendedFormatId_)
{{
    this->intendedFormatId = intendedFormatId_;

    id<MTLDevice> metalDevice = display->getMetalDevice();

    // Actual conversion
    switch (this->intendedFormatId)
    {{
{angle_image_format_switch}
    }}
}}

void VertexFormat::init(angle::FormatID angleFormatId, bool tightlyPacked)
{{
    this->intendedFormatId = angleFormatId;

    // Actual conversion
    switch (this->intendedFormatId)
    {{
{angle_vertex_format_switch}
    }}
}}

}}  // namespace mtl
}}  // namespace rx
"""

image_format_assign_template1 = """
            this->metalFormat = {mtl_format};
            this->actualFormatId = angle::FormatID::{actual_angle_format};
"""

image_format_assign_template2 = """
            if (metalDevice.depth24Stencil8PixelFormatSupported)
            {{
                this->metalFormat = {mtl_format};
                this->actualFormatId = angle::FormatID::{actual_angle_format};
            }}
            else
            {{
                this->metalFormat = {mtl_format_fallback};
                this->actualFormatId = angle::FormatID::{actual_angle_format_fallback};
            }}
"""

case_image_format_template1 = """        case angle::FormatID::{angle_format}:
            {image_format_assign}
            this->swizzled = false;
            break;

"""

case_image_format_template2 = """        case angle::FormatID::{angle_format}:
#if defined(__IPHONE_13_0) || defined(__MAC_10_15)
            if (display->getFeatures().hasTextureSwizzle.enabled)
            {{
                {image_format_assign_swizzled}
                this->swizzled = true;
                this->swizzle  = {mtl_swizzle};
            }}
            else
#endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
            {{
                {image_format_assign_default}
                this->swizzled = false;
            }}
            break;

"""

case_vertex_format_template1 = """        case angle::FormatID::{angle_format}:
            this->metalFormat = {mtl_format};
            this->actualFormatId = angle::FormatID::{actual_angle_format};
            this->vertexLoadFunction = {vertex_copy_function};
            break;

"""

case_vertex_format_template2 = """        case angle::FormatID::{angle_format}:
            if (tightlyPacked)
            {{
                this->metalFormat = {mtl_format_packed};
                this->actualFormatId = angle::FormatID::{actual_angle_format_packed};
                this->vertexLoadFunction = {vertex_copy_function_packed};
            }}
            else
            {{
                this->metalFormat = {mtl_format};
                this->actualFormatId = angle::FormatID::{actual_angle_format};
                this->vertexLoadFunction = {vertex_copy_function};
            }}
            break;

"""


# NOTE(hqle): This is a modified version of the get_vertex_copy_function() function in
# src/libANGLE/renderer/angle_format.py
def get_vertex_copy_function_mtl(src_format, dst_format):
    if dst_format == "NONE":
        return "nullptr"

    num_channel = len(angle_format.get_channel_tokens(src_format))
    if num_channel < 1 or num_channel > 4:
        return "nullptr"

    src_gl_type = angle_format.get_format_gl_type(src_format)
    dst_gl_type = angle_format.get_format_gl_type(dst_format)

    if src_gl_type == dst_gl_type:
        if src_format.startswith('R10G10B10A2'):
            return 'CopyNativeVertexData<GLuint, 1, 1, 0>'

        if src_gl_type == None:
            return 'nullptr'
        dst_num_channel = len(angle_format.get_channel_tokens(dst_format))
        default_alpha = '1'
        if num_channel == dst_num_channel or dst_num_channel < 4:
            default_alpha = '0'
        elif 'A16_FLOAT' in dst_format:
            default_alpha = 'gl::Float16One'
        elif 'A32_FLOAT' in dst_format:
            default_alpha = 'gl::Float32One'
        elif 'NORM' in dst_format:
            default_alpha = 'std::numeric_limits<%s>::max()' % (src_gl_type)

        return 'CopyNativeVertexData<%s, %d, %d, %s>' % (src_gl_type, num_channel, dst_num_channel,
                                                         default_alpha)

    if src_format.startswith('R10G10B10A2'):
        assert 'FLOAT' in dst_format, ('get_vertex_copy_function: can only convert to float,' +
                                       ' not to ' + dst_format)
        is_signed = 'true' if 'SINT' in src_format or 'SNORM' in src_format or 'SSCALED' in src_format else 'false'
        is_normal = 'true' if 'NORM' in src_format else 'false'
        return 'CopyXYZ10W2ToXYZW32FVertexData<%s, %s, true>' % (is_signed, is_normal)

    return angle_format.get_vertex_copy_function(src_format, dst_format)


# Generate format conversion switch case (generic case)
def gen_image_map_switch_case(angle_format, actual_angle_format_info, angle_to_mtl_map,
                              assign_gen_func):
    if isinstance(actual_angle_format_info, dict):
        default_actual_angle_format = actual_angle_format_info['default']
        # Check if the format can be override with swizzle feature
        if 'swizzle' in actual_angle_format_info:
            swizzle_info = actual_angle_format_info['swizzle']
            swizzle_channels = swizzle_info[0]
            swizzled_actual_angle_format = swizzle_info[1]
            swizzle_map = {
                'R': 'MTLTextureSwizzleRed',
                'G': 'MTLTextureSwizzleGreen',
                'B': 'MTLTextureSwizzleBlue',
                'A': 'MTLTextureSwizzleAlpha',
                '1': 'MTLTextureSwizzleOne',
                '0': 'MTLTextureSwizzleZero',
            }

            mtl_swizzle_make = 'MTLTextureSwizzleChannelsMake({r}, {g}, {b}, {a})'.format(
                r=swizzle_map[swizzle_channels[0:1]],
                g=swizzle_map[swizzle_channels[1:2]],
                b=swizzle_map[swizzle_channels[2:3]],
                a=swizzle_map[swizzle_channels[3:]])
            return case_image_format_template2.format(
                angle_format=angle_format,
                image_format_assign_default=assign_gen_func(default_actual_angle_format,
                                                            angle_to_mtl_map),
                image_format_assign_swizzled=assign_gen_func(swizzled_actual_angle_format,
                                                             angle_to_mtl_map),
                mtl_swizzle=mtl_swizzle_make)
        else:
            # Only default case
            return gen_image_map_switch_case(angle_format, default_actual_angle_format,
                                             angle_to_mtl_map, assign_gen_func)
    else:
        # Default case
        return case_image_format_template1.format(
            angle_format=angle_format,
            image_format_assign=assign_gen_func(actual_angle_format_info, angle_to_mtl_map))


# Generate format conversion switch case (simple case)
def gen_image_map_switch_simple_case(angle_format, actual_angle_format_info, angle_to_mtl_map):

    def gen_format_assign_code(actual_angle_format, angle_to_mtl_map):
        return image_format_assign_template1.format(
            actual_angle_format=actual_angle_format,
            mtl_format=angle_to_mtl_map[actual_angle_format])

    return gen_image_map_switch_case(angle_format, actual_angle_format_info, angle_to_mtl_map,
                                     gen_format_assign_code)


# Generate format conversion switch case (Mac case)
def gen_image_map_switch_mac_case(angle_format, actual_angle_format_info, angle_to_mtl_map,
                                  mac_fallbacks):

    def gen_format_assign_code(actual_angle_format, angle_to_mtl_map):
        if actual_angle_format in mac_fallbacks:
            # This format requires fallback when depth24Stencil8PixelFormatSupported flag is false.
            # Fallback format:
            actual_angle_format_fallback = mac_fallbacks[actual_angle_format]
            # return if else block:
            return image_format_assign_template2.format(
                actual_angle_format=actual_angle_format,
                mtl_format=angle_to_mtl_map[actual_angle_format],
                actual_angle_format_fallback=actual_angle_format_fallback,
                mtl_format_fallback=angle_to_mtl_map[actual_angle_format_fallback])
        else:
            # return ordinary block:
            return image_format_assign_template1.format(
                actual_angle_format=actual_angle_format,
                mtl_format=angle_to_mtl_map[actual_angle_format])

    return gen_image_map_switch_case(angle_format, actual_angle_format_info, angle_to_mtl_map,
                                     gen_format_assign_code)


def gen_image_map_switch_string(image_table):
    angle_override = image_table["override"]
    mac_override = image_table["override_mac"]
    ios_override = image_table["override_ios"]
    mac_fallbacks = image_table["fallbacks_mac"]
    angle_to_mtl = image_table["map"]
    mac_specific_map = image_table["map_mac"]
    ios_specific_map = image_table["map_ios"]

    # mac_specific_map + angle_to_mtl:
    mac_angle_to_mtl = mac_specific_map.copy()
    mac_angle_to_mtl.update(angle_to_mtl)
    # ios_specific_map + angle_to_mtl
    ios_angle_to_mtl = ios_specific_map.copy()
    ios_angle_to_mtl.update(angle_to_mtl)

    switch_data = ''

    def gen_image_map_switch_common_case(angle_format, actual_angle_format):
        mac_case = gen_image_map_switch_mac_case(angle_format, actual_angle_format,
                                                 mac_angle_to_mtl, mac_fallbacks)
        non_mac_case = gen_image_map_switch_simple_case(angle_format, actual_angle_format,
                                                        angle_to_mtl)
        if mac_case == non_mac_case:
            return mac_case

        re = ''
        re += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
        re += mac_case
        re += "#else  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
        re += non_mac_case
        re += "#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
        return re

    # Common case
    for angle_format in sorted(angle_to_mtl.keys()):
        switch_data += gen_image_map_switch_common_case(angle_format, angle_format)
    for angle_format in sorted(angle_override.keys()):
        switch_data += gen_image_map_switch_common_case(angle_format, angle_override[angle_format])

    # Mac specific
    switch_data += "#if TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
    for angle_format in sorted(mac_specific_map.keys()):
        switch_data += gen_image_map_switch_mac_case(angle_format, angle_format, mac_angle_to_mtl,
                                                     mac_fallbacks)
    for angle_format in sorted(mac_override.keys()):
        switch_data += gen_image_map_switch_mac_case(angle_format, mac_override[angle_format],
                                                     mac_angle_to_mtl, mac_fallbacks)

    # iOS specific
    switch_data += "#elif TARGET_OS_IOS  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
    for angle_format in sorted(ios_specific_map.keys()):
        switch_data += gen_image_map_switch_simple_case(angle_format, angle_format,
                                                        ios_specific_map)
    for angle_format in sorted(ios_override.keys()):
        switch_data += gen_image_map_switch_simple_case(angle_format, ios_override[angle_format],
                                                        ios_angle_to_mtl)
    switch_data += "#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
    switch_data += "        default:\n"
    switch_data += "            this->metalFormat = MTLPixelFormatInvalid;\n"
    switch_data += "            this->actualFormatId = angle::FormatID::NONE;"
    return switch_data


def gen_vertex_map_switch_case(angle_fmt, actual_angle_fmt, angle_to_mtl_map, override_packed_map):
    mtl_format = angle_to_mtl_map[actual_angle_fmt]
    copy_function = get_vertex_copy_function_mtl(angle_fmt, actual_angle_fmt)
    if actual_angle_fmt in override_packed_map:
        # This format has an override when used in tightly packed buffer,
        # Return if else block
        angle_fmt_packed = override_packed_map[actual_angle_fmt]
        mtl_format_packed = angle_to_mtl_map[angle_fmt_packed]
        copy_function_packed = get_vertex_copy_function_mtl(angle_fmt, angle_fmt_packed)
        return case_vertex_format_template2.format(
            angle_format=angle_fmt,
            mtl_format_packed=mtl_format_packed,
            actual_angle_format_packed=angle_fmt_packed,
            vertex_copy_function_packed=copy_function_packed,
            mtl_format=mtl_format,
            actual_angle_format=actual_angle_fmt,
            vertex_copy_function=copy_function)
    else:
        # This format has no packed buffer's override, return ordinary block.
        return case_vertex_format_template1.format(
            angle_format=angle_fmt,
            mtl_format=mtl_format,
            actual_angle_format=actual_angle_fmt,
            vertex_copy_function=copy_function)


def gen_vertex_map_switch_string(vertex_table):
    angle_to_mtl = vertex_table["map"]
    angle_override = vertex_table["override"]
    override_packed = vertex_table["override_tightly_packed"]

    switch_data = ''
    for angle_fmt in sorted(angle_to_mtl.keys()):
        switch_data += gen_vertex_map_switch_case(angle_fmt, angle_fmt, angle_to_mtl,
                                                  override_packed)

    for angle_fmt in sorted(angle_override.keys()):
        switch_data += gen_vertex_map_switch_case(angle_fmt, angle_override[angle_fmt],
                                                  angle_to_mtl, override_packed)

    switch_data += "        default:\n"
    switch_data += "            this->metalFormat = MTLVertexFormatInvalid;\n"
    switch_data += "            this->actualFormatId = angle::FormatID::NONE;\n"
    switch_data += "            this->vertexLoadFunction = nullptr;"
    return switch_data


def main():
    # auto_script parameters.
    if len(sys.argv) > 1:
        inputs = ['mtl_format_map.json']
        outputs = ['mtl_format_table_autogen.mm']

        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print ','.join(outputs)
        else:
            print('Invalid script parameters')
            return 1
        return 0

    data_source_name = 'mtl_format_map.json'
    map_json = angle_format.load_json(data_source_name)
    map_image = map_json["image"]
    map_vertex = map_json["vertex"]

    image_switch_data = gen_image_map_switch_string(map_image)

    vertex_switch_data = gen_vertex_map_switch_string(map_vertex)

    output_cpp = template_autogen_inl.format(
        script_name=sys.argv[0],
        copyright_year=date.today().year,
        data_source_name=data_source_name,
        angle_image_format_switch=image_switch_data,
        angle_vertex_format_switch=vertex_switch_data)
    with open('mtl_format_table_autogen.mm', 'wt') as out_file:
        out_file.write(output_cpp)
        out_file.close()


if __name__ == '__main__':
    sys.exit(main())
