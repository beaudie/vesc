// GENERATED FILE - DO NOT EDIT.
// Generated by gen_vk_internal_shaders.py using data from shaders/src/*
//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// vk_internal_shaders_autogen.cpp:
//   Pre-generated shader library for the ANGLE Vulkan back-end.

#include "libANGLE/renderer/vulkan/vk_internal_shaders_autogen.h"

namespace rx
{
namespace vk
{
namespace
{
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000000.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000001.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000002.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000003.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000004.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000005.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000006.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000007.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000008.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.00000009.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.0000000A.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/BufferUtils.comp.0000000B.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/FullScreenQuad.vert.00000000.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/PushConstantColor.frag.00000000.inc"

// This is SPIR-V binary blob and the size.
struct ShaderBlob
{
    const uint32_t *code;
    size_t codeSize;
};

constexpr ShaderBlob kBufferUtils_comp_shaders[] = {
    {kBufferUtils_comp_00000000, sizeof(kBufferUtils_comp_00000000)},
    {kBufferUtils_comp_00000001, sizeof(kBufferUtils_comp_00000001)},
    {kBufferUtils_comp_00000002, sizeof(kBufferUtils_comp_00000002)},
    {kBufferUtils_comp_00000003, sizeof(kBufferUtils_comp_00000003)},
    {kBufferUtils_comp_00000004, sizeof(kBufferUtils_comp_00000004)},
    {kBufferUtils_comp_00000005, sizeof(kBufferUtils_comp_00000005)},
    {kBufferUtils_comp_00000006, sizeof(kBufferUtils_comp_00000006)},
    {kBufferUtils_comp_00000007, sizeof(kBufferUtils_comp_00000007)},
    {kBufferUtils_comp_00000008, sizeof(kBufferUtils_comp_00000008)},
    {kBufferUtils_comp_00000009, sizeof(kBufferUtils_comp_00000009)},
    {kBufferUtils_comp_0000000A, sizeof(kBufferUtils_comp_0000000A)},
    {kBufferUtils_comp_0000000B, sizeof(kBufferUtils_comp_0000000B)},
};
constexpr ShaderBlob kFullScreenQuad_vert_shaders[] = {
    {kFullScreenQuad_vert_00000000, sizeof(kFullScreenQuad_vert_00000000)},
};
constexpr ShaderBlob kPushConstantColor_frag_shaders[] = {
    {kPushConstantColor_frag_00000000, sizeof(kPushConstantColor_frag_00000000)},
};

angle::Result GetShader(Context *context,
                        RefCounted<ShaderAndSerial> *shaders,
                        const ShaderBlob *shaderBlobs,
                        size_t shadersCount,
                        uint32_t shaderFlags,
                        RefCounted<ShaderAndSerial> **shaderOut)
{
    ASSERT(shaderFlags < shadersCount);
    RefCounted<ShaderAndSerial> &shader = shaders[shaderFlags];
    *shaderOut                          = &shader;

    if (shader.get().valid())
    {
        return angle::Result::Continue();
    }

    // Create shader lazily. Access will need to be locked for multi-threading.
    const ShaderBlob &shaderCode = shaderBlobs[shaderFlags];
    ASSERT(shaderCode.code != nullptr);

    return InitShaderAndSerial(context, &shader.get(), shaderCode.code, shaderCode.codeSize);
}
}  // anonymous namespace

ShaderLibrary::ShaderLibrary() {}

ShaderLibrary::~ShaderLibrary() {}

void ShaderLibrary::destroy(VkDevice device)
{
    for (RefCounted<ShaderAndSerial> &shader : mBufferUtils_comp_shaders)
    {
        shader.get().destroy(device);
    }
    for (RefCounted<ShaderAndSerial> &shader : mFullScreenQuad_vert_shaders)
    {
        shader.get().destroy(device);
    }
    for (RefCounted<ShaderAndSerial> &shader : mPushConstantColor_frag_shaders)
    {
        shader.get().destroy(device);
    }
}

angle::Result ShaderLibrary::getBufferUtils_comp(Context *context,
                                                 uint32_t shaderFlags,
                                                 RefCounted<ShaderAndSerial> **shaderOut)
{
    return GetShader(context, mBufferUtils_comp_shaders, kBufferUtils_comp_shaders,
                     ArraySize(kBufferUtils_comp_shaders), shaderFlags, shaderOut);
}

angle::Result ShaderLibrary::getFullScreenQuad_vert(Context *context,
                                                    uint32_t shaderFlags,
                                                    RefCounted<ShaderAndSerial> **shaderOut)
{
    return GetShader(context, mFullScreenQuad_vert_shaders, kFullScreenQuad_vert_shaders,
                     ArraySize(kFullScreenQuad_vert_shaders), shaderFlags, shaderOut);
}

angle::Result ShaderLibrary::getPushConstantColor_frag(Context *context,
                                                       uint32_t shaderFlags,
                                                       RefCounted<ShaderAndSerial> **shaderOut)
{
    return GetShader(context, mPushConstantColor_frag_shaders, kPushConstantColor_frag_shaders,
                     ArraySize(kPushConstantColor_frag_shaders), shaderFlags, shaderOut);
}

}  // namespace vk
}  // namespace rx
