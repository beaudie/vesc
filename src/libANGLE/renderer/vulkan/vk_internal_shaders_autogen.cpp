// GENERATED FILE - DO NOT EDIT.
// Generated by gen_vk_internal_shaders.py using data from shaders/src/*
//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// vk_internal_shaders_autogen.cpp:
//   Pre-generated shader library for the ANGLE Vulkan back-end.

#include "libANGLE/renderer/vulkan/vk_internal_shaders_autogen.h"

namespace rx
{
namespace vk
{
namespace
{
#include "libANGLE/renderer/vulkan/shaders/gen/FullScreenQuad.vert.00000000.inc"
#include "libANGLE/renderer/vulkan/shaders/gen/PushConstantColor.frag.00000000.inc"

// This is SPIR-V binary blob and the size.
struct ShaderBlob
{
    const uint32_t *code;
    size_t codeSize;
};

constexpr ShaderBlob kFullScreenQuad_vert_shaders[] = {
    {kFullScreenQuad_vert_00000000, sizeof(kFullScreenQuad_vert_00000000)},
};
constexpr ShaderBlob kPushConstantColor_frag_shaders[] = {
    {kPushConstantColor_frag_00000000, sizeof(kPushConstantColor_frag_00000000)},
};

angle::Result GetShader(Context *context,
                        RefCounted<ShaderAndSerial> *shaders,
                        const ShaderBlob *shaderBlobs,
                        size_t shadersCount,
                        uint32_t shaderFlags,
                        RefCounted<ShaderAndSerial> **shaderOut)
{
    ASSERT(shaderFlags < shadersCount);
    RefCounted<ShaderAndSerial> &shader = shaders[shaderFlags];
    *shaderOut                          = &shader;

    if (shader.get().valid())
    {
        return angle::Result::Continue();
    }

    // Create shader lazily. Access will need to be locked for multi-threading.
    const ShaderBlob &shaderCode = shaderBlobs[shaderFlags];
    ASSERT(shaderCode.code != nullptr);

    return InitShaderAndSerial(context, &shader.get(), shaderCode.code, shaderCode.codeSize);
}
}  // anonymous namespace

ShaderLibrary::ShaderLibrary() {}

ShaderLibrary::~ShaderLibrary() {}

void ShaderLibrary::destroy(VkDevice device)
{
    for (RefCounted<ShaderAndSerial> &shader : mFullScreenQuad_vert_shaders)
    {
        shader.get().destroy(device);
    }
    for (RefCounted<ShaderAndSerial> &shader : mPushConstantColor_frag_shaders)
    {
        shader.get().destroy(device);
    }
}

angle::Result ShaderLibrary::getFullScreenQuad_vert(Context *context,
                                                    uint32_t shaderFlags,
                                                    RefCounted<ShaderAndSerial> **shaderOut)
{
    return GetShader(context, mFullScreenQuad_vert_shaders, kFullScreenQuad_vert_shaders,
                     ArraySize(kFullScreenQuad_vert_shaders), shaderFlags, shaderOut);
}

angle::Result ShaderLibrary::getPushConstantColor_frag(Context *context,
                                                       uint32_t shaderFlags,
                                                       RefCounted<ShaderAndSerial> **shaderOut)
{
    return GetShader(context, mPushConstantColor_frag_shaders, kPushConstantColor_frag_shaders,
                     ArraySize(kPushConstantColor_frag_shaders), shaderFlags, shaderOut);
}

}  // namespace vk
}  // namespace rx
