#! /usr/bin/python

# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_vk_overlay_fonts.py:
#  Code generation for overlay fonts.  Should be run when the font image files under overlay/
#  are changed.  All font images are assumed to contain a 32x3 grid of fixed-width font glyphs,
#  starting from ' ' up to '~' in ASCII order.
#  NOTE: don't run this script directly. Run scripts/run_code_generation.py.
#
# NOTE: you need to `pip install pillow` to run this script.

from datetime import date
import sys

if len(sys.argv) < 2:
    from PIL import Image

out_file_cpp = 'OverlayVk_font_autogen.cpp'
out_file_h = 'OverlayVk_font_autogen.h'
font_file_prefix = 'overlay/overlay_font_'
font_files = [
    font_file_prefix + 'large.png', font_file_prefix + 'medium.png', font_file_prefix + 'small.png'
]


def get_font_tag(font_file):
    return font_file[len(font_file_prefix):-4].capitalize()


template_out_file_h = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using images from overlay/*.png
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// {out_file_name}:
//   Autogenerated overlay font data.

#include "libANGLE/renderer/vulkan/OverlayVk.h"

namespace rx
{{
namespace overlay
{{
constexpr int kFontCount = {font_count};
constexpr int kFontGlyphWidths[kFontCount] = {{ {font_glyph_widths} }};
constexpr int kFontGlyphHeights[kFontCount] = {{ {font_glyph_heights} }};
constexpr int kFontCharactersPerRow = 32;
constexpr int kFontCharactersPerCol = 3;
constexpr int kFontCharacters = kFontCharactersPerRow * kFontCharactersPerCol;
constexpr int kFontImageWidth = {max_font_width} * kFontCharactersPerRow;
constexpr int kFontImageHeight = {max_font_height} * kFontCharactersPerCol;
{font_layers}
}}  // namespace overlay
}}  // namespace rx

"""

template_out_file_cpp = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using images from overlay/*.png
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// {out_file_name}:
//   Autogenerated overlay font data.

#include "libANGLE/renderer/vulkan/OverlayVk.h"
#include "libANGLE/renderer/vulkan/OverlayVk_font_autogen.h"

#include <numeric>

namespace rx
{{
using namespace overlay;

namespace
{{
constexpr int kFontWidths[kFontCount] = {{ {font_layer_widths} }};
constexpr int kFontHeights[kFontCount] = {{ {font_layer_heights} }};

{font_data}

// Returns a bit with the value of the pixel.
template<int kFontWidth, int kFontHeight>
uint32_t GetFontLayerPixel(const uint32_t fontImage[kFontHeight][kFontWidth / 32], int x, int y)
{{
    ASSERT(x >= 0 && x < kFontWidth && y >= 0 && y < kFontHeight);
    return fontImage[y][x / 32] >> (x % 32) & 1;
}}

inline uint32_t GetFontPixel(int layer, int x, int y)
{{
    switch (layer)
    {{
    {get_font_layer_pixel}
    default:
        UNREACHABLE();
        return 0;
    }}
}}

}}  // anonymous namespace

void OverlayVk::initFontData(uint8_t *fontData)
{{
    constexpr int kFontDataLayerSize = kFontImageWidth * kFontImageHeight;

    // Unpack the font bitmap into R8_UNORM format.  Border pixels are given a 0.5 value for better
    // font visibility.
    for (int layer = 0; layer < kFontCount; ++layer)
    {{
        memset(fontData, 0, kFontDataLayerSize);
        for (int y = 0; y < kFontHeights[layer]; ++y)
        {{
            for (int x = 0; x < kFontWidths[layer]; ++x)
            {{
                uint32_t src     = GetFontPixel(layer, x, y);
                uint8_t dstValue = src ? 255 : 0;
                fontData[y * kFontImageWidth + x] = dstValue;
            }}
        }}
        fontData += kFontDataLayerSize;
    }}
}}
}}  // namespace rx
"""

template_get_font_layer_pixel = u"""case {layer}:
    return GetFontLayerPixel<kFontWidths[{layer}], kFontHeights[{layer}]>({font_image}, x, y);
"""


def main():
    if len(sys.argv) == 2 and sys.argv[1] == 'inputs':
        print(','.join(font_files))
        return
    if len(sys.argv) == 2 and sys.argv[1] == 'outputs':
        print(','.join([out_file_cpp, out_file_h]))
        return

    font_glyph_widths = []
    font_glyph_heights = []
    font_layers = []
    font_data = []
    get_font_layer_pixel = []
    current_font_layer = 0

    for font_file in font_files:
        image = Image.open(font_file)

        # The image must be layed out as three rows of 32 monospace chars each.
        assert (image.size[0] % 32 == 0)
        assert (image.size[1] % 3 == 0)

        font_tag = get_font_tag(font_file)
        font_layer = str(current_font_layer)
        font_layer_symbol = 'kFontLayer' + font_tag
        font_array_name = 'kFontImage' + font_tag
        font_width = 'kFontWidths[' + font_layer_symbol + ']'
        font_height = 'kFontHeights[' + font_layer_symbol + ']'

        data = 'constexpr uint32_t ' + font_array_name + '[' + font_height + '][' + font_width + '/32] = {\n'
        for y in range(image.size[1]):
            data += '{'
            cur_bit = 0
            cur_word = 0
            for x in range(image.size[0]):
                pixel_value = image.getpixel((x, y))
                output_bit = 0 if pixel_value[0] > 191 else 1

                cur_word |= output_bit << cur_bit
                cur_bit = cur_bit + 1

                if cur_bit == 32:
                    data += '0x{:08X}, '.format(cur_word)
                    cur_bit = 0
                    cur_word = 0

            data += '},\n'
        data += '};\n'

        font_glyph_widths.append(image.size[0] / 32)
        font_glyph_heights.append(image.size[1] / 3)
        font_layers.append('constexpr int ' + font_layer_symbol + ' = ' + font_layer + ';')
        font_data.append(data)
        get_font_layer_pixel.append(
            template_get_font_layer_pixel.format(
                layer=font_layer_symbol, font_image=font_array_name))
        current_font_layer += 1

    with open(out_file_h, 'w') as outfile:
        outfile.write(
            template_out_file_h.format(
                script_name=__file__,
                copyright_year=date.today().year,
                out_file_name=out_file_h,
                font_count=len(font_data),
                font_glyph_widths=','.join(map(str, font_glyph_widths)),
                font_glyph_heights=','.join(map(str, font_glyph_heights)),
                max_font_width=max(font_glyph_widths),
                max_font_height=max(font_glyph_heights),
                font_layers='\n'.join(font_layers)))
        outfile.close()

    font_layer_widths = [
        'kFontGlyphWidths[' + str(layer) + '] * kFontCharactersPerRow'
        for layer in range(len(font_data))
    ]
    font_layer_heights = [
        'kFontGlyphHeights[' + str(layer) + '] * kFontCharactersPerCol'
        for layer in range(len(font_data))
    ]

    with open(out_file_cpp, 'w') as outfile:
        outfile.write(
            template_out_file_cpp.format(
                script_name=__file__,
                copyright_year=date.today().year,
                out_file_name=out_file_cpp,
                font_layer_widths=','.join(font_layer_widths),
                font_layer_heights=','.join(font_layer_heights),
                font_data='\n'.join(font_data),
                get_font_layer_pixel=''.join(get_font_layer_pixel)))
        outfile.close()


if __name__ == '__main__':
    sys.exit(main())
