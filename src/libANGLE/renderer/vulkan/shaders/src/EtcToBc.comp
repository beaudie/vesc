#version 450 core

#if EtcToBC1
#define OUTFORMAT rg32ui
#define DECODE_RGBA 1
#define ENCODE_RGB 1
#elif EtcToBC3
#define DECODE_RGBA 1
#define ENCODE_RGB 1
#define ENCODE_ALPHA 1
#define OUTFORMAT rgba32ui
#elif EtcToBC4
#define DECODE_R11 1
#define ENCODE_R11 1
#define OUTFORMAT rg32ui
#define R11 1
#elif EtcToBC5
#define DECODE_R11 1
#define ENCODE_R11 1
#define DECODE_G11 1
#define ENCODE_G11 1
#define OUTFORMAT rgba32ui
#define R11 1
#elif EtcToR8
#define DECODE_R11 1
#define OUTFORMAT r8ui
#define R11 1
#elif EtcToRG8
#define DECODE_R11 1
#define DECODE_G11 1
#define OUTFORMAT rg8ui
#define R11 1
#else //EtcToRGBA
#define DECODE_RGBA 1
#define OUTFORMAT rgba8ui
#endif


#if ENCODE_RGB || ENCODE_R11
#define SUBGROUP_OP 1
#define TRANSCODE 1
#endif


#if SUBGROUP_OP
#extension GL_KHR_shader_subgroup_clustered : enable
#extension GL_KHR_shader_subgroup_shuffle : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic: enable
#endif



layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(binding = 0) uniform highp usamplerBuffer  uInputBuffer;
layout(binding = 1, OUTFORMAT) writeonly uniform  uimage2D uOutput;


layout(push_constant) uniform imagInfo {
    // for transcode to BC the width and height need to be aligned to block size
    // we need full block data. if decode to RGBA, we don't need to write full block data out.
    // kOffsetX, kOffsetY both need to be multiple of four.
    uniform  int kOffsetX;
    uniform  int kOffsetY;
    uniform  int texelOffset;
    uniform  int kWidth;
    uniform  int kHeight;
    uniform  int kAlphaBits;
    uniform  int kIsSigned;
};


ivec2 build_coord()
{
    ivec2 base = ivec2(gl_WorkGroupID.xy) * 8;
    int blockid = int(gl_LocalInvocationID.x >> 4u);
    int blockxy = int(gl_LocalInvocationID.x & 0xfu);
    base.x +=  4 * (blockid & 0x1);
    base.y +=  2 * (blockid & 0x2);
    base += ivec2(blockxy & 0x3, blockxy >> 0x2);
    return base;
}

uint flip_endian(uint v)
{
    uvec4 words = uvec4(v) >> uvec4(0, 8, 16, 24);
    words &= 0xffu;
    return (words.x << 24u) | (words.y << 16u) | (words.z << 8u) | (words.w << 0u);
}

uvec2 flip_endian(uvec2 v)
{
    return uvec2(flip_endian(v.y), flip_endian(v.x));
}

const ivec2 etc1_color_modifier_table[8] = ivec2[](
    ivec2(2, 8),
    ivec2(5, 17),
    ivec2(9, 29),
    ivec2(13, 42),
    ivec2(18, 60),
    ivec2(24, 80),
    ivec2(33, 106),
    ivec2(47, 183));

const ivec4 etc2_alpha_modifier_table[16] = ivec4[](
    ivec4(2, 5, 8, 14),
    ivec4(2, 6, 9, 12),
    ivec4(1, 4, 7, 12),
    ivec4(1, 3, 5, 12),
    ivec4(2, 5, 7, 11),
    ivec4(2, 6, 8, 10),
    ivec4(3, 6, 7, 10),
    ivec4(2, 4, 7, 10),
    ivec4(1, 5, 7, 9),
    ivec4(1, 4, 7, 9),
    ivec4(1, 3, 7, 9),
    ivec4(1, 4, 6, 9),
    ivec4(2, 3, 6, 9),
    ivec4(0, 1, 2, 9),
    ivec4(3, 5, 7, 8),
    ivec4(2, 4, 6, 8)
);

const int etc2_distance_table[8] = int[](3, 6, 11, 16, 23, 32, 41, 64);

int decode_etc2_alpha(uvec2 payload, int linear_pixel)
{
    int bit_offset = 45 - 3 * linear_pixel;
#if R11
    int base = kIsSigned !=0 ? bitfieldExtract(int(payload.y), 24, 8) : int(bitfieldExtract(payload.y, 24, 8));
#else
    int base = int(bitfieldExtract(payload.y, 24, 8));
#endif
    int multiplier = int(bitfieldExtract(payload.y, 20, 4));
    int table = int(bitfieldExtract(payload.y, 16, 4));

    int lsb_index = int(bitfieldExtract(payload[bit_offset >> 5], bit_offset & 31, 2));
    bit_offset += 2;
    int msb = int((payload[bit_offset >> 5] >> (bit_offset & 31)) & 1u);
    int mod = etc2_alpha_modifier_table[table][lsb_index] ^ (msb - 1);
#if R11
    int a = base * 8 + 4;
    a += multiplier != 0 ? mod * multiplier * 8 : mod;
    int minValue = kIsSigned !=0 ? -1023: 0;
    int maxValue = kIsSigned !=0 ? 1023 : 2047;
    a = clamp(a, minValue, maxValue);
    float scale = kIsSigned !=0 ? 127.0f : 255.0f;
    return int(a/float(maxValue) * scale + 0.5f);  
#else
    int a = base + mod * multiplier;
    return clamp(a, 0, 0xff);
#endif
}

#if SUBGROUP_OP
uint GetIndicesRGB(vec3 color, vec3 minColor, vec3 maxColor)
{
    vec3 dir = minColor - maxColor;
    float distMin = dot(minColor, dir);
    float distMax = dot(maxColor, dir);
    float dist = dot(color, dir);
    uint factor = uint(clamp(int( (dist - distMax) / (distMin - distMax) * 3.0f + 0.5f), 0, 3));

    // Now we need to convert our index into the somewhat unintuivive BC1 indexing scheme:
    //  0: maxColor
    //  1: minColor
    //  2: (2/3)*maxColor + (1/3)*minColor
    //  3: (1/3)*maxColor + (2/3)*minColor
    //
    // The mapping is:
    //  0 -> 0
    //  1 -> 2
    //  2 -> 3
    //  3 -> 1
    //
    // We can perform this mapping using bitwise operations, which is faster
    // than predication or branching as long as it does not increase our register
    //  count too much. The mapping in binary looks like:
    //  00 -> 00
    //  01 -> 10
    //  10 -> 11
    //  11 -> 01
    //
    // Splitting it up by bit, the output looks like:
    //  bit1_out = bit0_in XOR bit1_in
    //  bit0_out = bit1_in
    uint bit0_in = factor & 1u;
    uint bit1_in = factor >> 1;
    return ((bit0_in^bit1_in) << 1) | bit1_in;
}

// Select end point using PCA
void ComputeMaxMinColor(uvec3 rgbColor, inout uvec3 minColor, inout uvec3 maxColor) {
    ivec3 dx = ivec3(rgbColor) - ivec3((subgroupClusteredAdd(rgbColor, 16)+8)>>4);
    float cov0 = float(subgroupClusteredAdd(dx.r*dx.r, 16));
    float cov1 = float(subgroupClusteredAdd(dx.r*dx.g, 16));
    float cov2 = float(subgroupClusteredAdd(dx.r*dx.b, 16));
    float cov3 = float(subgroupClusteredAdd(dx.g*dx.g, 16));
    float cov4 = float(subgroupClusteredAdd(dx.g*dx.b, 16));
    float cov5 = float(subgroupClusteredAdd(dx.b*dx.b, 16));

    vec3  vg = vec3(subgroupClusteredMax(rgbColor, 16) - subgroupClusteredMin(rgbColor, 16));
    float eigenvalue = 0.0f;

    // unroll ? compiler should do
    for( int i = 0; i<4; i++ ) {
        float r = dot(vec3(cov0, cov1, cov2), vg);
        float g = dot(vec3(cov1, cov3, cov4), vg);
        float b = dot(vec3(cov2, cov4, cov5), vg);
        vg = vec3(r, g, b);
        eigenvalue = sqrt(dot(vg, vg));
        if( eigenvalue > 0.0f ) {
            float invNorm = 1.0f/eigenvalue;
            vg *= invNorm;
        }
    }

    const float kDefaultLuminanceThreshold = 4.0f * 255;
    const float kQuantizeRange             = 0.512f;

    if (eigenvalue < kDefaultLuminanceThreshold) {
        vg = vec3(0.299f, 0.587f, 0.114f);
    }
    else {
        float magn = max(max(abs(vg.r), abs(vg.g)), abs(vg.b));
        vg *= kQuantizeRange / magn;
    }
    float dist = dot(vec3(rgbColor), vg);
    float min_dist = subgroupClusteredMin(dist, 16);
    float max_dist = subgroupClusteredMax(dist, 16);
    uint  min_index = subgroupClusteredMax(dist == min_dist? gl_SubgroupInvocationID : 0, 16);
    uint  max_index = subgroupClusteredMax(dist == max_dist? gl_SubgroupInvocationID : 0, 16);
    minColor = subgroupShuffle(rgbColor, min_index);
    maxColor = subgroupShuffle(rgbColor, max_index);
}

uint GetIndicesAlpha(int alpha, int minAlpha, int maxAlpha)
{
    float dist  = float(maxAlpha-minAlpha);
    uint ind = uint(float(alpha - minAlpha)/dist*7.0f + 0.5f);
    // 0 : maxAlpha
    // 1 : minAlpha
    // 2 : 6/7*maxAlpha + 1/7*minAlpha;
    // 3 : 5/7*maxAlpha + 2/7*minAlpha;
    // 4 : 4/7*maxAlpha + 3/7*minAlpha;
    // 5 : 3/7*maxAlpha + 4/7*minAlpha;
    // 6 : 2/7*maxAlpha + 5/7*minAlpha;
    // 7 : 1/7*maxAlpha + 6/7*minAlpha;
    // so the mapping is
    // 0 -> 1
    // 7 -> 0
    // 1 -> 7
    // 2 -> 6
    // 3 -> 5
    // 4 -> 4
    // 5 -> 3
    // 6 -> 2

    ind = -ind & 7;
    ind ^= int(2 > ind);
    return ind;
}

void ComputeMaxMin(int alpha, inout int minAlpha, inout int maxAlpha) {
    minAlpha = subgroupClusteredMin(alpha, 16);
    maxAlpha = subgroupClusteredMax(alpha, 16);
}
uvec2 EncodeBC4(int value, uint pid) {
    int minValue, maxValue;
    ComputeMaxMin(value, minValue, maxValue);
    uint indices = 0;
    if( minValue != maxValue )
        indices = GetIndicesAlpha(value, minValue, maxValue);

    uint indices0 = pid<5 ? indices<<(3*pid+16) : 0x0;
    uint indices1 = pid>5 ? indices<<(3*pid-16) : 0x0;
    if( pid == 5 ) {
        indices0 |= (indices&0x1)<<31;
        indices1 |= (indices&0x6)>>1;
    }
    uint mask0 = subgroupClusteredOr( indices0, 16);
    uint mask1 = subgroupClusteredOr( indices1, 16);
    
    return  uvec2((maxValue & 0xff) | ((minValue & 0xff) << 8) |  mask0, mask1);
}
#endif


#if DECODE_RGBA
ivec4 DecodeRGBA(ivec2 pixel_coord, uvec4 payload, int linear_pixel, inout bool punchthrough) {
    uvec2 color_payload;
    int alpha_result;
    if ( kAlphaBits == 8)
    {
        uvec2 alpha_payload = flip_endian(payload.xy);
        alpha_result = decode_etc2_alpha(alpha_payload, linear_pixel);
        color_payload = flip_endian(payload.zw);
    }
    else
    {
        color_payload = flip_endian(payload.xy);
        alpha_result = 0xff;
    }

    ivec3 rgb_result;
    ivec3 base_rgb;
    uint flip = color_payload.y & 1u;
    uint subblock = uint((pixel_coord[flip] & 2) >> 1);
    bool etc1_compat = false;

    if (kAlphaBits == 1)
        punchthrough = (color_payload.y & 2u) == 0u;
    else
        punchthrough = false;

    if (kAlphaBits != 1 && (color_payload.y & 2u) == 0u)
    {
        // Individual mode (ETC1)
        etc1_compat = true;
        base_rgb = ivec3(color_payload.yyy >> (uvec3(28, 20, 12) - 4u * subblock));
        base_rgb &= 0xf;
        base_rgb *= 0x11;
    }
    else
    {
        int r = int(bitfieldExtract(color_payload.y, 27, 5));
        int rd = bitfieldExtract(int(color_payload.y), 24, 3);
        int g = int(bitfieldExtract(color_payload.y, 19, 5));
        int gd = bitfieldExtract(int(color_payload.y), 16, 3);
        int b = int(bitfieldExtract(color_payload.y, 11, 5));
        int bd = bitfieldExtract(int(color_payload.y), 8, 3);

        int r1 = r + rd;
        int g1 = g + gd;
        int b1 = b + bd;

        if (uint(r1) > 31u) // T mode
        {
            int r1 = int(bitfieldExtract(color_payload.y, 56 - 32, 2)) |
                    (int(bitfieldExtract(color_payload.y, 59 - 32, 2)) << 2);
            int g1 = int(bitfieldExtract(color_payload.y, 52 - 32, 4));
            int b1 = int(bitfieldExtract(color_payload.y, 48 - 32, 4));
            int r2 = int(bitfieldExtract(color_payload.y, 44 - 32, 4));
            int g2 = int(bitfieldExtract(color_payload.y, 40 - 32, 4));
            int b2 = int(bitfieldExtract(color_payload.y, 36 - 32, 4));
            uint da = (bitfieldExtract(color_payload.y, 34 - 32, 2) << 1) |
                    (color_payload.y & 1u);
            int dist = etc2_distance_table[da];

            int msb = int((color_payload.x >> (15 + linear_pixel)) & 2u);
            int lsb = int((color_payload.x >> linear_pixel) & 1u);
            int index = msb | lsb;

            if (punchthrough)
                punchthrough = index == 2;

            if (index == 0)
            {
                rgb_result = ivec3(r1, g1, b1);
                rgb_result *= 0x11;
            }
            else
            {
                int mod = 2 - index;
                ivec3 rgb = ivec3(r2, g2, b2) * 0x11 + mod * dist;
                rgb_result = ivec3(clamp(rgb, ivec3(0), ivec3(255)));
            }
        }
        else if (uint(g1) > 31u) // H mode
        {
            int r1 = int(bitfieldExtract(color_payload.y, 59 - 32, 4));
            int g1 = (int(bitfieldExtract(color_payload.y, 56 - 32, 3)) << 1) |
                    int((color_payload.y >> 20u) & 1u);
            int b1 = int(bitfieldExtract(color_payload.y, 47 - 32, 3)) |
                    int((color_payload.y >> 16u) & 8u);
            int r2 = int(bitfieldExtract(color_payload.y, 43 - 32, 4));
            int g2 = int(bitfieldExtract(color_payload.y, 39 - 32, 4));
            int b2 = int(bitfieldExtract(color_payload.y, 35 - 32, 4));
            uint da = color_payload.y & 4u;
            uint db = color_payload.y & 1u;
            uint d = da + 2u * db;
            d += uint((r1 * 0x10000 + g1 * 0x100 + b1) >= (r2 * 0x10000 + g2 * 0x100 + b2));
            int dist = etc2_distance_table[d];
            int msb = int((color_payload.x >> (15 + linear_pixel)) & 2u);
            int lsb = int((color_payload.x >> linear_pixel) & 1u);

            if (punchthrough)
                punchthrough = (msb + lsb) == 2;

            ivec3 base = msb != 0 ? ivec3(r2, g2, b2) : ivec3(r1, g1, b1);
            base *= 0x11;
            int mod = 1 - 2 * lsb;
            base += mod * dist;
            rgb_result = ivec3(clamp(base, ivec3(0), ivec3(0xff)));
        }
        else if (uint(b1) > 31u) // plane mode
        {
            // Planar mode
            int r = int(bitfieldExtract(color_payload.y, 57 - 32, 6));
            int g = int(bitfieldExtract(color_payload.y, 49 - 32, 6)) |
                    (int(color_payload.y >> 18) & 0x40);
            int b = int(bitfieldExtract(color_payload.y, 39 - 32, 3)) |
                    (int(bitfieldExtract(color_payload.y, 43 - 32, 2)) << 3) |
                    (int(color_payload.y >> 11) & 0x20);
            int rh = int(color_payload.y & 1u) |
                    (int(bitfieldExtract(color_payload.y, 2, 5)) << 1);
            int rv = int(bitfieldExtract(color_payload.x, 13, 6));
            int gh = int(bitfieldExtract(color_payload.x, 25, 7));
            int gv = int(bitfieldExtract(color_payload.x, 6, 7));
            int bh = int(bitfieldExtract(color_payload.x, 19, 6));
            int bv = int(bitfieldExtract(color_payload.x, 0, 6));

            r = (r << 2) | (r >> 4);
            rh = (rh << 2) | (rh >> 4);
            rv = (rv << 2) | (rv >> 4);
            g = (g << 1) | (g >> 6);
            gh = (gh << 1) | (gh >> 6);
            gv = (gv << 1) | (gv >> 6);
            b = (b << 2) | (b >> 4);
            bh = (bh << 2) | (bh >> 4);
            bv = (bv << 2) | (bv >> 4);

            ivec3 rgb = ivec3(r, g, b);
            ivec3 dx = ivec3(rh, gh, bh) - rgb;
            ivec3 dy = ivec3(rv, gv, bv) - rgb;
            dx *= pixel_coord.x;
            dy *= pixel_coord.y;
            rgb = rgb + ((dx + dy + 2) >> 2);
            rgb = clamp(rgb, ivec3(0), ivec3(255));
            rgb_result = ivec3(rgb);
            punchthrough = false;
        }
        else // diff mode
        {
            // Differential mode (ETC1)
            etc1_compat = true;
            base_rgb = ivec3(r, g, b) + int(subblock) * ivec3(rd, gd, bd);
            base_rgb = (base_rgb << 3) | (base_rgb >> 2);
        }
    }

    if (etc1_compat)
    {
        uint etc1_table_index = bitfieldExtract(color_payload.y, 5 - 3 * int(subblock != 0u), 3);
        int msb = int((color_payload.x >> (15 + linear_pixel)) & 2u);
        int lsb = int((color_payload.x >> linear_pixel) & 1u);
        int sgn = 1 - msb;
        if (punchthrough)
        {
            sgn *= lsb;
            punchthrough = (msb + lsb) == 2;
        }
        int offset = etc1_color_modifier_table[etc1_table_index][lsb] * sgn;
        base_rgb = clamp(base_rgb + offset, ivec3(0), ivec3(255));
        rgb_result = ivec3(base_rgb);
    }

    if (kAlphaBits == 1 && punchthrough)
    {
        rgb_result = ivec3(0);
        alpha_result = 0;
    }
    return ivec4(rgb_result.r, rgb_result.g, rgb_result.b, alpha_result);
}
#endif


uint packColorToRGB565(uvec3 color) {
    return ((color.r>>3)<<11) | ((color.g>>2)<<5) | (color.b>>3);
}


void swap( inout uint a, inout uint b) {
    uint t = a;
    a = b;
    b = t;
}


void main()
{
    ivec2 coord = build_coord();
    if( any(greaterThanEqual(coord, ivec2(kWidth, kHeight)) ))
        return;

    ivec2 tile_coord = coord >> 2;
    ivec2 pixel_coord = coord & 3;
    int linear_pixel = 4 * pixel_coord.x + pixel_coord.y;
    int pid = 4 * pixel_coord.y + pixel_coord.x;
#if TRANSCODE
    int texOffsetY = kWidth >> 2;
#else
    int texOffsetY = ((kWidth+3)>>2);
#endif
    uvec4 payload = texelFetch(uInputBuffer, tile_coord.y * texOffsetY + tile_coord.x + texelOffset);

    ivec4 result;
#if DECODE_RGBA
    bool punchthrough;
    result = DecodeRGBA(pixel_coord, payload, linear_pixel, punchthrough);
#endif

#if DECODE_R11
    result.r = decode_etc2_alpha(flip_endian(payload.xy), linear_pixel);
#endif

#if DECODE_G11
    result.g = decode_etc2_alpha(flip_endian(payload.zw), linear_pixel);
#endif

    uvec4 finalResult;
#if ENCODE_RGB
    uvec3 minColor, maxColor;
    ComputeMaxMinColor(uvec3(result.r, result.g, result.b), minColor, maxColor);

    uint minColor565 = packColorToRGB565(minColor);
    uint maxColor565 = packColorToRGB565(maxColor);
    if (minColor565 > maxColor565) {
        swap(minColor565, maxColor565);
    }
    uint indices = 0;
    if( minColor565 != maxColor565 ) {
        indices = GetIndicesRGB(vec3(result.r, result.g, result.b), vec3(minColor), vec3(maxColor));
    }
    else {
        indices = punchthrough && result.a == 0? 0x3u : 0x0u;
    }
    uint mask = subgroupClusteredOr(indices << (2*pid), 16);
#if ENCODE_ALPHA
    finalResult.b = maxColor565 | (minColor565<<16);
    finalResult.a = mask;
#else
    finalResult.r = maxColor565 | (minColor565<<16);
    finalResult.g = mask;
#endif
#endif

#if ENCODE_ALPHA
    finalResult.rg = EncodeBC4(result.a, pid);
#endif

#if ENCODE_R11
    finalResult.rg = EncodeBC4(result.r, pid);
#endif

#if ENCODE_G11
    finalResult.ba = EncodeBC4(result.g, pid);
#endif

#if TRANSCODE
    if( pid == 0 ) {
        tile_coord += ivec2(kOffsetX/4, kOffsetY/4);
        imageStore(uOutput, tile_coord, finalResult);
    }
#else
    coord +=  ivec2(kOffsetX, kOffsetY);
    imageStore(uOutput, coord, uvec4(result));
#endif
}
