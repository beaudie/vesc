//
// Copyright 2024 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// ClearTexture.comp: Generates the buffer data to clear a texture to a
// constant value based on the input data.

#version 450 core
layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) buffer dest
{
    uint dataBuffer[];
};

layout (push_constant) uniform PushConstants
{
    uint data[4];
    uint texelCount;
} params;

void main()
{
    uint threadId = gl_GlobalInvocationID.x;
    uint texelCount = params.texelCount;
#if Pixel1Byte
    if (threadId >= ceil(texelCount / 4))
    {
        return;
    }
    uint byteData = params.data[0] & 0xFF;
    dataBuffer[threadId] = (byteData) | (byteData << 8) | (byteData << 16) | (byteData << 24);
#elif Pixel2Byte
    if (threadId >= ceil(texelCount / 2))
    {
        return;
    }
    uint byteData = params.data[0] & 0xFFFF;
    dataBuffer[threadId] = (byteData) | (byteData << 16);
#elif Pixel3Byte
    if (threadId >= ceil(texelCount * 3 / 4))
    {
        return;
    }

    uint shift = (threadId % 3) * 8;
    uint byteData = params.data[0];

    dataBuffer[threadId] = (byteData >> shift) | (byteData << (24 - shift));

#elif Pixel4Byte
    if (threadId >= texelCount)
    {
        return;
    }
    dataBuffer[threadId] = params.data[0];
#elif Pixel4ByteDS
    // For D24S8, the 24-bit depth will use the entire uint.
    if (threadId >= texelCount)
    {
        return;
    }

    uint depthValue = params.data[0] & 0xFFFFFF;
    dataBuffer[threadId] = depthValue;

    if (threadId > texelCount)
    {
        return;
    }

    barrier();

    // The stencil data will follow the depth data.
    uint offset = uint(ceil(texelCount));
    uint stencilValue = params.data[0] >> 24;
    dataBuffer[threadId + offset] = (stencilValue) | (stencilValue << 8) | (stencilValue << 16) | (stencilValue << 24);

#elif Pixel8Byte
    if (threadId >= texelCount)
    {
        return;
    }
    dataBuffer[threadId * 2] = params.data[0];
    dataBuffer[threadId * 2 + 1] = params.data[1];

#elif Pixel8ByteDS
    // The depth data will use 4 bytes.
    if (threadId >= texelCount)
    {
        return;
    }
    dataBuffer[threadId] = params.data[0];

    if (threadId > ceil(texelCount / 4))
    {
        return;
    }

    barrier();

    // The stencil data will follow the depth data.
    uint offset = texelCount;
    uint stencilValue = params.data[1] & 0xFF;
    dataBuffer[threadId + offset] = (stencilValue) | (stencilValue << 8) | (stencilValue << 16) | (stencilValue << 24);

#elif Pixel16Byte
    if (threadId >= texelCount)
    {
        return;
    }
    dataBuffer[threadId * 4] = params.data[0];
    dataBuffer[threadId * 4 + 1] = params.data[1];
    dataBuffer[threadId * 4 + 2] = params.data[2];
    dataBuffer[threadId * 4 + 3] = params.data[3];
#else
#error "Undefined behavior"
#endif
}

