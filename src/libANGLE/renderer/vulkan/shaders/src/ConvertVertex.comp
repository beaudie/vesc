//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// ConvertVertex.comp: vertex buffer conversion.  Implements functionality in copyvertex.inc.
//
// Each thread of the dispatch call fills in one 4-byte element, no matter how many components
// fit in it.  The src data is laid out in the most general form as follows.  Note that component
// size is assumed to divide buffer stride.
//
//    Ns components, each Bs bytes
//         ____^____
//        /         \
//       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
//       |C1|C2|..|CN|..|..|..|..|C1|C2|..|CN|..|..|..|..|C1|C2|..|CN| ... Repeated V times
//       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
//        \__________ __________/
//                   V
//           Ss bytes of stride
//
// The output is the array of components converted to the destination format (each Bd bytes) with
// stride Sd = Nd*Bd (i.e. packed).  The output size is therefore V*Nd*Bd bytes.  The dispatch size
// is accordingly ciel(V*Nd*Bd / 4).
//
// The input is received in 4-byte elements, therefore each element has Es=4/Bs components.
//
// To output exactly one 4-byte element, each thread is responsible for Ed=4/Bd components.
// Therefore, thread t is responsible for component indices [Ed*t, Ed*(t + 1)).
//
// Component index c is at source offset:
//
//     floor(c / Ns) * Ss + mod(c, Ns) * Bs
//
//   - Flags:
//     * IsAligned: if true, assumes the workgroup size divides the output count, so there is no
//                  need for bound checking
//     * IsBigEndian
//   - Conversion:
//     * IntToInt: covers byte, short and int types (distinguished by Bs and Bd).
//     * UintToUint: covers ubyte, ushort and uint types (distinguished by Bs and Bd).
//     * IntToFloat: Same types as IntToInt for source (including scaled).  Converts to float.
//     * UintToFloat: Same types as UintToUint for source (including uscaled).  Converst to float.
//     * SnormToFloat: Similar to IntToFloat, but normalized.
//     * UnormToFloat: Similar to UintToFloat, but normalized.
//     * FixedToFloat: 16.16 signed fixed-point to floating point.
//     * FloatToFloat: float.
//
// IntToInt, UintToUint and FloatToFloat correspond to CopyNativeVertexData() and
// Copy8SintTo16SintVertexData() in renderer/copyvertex.inc, FixedToFloat corresponds to
// Copy32FixedTo32FVertexData, IntToFloat and UintToFloat correspond to CopyTo32FVertexData with
// normalized=false and SnormToFloat and UnormToFloat correspond to CopyTo32FVertexData with
// normalized=true.
//

#version 450 core

// Source type
#if IntToInt || IntToFloat
#define SrcType int
#define SrcTypeVec4 ivec4
#elif UintToUint || UintToFloat
#define SrcType uint
#define SrcTypeVec4 uvec4
#elif SnormToFloat || UnormToFloat || FixedToFloat || FloatToFloat
#define SrcType float
#define SrcTypeVec4 vec4
#else
#error "Not all conversions are accounted for"
#endif

// Destination type
#if IntToInt
#define DestType int
#define DestTypeVec4 ivec4
#elif UintToUint
#define DestType uint
#define DestTypeVec4 uvec4
#elif IntToFloat || UintToFloat || SnormToFloat || UnormToFloat || FixedToFloat || FloatToFloat
#define DestType float
#define DestTypeVec4 vec4
#else
#error "Not all conversions are accounted for"
#endif

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) buffer dest
{
    uint destData[];
};

layout (set = 0, binding = 1) uniform src
{
    uint srcData[];
};

layout (push_constant) uniform PushConstants
{
    // total number of components to convert; used for range checking
    uint componentCount;

    // Parameters from the above explanation
    uint Ns;       // Number of source components in one vertex attribute
    uint Bs;       // Source component byte size
    uint Ss;       // Source vertex attribyte byte stride
    uint Es;       // Precalculated 4/Bs

    uint Nd;       // Number of destination components in one vertex attribute
    uint Bd;       // Destination component byte size
    uint Sd;       // Precalculated Nd*Bd
    uint Ed;       // Precalculated 4/Bd

    SrcType alpha; // Default alpha value.  Note that extra channels turn to 0, but alpha has a
                   // special default value.
} params;

uint getSourceComponentOffset(uint vertex, uint component)
{
    return vertex * Ss + component * Bs;
}

uint getDestinationComponentOffset(uint vertex, uint component)
{
    return vertex * Nd * Bd + component * Bd;
}

SrcType loadSourceComponent(uint cd)
{
    // cd is component index in the destination buffer, which is equal to t (invocation id)
    uint vertex = cd / Nd;
    uint component = cd % Nd;

    // If no such component, return 0, unless it's component three, in which case return default
    // alpha
    if (component >= Ns)
        return component == 3 ? alpha : 0;

    // Load the source component
    uint offset = getSourceComponentOffset(vertex, component);
    uint block = srcData[offset / Es];
    uint shift = offset % Es;

    // If big-endian, the most-significant bits contain the first components, so we reverse the
    // shift count.
#if IsBigEndian
    shift = Es - 1 - shift;
#endif

    uint valueBits = Bs * 8;
    uint valueMask = (1 << valueBits) - 1;
    uint valueAsUint = (block >> (shift * valueBits)) & valueMask;

    //TODO: convert to SrcType
}

DestType convertComponent(SrcType)
{
    // TODO
}

uint makeDestinationComponent(uint cd, DestType value)
{
    // TODO: return valueAsUint, shifted to the right spot.  Multiple calls to this function should
    // be |ed and eventually written to the destination.
}

void storeDestinationComponents(uint cd, uint valuesAsUint)
{
    // TODO
}

// TODO

#if IsFloat
#define ADD_TYPE_PREFIX(type) type
#define BUFFER_FORMAT rgba32f
#define GVEC4 vec4
#elif IsInt
#define ADD_TYPE_PREFIX(type) i ## type
#define BUFFER_FORMAT rgba32i
#define GVEC4 ivec4
#elif IsUint
#define ADD_TYPE_PREFIX(type) u ## type
#define BUFFER_FORMAT rgba32ui
#define GVEC4 uvec4
#else
#error "Not all formats are accounted for"
#endif

#define BUFFER_WRITE_TYPE ADD_TYPE_PREFIX(imageBuffer)
#define BUFFER_READ_TYPE ADD_TYPE_PREFIX(samplerBuffer)

layout (set = 0, binding = 0, BUFFER_FORMAT) uniform writeonly BUFFER_WRITE_TYPE dest;
#if IsCopy
layout (set = 0, binding = 1) uniform BUFFER_READ_TYPE src;
#endif // IsCopy

layout (push_constant) uniform PushConstants
{
    // destOffset: used in all cases
    uint destOffset;
    // size: used if !IsAligned
    uint size;
    // srcOffset: used if IsCopy
    uint srcOffset;
    uint padding;
    // clearValue: used if IsClear
    GVEC4 clearValue;
} params;

void main()
{
#if !IsAligned
    if (gl_GlobalInvocationID.x >= params.size)
        return;
#endif // IsAligned

    int destIndex = int(params.destOffset.x + gl_GlobalInvocationID.x);
    int srcIndex = int(params.srcOffset.x + gl_GlobalInvocationID.x);

#if IsClear
    GVEC4 srcValue = params.clearValue;
#elif IsCopy
    GVEC4 srcValue = texelFetch(src, srcIndex);
#else
#error "Not all functions are accounted for"
#endif // Function

    imageStore(dest, destIndex, srcValue);
}
