//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// DispatchUtils.comp: various utilities such as clear and copy.
//
// The following defines tweak the functionality, and a differnt shader is built based on these
//
//   - Flags:
//     * IsAligned: if true, assumes the workgroup size divides the resource size, so there is no need for bound checking
//   - Format:
//     * IsFloat
//     * IsInt
//     * IsUint
//   - Function:
//     * IsClear: the resource will be created
//     * IsCopy: a resource will be copied to another
//   - Resource Type:
//     * IsBuffer: operates on a buffer
//     * IsTexture1d: operates on a 1D texture
//     * IsTexture2d: operates on a 2D texture
//     * IsTexture3d: operates on a 3D texture
//     * IsTexture2darray: operates on a 2D array texture
//

#version 450 core

// Choose a workgroup size that's likely to result in better cache locality w.r.t to texture tiling.
#if IsBuffer || IsTexture1d
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
#elif IsTexture2d || IsTexture2darray
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
#elif IsTexture3d
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
#else
#error "Not all resource types are accounted for"
#endif // Resource Type

#if IsFloat
#define BUFFER imageBuffer
#define IMAGE1D image1D
#define IMAGE2D image2D
#define IMAGE3D image3D
#define IMAGE2DARRAY image2DArray
#define IMAGE_FORMAT rgba32f
#elif IsInt
#define BUFFER iimageBuffer
#define IMAGE1D iimage1D
#define IMAGE2D iimage2D
#define IMAGE3D iimage3D
#define IMAGE2DARRAY iimage2DArray
#define IMAGE_FORMAT rgba32i
#elif IsUint
#define BUFFER uimageBuffer
#define IMAGE1D uimage1D
#define IMAGE2D uimage2D
#define IMAGE3D uimage3D
#define IMAGE2DARRAY uimage2DArray
#define IMAGE_FORMAT rgba32ui
#else
#error "Not all formats are accounted for"
#endif // IsInt

// Define the resources.  Destination is always on set 0, binding 0.  If copy, source is on set 0, binding 1
#if IsBuffer
layout (set = 0, binding = 0, IMAGE_FORMAT) uniform writeonly BUFFER dest;
#elif IsTexture1d
layout (set = 0, binding = 0, IMAGE_FORMAT) uniform writeonly IMAGE1D dest;
#elif IsTexture2d
layout (set = 0, binding = 0, IMAGE_FORMAT) uniform writeonly IMAGE2D dest;
#elif IsTexture3d
layout (set = 0, binding = 0, IMAGE_FORMAT) uniform writeonly IMAGE3D dest;
#elif IsTexture2darray
layout (set = 0, binding = 0, IMAGE_FORMAT) uniform writeonly IMAGE2DARRAY dest;
#else
#error "Not all resource types are accounted for"
#endif // Resource Type

#if IsCopy
#if IsBuffer
layout (set = 0, binding = 1, IMAGE_FORMAT) uniform readonly BUFFER src;
#elif IsTexture1d
layout (set = 0, binding = 1, IMAGE_FORMAT) uniform readonly IMAGE1D src;
#elif IsTexture2d
layout (set = 0, binding = 1, IMAGE_FORMAT) uniform readonly IMAGE2D src;
#elif IsTexture3d
layout (set = 0, binding = 1, IMAGE_FORMAT) uniform readonly IMAGE3D src;
#elif IsTexture2darray
layout (set = 0, binding = 1, IMAGE_FORMAT) uniform readonly IMAGE2DARRAY src;
#else
#error "Not all resource types are accounted for"
#endif // Resource Type
#endif // IsCopy

layout (push_constant) uniform PushConstants
{
    // destOffset: used in all cases
    uvec3 destOffset;
    uint padding1;
    // extents: used if !IsAligned
    uvec3 extents;
    uint padding2;
    // srcOffset: used if IsCopy
    uvec3 srcOffset;
    uint padding3;
    // clearValue and clearValuef: used if IsClear, value taken based on IsFloat or not
    uvec4 clearValue;
    vec4 clearValuef;
} params;


void main()
{
#if !IsAligned
#if IsBuffer || IsTexture1d
    if (gl_GlobalInvocationID.x >= params.extents.x)
        return;
#elif IsTexture2d
    if (gl_GlobalInvocationID.x >= params.extents.x
            || gl_GlobalInvocationID.y >= params.extents.y)
        return;
#elif IsTexture3d || IsTexture2darray
    if (gl_GlobalInvocationID.x >= params.extents.x
            || gl_GlobalInvocationID.y >= params.extents.y
            || gl_GlobalInvocationID.z >= params.extents.z)
        return;
#else
#error "Not all texture types are accounted for"
#endif // IsTexture*
#endif // IsAligned

#if IsBuffer || IsTexture1d
    int destIndex = int(params.destOffset.x + gl_GlobalInvocationID.x);
    int srcIndex = int(params.srcOffset.x + gl_GlobalInvocationID.x);
#elif IsTexture2d
    ivec2 destIndex = ivec2(params.destOffset.xy + gl_GlobalInvocationID.xy);
    ivec2 srcIndex = ivec2(params.srcOffset.xy + gl_GlobalInvocationID.xy);
#elif IsTexture3d || IsTexture2darray
    ivec3 destIndex = ivec3(params.destOffset.xyz + gl_GlobalInvocationID.xyz);
    ivec3 srcIndex = ivec3(params.srcOffset.xyz + gl_GlobalInvocationID.xyz);
#else
#error "Not all texture types are accounted for"
#endif // IsTexture*

#if IsClear
#if IsFloat
    imageStore(dest, destIndex, params.clearValuef);
#elif IsInt
    imageStore(dest, destIndex, ivec4(params.clearValue));
#elif IsUint
    imageStore(dest, destIndex, params.clearValue);
#else
#error "Not all formats are accounted for"
#endif // IsFloat
#elif IsCopy
    imageStore(dest, destIndex, imageLoad(src, srcIndex));
#else
#error "Not all functions are accounted for"
#endif // Function
}
