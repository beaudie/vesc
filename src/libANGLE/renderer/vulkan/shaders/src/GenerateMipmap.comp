//
// Copyright 2020 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// GenerateMipmap.comp: Generate mipmap of texture in a single pass.  Uses AMD's FFX SPD located in
// third_parth/ffx_spd/.

#version 450 core

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_samplerless_texture_functions : require

#if UseFloat16
#define DST_FORMAT rgba16
#else
#define DST_FORMAT rgba32f
#endif

// TODO: Support sRGB
// TODO: Support non-float formats
// TODO: Support subgroup mode

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, DST_FORMAT) uniform coherent image2D dst[12];
layout(set = 0, binding = 1) uniform sampler2D src;
layout(set = 0, binding = 2) coherent buffer GlobalAtomic
{
    uint counter;
} globalAtomic;

layout(push_constant) uniform PushConstants {
    // Number of levels to generate mipmaps for.
    uint levelCount;
    // Total number of thread groups, i.e. numWorkGroupsX * numWorkGroupsY.
    uint numWorkGroups;
    // Inverse extents of src image for uv calculation.
    vec2 invSrcExtent;
} params;

#define A_GPU
#define A_GLSL

// For 8- and 16-bit-per-channel images, use half instead of float if supported.
#if UseFloat16
#define A_HALF
#endif

#include "third_party/ffx_spd/ffx_a.h"

// Shared memory
#ifdef A_HALF
shared AH4 spd_intermediate[16][16];
#else
shared AF4 spd_intermediate[16][16];
#endif
shared AU1 spd_counter;

#define SPD_NO_WAVE_OPERATIONS

// Use a linear sampler to sample from mip 0 instead of multiple loads and manual averaging.
#define SPD_LINEAR_SAMPLER

// Utility functions used by ffx_spd.h

#ifdef A_HALF

#define SPD_PACKED_ONLY

// Load from source image
AH4 SpdLoadSourceImageH(ASU2 p)
{
   AF2 textureCoord = p * params.invSrcExtent + params.invSrcExtent;
   return AH4(texture(src, textureCoord));
}

// SpdLoadH() takes a 32-bit signed integer 2D coordinate and loads color.
// Loads the 5th mip level, each value is computed by a different thread group
// last thread group will access all its elements and compute the subsequent mips
AH4 SpdLoadH(ASU2 p)
{
    return AH4(imageLoad(dst[5], p));
}

// Define the store function
void SpdStoreH(ASU2 p, AH4 value, AU1 mip)
{
    imageStore(dst[mip], p, AF4(value));
}

// Define the lds load and store functions
// GLSL:
AH4 SpdLoadIntermediateH(AU1 x, AU1 y)
{
    return spd_intermediate[x][y];
}
void SpdStoreIntermediateH(AU1 x, AU1 y, AH4 value)
{
    spd_intermediate[x][y] = value;
}

// Define your reduction function: takes as input the four 2x2 values and returns 1 output value
AH4 SpdReduce4H(AH4 v0, AH4 v1, AH4 v2, AH4 v3)
{
    return (v0 + v1 + v2 + v3) * AH1(0.25);
}

#else  // A_HALF

// Load from source image
AF4 SpdLoadSourceImage(ASU2 p)
{
    AF2 textureCoord = p * params.invSrcExtent + params.invSrcExtent;
    return texture(src, textureCoord);
}

// SpdLoad() takes a 32-bit signed integer 2D coordinate and loads color.
// Loads the 5th mip level, each value is computed by a different thread group
// last thread group will access all its elements and compute the subsequent mips
AF4 SpdLoad(ASU2 p)
{
    return imageLoad(dst[5], p);
}

// Define the store function
void SpdStore(ASU2 p, AF4 value, AU1 mip)
{
    imageStore(dst[mip], p, value);
}

// Define the LDS load and store functions
AF4 SpdLoadIntermediate(AU1 x, AU1 y)
{
    return spd_intermediate[x][y];
}
void SpdStoreIntermediate(AU1 x, AU1 y, AF4 value)
{
    spd_intermediate[x][y] = value;
}

// Define your reduction function: takes as input the four 2x2 values and returns 1 output value
AF4 SpdReduce4(AF4 v0, AF4 v1, AF4 v2, AF4 v3)
{
    return (v0 + v1 + v2 + v3) * 0.25;
}
#endif  // A_HALF

// Define the atomic counter increase function
void SpdIncreaseAtomicCounter()
{
    spd_counter = atomicAdd(globalAtomic.counter, 1);
}
AU1 SpdGetAtomicCounter()
{
    return spd_counter;
}

#include "third_party/ffx_spd/ffx_spd.h"

void main()
{
#ifdef A_HALF
    SpdDownsampleH(gl_WorkGroupID.xy, gl_LocalInvocationIndex,
            params.levelCount, params.numWorkGroups);
#else
    SpdDownsample(gl_WorkGroupID.xy, gl_LocalInvocationIndex,
            params.levelCount, params.numWorkGroups);
#endif
}
