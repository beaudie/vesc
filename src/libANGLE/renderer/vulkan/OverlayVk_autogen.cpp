// GENERATED FILE - DO NOT EDIT.
// Generated by gen_vk_overlay_items.py using data from vk_overlay_items.json.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// OverlayVk_autogen.cpp:
//   Autogenerated overlay item declarations.

#include "libANGLE/renderer/driver_utils.h"
#include "libANGLE/renderer/vulkan/OverlayVk.h"
#include "libANGLE/renderer/vulkan/OverlayVk_font_autogen.h"

namespace rx
{
using namespace overlay;

namespace
{
int GetFontSize(int fontSize, bool largeFont)
{
    if (largeFont && fontSize > 0)
    {
        return fontSize - 1;
    }
    return fontSize;
}
}  // anonymous namespace

void OverlayVk::initOverlayItems()
{
    const bool kLargeFont = IsAndroid();

    {
        PerSecond *item = new PerSecond;
        {
            const int32_t fontSize = GetFontSize(kFontLayerMedium, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = 10;
            const int32_t width    = 12 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            item->type      = OverlayType::PerSecond;
            item->fontSize  = fontSize;
            item->coords[0] = offsetX;
            item->coords[1] = offsetY;
            item->coords[2] = offsetX + width;
            item->coords[3] = offsetY + height;
            item->color[0]  = 0.498039215686;
            item->color[1]  = 0.749019607843;
            item->color[2]  = 1.0;
            item->color[3]  = 1.0;
        }
        mOverlayItems[OverlayId::FPS] = item;
    }

    {
        Text *item = new Text;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = -10;
            const int32_t width    = 150 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            item->type      = OverlayType::Text;
            item->fontSize  = fontSize;
            item->coords[0] = offsetX;
            item->coords[1] = offsetY - height;
            item->coords[2] = offsetX + width;
            item->coords[3] = offsetY;
            item->color[0]  = 1.0;
            item->color[1]  = 0.0;
            item->color[2]  = 0.0;
            item->color[3]  = 1.0;
        }
        mOverlayItems[OverlayId::LastValidationMessage] = item;
    }

    {
        Count *item = new Count;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = mOverlayItems[OverlayId::LastValidationMessage]->coords[1];
            const int32_t width    = 25 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            item->type      = OverlayType::Count;
            item->fontSize  = fontSize;
            item->coords[0] = offsetX;
            item->coords[1] = offsetY - height;
            item->coords[2] = offsetX + width;
            item->coords[3] = offsetY;
            item->color[0]  = 1.0;
            item->color[1]  = 0.0;
            item->color[2]  = 0.0;
            item->color[3]  = 1.0;
        }
        mOverlayItems[OverlayId::ValidationMessageCount] = item;
    }

    {
        RunningGraph *item = new RunningGraph(60);
        {
            const int32_t fontSize = GetFontSize(0, kLargeFont);
            const int32_t offsetX  = 10;
            const int32_t offsetY  = 100;
            const int32_t width    = 5 * static_cast<uint32_t>(item->runningValues.size());
            const int32_t height   = 100;

            item->type      = OverlayType::RunningGraph;
            item->fontSize  = fontSize;
            item->coords[0] = offsetX;
            item->coords[1] = offsetY;
            item->coords[2] = offsetX + width;
            item->coords[3] = offsetY + height;
            item->color[0]  = 0.294117647059;
            item->color[1]  = 0.78431372549;
            item->color[2]  = 0.0;
            item->color[3]  = 0.78431372549;
        }
        mOverlayItems[OverlayId::CommandGraphSize] = item;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX  = mOverlayItems[OverlayId::CommandGraphSize]->coords[0];
            const int32_t offsetY  = mOverlayItems[OverlayId::CommandGraphSize]->coords[1];
            const int32_t width    = 40 * kFontGlyphWidths[fontSize];
            const int32_t height   = kFontGlyphHeights[fontSize];

            item->description.type      = OverlayType::Text;
            item->description.fontSize  = fontSize;
            item->description.coords[0] = offsetX;
            item->description.coords[1] = std::max(offsetY - height, 1);
            item->description.coords[2] = offsetX + width;
            item->description.coords[3] = offsetY;
            item->description.color[0]  = 0.294117647059;
            item->description.color[1]  = 0.78431372549;
            item->description.color[2]  = 0.0;
            item->description.color[3]  = 1.0;
        }
    }

    {
        RunningHistogram *item = new RunningHistogram(50);
        {
            const int32_t fontSize = GetFontSize(0, kLargeFont);
            const int32_t offsetX  = -50;
            const int32_t offsetY  = 100;
            const int32_t width    = 6 * static_cast<uint32_t>(item->runningValues.size());
            const int32_t height   = 100;

            item->type      = OverlayType::RunningHistogram;
            item->fontSize  = fontSize;
            item->coords[0] = offsetX - width;
            item->coords[1] = offsetY;
            item->coords[2] = offsetX;
            item->coords[3] = offsetY + height;
            item->color[0]  = 1.0;
            item->color[1]  = 0.78431372549;
            item->color[2]  = 0.294117647059;
            item->color[3]  = 0.78431372549;
        }
        mOverlayItems[OverlayId::SecondaryCommandBufferPoolWaste] = item;
        {
            const int32_t fontSize = GetFontSize(kFontLayerSmall, kLargeFont);
            const int32_t offsetX =
                mOverlayItems[OverlayId::SecondaryCommandBufferPoolWaste]->coords[0];
            const int32_t offsetY =
                mOverlayItems[OverlayId::SecondaryCommandBufferPoolWaste]->coords[1];
            const int32_t width  = 40 * kFontGlyphWidths[fontSize];
            const int32_t height = kFontGlyphHeights[fontSize];

            item->description.type      = OverlayType::Text;
            item->description.fontSize  = fontSize;
            item->description.coords[0] = offsetX;
            item->description.coords[1] = std::max(offsetY - height, 1);
            item->description.coords[2] = std::min(offsetX + width, -1);
            item->description.coords[3] = offsetY;
            item->description.color[0]  = 1.0;
            item->description.color[1]  = 0.78431372549;
            item->description.color[2]  = 0.294117647059;
            item->description.color[3]  = 1.0;
        }
    }
}

}  // namespace rx
