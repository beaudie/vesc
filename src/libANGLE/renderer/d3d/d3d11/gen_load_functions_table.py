#!/usr/bin/python
# Copyright 2015 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_load_functions_table.py:
#  Code generation for the DXGI support tables. Determines which formats
#  are natively support in D3D10+.
#

import json
import pprint

template = """// GENERATED FILE - DO NOT EDIT.
// Generated by gen_load_functions_table.py using data from load_functions_data.json
//
// Copyright 2015 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// load_functions_table:
//   Contains the GetLoadFunctionsMap for texture_format_util.h
//

#include "libANGLE/renderer/d3d/d3d11/load_functions_table.h"
#include "libANGLE/renderer/d3d/d3d11/formatutils11.h"
#include "libANGLE/renderer/d3d/loadimage.h"

namespace rx
{{

namespace d3d11
{{

namespace
{{

// ES3 image loading functions vary based on:
//    - the GL internal format (supplied to glTex*Image*D)
//    - the GL data type given (supplied to glTex*Image*D)
//    - the target DXGI_FORMAT that the image will be loaded into (which is chosen based on the D3D
//    device's capabilities)
// This map type determines which loading function to use, based on these three parameters.
// Source formats and types are taken from Tables 3.2 and 3.3 of the ES 3 spec.
void UnimplementedLoadFunction(size_t width,
                               size_t height,
                               size_t depth,
                               const uint8_t *input,
                               size_t inputRowPitch,
                               size_t inputDepthPitch,
                               uint8_t *output,
                               size_t outputRowPitch,
                               size_t outputDepthPitch)
{{
    UNIMPLEMENTED();
}}

void UnreachableLoadFunction(size_t width,
                             size_t height,
                             size_t depth,
                             const uint8_t *input,
                             size_t inputRowPitch,
                             size_t inputDepthPitch,
                             uint8_t *output,
                             size_t outputRowPitch,
                             size_t outputDepthPitch)
{{
    UNREACHABLE();
}}

}}  // namespace

const std::map<GLenum, LoadImageFunction> &GetLoadFunctionsMap(GLenum {internal_format},
                                                               DXGI_FORMAT {dxgi_format})
{{
    // clang-format off
    switch ({internal_format})
    {{
{data}
        default:
        {{
            static std::map<GLenum, LoadImageFunction> emptyLoadFunctionsMap;
            return emptyLoadFunctionsMap;
        }}
    }}
    // clang-format on

}}  // GetLoadFunctionsMap

}}  // namespace d3d11

}}  // namespace rx
"""

internal_format_param = 'internalFormat'
dxgi_format_param = 'dxgiFormat'
dxgi_format_unknown = "DXGI_FORMAT_UNKNOWN"

def load_function_maps_string(typeFunction):
    # typeFunction['requiresConversion'] element is not in use at the moment but may be needed later
    return '                    loadFunctionsMap.insert(std::make_pair(' + typeFunction['type'] + ', ' + typeFunction['loadFunction'] + '));\n'

def load_unknown_format_string(json_data, internal_format_item, dxgi_unknown_string):
    if dxgi_format_unknown not in json_data[internal_format_item]:
        return ''

    table_data = ''
    for typeFunction in json_data[internal_format_item][dxgi_unknown_string]:
        table_data += load_function_maps_string(typeFunction)

    return table_data

def parse_json_into_switch_string(json_data):
    table_data = ''
    for internal_format_item in json_data:
        table_data += '        case ' + internal_format_item + ':\n'
        table_data += '        {\n'
        table_data += '            switch (' + dxgi_format_param + ')\n'
        table_data += '            {\n'

        unknown_format_string = load_unknown_format_string(json_data, internal_format_item, dxgi_format_unknown);
        for dxgi_format_item in json_data[internal_format_item]:
            table_data += '                case ' + dxgi_format_item + ':\n'

            table_data += '                {\n'
            table_data += '                    static std::map<GLenum, LoadImageFunction> loadFunctionsMap;\n'

            for typeFunction in json_data[internal_format_item][dxgi_format_item]:
                table_data += load_function_maps_string(typeFunction)

            # If there is an unknown format, we want to add its map elements add to the end of all the other formats
            if unknown_format_string:
                table_data += '\n'
                table_data += '                    // DXGI_FORMAT_UNKNOWN add ons\n'
                table_data += unknown_format_string
            table_data += '                    return loadFunctionsMap;\n'
            table_data += '                }\n'


        table_data += '                default:\n'

        if unknown_format_string:
            table_data += '                {\n'
            table_data += '                    static std::map<GLenum, LoadImageFunction> loadFunctionsMap;\n'
            table_data += unknown_format_string
            table_data += '                    return loadFunctionsMap;\n'
            table_data += '                }\n'
        else:
            table_data += '                    break;\n'
        table_data += '            }\n'
        table_data += '        }\n'

    return table_data

with open('load_functions_data.json') as functions_json_file:
    functions_data = functions_json_file.read();
    functions_json_file.close()
    json_data = json.loads(functions_data)

    table_data = parse_json_into_switch_string(json_data)
    output = template.format(internal_format = internal_format_param,
                             dxgi_format = dxgi_format_param,
                             data=table_data)

    with open('load_functions_table.cpp', 'wt') as out_file:
        out_file.write(output)
        out_file.close()
