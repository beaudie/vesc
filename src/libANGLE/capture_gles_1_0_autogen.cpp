// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml and gl_angle_ext.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// capture_gles_1_0_autogen.cpp:
//   Capture functions for the OpenGL ES 1.0 entry points.

#include "libANGLE/capture_gles_1_0_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/FrameCapture.h"
#include "libANGLE/validationES1.h"

using namespace angle;

namespace gl
{

void CaptureAlphaFunc(Context *context, AlphaTestFunc funcPacked, GLfloat ref)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateAlphaFunc(context, funcPacked, ref);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("funcPacked", ParamType::TAlphaTestFunc, funcPacked);
    paramBuffer.addValueParam("ref", ParamType::TGLfloat, ref);

    frameCapture->captureCall(context, "glAlphaFunc", std::move(paramBuffer), isCallValid);
}

void CaptureAlphaFuncx(Context *context, AlphaTestFunc funcPacked, GLfixed ref)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateAlphaFuncx(context, funcPacked, ref);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("funcPacked", ParamType::TAlphaTestFunc, funcPacked);
    paramBuffer.addValueParam("ref", ParamType::TGLfixed, ref);

    frameCapture->captureCall(context, "glAlphaFuncx", std::move(paramBuffer), isCallValid);
}

void CaptureClearColorx(Context *context, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClearColorx(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLfixed, red);
    paramBuffer.addValueParam("green", ParamType::TGLfixed, green);
    paramBuffer.addValueParam("blue", ParamType::TGLfixed, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLfixed, alpha);

    frameCapture->captureCall(context, "glClearColorx", std::move(paramBuffer), isCallValid);
}

void CaptureClearDepthx(Context *context, GLfixed depth)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClearDepthx(context, depth);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("depth", ParamType::TGLfixed, depth);

    frameCapture->captureCall(context, "glClearDepthx", std::move(paramBuffer), isCallValid);
}

void CaptureClientActiveTexture(Context *context, GLenum texture)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClientActiveTexture(context, texture);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("texture", ParamType::TGLenum, texture);

    frameCapture->captureCall(context, "glClientActiveTexture", std::move(paramBuffer),
                              isCallValid);
}

void CaptureClipPlanef(Context *context, GLenum p, const GLfloat *eqn)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClipPlanef(context, p, eqn);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("p", ParamType::TGLenum, p);

    ParamCapture eqnParam("eqn", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, eqn, &eqnParam.value);
    CaptureClipPlanef_eqn(context, p, eqn, isCallValid, &eqnParam);
    paramBuffer.addParam(std::move(eqnParam));

    frameCapture->captureCall(context, "glClipPlanef", std::move(paramBuffer), isCallValid);
}

void CaptureClipPlanex(Context *context, GLenum plane, const GLfixed *equation)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateClipPlanex(context, plane, equation);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("plane", ParamType::TGLenum, plane);

    ParamCapture equationParam("equation", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, equation, &equationParam.value);
    CaptureClipPlanex_equation(context, plane, equation, isCallValid, &equationParam);
    paramBuffer.addParam(std::move(equationParam));

    frameCapture->captureCall(context, "glClipPlanex", std::move(paramBuffer), isCallValid);
}

void CaptureColor4f(Context *context, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateColor4f(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLfloat, red);
    paramBuffer.addValueParam("green", ParamType::TGLfloat, green);
    paramBuffer.addValueParam("blue", ParamType::TGLfloat, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLfloat, alpha);

    frameCapture->captureCall(context, "glColor4f", std::move(paramBuffer), isCallValid);
}

void CaptureColor4ub(Context *context, GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateColor4ub(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLubyte, red);
    paramBuffer.addValueParam("green", ParamType::TGLubyte, green);
    paramBuffer.addValueParam("blue", ParamType::TGLubyte, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLubyte, alpha);

    frameCapture->captureCall(context, "glColor4ub", std::move(paramBuffer), isCallValid);
}

void CaptureColor4x(Context *context, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateColor4x(context, red, green, blue, alpha);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("red", ParamType::TGLfixed, red);
    paramBuffer.addValueParam("green", ParamType::TGLfixed, green);
    paramBuffer.addValueParam("blue", ParamType::TGLfixed, blue);
    paramBuffer.addValueParam("alpha", ParamType::TGLfixed, alpha);

    frameCapture->captureCall(context, "glColor4x", std::move(paramBuffer), isCallValid);
}

void CaptureColorPointer(Context *context,
                         GLint size,
                         VertexAttribType typePacked,
                         GLsizei stride,
                         const void *pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateColorPointer(context, size, typePacked, stride, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("size", ParamType::TGLint, size);
    paramBuffer.addValueParam("typePacked", ParamType::TVertexAttribType, typePacked);
    paramBuffer.addValueParam("stride", ParamType::TGLsizei, stride);

    ParamCapture pointerParam("pointer", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pointer, &pointerParam.value);
    CaptureColorPointer_pointer(context, size, typePacked, stride, pointer, isCallValid,
                                &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glColorPointer", std::move(paramBuffer), isCallValid);
}

void CaptureDepthRangex(Context *context, GLfixed n, GLfixed f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDepthRangex(context, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("n", ParamType::TGLfixed, n);
    paramBuffer.addValueParam("f", ParamType::TGLfixed, f);

    frameCapture->captureCall(context, "glDepthRangex", std::move(paramBuffer), isCallValid);
}

void CaptureDisableClientState(Context *context, ClientVertexArrayType arrayPacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateDisableClientState(context, arrayPacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("arrayPacked", ParamType::TClientVertexArrayType, arrayPacked);

    frameCapture->captureCall(context, "glDisableClientState", std::move(paramBuffer), isCallValid);
}

void CaptureEnableClientState(Context *context, ClientVertexArrayType arrayPacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateEnableClientState(context, arrayPacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("arrayPacked", ParamType::TClientVertexArrayType, arrayPacked);

    frameCapture->captureCall(context, "glEnableClientState", std::move(paramBuffer), isCallValid);
}

void CaptureFogf(Context *context, GLenum pname, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFogf(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glFogf", std::move(paramBuffer), isCallValid);
}

void CaptureFogfv(Context *context, GLenum pname, const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFogfv(context, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureFogfv_params(context, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glFogfv", std::move(paramBuffer), isCallValid);
}

void CaptureFogx(Context *context, GLenum pname, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFogx(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glFogx", std::move(paramBuffer), isCallValid);
}

void CaptureFogxv(Context *context, GLenum pname, const GLfixed *param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFogxv(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramParam("param", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, param, &paramParam.value);
    CaptureFogxv_param(context, pname, param, isCallValid, &paramParam);
    paramBuffer.addParam(std::move(paramParam));

    frameCapture->captureCall(context, "glFogxv", std::move(paramBuffer), isCallValid);
}

void CaptureFrustumf(Context *context,
                     GLfloat l,
                     GLfloat r,
                     GLfloat b,
                     GLfloat t,
                     GLfloat n,
                     GLfloat f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFrustumf(context, l, r, b, t, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("l", ParamType::TGLfloat, l);
    paramBuffer.addValueParam("r", ParamType::TGLfloat, r);
    paramBuffer.addValueParam("b", ParamType::TGLfloat, b);
    paramBuffer.addValueParam("t", ParamType::TGLfloat, t);
    paramBuffer.addValueParam("n", ParamType::TGLfloat, n);
    paramBuffer.addValueParam("f", ParamType::TGLfloat, f);

    frameCapture->captureCall(context, "glFrustumf", std::move(paramBuffer), isCallValid);
}

void CaptureFrustumx(Context *context,
                     GLfixed l,
                     GLfixed r,
                     GLfixed b,
                     GLfixed t,
                     GLfixed n,
                     GLfixed f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateFrustumx(context, l, r, b, t, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("l", ParamType::TGLfixed, l);
    paramBuffer.addValueParam("r", ParamType::TGLfixed, r);
    paramBuffer.addValueParam("b", ParamType::TGLfixed, b);
    paramBuffer.addValueParam("t", ParamType::TGLfixed, t);
    paramBuffer.addValueParam("n", ParamType::TGLfixed, n);
    paramBuffer.addValueParam("f", ParamType::TGLfixed, f);

    frameCapture->captureCall(context, "glFrustumx", std::move(paramBuffer), isCallValid);
}

void CaptureGetClipPlanef(Context *context, GLenum plane, GLfloat *equation)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetClipPlanef(context, plane, equation);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("plane", ParamType::TGLenum, plane);

    ParamCapture equationParam("equation", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, equation, &equationParam.value);
    CaptureGetClipPlanef_equation(context, plane, equation, isCallValid, &equationParam);
    paramBuffer.addParam(std::move(equationParam));

    frameCapture->captureCall(context, "glGetClipPlanef", std::move(paramBuffer), isCallValid);
}

void CaptureGetClipPlanex(Context *context, GLenum plane, GLfixed *equation)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetClipPlanex(context, plane, equation);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("plane", ParamType::TGLenum, plane);

    ParamCapture equationParam("equation", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, equation, &equationParam.value);
    CaptureGetClipPlanex_equation(context, plane, equation, isCallValid, &equationParam);
    paramBuffer.addParam(std::move(equationParam));

    frameCapture->captureCall(context, "glGetClipPlanex", std::move(paramBuffer), isCallValid);
}

void CaptureGetFixedv(Context *context, GLenum pname, GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetFixedv(context, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, params, &paramsParam.value);
    CaptureGetFixedv_params(context, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetFixedv", std::move(paramBuffer), isCallValid);
}

void CaptureGetLightfv(Context *context, GLenum light, LightParameter pnamePacked, GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetLightfv(context, light, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetLightfv_params(context, light, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetLightfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetLightxv(Context *context, GLenum light, LightParameter pnamePacked, GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetLightxv(context, light, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, params, &paramsParam.value);
    CaptureGetLightxv_params(context, light, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetLightxv", std::move(paramBuffer), isCallValid);
}

void CaptureGetMaterialfv(Context *context,
                          GLenum face,
                          MaterialParameter pnamePacked,
                          GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetMaterialfv(context, face, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetMaterialfv_params(context, face, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetMaterialfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetMaterialxv(Context *context,
                          GLenum face,
                          MaterialParameter pnamePacked,
                          GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetMaterialxv(context, face, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, params, &paramsParam.value);
    CaptureGetMaterialxv_params(context, face, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetMaterialxv", std::move(paramBuffer), isCallValid);
}

void CaptureGetPointerv(Context *context, GLenum pname, void **params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetPointerv(context, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TvoidPointerPointer);
    InitParamValue(ParamType::TvoidPointerPointer, params, &paramsParam.value);
    CaptureGetPointerv_params(context, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetPointerv", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexEnvfv(Context *context,
                        TextureEnvTarget targetPacked,
                        TextureEnvParameter pnamePacked,
                        GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexEnvfv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatPointer);
    InitParamValue(ParamType::TGLfloatPointer, params, &paramsParam.value);
    CaptureGetTexEnvfv_params(context, targetPacked, pnamePacked, params, isCallValid,
                              &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexEnvfv", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexEnviv(Context *context,
                        TextureEnvTarget targetPacked,
                        TextureEnvParameter pnamePacked,
                        GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexEnviv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLintPointer);
    InitParamValue(ParamType::TGLintPointer, params, &paramsParam.value);
    CaptureGetTexEnviv_params(context, targetPacked, pnamePacked, params, isCallValid,
                              &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexEnviv", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexEnvxv(Context *context,
                        TextureEnvTarget targetPacked,
                        TextureEnvParameter pnamePacked,
                        GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexEnvxv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, params, &paramsParam.value);
    CaptureGetTexEnvxv_params(context, targetPacked, pnamePacked, params, isCallValid,
                              &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexEnvxv", std::move(paramBuffer), isCallValid);
}

void CaptureGetTexParameterxv(Context *context,
                              TextureType targetPacked,
                              GLenum pname,
                              GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateGetTexParameterxv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfixedPointer);
    InitParamValue(ParamType::TGLfixedPointer, params, &paramsParam.value);
    CaptureGetTexParameterxv_params(context, targetPacked, pname, params, isCallValid,
                                    &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glGetTexParameterxv", std::move(paramBuffer), isCallValid);
}

void CaptureLightModelf(Context *context, GLenum pname, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightModelf(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glLightModelf", std::move(paramBuffer), isCallValid);
}

void CaptureLightModelfv(Context *context, GLenum pname, const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightModelfv(context, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureLightModelfv_params(context, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glLightModelfv", std::move(paramBuffer), isCallValid);
}

void CaptureLightModelx(Context *context, GLenum pname, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightModelx(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glLightModelx", std::move(paramBuffer), isCallValid);
}

void CaptureLightModelxv(Context *context, GLenum pname, const GLfixed *param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightModelxv(context, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramParam("param", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, param, &paramParam.value);
    CaptureLightModelxv_param(context, pname, param, isCallValid, &paramParam);
    paramBuffer.addParam(std::move(paramParam));

    frameCapture->captureCall(context, "glLightModelxv", std::move(paramBuffer), isCallValid);
}

void CaptureLightf(Context *context, GLenum light, LightParameter pnamePacked, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightf(context, light, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glLightf", std::move(paramBuffer), isCallValid);
}

void CaptureLightfv(Context *context,
                    GLenum light,
                    LightParameter pnamePacked,
                    const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightfv(context, light, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureLightfv_params(context, light, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glLightfv", std::move(paramBuffer), isCallValid);
}

void CaptureLightx(Context *context, GLenum light, LightParameter pnamePacked, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightx(context, light, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glLightx", std::move(paramBuffer), isCallValid);
}

void CaptureLightxv(Context *context,
                    GLenum light,
                    LightParameter pnamePacked,
                    const GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLightxv(context, light, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("light", ParamType::TGLenum, light);
    paramBuffer.addValueParam("pnamePacked", ParamType::TLightParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, params, &paramsParam.value);
    CaptureLightxv_params(context, light, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glLightxv", std::move(paramBuffer), isCallValid);
}

void CaptureLineWidthx(Context *context, GLfixed width)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLineWidthx(context, width);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("width", ParamType::TGLfixed, width);

    frameCapture->captureCall(context, "glLineWidthx", std::move(paramBuffer), isCallValid);
}

void CaptureLoadIdentity(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLoadIdentity(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glLoadIdentity", std::move(paramBuffer), isCallValid);
}

void CaptureLoadMatrixf(Context *context, const GLfloat *m)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLoadMatrixf(context, m);
    ParamBuffer paramBuffer;

    ParamCapture mParam("m", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, m, &mParam.value);
    CaptureLoadMatrixf_m(context, m, isCallValid, &mParam);
    paramBuffer.addParam(std::move(mParam));

    frameCapture->captureCall(context, "glLoadMatrixf", std::move(paramBuffer), isCallValid);
}

void CaptureLoadMatrixx(Context *context, const GLfixed *m)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLoadMatrixx(context, m);
    ParamBuffer paramBuffer;

    ParamCapture mParam("m", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, m, &mParam.value);
    CaptureLoadMatrixx_m(context, m, isCallValid, &mParam);
    paramBuffer.addParam(std::move(mParam));

    frameCapture->captureCall(context, "glLoadMatrixx", std::move(paramBuffer), isCallValid);
}

void CaptureLogicOp(Context *context, LogicalOperation opcodePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateLogicOp(context, opcodePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("opcodePacked", ParamType::TLogicalOperation, opcodePacked);

    frameCapture->captureCall(context, "glLogicOp", std::move(paramBuffer), isCallValid);
}

void CaptureMaterialf(Context *context, GLenum face, MaterialParameter pnamePacked, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMaterialf(context, face, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glMaterialf", std::move(paramBuffer), isCallValid);
}

void CaptureMaterialfv(Context *context,
                       GLenum face,
                       MaterialParameter pnamePacked,
                       const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMaterialfv(context, face, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureMaterialfv_params(context, face, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glMaterialfv", std::move(paramBuffer), isCallValid);
}

void CaptureMaterialx(Context *context, GLenum face, MaterialParameter pnamePacked, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMaterialx(context, face, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glMaterialx", std::move(paramBuffer), isCallValid);
}

void CaptureMaterialxv(Context *context,
                       GLenum face,
                       MaterialParameter pnamePacked,
                       const GLfixed *param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMaterialxv(context, face, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("face", ParamType::TGLenum, face);
    paramBuffer.addValueParam("pnamePacked", ParamType::TMaterialParameter, pnamePacked);

    ParamCapture paramParam("param", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, param, &paramParam.value);
    CaptureMaterialxv_param(context, face, pnamePacked, param, isCallValid, &paramParam);
    paramBuffer.addParam(std::move(paramParam));

    frameCapture->captureCall(context, "glMaterialxv", std::move(paramBuffer), isCallValid);
}

void CaptureMatrixMode(Context *context, MatrixType modePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMatrixMode(context, modePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modePacked", ParamType::TMatrixType, modePacked);

    frameCapture->captureCall(context, "glMatrixMode", std::move(paramBuffer), isCallValid);
}

void CaptureMultMatrixf(Context *context, const GLfloat *m)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMultMatrixf(context, m);
    ParamBuffer paramBuffer;

    ParamCapture mParam("m", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, m, &mParam.value);
    CaptureMultMatrixf_m(context, m, isCallValid, &mParam);
    paramBuffer.addParam(std::move(mParam));

    frameCapture->captureCall(context, "glMultMatrixf", std::move(paramBuffer), isCallValid);
}

void CaptureMultMatrixx(Context *context, const GLfixed *m)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMultMatrixx(context, m);
    ParamBuffer paramBuffer;

    ParamCapture mParam("m", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, m, &mParam.value);
    CaptureMultMatrixx_m(context, m, isCallValid, &mParam);
    paramBuffer.addParam(std::move(mParam));

    frameCapture->captureCall(context, "glMultMatrixx", std::move(paramBuffer), isCallValid);
}

void CaptureMultiTexCoord4f(Context *context,
                            GLenum target,
                            GLfloat s,
                            GLfloat t,
                            GLfloat r,
                            GLfloat q)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMultiTexCoord4f(context, target, s, t, r, q);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("target", ParamType::TGLenum, target);
    paramBuffer.addValueParam("s", ParamType::TGLfloat, s);
    paramBuffer.addValueParam("t", ParamType::TGLfloat, t);
    paramBuffer.addValueParam("r", ParamType::TGLfloat, r);
    paramBuffer.addValueParam("q", ParamType::TGLfloat, q);

    frameCapture->captureCall(context, "glMultiTexCoord4f", std::move(paramBuffer), isCallValid);
}

void CaptureMultiTexCoord4x(Context *context,
                            GLenum texture,
                            GLfixed s,
                            GLfixed t,
                            GLfixed r,
                            GLfixed q)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateMultiTexCoord4x(context, texture, s, t, r, q);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("texture", ParamType::TGLenum, texture);
    paramBuffer.addValueParam("s", ParamType::TGLfixed, s);
    paramBuffer.addValueParam("t", ParamType::TGLfixed, t);
    paramBuffer.addValueParam("r", ParamType::TGLfixed, r);
    paramBuffer.addValueParam("q", ParamType::TGLfixed, q);

    frameCapture->captureCall(context, "glMultiTexCoord4x", std::move(paramBuffer), isCallValid);
}

void CaptureNormal3f(Context *context, GLfloat nx, GLfloat ny, GLfloat nz)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateNormal3f(context, nx, ny, nz);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("nx", ParamType::TGLfloat, nx);
    paramBuffer.addValueParam("ny", ParamType::TGLfloat, ny);
    paramBuffer.addValueParam("nz", ParamType::TGLfloat, nz);

    frameCapture->captureCall(context, "glNormal3f", std::move(paramBuffer), isCallValid);
}

void CaptureNormal3x(Context *context, GLfixed nx, GLfixed ny, GLfixed nz)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateNormal3x(context, nx, ny, nz);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("nx", ParamType::TGLfixed, nx);
    paramBuffer.addValueParam("ny", ParamType::TGLfixed, ny);
    paramBuffer.addValueParam("nz", ParamType::TGLfixed, nz);

    frameCapture->captureCall(context, "glNormal3x", std::move(paramBuffer), isCallValid);
}

void CaptureNormalPointer(Context *context,
                          VertexAttribType typePacked,
                          GLsizei stride,
                          const void *pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateNormalPointer(context, typePacked, stride, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("typePacked", ParamType::TVertexAttribType, typePacked);
    paramBuffer.addValueParam("stride", ParamType::TGLsizei, stride);

    ParamCapture pointerParam("pointer", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pointer, &pointerParam.value);
    CaptureNormalPointer_pointer(context, typePacked, stride, pointer, isCallValid, &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glNormalPointer", std::move(paramBuffer), isCallValid);
}

void CaptureOrthof(Context *context,
                   GLfloat l,
                   GLfloat r,
                   GLfloat b,
                   GLfloat t,
                   GLfloat n,
                   GLfloat f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateOrthof(context, l, r, b, t, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("l", ParamType::TGLfloat, l);
    paramBuffer.addValueParam("r", ParamType::TGLfloat, r);
    paramBuffer.addValueParam("b", ParamType::TGLfloat, b);
    paramBuffer.addValueParam("t", ParamType::TGLfloat, t);
    paramBuffer.addValueParam("n", ParamType::TGLfloat, n);
    paramBuffer.addValueParam("f", ParamType::TGLfloat, f);

    frameCapture->captureCall(context, "glOrthof", std::move(paramBuffer), isCallValid);
}

void CaptureOrthox(Context *context,
                   GLfixed l,
                   GLfixed r,
                   GLfixed b,
                   GLfixed t,
                   GLfixed n,
                   GLfixed f)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateOrthox(context, l, r, b, t, n, f);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("l", ParamType::TGLfixed, l);
    paramBuffer.addValueParam("r", ParamType::TGLfixed, r);
    paramBuffer.addValueParam("b", ParamType::TGLfixed, b);
    paramBuffer.addValueParam("t", ParamType::TGLfixed, t);
    paramBuffer.addValueParam("n", ParamType::TGLfixed, n);
    paramBuffer.addValueParam("f", ParamType::TGLfixed, f);

    frameCapture->captureCall(context, "glOrthox", std::move(paramBuffer), isCallValid);
}

void CapturePointParameterf(Context *context, PointParameter pnamePacked, GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointParameterf(context, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pnamePacked", ParamType::TPointParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glPointParameterf", std::move(paramBuffer), isCallValid);
}

void CapturePointParameterfv(Context *context, PointParameter pnamePacked, const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointParameterfv(context, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pnamePacked", ParamType::TPointParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CapturePointParameterfv_params(context, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glPointParameterfv", std::move(paramBuffer), isCallValid);
}

void CapturePointParameterx(Context *context, PointParameter pnamePacked, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointParameterx(context, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pnamePacked", ParamType::TPointParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glPointParameterx", std::move(paramBuffer), isCallValid);
}

void CapturePointParameterxv(Context *context, PointParameter pnamePacked, const GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointParameterxv(context, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("pnamePacked", ParamType::TPointParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, params, &paramsParam.value);
    CapturePointParameterxv_params(context, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glPointParameterxv", std::move(paramBuffer), isCallValid);
}

void CapturePointSize(Context *context, GLfloat size)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointSize(context, size);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("size", ParamType::TGLfloat, size);

    frameCapture->captureCall(context, "glPointSize", std::move(paramBuffer), isCallValid);
}

void CapturePointSizex(Context *context, GLfixed size)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePointSizex(context, size);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("size", ParamType::TGLfixed, size);

    frameCapture->captureCall(context, "glPointSizex", std::move(paramBuffer), isCallValid);
}

void CapturePolygonOffsetx(Context *context, GLfixed factor, GLfixed units)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePolygonOffsetx(context, factor, units);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("factor", ParamType::TGLfixed, factor);
    paramBuffer.addValueParam("units", ParamType::TGLfixed, units);

    frameCapture->captureCall(context, "glPolygonOffsetx", std::move(paramBuffer), isCallValid);
}

void CapturePopMatrix(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePopMatrix(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glPopMatrix", std::move(paramBuffer), isCallValid);
}

void CapturePushMatrix(Context *context)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidatePushMatrix(context);
    ParamBuffer paramBuffer;

    frameCapture->captureCall(context, "glPushMatrix", std::move(paramBuffer), isCallValid);
}

void CaptureRotatef(Context *context, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateRotatef(context, angle, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("angle", ParamType::TGLfloat, angle);
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);
    paramBuffer.addValueParam("z", ParamType::TGLfloat, z);

    frameCapture->captureCall(context, "glRotatef", std::move(paramBuffer), isCallValid);
}

void CaptureRotatex(Context *context, GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateRotatex(context, angle, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("angle", ParamType::TGLfixed, angle);
    paramBuffer.addValueParam("x", ParamType::TGLfixed, x);
    paramBuffer.addValueParam("y", ParamType::TGLfixed, y);
    paramBuffer.addValueParam("z", ParamType::TGLfixed, z);

    frameCapture->captureCall(context, "glRotatex", std::move(paramBuffer), isCallValid);
}

void CaptureSampleCoveragex(Context *context, GLclampx value, GLboolean invert)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateSampleCoveragex(context, value, invert);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("value", ParamType::TGLclampx, value);
    paramBuffer.addValueParam("invert", ParamType::TGLboolean, invert);

    frameCapture->captureCall(context, "glSampleCoveragex", std::move(paramBuffer), isCallValid);
}

void CaptureScalef(Context *context, GLfloat x, GLfloat y, GLfloat z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateScalef(context, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);
    paramBuffer.addValueParam("z", ParamType::TGLfloat, z);

    frameCapture->captureCall(context, "glScalef", std::move(paramBuffer), isCallValid);
}

void CaptureScalex(Context *context, GLfixed x, GLfixed y, GLfixed z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateScalex(context, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLfixed, x);
    paramBuffer.addValueParam("y", ParamType::TGLfixed, y);
    paramBuffer.addValueParam("z", ParamType::TGLfixed, z);

    frameCapture->captureCall(context, "glScalex", std::move(paramBuffer), isCallValid);
}

void CaptureShadeModel(Context *context, ShadingModel modePacked)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateShadeModel(context, modePacked);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("modePacked", ParamType::TShadingModel, modePacked);

    frameCapture->captureCall(context, "glShadeModel", std::move(paramBuffer), isCallValid);
}

void CaptureTexCoordPointer(Context *context,
                            GLint size,
                            VertexAttribType typePacked,
                            GLsizei stride,
                            const void *pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexCoordPointer(context, size, typePacked, stride, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("size", ParamType::TGLint, size);
    paramBuffer.addValueParam("typePacked", ParamType::TVertexAttribType, typePacked);
    paramBuffer.addValueParam("stride", ParamType::TGLsizei, stride);

    ParamCapture pointerParam("pointer", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pointer, &pointerParam.value);
    CaptureTexCoordPointer_pointer(context, size, typePacked, stride, pointer, isCallValid,
                                   &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glTexCoordPointer", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnvf(Context *context,
                    TextureEnvTarget targetPacked,
                    TextureEnvParameter pnamePacked,
                    GLfloat param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnvf(context, targetPacked, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfloat, param);

    frameCapture->captureCall(context, "glTexEnvf", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnvfv(Context *context,
                     TextureEnvTarget targetPacked,
                     TextureEnvParameter pnamePacked,
                     const GLfloat *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnvfv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfloatConstPointer);
    InitParamValue(ParamType::TGLfloatConstPointer, params, &paramsParam.value);
    CaptureTexEnvfv_params(context, targetPacked, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexEnvfv", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnvi(Context *context,
                    TextureEnvTarget targetPacked,
                    TextureEnvParameter pnamePacked,
                    GLint param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnvi(context, targetPacked, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLint, param);

    frameCapture->captureCall(context, "glTexEnvi", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnviv(Context *context,
                     TextureEnvTarget targetPacked,
                     TextureEnvParameter pnamePacked,
                     const GLint *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnviv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLintConstPointer);
    InitParamValue(ParamType::TGLintConstPointer, params, &paramsParam.value);
    CaptureTexEnviv_params(context, targetPacked, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexEnviv", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnvx(Context *context,
                    TextureEnvTarget targetPacked,
                    TextureEnvParameter pnamePacked,
                    GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnvx(context, targetPacked, pnamePacked, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glTexEnvx", std::move(paramBuffer), isCallValid);
}

void CaptureTexEnvxv(Context *context,
                     TextureEnvTarget targetPacked,
                     TextureEnvParameter pnamePacked,
                     const GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexEnvxv(context, targetPacked, pnamePacked, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureEnvTarget, targetPacked);
    paramBuffer.addValueParam("pnamePacked", ParamType::TTextureEnvParameter, pnamePacked);

    ParamCapture paramsParam("params", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, params, &paramsParam.value);
    CaptureTexEnvxv_params(context, targetPacked, pnamePacked, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexEnvxv", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameterx(Context *context, TextureType targetPacked, GLenum pname, GLfixed param)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameterx(context, targetPacked, pname, param);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);
    paramBuffer.addValueParam("param", ParamType::TGLfixed, param);

    frameCapture->captureCall(context, "glTexParameterx", std::move(paramBuffer), isCallValid);
}

void CaptureTexParameterxv(Context *context,
                           TextureType targetPacked,
                           GLenum pname,
                           const GLfixed *params)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTexParameterxv(context, targetPacked, pname, params);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("targetPacked", ParamType::TTextureType, targetPacked);
    paramBuffer.addValueParam("pname", ParamType::TGLenum, pname);

    ParamCapture paramsParam("params", ParamType::TGLfixedConstPointer);
    InitParamValue(ParamType::TGLfixedConstPointer, params, &paramsParam.value);
    CaptureTexParameterxv_params(context, targetPacked, pname, params, isCallValid, &paramsParam);
    paramBuffer.addParam(std::move(paramsParam));

    frameCapture->captureCall(context, "glTexParameterxv", std::move(paramBuffer), isCallValid);
}

void CaptureTranslatef(Context *context, GLfloat x, GLfloat y, GLfloat z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTranslatef(context, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLfloat, x);
    paramBuffer.addValueParam("y", ParamType::TGLfloat, y);
    paramBuffer.addValueParam("z", ParamType::TGLfloat, z);

    frameCapture->captureCall(context, "glTranslatef", std::move(paramBuffer), isCallValid);
}

void CaptureTranslatex(Context *context, GLfixed x, GLfixed y, GLfixed z)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateTranslatex(context, x, y, z);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("x", ParamType::TGLfixed, x);
    paramBuffer.addValueParam("y", ParamType::TGLfixed, y);
    paramBuffer.addValueParam("z", ParamType::TGLfixed, z);

    frameCapture->captureCall(context, "glTranslatex", std::move(paramBuffer), isCallValid);
}

void CaptureVertexPointer(Context *context,
                          GLint size,
                          VertexAttribType typePacked,
                          GLsizei stride,
                          const void *pointer)
{
    FrameCapture *frameCapture = context->getFrameCapture();
    if (!frameCapture->enabled())
        return;

    bool isCallValid = ValidateVertexPointer(context, size, typePacked, stride, pointer);
    ParamBuffer paramBuffer;
    paramBuffer.addValueParam("size", ParamType::TGLint, size);
    paramBuffer.addValueParam("typePacked", ParamType::TVertexAttribType, typePacked);
    paramBuffer.addValueParam("stride", ParamType::TGLsizei, stride);

    ParamCapture pointerParam("pointer", ParamType::TvoidConstPointer);
    InitParamValue(ParamType::TvoidConstPointer, pointer, &pointerParam.value);
    CaptureVertexPointer_pointer(context, size, typePacked, stride, pointer, isCallValid,
                                 &pointerParam);
    paramBuffer.addParam(std::move(pointerParam));

    frameCapture->captureCall(context, "glVertexPointer", std::move(paramBuffer), isCallValid);
}

}  // namespace gl
