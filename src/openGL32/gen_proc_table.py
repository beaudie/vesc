#!python
# Copyright 2017 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_proc_table.py:
#  Code generation for entry point loading tables.
#  NOTE: don't run this script directly. Run scripts/run_code_generation.py.

import sys
from datetime import date
sys.path.append('../../scripts')
import registry_xml

out_file_name = "proc_table_wgl_autogen.cpp"

# The EGL_ANGLE_explicit_context extension is generated differently from other extensions.
# Toggle generation here.
support_egl_ANGLE_explicit_context = False

strip_suffixes = ["ANGLE", "EXT", "KHR", "OES", "CHROMIUM", "OVR"]

template_cpp = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// getProcAddress loader table:
//   Mapping from a string entry point name to function address.
//

#include "openGL32/proc_table_wgl.h"

#include "openGL32/openGL32_wgl.h"
#include "openGL32/entry_points_gl_1_0_autogen.h"
#include "openGL32/entry_points_gl_1_1_autogen.h"
#include "openGL32/entry_points_gl_1_2_autogen.h"
#include "openGL32/entry_points_gl_1_3_autogen.h"
#include "openGL32/entry_points_gl_1_4_autogen.h"
#include "openGL32/entry_points_gl_1_5_autogen.h"
#include "openGL32/entry_points_gl_2_0_autogen.h"
#include "openGL32/entry_points_gl_2_1_autogen.h"
#include "openGL32/entry_points_gl_3_0_autogen.h"
#include "openGL32/entry_points_gl_3_1_autogen.h"
#include "platform/Platform.h"

#define P(FUNC) reinterpret_cast<PROC>(FUNC)

namespace wgl
{{
ProcEntry g_procTable[] = {{
{proc_data}
}};

size_t g_numProcs = {num_procs};
}}  // namespace wgl
"""

sys.path.append('../libANGLE/renderer')
import angle_format


def main():

    # auto_script parameters.
    if len(sys.argv) > 1:
        inputs = ['../../scripts/' + source for source in registry_xml.xml_inputs]
        outputs = [out_file_name]
        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print ','.join(outputs)
        else:
            print('Invalid script parameters')
            return 1
        return 0

    xml = registry_xml.RegistryXML('../../scripts/gl.xml', '../../scripts/gl_angle_ext.xml')
    glxml = registry_xml.RegistryXML('../../scripts/gl.xml')

    gles_commands = []

    # Track the GLES commands so we don't add them
    for major_version, minor_version in [[2, 0], [3, 0], [3, 1], [1, 0]]:
        version = "{}_{}".format(major_version, minor_version)
        annotation = "GLES_{}".format(version)
        name_prefix = "GL_ES_VERSION_"

        is_gles1 = major_version == 1
        if is_gles1:
            name_prefix = "GL_VERSION_ES_CM_"

        comment = "{}.{}".format(major_version, minor_version)
        feature_name = "{}{}".format(name_prefix, version)

        xml.AddCommands(feature_name, version)

        gles_commands.extend(xml.commands[version])

    # Also don't add GLES extension commands
    xml.AddExtensionCommands(registry_xml.supported_extensions, ['gles2', 'gles1'])

    extension_commands = []
    for extension_name, ext_cmd_names in sorted(xml.ext_data.iteritems()):
        extension_commands.extend(xml.ext_data[extension_name])
    for name in extension_commands:
        name_no_suffix = name
        for suffix in strip_suffixes:
            if name_no_suffix.endswith(suffix):
                name_no_suffix = name_no_suffix[0:-len(suffix)]
        gles_commands.append(name_no_suffix)

    for annotation in ["1_0", "1_1", "1_2", "1_3", "1_4", "1_5", "2_0", "2_1", "3_0", "3_1"]:

        name_prefix = "GL_VERSION_"
        feature_name = "{}{}".format(name_prefix, annotation)

        glxml.AddCommands(feature_name, annotation)

    data = [cmd for cmd in glxml.all_cmd_names.get_all_commands() if cmd not in gles_commands]

    wglxml = registry_xml.RegistryXML('../../scripts/wgl.xml')

    for annotation in ["1_0"]:

        name_prefix = "WGL_VERSION_"
        feature_name = "{}{}".format(name_prefix, annotation)

        wglxml.AddCommands(feature_name, annotation)

    wgl_commands = wglxml.all_cmd_names.get_all_commands()
    data.extend([cmd if cmd[:3] == 'wgl' else 'wgl' + cmd for cmd in wgl_commands])

    all_functions = {}

    for function in data:
        if function.startswith("gl"):
            all_functions[function] = "gl::" + function[2:]
        else:
            all_functions[function] = function

    proc_data = [('    {"%s", P(%s)}' % (func, angle_func))
                 for func, angle_func in sorted(all_functions.iteritems())]

    with open(out_file_name, 'w') as out_file:
        output_cpp = template_cpp.format(
            script_name=sys.argv[0],
            data_source_name="gl.xml, wgl.xml",
            copyright_year=date.today().year,
            proc_data=",\n".join(proc_data),
            num_procs=len(proc_data))
        out_file.write(output_cpp)
        out_file.close()
    return 0


if __name__ == '__main__':
    sys.exit(main())
