diff --git a/src/tests/third_party/gpu_test_expectations/angle_config.h b/src/tests/third_party/gpu_test_expectations/angle_config.h
new file mode 100644
index 000000000..37ed6d1b1
--- /dev/null
+++ b/src/tests/third_party/gpu_test_expectations/angle_config.h
@@ -0,0 +1,62 @@
+//
+// Copyright 2015 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// angle_config.h:
+//   Helpers for importing the gpu test expectations package from Chrome.
+//
+
+#ifndef GPU_TEST_EXPECTATIONS_ANGLE_CONFIG_H_
+#define GPU_TEST_EXPECTATIONS_ANGLE_CONFIG_H_
+
+#include <stdint.h>
+
+#include <iostream>
+
+#include "common/debug.h"
+#include "common/string_utils.h"
+
+#define DCHECK_EQ(A,B) ASSERT((A) == (B))
+#define DCHECK_NE(A,B) ASSERT((A) != (B))
+#define DCHECK(X) ASSERT(X)
+#define DLOG(X) std::cerr
+#define LOG(X) std::cerr
+
+#define GPU_EXPORT
+
+typedef int32_t int32;
+typedef uint32_t uint32;
+typedef int64_t int64;
+typedef uint64_t uint64;
+
+// Shim Chromium's base by importing functions in the base namespace.
+namespace base
+{
+    using angle::kWhitespaceASCII;
+    using angle::TRIM_WHITESPACE;
+    using angle::KEEP_WHITESPACE;
+    using angle::SPLIT_WANT_ALL;
+    using angle::SPLIT_WANT_NONEMPTY;
+    using angle::SplitString;
+    using angle::SplitStringAlongWhitespace;
+    using angle::HexStringToUInt;
+    using angle::ReadFileToString;
+}
+
+// TODO(jmadill): other platforms
+// clang-format off
+#if defined(_WIN32) || defined(_WIN64)
+#    define OS_WIN
+#elif defined(ANDROID)
+#    define OS_ANDROID
+#elif defined(__linux__)
+#    define OS_LINUX
+#elif defined(__APPLE__)
+#    define OS_MACOSX
+#else
+#    error "Unsupported platform"
+#endif
+// clang-format on
+
+#endif
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_info.cc b/src/tests/third_party/gpu_test_expectations/gpu_info.cc
index 23d52169f..8d41a51ba 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_info.cc
+++ b/src/tests/third_party/gpu_test_expectations/gpu_info.cc
@@ -2,7 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "gpu/config/gpu_info.h"
+#include <stdint.h>
+
+#include "gpu_info.h"
 
 namespace {
 
@@ -17,31 +19,6 @@ void EnumerateGPUDevice(const gpu::GPUInfo::GPUDevice& device,
   enumerator->EndGPUDevice();
 }
 
-void EnumerateVideoDecodeAcceleratorSupportedProfile(
-    const gpu::VideoDecodeAcceleratorSupportedProfile& profile,
-    gpu::GPUInfo::Enumerator* enumerator) {
-  enumerator->BeginVideoDecodeAcceleratorSupportedProfile();
-  enumerator->AddInt("profile", profile.profile);
-  enumerator->AddInt("maxResolutionWidth", profile.max_resolution.width());
-  enumerator->AddInt("maxResolutionHeight", profile.max_resolution.height());
-  enumerator->AddInt("minResolutionWidth", profile.min_resolution.width());
-  enumerator->AddInt("minResolutionHeight", profile.min_resolution.height());
-  enumerator->EndVideoDecodeAcceleratorSupportedProfile();
-}
-
-void EnumerateVideoEncodeAcceleratorSupportedProfile(
-    const gpu::VideoEncodeAcceleratorSupportedProfile& profile,
-    gpu::GPUInfo::Enumerator* enumerator) {
-  enumerator->BeginVideoEncodeAcceleratorSupportedProfile();
-  enumerator->AddInt("profile", profile.profile);
-  enumerator->AddInt("maxResolutionWidth", profile.max_resolution.width());
-  enumerator->AddInt("maxResolutionHeight", profile.max_resolution.height());
-  enumerator->AddInt("maxFramerateNumerator", profile.max_framerate_numerator);
-  enumerator->AddInt("maxFramerateDenominator",
-                     profile.max_framerate_denominator);
-  enumerator->EndVideoEncodeAcceleratorSupportedProfile();
-}
-
 }  // namespace
 
 namespace gpu {
@@ -57,35 +34,40 @@ GPUInfo::GPUDevice::~GPUDevice() { }
 GPUInfo::GPUInfo()
     : optimus(false),
       amd_switchable(false),
-      lenovo_dcute(false),
-      adapter_luid(0),
       gl_reset_notification_strategy(0),
-      can_lose_context(false),
       software_rendering(false),
       direct_rendering(true),
       sandboxed(false),
       process_crash_count(0),
       in_process_gpu(true),
+      passthrough_cmd_decoder(false),
       basic_info_state(kCollectInfoNone),
       context_info_state(kCollectInfoNone),
-#if defined(OS_WIN)
-      dx_diagnostics_info_state(kCollectInfoNone),
-#endif
-      jpeg_decode_accelerator_supported(false) {
+      jpeg_decode_accelerator_supported(false)
+{
 }
 
+GPUInfo::GPUInfo(const GPUInfo& other) = default;
+
 GPUInfo::~GPUInfo() { }
 
+const GPUInfo::GPUDevice& GPUInfo::active_gpu() const {
+  if (gpu.active)
+    return gpu;
+  for (const GPUDevice& secondary_gpu : secondary_gpus) {
+    if (secondary_gpu.active)
+      return secondary_gpu;
+  }
+  DLOG(ERROR) << "No active GPU found, returning primary GPU.";
+  return gpu;
+}
+
 void GPUInfo::EnumerateFields(Enumerator* enumerator) const {
   struct GPUInfoKnownFields {
-    base::TimeDelta initialization_time;
     bool optimus;
     bool amd_switchable;
-    bool lenovo_dcute;
-    Version display_link_version;
     GPUDevice gpu;
     std::vector<GPUDevice> secondary_gpus;
-    uint64 adapter_luid;
     std::string driver_vendor;
     std::string driver_version;
     std::string driver_date;
@@ -101,23 +83,18 @@ void GPUInfo::EnumerateFields(Enumerator* enumerator) const {
     std::string gl_ws_vendor;
     std::string gl_ws_version;
     std::string gl_ws_extensions;
-    uint32 gl_reset_notification_strategy;
-    bool can_lose_context;
+    uint32_t gl_reset_notification_strategy;
     bool software_rendering;
     bool direct_rendering;
     bool sandboxed;
     int process_crash_count;
     bool in_process_gpu;
+    bool passthrough_cmd_decoder;
+    bool supports_overlays;
+    bool hdr;
+    bool can_support_threaded_texture_mailbox;
     CollectInfoResult basic_info_state;
     CollectInfoResult context_info_state;
-#if defined(OS_WIN)
-    CollectInfoResult dx_diagnostics_info_state;
-    DxDiagNode dx_diagnostics;
-#endif
-    VideoDecodeAcceleratorSupportedProfiles
-        video_decode_accelerator_supported_profiles;
-    VideoEncodeAcceleratorSupportedProfiles
-        video_encode_accelerator_supported_profiles;
     bool jpeg_decode_accelerator_supported;
   };
 
@@ -136,16 +113,8 @@ void GPUInfo::EnumerateFields(Enumerator* enumerator) const {
     EnumerateGPUDevice(secondary_gpu, enumerator);
 
   enumerator->BeginAuxAttributes();
-  enumerator->AddTimeDeltaInSecondsF("initializationTime",
-                                     initialization_time);
   enumerator->AddBool("optimus", optimus);
   enumerator->AddBool("amdSwitchable", amd_switchable);
-  enumerator->AddBool("lenovoDcute", lenovo_dcute);
-  if (display_link_version.IsValid()) {
-    enumerator->AddString("displayLinkVersion",
-                          display_link_version.GetString());
-  }
-  enumerator->AddInt64("adapterLuid", adapter_luid);
   enumerator->AddString("driverVendor", driver_vendor);
   enumerator->AddString("driverVersion", driver_version);
   enumerator->AddString("driverDate", driver_date);
@@ -162,23 +131,20 @@ void GPUInfo::EnumerateFields(Enumerator* enumerator) const {
   enumerator->AddInt(
       "glResetNotificationStrategy",
       static_cast<int>(gl_reset_notification_strategy));
-  enumerator->AddBool("can_lose_context", can_lose_context);
   // TODO(kbr): add performance_stats.
   enumerator->AddBool("softwareRendering", software_rendering);
   enumerator->AddBool("directRendering", direct_rendering);
   enumerator->AddBool("sandboxed", sandboxed);
   enumerator->AddInt("processCrashCount", process_crash_count);
   enumerator->AddBool("inProcessGpu", in_process_gpu);
+  enumerator->AddBool("passthroughCmdDecoder", passthrough_cmd_decoder);
+  enumerator->AddBool("supportsOverlays", supports_overlays);
+  enumerator->AddBool("hdr", hdr);
+  enumerator->AddBool("canSupportThreadedTextureMailbox",
+                      can_support_threaded_texture_mailbox);
   enumerator->AddInt("basicInfoState", basic_info_state);
   enumerator->AddInt("contextInfoState", context_info_state);
-#if defined(OS_WIN)
-  enumerator->AddInt("DxDiagnosticsInfoState", dx_diagnostics_info_state);
-#endif
   // TODO(kbr): add dx_diagnostics on Windows.
-  for (const auto& profile : video_decode_accelerator_supported_profiles)
-    EnumerateVideoDecodeAcceleratorSupportedProfile(profile, enumerator);
-  for (const auto& profile : video_encode_accelerator_supported_profiles)
-    EnumerateVideoEncodeAcceleratorSupportedProfile(profile, enumerator);
   enumerator->AddBool("jpegDecodeAcceleratorSupported",
       jpeg_decode_accelerator_supported);
   enumerator->EndAuxAttributes();
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_info.h b/src/tests/third_party/gpu_test_expectations/gpu_info.h
index d6f61fd60..02013bc38 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_info.h
+++ b/src/tests/third_party/gpu_test_expectations/gpu_info.h
@@ -8,16 +8,16 @@
 // Provides access to the GPU information for the system
 // on which chrome is currently running.
 
+#include <stdint.h>
+
 #include <string>
 #include <vector>
 
-#include "base/basictypes.h"
-#include "base/time/time.h"
-#include "base/version.h"
-#include "build/build_config.h"
-#include "gpu/config/dx_diag_node.h"
-#include "gpu/gpu_export.h"
-#include "ui/gfx/geometry/size.h"
+#include "angle_config.h"
+
+#if defined(USE_X11) && !defined(OS_CHROMEOS)
+typedef unsigned long VisualID;
+#endif
 
 namespace gpu {
 
@@ -39,51 +39,42 @@ enum VideoCodecProfile {
   VIDEO_CODEC_PROFILE_UNKNOWN = -1,
   VIDEO_CODEC_PROFILE_MIN = VIDEO_CODEC_PROFILE_UNKNOWN,
   H264PROFILE_BASELINE = 0,
-  H264PROFILE_MAIN = 1,
-  H264PROFILE_EXTENDED = 2,
-  H264PROFILE_HIGH = 3,
-  H264PROFILE_HIGH10PROFILE = 4,
-  H264PROFILE_HIGH422PROFILE = 5,
-  H264PROFILE_HIGH444PREDICTIVEPROFILE = 6,
-  H264PROFILE_SCALABLEBASELINE = 7,
-  H264PROFILE_SCALABLEHIGH = 8,
-  H264PROFILE_STEREOHIGH = 9,
-  H264PROFILE_MULTIVIEWHIGH = 10,
-  VP8PROFILE_ANY = 11,
-  VP9PROFILE_ANY = 12,
-  VIDEO_CODEC_PROFILE_MAX = VP9PROFILE_ANY,
+  H264PROFILE_MAIN,
+  H264PROFILE_EXTENDED,
+  H264PROFILE_HIGH,
+  H264PROFILE_HIGH10PROFILE,
+  H264PROFILE_HIGH422PROFILE,
+  H264PROFILE_HIGH444PREDICTIVEPROFILE,
+  H264PROFILE_SCALABLEBASELINE,
+  H264PROFILE_SCALABLEHIGH,
+  H264PROFILE_STEREOHIGH,
+  H264PROFILE_MULTIVIEWHIGH,
+  VP8PROFILE_ANY,
+  VP9PROFILE_PROFILE0,
+  VP9PROFILE_PROFILE1,
+  VP9PROFILE_PROFILE2,
+  VP9PROFILE_PROFILE3,
+  HEVCPROFILE_MAIN,
+  HEVCPROFILE_MAIN10,
+  HEVCPROFILE_MAIN_STILL_PICTURE,
+  DOLBYVISION_PROFILE0,
+  DOLBYVISION_PROFILE4,
+  DOLBYVISION_PROFILE5,
+  DOLBYVISION_PROFILE7,
+  VIDEO_CODEC_PROFILE_MAX = DOLBYVISION_PROFILE7,
 };
 
-// Specification of a decoding profile supported by a hardware decoder.
-struct GPU_EXPORT VideoDecodeAcceleratorSupportedProfile {
-  VideoCodecProfile profile;
-  gfx::Size max_resolution;
-  gfx::Size min_resolution;
-};
-using VideoDecodeAcceleratorSupportedProfiles =
-    std::vector<VideoDecodeAcceleratorSupportedProfile>;
-
-// Specification of an encoding profile supported by a hardware encoder.
-struct GPU_EXPORT VideoEncodeAcceleratorSupportedProfile {
-  VideoCodecProfile profile;
-  gfx::Size max_resolution;
-  uint32 max_framerate_numerator;
-  uint32 max_framerate_denominator;
-};
-using VideoEncodeAcceleratorSupportedProfiles =
-    std::vector<VideoEncodeAcceleratorSupportedProfile>;
-
 struct GPU_EXPORT GPUInfo {
   struct GPU_EXPORT GPUDevice {
     GPUDevice();
     ~GPUDevice();
 
-    // The DWORD (uint32) representing the graphics card vendor id.
-    uint32 vendor_id;
+    // The DWORD (uint32_t) representing the graphics card vendor id.
+    uint32_t vendor_id;
 
-    // The DWORD (uint32) representing the graphics card device id.
+    // The DWORD (uint32_t) representing the graphics card device id.
     // Device ids are unique to vendor, not to one another.
-    uint32 device_id;
+    uint32_t device_id;
 
     // Whether this GPU is the currently used one.
     // Currently this field is only supported and meaningful on OS X.
@@ -98,41 +89,23 @@ struct GPU_EXPORT GPUInfo {
   };
 
   GPUInfo();
+  GPUInfo(const GPUInfo& other);
   ~GPUInfo();
 
-  bool SupportsAccelerated2dCanvas() const {
-    return !can_lose_context && !software_rendering;
-  }
-
-  // The amount of time taken to get from the process starting to the message
-  // loop being pumped.
-  base::TimeDelta initialization_time;
-
   // Computer has NVIDIA Optimus
   bool optimus;
 
   // Computer has AMD Dynamic Switchable Graphics
   bool amd_switchable;
 
-  // Lenovo dCute is installed. http://crbug.com/181665.
-  bool lenovo_dcute;
-
-  // Version of DisplayLink driver installed. Zero if not installed.
-  // http://crbug.com/177611.
-  Version display_link_version;
-
   // Primary GPU, for exmaple, the discrete GPU in a dual GPU machine.
   GPUDevice gpu;
 
   // Secondary GPUs, for example, the integrated GPU in a dual GPU machine.
   std::vector<GPUDevice> secondary_gpus;
 
-  // On Windows, the unique identifier of the adapter the GPU process uses.
-  // The default is zero, which makes the browser process create its D3D device
-  // on the primary adapter. Note that the primary adapter can change at any
-  // time so it is better to specify a particular LUID. Note that valid LUIDs
-  // are always non-zero.
-  uint64 adapter_luid;
+  // The currently active gpu.
+  const GPUDevice& active_gpu() const;
 
   // The vendor of the graphics driver currently installed.
   std::string driver_vendor;
@@ -188,11 +161,7 @@ struct GPU_EXPORT GPUInfo {
 
   // GL reset notification strategy as defined by GL_ARB_robustness. 0 if GPU
   // reset detection or notification not available.
-  uint32 gl_reset_notification_strategy;
-
-  // The device semantics, i.e. whether the Vista and Windows 7 specific
-  // semantics are available.
-  bool can_lose_context;
+  uint32_t gl_reset_notification_strategy;
 
   bool software_rendering;
 
@@ -209,21 +178,25 @@ struct GPU_EXPORT GPUInfo {
   // True if the GPU is running in the browser process instead of its own.
   bool in_process_gpu;
 
+  // True if the GPU process is using the passthrough command decoder.
+  bool passthrough_cmd_decoder;
+
+  // True if the current set of outputs supports overlays.
+  bool supports_overlays = false;
+
+  // True if the current set of outputs supports HDR.
+  bool hdr = false;
+
+  // True only on android when extensions for threaded mailbox sharing are
+  // present. Threaded mailbox sharing is used on Android only, so this check
+  // is only implemented on Android.
+  bool can_support_threaded_texture_mailbox = false;
+
   // The state of whether the basic/context/DxDiagnostics info is collected and
   // if the collection fails or not.
   CollectInfoResult basic_info_state;
   CollectInfoResult context_info_state;
-#if defined(OS_WIN)
-  CollectInfoResult dx_diagnostics_info_state;
-
-  // The information returned by the DirectX Diagnostics Tool.
-  DxDiagNode dx_diagnostics;
-#endif
 
-  VideoDecodeAcceleratorSupportedProfiles
-      video_decode_accelerator_supported_profiles;
-  VideoEncodeAcceleratorSupportedProfiles
-      video_encode_accelerator_supported_profiles;
   bool jpeg_decode_accelerator_supported;
 
   // Note: when adding new members, please remember to update EnumerateFields
@@ -239,12 +212,10 @@ struct GPU_EXPORT GPUInfo {
     // is the root object, but calls to BeginGPUDevice/EndGPUDevice and
     // BeginAuxAttributes/EndAuxAttributes change the object to which these
     // calls should apply.
-    virtual void AddInt64(const char* name, int64 value) = 0;
+    virtual void AddInt64(const char* name, int64_t value) = 0;
     virtual void AddInt(const char* name, int value) = 0;
     virtual void AddString(const char* name, const std::string& value) = 0;
     virtual void AddBool(const char* name, bool value) = 0;
-    virtual void AddTimeDeltaInSecondsF(const char* name,
-                                        const base::TimeDelta& value) = 0;
 
     // Markers indicating that a GPUDevice is being described.
     virtual void BeginGPUDevice() = 0;
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_config.cc b/src/tests/third_party/gpu_test_expectations/gpu_test_config.cc
index a7cc4b412..06a5b9107 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_test_config.cc
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_config.cc
@@ -2,20 +2,205 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "gpu/config/gpu_test_config.h"
+#include "gpu_test_config.h"
 
-#include "base/logging.h"
-#include "base/sys_info.h"
-#include "gpu/config/gpu_info.h"
-#include "gpu/config/gpu_info_collector.h"
-#include "gpu/config/gpu_test_expectations_parser.h"
+#include "gpu_info.h"
+#include "gpu_test_expectations_parser.h"
+
+#if defined(OS_LINUX)
+extern "C" {
+#   include <pci/pci.h>
+}
+#endif
 
 #if defined(OS_MACOSX)
-#include "base/mac/mac_util.h"
-#elif defined(OS_WIN)
-#include "base/win/windows_version.h"
+#include "gpu_test_config_mac.h"
+#endif
+
+using namespace gpu;
+
+#if defined(OS_WIN)
+
+namespace base {
+
+namespace {
+
+// Disable the deprecated function warning for GetVersionEx
+#pragma warning(disable: 4996)
+
+class SysInfo
+{
+  public:
+    static void OperatingSystemVersionNumbers(
+        int32 *major_version, int32 *minor_version, int32 *bugfix_version);
+};
+
+// static
+void SysInfo::OperatingSystemVersionNumbers(
+    int32 *major_version, int32 *minor_version, int32 *bugfix_version)
+{
+  OSVERSIONINFOEX version_info = { sizeof version_info };
+  ::GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&version_info));
+  *major_version = version_info.dwMajorVersion;
+  *minor_version = version_info.dwMinorVersion;
+  *bugfix_version = version_info.dwBuildNumber;
+}
+
+} // anonymous namespace
+
+} // namespace base
+
+void DeviceIDToVendorAndDevice(const std::string& id,
+                               uint32* vendor_id,
+                               uint32* device_id) {
+  *vendor_id = 0;
+  *device_id = 0;
+  if (id.length() < 21)
+    return;
+  std::string vendor_id_string = id.substr(8, 4);
+  std::string device_id_string = id.substr(17, 4);
+  base::HexStringToUInt(vendor_id_string, vendor_id);
+  base::HexStringToUInt(device_id_string, device_id);
+}
+
+CollectInfoResult CollectGpuID(uint32* vendor_id, uint32* device_id) {
+  DCHECK(vendor_id && device_id);
+  *vendor_id = 0;
+  *device_id = 0;
+
+  // Taken from http://developer.nvidia.com/object/device_ids.html
+  DISPLAY_DEVICEA dd;
+  dd.cb = sizeof(DISPLAY_DEVICEA);
+  std::string id;
+  for (int i = 0; EnumDisplayDevicesA(NULL, i, &dd, 0); ++i) {
+    if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {
+      id = dd.DeviceID;
+      break;
+    }
+  }
+
+  if (id.length() > 20) {
+    DeviceIDToVendorAndDevice(id, vendor_id, device_id);
+    if (*vendor_id != 0 && *device_id != 0)
+      return kCollectInfoSuccess;
+  }
+  return kCollectInfoNonFatalFailure;
+}
+
+#endif // defined(OS_WIN)
+
+#if defined(OS_LINUX)
+
+const uint32 kVendorIDIntel = 0x8086;
+const uint32 kVendorIDNVidia = 0x10de;
+const uint32 kVendorIDAMD = 0x1002;
+
+CollectInfoResult CollectPCIVideoCardInfo(GPUInfo* gpu_info) {
+  DCHECK(gpu_info);
+
+  struct pci_access* access = pci_alloc();
+  DCHECK(access != NULL);
+  pci_init(access);
+  pci_scan_bus(access);
+
+  bool primary_gpu_identified = false;
+  for (pci_dev* device = access->devices;
+       device != NULL; device = device->next) {
+    pci_fill_info(device, 33);
+    bool is_gpu = false;
+    switch (device->device_class) {
+      case PCI_CLASS_DISPLAY_VGA:
+      case PCI_CLASS_DISPLAY_XGA:
+      case PCI_CLASS_DISPLAY_3D:
+        is_gpu = true;
+        break;
+      case PCI_CLASS_DISPLAY_OTHER:
+      default:
+        break;
+    }
+    if (!is_gpu)
+      continue;
+    if (device->vendor_id == 0 || device->device_id == 0)
+      continue;
+
+    GPUInfo::GPUDevice gpu;
+    gpu.vendor_id = device->vendor_id;
+    gpu.device_id = device->device_id;
+
+    if (!primary_gpu_identified) {
+      primary_gpu_identified = true;
+      gpu_info->gpu = gpu;
+    } else {
+      // TODO(zmo): if there are multiple GPUs, we assume the non Intel
+      // one is primary. Revisit this logic because we actually don't know
+      // which GPU we are using at this point.
+      if (gpu_info->gpu.vendor_id == kVendorIDIntel &&
+          gpu.vendor_id != kVendorIDIntel) {
+        gpu_info->secondary_gpus.push_back(gpu_info->gpu);
+        gpu_info->gpu = gpu;
+      } else {
+        gpu_info->secondary_gpus.push_back(gpu);
+      }
+    }
+  }
+
+  // Detect Optimus or AMD Switchable GPU.
+  if (gpu_info->secondary_gpus.size() == 1 &&
+      gpu_info->secondary_gpus[0].vendor_id == kVendorIDIntel) {
+    if (gpu_info->gpu.vendor_id == kVendorIDNVidia)
+      gpu_info->optimus = true;
+    if (gpu_info->gpu.vendor_id == kVendorIDAMD)
+      gpu_info->amd_switchable = true;
+  }
+
+  pci_cleanup(access);
+  if (!primary_gpu_identified)
+    return kCollectInfoNonFatalFailure;
+  return kCollectInfoSuccess;
+}
+
+CollectInfoResult CollectGpuID(uint32* vendor_id, uint32* device_id) {
+  DCHECK(vendor_id && device_id);
+  *vendor_id = 0;
+  *device_id = 0;
+
+  GPUInfo gpu_info;
+  CollectInfoResult result = CollectPCIVideoCardInfo(&gpu_info);
+  if (result == kCollectInfoSuccess) {
+    *vendor_id = gpu_info.gpu.vendor_id;
+    *device_id = gpu_info.gpu.device_id;
+  }
+  return result;
+}
+
+#endif // defined(OS_LINUX)
+
+#if defined(OS_MACOSX)
+
+CollectInfoResult CollectGpuID(uint32* vendor_id, uint32* device_id) {
+  DCHECK(vendor_id && device_id);
+
+  GPUInfo::GPUDevice gpu = GetActiveGPU();
+  *vendor_id = gpu.vendor_id;
+  *device_id = gpu.device_id;
+
+  if (*vendor_id != 0 && *device_id != 0)
+    return kCollectInfoSuccess;
+  return kCollectInfoNonFatalFailure;
+}
+
 #endif
 
+#if defined(OS_ANDROID)
+CollectInfoResult CollectGpuID(uint32 *vendor_id, uint32 *device_id)
+{
+    DCHECK(vendor_id && device_id);
+    *vendor_id = 0;
+    *device_id = 0;
+    return kCollectInfoNonFatalFailure;
+}
+#endif  // defined(OS_ANDROID)
+
 namespace gpu {
 
 namespace {
@@ -26,9 +211,9 @@ GPUTestConfig::OS GetCurrentOS() {
 #elif defined(OS_LINUX) || defined(OS_OPENBSD)
   return GPUTestConfig::kOsLinux;
 #elif defined(OS_WIN)
-  int32 major_version = 0;
-  int32 minor_version = 0;
-  int32 bugfix_version = 0;
+  int32_t major_version = 0;
+  int32_t minor_version = 0;
+  int32_t bugfix_version = 0;
   base::SysInfo::OperatingSystemVersionNumbers(
       &major_version, &minor_version, &bugfix_version);
   if (major_version == 5)
@@ -42,9 +227,9 @@ GPUTestConfig::OS GetCurrentOS() {
   if (major_version == 10)
     return GPUTestConfig::kOsWin10;
 #elif defined(OS_MACOSX)
-  int32 major_version = 0;
-  int32 minor_version = 0;
-  int32 bugfix_version = 0;
+  int32_t major_version = 0;
+  int32_t minor_version = 0;
+  int32_t bugfix_version = 0;
   base::SysInfo::OperatingSystemVersionNumbers(
       &major_version, &minor_version, &bugfix_version);
   if (major_version == 10) {
@@ -63,6 +248,8 @@ GPUTestConfig::OS GetCurrentOS() {
         return GPUTestConfig::kOsMacYosemite;
       case 11:
         return GPUTestConfig::kOsMacElCapitan;
+      case 12:
+        return GPUTestConfig::kOsMacSierra;
     }
   }
 #elif defined(OS_ANDROID)
@@ -80,31 +267,33 @@ GPUTestConfig::GPUTestConfig()
       build_type_(kBuildTypeUnknown),
       api_(kAPIUnknown) {}
 
+GPUTestConfig::GPUTestConfig(const GPUTestConfig& other) = default;
+
 GPUTestConfig::~GPUTestConfig() {
 }
 
-void GPUTestConfig::set_os(int32 os) {
+void GPUTestConfig::set_os(int32_t os) {
   DCHECK_EQ(0, os & ~(kOsAndroid | kOsWin | kOsMac | kOsLinux | kOsChromeOS));
   os_ = os;
 }
 
-void GPUTestConfig::AddGPUVendor(uint32 gpu_vendor) {
+void GPUTestConfig::AddGPUVendor(uint32_t gpu_vendor) {
   DCHECK_NE(0u, gpu_vendor);
   for (size_t i = 0; i < gpu_vendor_.size(); ++i)
     DCHECK_NE(gpu_vendor_[i], gpu_vendor);
   gpu_vendor_.push_back(gpu_vendor);
 }
 
-void GPUTestConfig::set_gpu_device_id(uint32 id) {
+void GPUTestConfig::set_gpu_device_id(uint32_t id) {
   gpu_device_id_ = id;
 }
 
-void GPUTestConfig::set_build_type(int32 build_type) {
+void GPUTestConfig::set_build_type(int32_t build_type) {
   DCHECK_EQ(0, build_type & ~(kBuildTypeRelease | kBuildTypeDebug));
   build_type_ = build_type;
 }
 
-void GPUTestConfig::set_api(int32 api) {
+void GPUTestConfig::set_api(int32_t api) {
   DCHECK_EQ(0, api & ~(kAPID3D9 | kAPID3D11 | kAPIGLDesktop | kAPIGLES));
   api_ = api;
 }
@@ -157,7 +346,7 @@ void GPUTestConfig::ClearGPUVendor() {
 GPUTestBotConfig::~GPUTestBotConfig() {
 }
 
-void GPUTestBotConfig::AddGPUVendor(uint32 gpu_vendor) {
+void GPUTestBotConfig::AddGPUVendor(uint32_t gpu_vendor) {
   DCHECK_EQ(0u, GPUTestConfig::gpu_vendor().size());
   GPUTestConfig::AddGPUVendor(gpu_vendor);
 }
@@ -186,6 +375,7 @@ bool GPUTestBotConfig::IsValid() const {
     case kOsMacMavericks:
     case kOsMacYosemite:
     case kOsMacElCapitan:
+    case kOsMacSierra:
     case kOsLinux:
     case kOsChromeOS:
     case kOsAndroid:
@@ -249,8 +439,7 @@ bool GPUTestBotConfig::LoadCurrentConfig(const GPUInfo* gpu_info) {
   bool rt;
   if (gpu_info == NULL) {
     GPUInfo my_gpu_info;
-    CollectInfoResult result = CollectGpuID(
-        &my_gpu_info.gpu.vendor_id, &my_gpu_info.gpu.device_id);
+    CollectInfoResult result = CollectGpuID(&my_gpu_info.gpu.vendor_id, &my_gpu_info.gpu.device_id);
     if (result != kCollectInfoSuccess) {
       LOG(ERROR) << "Fail to identify GPU";
       DisableGPUInfoValidation();
@@ -295,21 +484,5 @@ bool GPUTestBotConfig::CurrentConfigMatches(
   return false;
 }
 
-// static
-bool GPUTestBotConfig::GpuBlacklistedOnBot() {
-#if defined(OS_MACOSX)
-  // Blacklist rule #81 disables all Gpu acceleration on Mac < 10.8 bots.
-  if (CurrentConfigMatches("MAC VMWARE") && base::mac::IsOSLionOrEarlier()) {
-    return true;
-  }
-#elif defined(OS_WIN)
-  // Blacklist rule #79 disables all Gpu acceleration before Windows 7.
-  if (base::win::GetVersion() <= base::win::VERSION_VISTA) {
-    return true;
-  }
-#endif
-  return false;
-}
-
 }  // namespace gpu
 
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_config.h b/src/tests/third_party/gpu_test_expectations/gpu_test_config.h
index b5431e673..23b779c22 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_test_config.h
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_config.h
@@ -5,12 +5,12 @@
 #ifndef GPU_CONFIG_GPU_TEST_CONFIG_H_
 #define GPU_CONFIG_GPU_TEST_CONFIG_H_
 
+#include <stdint.h>
+
 #include <string>
 #include <vector>
 
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "gpu/gpu_export.h"
+#include "angle_config.h"
 
 namespace gpu {
 
@@ -31,13 +31,14 @@ class GPU_EXPORT GPUTestConfig {
     kOsMacMavericks = 1 << 8,
     kOsMacYosemite = 1 << 9,
     kOsMacElCapitan = 1 << 10,
+    kOsMacSierra = 1 << 11,
     kOsMac = kOsMacLeopard | kOsMacSnowLeopard | kOsMacLion |
              kOsMacMountainLion | kOsMacMavericks | kOsMacYosemite |
-             kOsMacElCapitan,
-    kOsLinux = 1 << 11,
-    kOsChromeOS = 1 << 12,
-    kOsAndroid = 1 << 13,
-    kOsWin10 = 1 << 14,
+             kOsMacElCapitan | kOsMacSierra,
+    kOsLinux = 1 << 12,
+    kOsChromeOS = 1 << 13,
+    kOsAndroid = 1 << 14,
+    kOsWin10 = 1 << 15,
     kOsWin = kOsWinXP | kOsWinVista | kOsWin7 | kOsWin8 | kOsWin10,
   };
 
@@ -56,20 +57,21 @@ class GPU_EXPORT GPUTestConfig {
   };
 
   GPUTestConfig();
+  GPUTestConfig(const GPUTestConfig& other);
   virtual ~GPUTestConfig();
 
-  void set_os(int32 os);
-  void set_gpu_device_id(uint32 id);
-  void set_build_type(int32 build_type);
-  void set_api(int32 api);
+  void set_os(int32_t os);
+  void set_gpu_device_id(uint32_t id);
+  void set_build_type(int32_t build_type);
+  void set_api(int32_t api);
 
-  virtual void AddGPUVendor(uint32 gpu_vendor);
+  virtual void AddGPUVendor(uint32_t gpu_vendor);
 
-  int32 os() const { return os_; }
-  const std::vector<uint32>& gpu_vendor() const { return gpu_vendor_; }
-  uint32 gpu_device_id() const { return gpu_device_id_; }
-  int32 build_type() const { return build_type_; }
-  int32 api() const { return api_; }
+  int32_t os() const { return os_; }
+  const std::vector<uint32_t>& gpu_vendor() const { return gpu_vendor_; }
+  uint32_t gpu_device_id() const { return gpu_device_id_; }
+  int32_t build_type() const { return build_type_; }
+  int32_t api() const { return api_; }
 
   // Check if the config is valid. For example, if gpu_device_id_ is set, but
   // gpu_vendor_ is unknown, then it's invalid.
@@ -91,19 +93,19 @@ class GPU_EXPORT GPUTestConfig {
 
  private:
   // operating system.
-  int32 os_;
+  int32_t os_;
 
   // GPU vendor.
-  std::vector<uint32> gpu_vendor_;
+  std::vector<uint32_t> gpu_vendor_;
 
   // GPU device id (unique to each vendor).
-  uint32 gpu_device_id_;
+  uint32_t gpu_device_id_;
 
   // Release or Debug.
-  int32 build_type_;
+  int32_t build_type_;
 
   // Back-end rendering APIs.
-  int32 api_;
+  int32_t api_;
 };
 
 class GPU_EXPORT GPUTestBotConfig : public GPUTestConfig {
@@ -112,7 +114,7 @@ class GPU_EXPORT GPUTestBotConfig : public GPUTestConfig {
   ~GPUTestBotConfig() override;
 
   // This should only be called when no gpu_vendor is added.
-  void AddGPUVendor(uint32 gpu_vendor) override;
+  void AddGPUVendor(uint32_t gpu_vendor) override;
 
   // Return false if gpu_info does not have valid vendor_id and device_id.
   bool SetGPUInfo(const GPUInfo& gpu_info);
@@ -134,9 +136,6 @@ class GPU_EXPORT GPUTestBotConfig : public GPUTestConfig {
   // Check if this bot's config matches |config_data| or any of the |configs|.
   static bool CurrentConfigMatches(const std::string& config_data);
   static bool CurrentConfigMatches(const std::vector<std::string>& configs);
-
-  // Check if the bot has blacklisted all GPU features.
-  static bool GpuBlacklistedOnBot();
 };
 
 }  // namespace gpu
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.h b/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.h
new file mode 100644
index 000000000..da22bd6ee
--- /dev/null
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.h
@@ -0,0 +1,28 @@
+//
+// Copyright 2015 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// gpu_test_config_mac.h:
+//   Helper functions for gpu_test_config that have to be compiled in ObjectiveC++
+//
+
+#ifndef GPU_TEST_EXPECTATIONS_GPU_TEST_CONFIG_MAC_H_
+#define GPU_TEST_EXPECTATIONS_GPU_TEST_CONFIG_MAC_H_
+
+#include "gpu_info.h"
+
+namespace base {
+
+class SysInfo
+{
+  public:
+    static void OperatingSystemVersionNumbers(
+        int32 *major_version, int32 *minor_version, int32 *bugfix_version);
+};
+
+} // namespace base
+
+gpu::GPUInfo::GPUDevice GetActiveGPU();
+
+#endif // GPU_TEST_EXPECTATIONS_GPU_TEST_CONFIG_MAC_H_
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.mm b/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.mm
new file mode 100644
index 000000000..e33804b7e
--- /dev/null
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_config_mac.mm
@@ -0,0 +1,75 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// gpu_test_config_mac.mm:
+//   Helper functions for gpu_test_config that have to be compiled in ObjectiveC++
+
+#include "gpu_test_config_mac.h"
+
+#import <Cocoa/Cocoa.h>
+
+namespace base {
+
+// OSX 10.8 deprecates Gestalt but doesn't make the operatingSystemVersion property part of the
+// public interface of NSProcessInfo until 10.10. Add a forward declaration.
+#if !defined(MAC_OS_X_VERSION_10_10) || MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10
+@interface NSProcessInfo (YosemiteSDK)
+@property(readonly) NSOperatingSystemVersion operatingSystemVersion;
+@end
+#endif
+
+void SysInfo::OperatingSystemVersionNumbers(
+    int32 *major_version, int32 *minor_version, int32 *bugfix_version)
+{
+#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_8
+  Gestalt(gestaltSystemVersionMajor, reinterpret_cast<SInt32*>(major_version));
+  Gestalt(gestaltSystemVersionMinor, reinterpret_cast<SInt32*>(minor_version));
+  Gestalt(gestaltSystemVersionBugFix, reinterpret_cast<SInt32*>(bugfix_version));
+#else
+  NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];
+  *major_version = version.majorVersion;
+  *minor_version = version.minorVersion;
+  *bugfix_version = version.patchVersion;
+#endif
+}
+
+} // namespace base
+
+UInt32 GetEntryProperty(io_registry_entry_t entry, CFStringRef property_name) {
+  CFTypeRef type = IORegistryEntrySearchCFProperty(entry,
+                                                   kIOServicePlane,
+                                                   property_name,
+                                                   kCFAllocatorDefault,
+                                                   kIORegistryIterateRecursively | kIORegistryIterateParents);
+  CFDataRef data = reinterpret_cast<CFDataRef>(type);
+  if (!data) {
+    CFRelease(data);
+    return 0;
+  }
+
+  UInt32 value = 0;
+  const uint32_t* valuePointer = reinterpret_cast<const uint32_t*>(CFDataGetBytePtr(data));
+  if (valuePointer != NULL) {
+    value = *valuePointer;
+  }
+  CFRelease(data);
+  return value;
+}
+
+gpu::GPUInfo::GPUDevice GetActiveGPU() {
+  gpu::GPUInfo::GPUDevice gpu;
+
+  // Ignore the fact that CGDisplayIOServicePort is deprecated as Apple
+  // did not provide a good replacement for it as of 10.10.
+  // TODO(cwallez) revisit with later systems
+  #pragma clang diagnostic push
+  #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    io_registry_entry_t dsp_port = CGDisplayIOServicePort(kCGDirectMainDisplay);
+  #pragma clang diagnostic pop
+
+  gpu.vendor_id = GetEntryProperty(dsp_port, CFSTR("vendor-id"));
+  gpu.device_id = GetEntryProperty(dsp_port, CFSTR("device-id"));
+  return gpu;
+}
+
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.cc b/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.cc
index 6dac74e21..7016078c2 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.cc
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.cc
@@ -2,14 +2,45 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "gpu/config/gpu_test_expectations_parser.h"
+#include "gpu_test_expectations_parser.h"
 
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/stringprintf.h"
+#include <sstream>
+
+#include "common/angleutils.h"
+
+namespace base {
+
+namespace {
+
+bool StartsWithASCII(const std::string& str,
+                     const std::string& search,
+                     bool case_sensitive) {
+  ASSERT(!case_sensitive);
+  return str.compare(0, search.length(), search) == 0;
+}
+
+template <class Char> inline Char ToLowerASCII(Char c) {
+  return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;
+}
+
+template<typename Iter>
+static inline bool DoLowerCaseEqualsASCII(Iter a_begin,
+                                          Iter a_end,
+                                          const char* b) {
+  for (Iter it = a_begin; it != a_end; ++it, ++b) {
+    if (!*b || base::ToLowerASCII(*it) != *b)
+      return false;
+  }
+  return *b == 0;
+}
+
+bool LowerCaseEqualsASCII(const std::string& a, const char* b) {
+  return DoLowerCaseEqualsASCII(a.begin(), a.end(), b);
+}
+
+} // anonymous namespace
+
+} // namespace base
 
 namespace gpu {
 
@@ -40,6 +71,7 @@ enum Token {
   kConfigMacMavericks,
   kConfigMacYosemite,
   kConfigMacElCapitan,
+  kConfigMacSierra,
   kConfigMac,
   kConfigLinux,
   kConfigChromeOS,
@@ -77,7 +109,7 @@ enum Token {
 
 struct TokenInfo {
   const char* name;
-  int32 flag;
+  int32_t flag;
 };
 
 const TokenInfo kTokenData[] = {
@@ -94,6 +126,7 @@ const TokenInfo kTokenData[] = {
     {"mavericks", GPUTestConfig::kOsMacMavericks},
     {"yosemite", GPUTestConfig::kOsMacYosemite},
     {"elcapitan", GPUTestConfig::kOsMacElCapitan},
+    {"sierra", GPUTestConfig::kOsMacSierra},
     {"mac", GPUTestConfig::kOsMac},
     {"linux", GPUTestConfig::kOsLinux},
     {"chromeos", GPUTestConfig::kOsChromeOS},
@@ -146,12 +179,12 @@ const char* kErrorMessage[] = {
 };
 
 Token ParseToken(const std::string& word) {
-  if (base::StartsWith(word, "//", base::CompareCase::INSENSITIVE_ASCII))
+  if (base::StartsWithASCII(word, "//", false))
     return kTokenComment;
-  if (base::StartsWith(word, "0x", base::CompareCase::INSENSITIVE_ASCII))
+  if (base::StartsWithASCII(word, "0x", false))
     return kConfigGPUDeviceID;
 
-  for (int32 i = 0; i < kNumberOfExactMatchTokens; ++i) {
+  for (int32_t i = 0; i < kNumberOfExactMatchTokens; ++i) {
     if (base::LowerCaseEqualsASCII(word, kTokenData[i].name))
       return static_cast<Token>(i);
   }
@@ -176,10 +209,10 @@ bool NamesMatching(const std::string& ref, const std::string& test_name) {
 
 GPUTestExpectationsParser::GPUTestExpectationsParser() {
   // Some sanity check.
-  DCHECK_EQ(static_cast<unsigned int>(kNumberOfExactMatchTokens),
-            sizeof(kTokenData) / sizeof(kTokenData[0]));
-  DCHECK_EQ(static_cast<unsigned int>(kNumberOfErrors),
-            sizeof(kErrorMessage) / sizeof(kErrorMessage[0]));
+  static_assert(static_cast<unsigned int>(kNumberOfExactMatchTokens) ==
+                sizeof(kTokenData) / sizeof(kTokenData[0]), "sanity check");
+  static_assert(static_cast<unsigned int>(kNumberOfErrors) ==
+                sizeof(kErrorMessage) / sizeof(kErrorMessage[0]), "sanity check");
 }
 
 GPUTestExpectationsParser::~GPUTestExpectationsParser() {
@@ -204,8 +237,8 @@ bool GPUTestExpectationsParser::LoadTestExpectations(const std::string& data) {
   return rt;
 }
 
-bool GPUTestExpectationsParser::LoadTestExpectations(
-    const base::FilePath& path) {
+bool GPUTestExpectationsParser::LoadTestExpectationsFromFile(
+    const std::string& path) {
   entries_.clear();
   error_messages_.clear();
 
@@ -217,7 +250,7 @@ bool GPUTestExpectationsParser::LoadTestExpectations(
   return LoadTestExpectations(data);
 }
 
-int32 GPUTestExpectationsParser::GetTestExpectation(
+int32_t GPUTestExpectationsParser::GetTestExpectation(
     const std::string& test_name,
     const GPUTestBotConfig& bot_config) const {
   for (size_t i = 0; i < entries_.size(); ++i) {
@@ -256,6 +289,7 @@ bool GPUTestExpectationsParser::ParseConfig(
       case kConfigMacMavericks:
       case kConfigMacYosemite:
       case kConfigMacElCapitan:
+      case kConfigMacSierra:
       case kConfigMac:
       case kConfigLinux:
       case kConfigChromeOS:
@@ -291,7 +325,7 @@ bool GPUTestExpectationsParser::ParseLine(
   std::vector<std::string> tokens = base::SplitString(
       line_data, base::kWhitespaceASCII, base::KEEP_WHITESPACE,
       base::SPLIT_WANT_NONEMPTY);
-  int32 stage = kLineParserBegin;
+  int32_t stage = kLineParserBegin;
   GPUTestExpectationEntry entry;
   entry.line_number = line_number;
   GPUTestConfig& config = entry.test_config;
@@ -315,6 +349,7 @@ bool GPUTestExpectationsParser::ParseLine(
       case kConfigMacMavericks:
       case kConfigMacYosemite:
       case kConfigMacElCapitan:
+      case kConfigMacSierra:
       case kConfigMac:
       case kConfigLinux:
       case kConfigChromeOS:
@@ -399,7 +434,7 @@ bool GPUTestExpectationsParser::ParseLine(
           stage++;
         break;
       default:
-        DCHECK(false);
+        UNREACHABLE();
         break;
     }
   }
@@ -419,8 +454,9 @@ bool GPUTestExpectationsParser::ParseLine(
   return false;
 }
 
-bool GPUTestExpectationsParser::UpdateTestConfig(
-    GPUTestConfig* config, int32 token, size_t line_number) {
+bool GPUTestExpectationsParser::UpdateTestConfig(GPUTestConfig* config,
+                                                 int32_t token,
+                                                 size_t line_number) {
   DCHECK(config);
   switch (token) {
     case kConfigWinXP:
@@ -436,6 +472,7 @@ bool GPUTestExpectationsParser::UpdateTestConfig(
     case kConfigMacMavericks:
     case kConfigMacYosemite:
     case kConfigMacElCapitan:
+    case kConfigMacSierra:
     case kConfigMac:
     case kConfigLinux:
     case kConfigChromeOS:
@@ -452,8 +489,7 @@ bool GPUTestExpectationsParser::UpdateTestConfig(
     case kConfigIntel:
     case kConfigVMWare:
       {
-        uint32 gpu_vendor =
-            static_cast<uint32>(kTokenData[token].flag);
+      uint32_t gpu_vendor = static_cast<uint32_t>(kTokenData[token].flag);
         for (size_t i = 0; i < config->gpu_vendor().size(); ++i) {
           if (config->gpu_vendor()[i] == gpu_vendor) {
             PushErrorMessage(
@@ -488,7 +524,7 @@ bool GPUTestExpectationsParser::UpdateTestConfig(
       config->set_api(config->api() | kTokenData[token].flag);
       break;
     default:
-      DCHECK(false);
+      UNREACHABLE();
       break;
   }
   return true;
@@ -499,7 +535,7 @@ bool GPUTestExpectationsParser::UpdateTestConfig(
     const std::string& gpu_device_id,
     size_t line_number) {
   DCHECK(config);
-  uint32 device_id = 0;
+  uint32_t device_id = 0;
   if (config->gpu_device_id() != 0 ||
       !base::HexStringToUInt(gpu_device_id, &device_id) ||
       device_id == 0) {
@@ -529,20 +565,18 @@ bool GPUTestExpectationsParser::DetectConflictsBetweenEntries() {
 
 void GPUTestExpectationsParser::PushErrorMessage(
     const std::string& message, size_t line_number) {
-  error_messages_.push_back(
-      base::StringPrintf("Line %d : %s",
-                         static_cast<int>(line_number), message.c_str()));
+    std::ostringstream stream;
+    stream << "Line " << line_number << " : " << message;
+    error_messages_.push_back(stream.str());
 }
 
 void GPUTestExpectationsParser::PushErrorMessage(
     const std::string& message,
     size_t entry1_line_number,
     size_t entry2_line_number) {
-  error_messages_.push_back(
-      base::StringPrintf("Line %d and %d : %s",
-                         static_cast<int>(entry1_line_number),
-                         static_cast<int>(entry2_line_number),
-                         message.c_str()));
+    std::ostringstream stream;
+    stream << "Line " << entry1_line_number << " and " << entry2_line_number << " : " << message;
+    error_messages_.push_back(stream.str());
 }
 
 GPUTestExpectationsParser:: GPUTestExpectationEntry::GPUTestExpectationEntry()
diff --git a/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.h b/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.h
index a69f7e96e..269c21544 100644
--- a/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.h
+++ b/src/tests/third_party/gpu_test_expectations/gpu_test_expectations_parser.h
@@ -5,13 +5,14 @@
 #ifndef GPU_CONFIG_GPU_TEST_EXPECTATIONS_PARSER_H_
 #define GPU_CONFIG_GPU_TEST_EXPECTATIONS_PARSER_H_
 
+#include <stddef.h>
+#include <stdint.h>
+
 #include <string>
 #include <vector>
 
-#include "base/basictypes.h"
-#include "base/files/file_path.h"
-#include "gpu/config/gpu_test_config.h"
-#include "gpu/gpu_export.h"
+#include "angle_config.h"
+#include "gpu_test_config.h"
 
 namespace gpu {
 
@@ -32,14 +33,14 @@ class GPU_EXPORT GPUTestExpectationsParser {
   // save all the entries. Otherwise, generate error messages.
   // Return true if parsing succeeds.
   bool LoadTestExpectations(const std::string& data);
-  bool LoadTestExpectations(const base::FilePath& path);
+  bool LoadTestExpectationsFromFile(const std::string& path);
 
   // Query error messages from the last LoadTestExpectations() call.
   const std::vector<std::string>& GetErrorMessages() const;
 
   // Get the test expectation of a given test on a given bot.
-  int32 GetTestExpectation(const std::string& test_name,
-                           const GPUTestBotConfig& bot_config) const;
+  int32_t GetTestExpectation(const std::string& test_name,
+                             const GPUTestBotConfig& bot_config) const;
 
   // Parse a list of config modifiers. If we have a valid entry with no
   // conflicts, | config | stores it, and the function returns true.
@@ -51,7 +52,7 @@ class GPU_EXPORT GPUTestExpectationsParser {
 
     std::string test_name;
     GPUTestConfig test_config;
-    int32 test_expectation;
+    int32_t test_expectation;
     size_t line_number;
   };
 
@@ -60,8 +61,9 @@ class GPU_EXPORT GPUTestExpectationsParser {
   bool ParseLine(const std::string& line_data, size_t line_number);
 
   // Update OS/GPUVendor/BuildType modifiers. May generate an error message.
-  bool UpdateTestConfig(
-      GPUTestConfig* config, int32 token, size_t line_number);
+  bool UpdateTestConfig(GPUTestConfig* config,
+                        int32_t token,
+                        size_t line_number);
 
   // Update GPUDeviceID modifier. May generate an error message.
   bool UpdateTestConfig(GPUTestConfig* config,
