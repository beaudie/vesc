// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from cl.xml.
//
// Copyright 2020 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_cl_autogen.cpp:
//   Defines the CL entry points.

extern "C" {

// CL 1.0
cl_int GL_APIENTRY GL_GetPlatformIDs(cl_uint num_entries,
                                     cl_platform_id *platforms,
                                     cl_uint *num_platforms)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetPlatformIDs,
          "context = %d, num_entries = %u, platforms = 0x%016" PRIxPTR
          ", num_platforms = 0x%016" PRIxPTR "",
          CID(context), num_entries, (uintptr_t)platforms, (uintptr_t)num_platforms);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetPlatformIDs(context, num_entries, platforms, num_platforms));
        if (isCallValid)
        {
            returnValue = context->getPlatformIDs(num_entries, platforms, num_platforms);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetPlatformIDs, cl_int>();
        }
        ANGLE_CAPTURE(GetPlatformIDs, isCallValid, context, num_entries, platforms, num_platforms,
                      returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetPlatformIDs, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetPlatformInfo(cl_platform_id platform,
                                      cl_platform_info param_name,
                                      size_t param_value_size,
                                      void *param_value,
                                      size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetPlatformInfo,
          "context = %d, platform = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)platform, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetPlatformInfo(context, platform, param_name, param_value_size,
                                                    param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getPlatformInfo(platform, param_name, param_value_size,
                                                   param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetPlatformInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetPlatformInfo, isCallValid, context, platform, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetPlatformInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetDeviceIDs(cl_platform_id platform,
                                   cl_device_type device_type,
                                   cl_uint num_entries,
                                   cl_device_id *devices,
                                   cl_uint *num_devices)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetDeviceIDs,
          "context = %d, platform = 0x%016" PRIxPTR
          ", device_type = %u, num_entries = %u, devices = 0x%016" PRIxPTR
          ", num_devices = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)platform, device_type, num_entries, (uintptr_t)devices,
          (uintptr_t)num_devices);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetDeviceIDs(context, platform, device_type,
                                                               num_entries, devices, num_devices));
        if (isCallValid)
        {
            returnValue =
                context->getDeviceIDs(platform, device_type, num_entries, devices, num_devices);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetDeviceIDs, cl_int>();
        }
        ANGLE_CAPTURE(GetDeviceIDs, isCallValid, context, platform, device_type, num_entries,
                      devices, num_devices, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetDeviceIDs, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetDeviceInfo(cl_device_id device,
                                    cl_device_info param_name,
                                    size_t param_value_size,
                                    void *param_value,
                                    size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetDeviceInfo,
          "context = %d, device = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)device, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetDeviceInfo(context, device, param_name, param_value_size,
                                                  param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getDeviceInfo(device, param_name, param_value_size, param_value,
                                                 param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetDeviceInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetDeviceInfo, isCallValid, context, device, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetDeviceInfo, cl_int>();
    }
    return returnValue;
}

cl_context GL_APIENTRY GL_CreateContext(const cl_context_properties *properties,
                                        cl_uint num_devices,
                                        const cl_device_id *devices,
                                        void(CL_CALLBACK *pfn_notify)(const char *errinfo,
                                                                      const void *private_info,
                                                                      size_t cb,
                                                                      void *user_data),
                                        void *user_data,
                                        cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateContext, "context = %d, properties = 0x%016" PRIxPTR ", num_devices = %u, devices = 0x%016" PRIxPTR ", user_data) = 0x%016" PRIxPTR ", user_data = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "", CID(context), (uintptr_t)properties, num_devices, (uintptr_t)devices, (uintptr_t)user_data), (uintptr_t)user_data, (uintptr_t)errcode_ret);

    cl_context returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateCreateContext(context, properties, num_devices, devices, user_data), user_data, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createContext(properties, num_devices, devices, user_data), user_data, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateContext, cl_context>();
        }
        ANGLE_CAPTURE(CreateContext, isCallValid, context, properties, num_devices, devices, user_data), user_data, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateContext, cl_context>();
    }
    return returnValue;
}

cl_context GL_APIENTRY
GL_CreateContextFromType(const cl_context_properties *properties,
                         cl_device_type device_type,
                         void(CL_CALLBACK *pfn_notify)(const char *errinfo,
                                                       const void *private_info,
                                                       size_t cb,
                                                       void *user_data),
                         void *user_data,
                         cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateContextFromType, "context = %d, properties = 0x%016" PRIxPTR ", device_type = %u, user_data) = 0x%016" PRIxPTR ", user_data = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "", CID(context), (uintptr_t)properties, device_type, (uintptr_t)user_data), (uintptr_t)user_data, (uintptr_t)errcode_ret);

    cl_context returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateCreateContextFromType(context, properties, device_type, user_data), user_data, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createContextFromType(properties, device_type, user_data), user_data, errcode_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLCreateContextFromType, cl_context>();
        }
        ANGLE_CAPTURE(CreateContextFromType, isCallValid, context, properties, device_type, user_data), user_data, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLCreateContextFromType, cl_context>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainContext(cl_context context)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainContext, "context = %d, context = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)context);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainContext(context, context));
        if (isCallValid)
        {
            returnValue = context->retainContext(context);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainContext, cl_int>();
        }
        ANGLE_CAPTURE(RetainContext, isCallValid, context, context, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainContext, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseContext(cl_context context)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseContext, "context = %d, context = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)context);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseContext(context, context));
        if (isCallValid)
        {
            returnValue = context->releaseContext(context);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseContext, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseContext, isCallValid, context, context, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseContext, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetContextInfo(cl_context context,
                                     cl_context_info param_name,
                                     size_t param_value_size,
                                     void *param_value,
                                     size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetContextInfo,
          "context = %d, context = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetContextInfo(context, context, param_name, param_value_size,
                                                   param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getContextInfo(context, param_name, param_value_size,
                                                  param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetContextInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetContextInfo, isCallValid, context, context, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetContextInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainCommandQueue(cl_command_queue command_queue)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainCommandQueue, "context = %d, command_queue = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateRetainCommandQueue(context, command_queue));
        if (isCallValid)
        {
            returnValue = context->retainCommandQueue(command_queue);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainCommandQueue, cl_int>();
        }
        ANGLE_CAPTURE(RetainCommandQueue, isCallValid, context, command_queue, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainCommandQueue, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseCommandQueue(cl_command_queue command_queue)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseCommandQueue, "context = %d, command_queue = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateReleaseCommandQueue(context, command_queue));
        if (isCallValid)
        {
            returnValue = context->releaseCommandQueue(command_queue);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseCommandQueue, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseCommandQueue, isCallValid, context, command_queue, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseCommandQueue, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetCommandQueueInfo(cl_command_queue command_queue,
                                          cl_command_queue_info param_name,
                                          size_t param_value_size,
                                          void *param_value,
                                          size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetCommandQueueInfo,
          "context = %d, command_queue = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, param_name, param_value_size,
          (uintptr_t)param_value, (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetCommandQueueInfo(context, command_queue, param_name, param_value_size,
                                         param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getCommandQueueInfo(command_queue, param_name, param_value_size,
                                                       param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetCommandQueueInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetCommandQueueInfo, isCallValid, context, command_queue, param_name,
                      param_value_size, param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetCommandQueueInfo, cl_int>();
    }
    return returnValue;
}

cl_mem GL_APIENTRY GL_CreateBuffer(cl_context context,
                                   cl_mem_flags flags,
                                   size_t size,
                                   void *host_ptr,
                                   cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateBuffer,
          "context = %d, context = 0x%016" PRIxPTR
          ", flags = %u, size = %u, host_ptr = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, flags, size, (uintptr_t)host_ptr,
          (uintptr_t)errcode_ret);

    cl_mem returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateCreateBuffer(context, context, flags, size, host_ptr, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createBuffer(context, flags, size, host_ptr, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateBuffer, cl_mem>();
        }
        ANGLE_CAPTURE(CreateBuffer, isCallValid, context, context, flags, size, host_ptr,
                      errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateBuffer, cl_mem>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainMemObject(cl_mem memobj)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainMemObject, "context = %d, memobj = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)memobj);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainMemObject(context, memobj));
        if (isCallValid)
        {
            returnValue = context->retainMemObject(memobj);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainMemObject, cl_int>();
        }
        ANGLE_CAPTURE(RetainMemObject, isCallValid, context, memobj, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainMemObject, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseMemObject(cl_mem memobj)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseMemObject, "context = %d, memobj = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)memobj);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseMemObject(context, memobj));
        if (isCallValid)
        {
            returnValue = context->releaseMemObject(memobj);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseMemObject, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseMemObject, isCallValid, context, memobj, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseMemObject, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetSupportedImageFormats(cl_context context,
                                               cl_mem_flags flags,
                                               cl_mem_object_type image_type,
                                               cl_uint num_entries,
                                               cl_image_format *image_formats,
                                               cl_uint *num_image_formats)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetSupportedImageFormats,
          "context = %d, context = 0x%016" PRIxPTR
          ", flags = %u, image_type = %u, num_entries = %u, image_formats = 0x%016" PRIxPTR
          ", num_image_formats = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, flags, image_type, num_entries,
          (uintptr_t)image_formats, (uintptr_t)num_image_formats);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetSupportedImageFormats(context, context, flags, image_type, num_entries,
                                              image_formats, num_image_formats));
        if (isCallValid)
        {
            returnValue = context->getSupportedImageFormats(context, flags, image_type, num_entries,
                                                            image_formats, num_image_formats);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLGetSupportedImageFormats, cl_int>();
        }
        ANGLE_CAPTURE(GetSupportedImageFormats, isCallValid, context, context, flags, image_type,
                      num_entries, image_formats, num_image_formats, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLGetSupportedImageFormats, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetMemObjectInfo(cl_mem memobj,
                                       cl_mem_info param_name,
                                       size_t param_value_size,
                                       void *param_value,
                                       size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetMemObjectInfo,
          "context = %d, memobj = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)memobj, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetMemObjectInfo(context, memobj, param_name, param_value_size,
                                                     param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getMemObjectInfo(memobj, param_name, param_value_size,
                                                    param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetMemObjectInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetMemObjectInfo, isCallValid, context, memobj, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetMemObjectInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetImageInfo(cl_mem image,
                                   cl_image_info param_name,
                                   size_t param_value_size,
                                   void *param_value,
                                   size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetImageInfo,
          "context = %d, image = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)image, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetImageInfo(context, image, param_name, param_value_size,
                                                 param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getImageInfo(image, param_name, param_value_size, param_value,
                                                param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetImageInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetImageInfo, isCallValid, context, image, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetImageInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainSampler(cl_sampler sampler)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainSampler, "context = %d, sampler = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)sampler);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainSampler(context, sampler));
        if (isCallValid)
        {
            returnValue = context->retainSampler(sampler);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainSampler, cl_int>();
        }
        ANGLE_CAPTURE(RetainSampler, isCallValid, context, sampler, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainSampler, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseSampler(cl_sampler sampler)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseSampler, "context = %d, sampler = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)sampler);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseSampler(context, sampler));
        if (isCallValid)
        {
            returnValue = context->releaseSampler(sampler);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseSampler, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseSampler, isCallValid, context, sampler, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseSampler, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetSamplerInfo(cl_sampler sampler,
                                     cl_sampler_info param_name,
                                     size_t param_value_size,
                                     void *param_value,
                                     size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetSamplerInfo,
          "context = %d, sampler = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)sampler, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetSamplerInfo(context, sampler, param_name, param_value_size,
                                                   param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getSamplerInfo(sampler, param_name, param_value_size,
                                                  param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetSamplerInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetSamplerInfo, isCallValid, context, sampler, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetSamplerInfo, cl_int>();
    }
    return returnValue;
}

cl_program GL_APIENTRY GL_CreateProgramWithSource(cl_context context,
                                                  cl_uint count,
                                                  const char **strings,
                                                  const size_t *lengths,
                                                  cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateProgramWithSource,
          "context = %d, context = 0x%016" PRIxPTR ", count = %u, strings = 0x%016" PRIxPTR
          ", lengths = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, count, (uintptr_t)strings, (uintptr_t)lengths,
          (uintptr_t)errcode_ret);

    cl_program returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateCreateProgramWithSource(context, context, count, strings,
                                                            lengths, errcode_ret));
        if (isCallValid)
        {
            returnValue =
                context->createProgramWithSource(context, count, strings, lengths, errcode_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLCreateProgramWithSource, cl_program>();
        }
        ANGLE_CAPTURE(CreateProgramWithSource, isCallValid, context, context, count, strings,
                      lengths, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLCreateProgramWithSource, cl_program>();
    }
    return returnValue;
}

cl_program GL_APIENTRY GL_CreateProgramWithBinary(cl_context context,
                                                  cl_uint num_devices,
                                                  const cl_device_id *device_list,
                                                  const size_t *lengths,
                                                  const unsigned char **binaries,
                                                  cl_int *binary_status,
                                                  cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateProgramWithBinary,
          "context = %d, context = 0x%016" PRIxPTR
          ", num_devices = %u, device_list = 0x%016" PRIxPTR ", lengths = 0x%016" PRIxPTR
          ", binaries = 0x%016" PRIxPTR ", binary_status = 0x%016" PRIxPTR
          ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, num_devices, (uintptr_t)device_list, (uintptr_t)lengths,
          (uintptr_t)binaries, (uintptr_t)binary_status, (uintptr_t)errcode_ret);

    cl_program returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateCreateProgramWithBinary(context, context, num_devices, device_list, lengths,
                                             binaries, binary_status, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createProgramWithBinary(
                context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLCreateProgramWithBinary, cl_program>();
        }
        ANGLE_CAPTURE(CreateProgramWithBinary, isCallValid, context, context, num_devices,
                      device_list, lengths, binaries, binary_status, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLCreateProgramWithBinary, cl_program>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainProgram(cl_program program)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainProgram, "context = %d, program = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)program);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainProgram(context, program));
        if (isCallValid)
        {
            returnValue = context->retainProgram(program);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainProgram, cl_int>();
        }
        ANGLE_CAPTURE(RetainProgram, isCallValid, context, program, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainProgram, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseProgram(cl_program program)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseProgram, "context = %d, program = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)program);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseProgram(context, program));
        if (isCallValid)
        {
            returnValue = context->releaseProgram(program);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseProgram, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseProgram, isCallValid, context, program, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseProgram, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_BuildProgram(cl_program program,
                                   cl_uint num_devices,
                                   const cl_device_id *device_list,
                                   const char *options,
                                   void(CL_CALLBACK *pfn_notify)(cl_program program,
                                                                 void *user_data),
                                   void *user_data)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLBuildProgram, "context = %d, program = 0x%016" PRIxPTR ", num_devices = %u, device_list = 0x%016" PRIxPTR ", options = 0x%016" PRIxPTR ", user_data) = 0x%016" PRIxPTR ", user_data = 0x%016" PRIxPTR "", CID(context), (uintptr_t)program, num_devices, (uintptr_t)device_list, (uintptr_t)options, (uintptr_t)user_data), (uintptr_t)user_data);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateBuildProgram(context, program, num_devices, device_list, options, user_data), user_data));
        if (isCallValid)
        {
            returnValue = context->buildProgram(program, num_devices, device_list, options, user_data), user_data);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLBuildProgram, cl_int>();
        }
        ANGLE_CAPTURE(BuildProgram, isCallValid, context, program, num_devices, device_list, options, user_data), user_data, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLBuildProgram, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetProgramInfo(cl_program program,
                                     cl_program_info param_name,
                                     size_t param_value_size,
                                     void *param_value,
                                     size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetProgramInfo,
          "context = %d, program = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)program, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetProgramInfo(context, program, param_name, param_value_size,
                                                   param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getProgramInfo(program, param_name, param_value_size,
                                                  param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetProgramInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetProgramInfo, isCallValid, context, program, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetProgramInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetProgramBuildInfo(cl_program program,
                                          cl_device_id device,
                                          cl_program_build_info param_name,
                                          size_t param_value_size,
                                          void *param_value,
                                          size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetProgramBuildInfo,
          "context = %d, program = 0x%016" PRIxPTR ", device = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)program, (uintptr_t)device, param_name, param_value_size,
          (uintptr_t)param_value, (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetProgramBuildInfo(context, program, device, param_name, param_value_size,
                                         param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getProgramBuildInfo(
                program, device, param_name, param_value_size, param_value, param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetProgramBuildInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetProgramBuildInfo, isCallValid, context, program, device, param_name,
                      param_value_size, param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetProgramBuildInfo, cl_int>();
    }
    return returnValue;
}

cl_kernel GL_APIENTRY GL_CreateKernel(cl_program program,
                                      const char *kernel_name,
                                      cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateKernel,
          "context = %d, program = 0x%016" PRIxPTR ", kernel_name = 0x%016" PRIxPTR
          ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)program, (uintptr_t)kernel_name, (uintptr_t)errcode_ret);

    cl_kernel returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateCreateKernel(context, program, kernel_name, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createKernel(program, kernel_name, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateKernel, cl_kernel>();
        }
        ANGLE_CAPTURE(CreateKernel, isCallValid, context, program, kernel_name, errcode_ret,
                      returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateKernel, cl_kernel>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_CreateKernelsInProgram(cl_program program,
                                             cl_uint num_kernels,
                                             cl_kernel *kernels,
                                             cl_uint *num_kernels_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateKernelsInProgram,
          "context = %d, program = 0x%016" PRIxPTR ", num_kernels = %u, kernels = 0x%016" PRIxPTR
          ", num_kernels_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)program, num_kernels, (uintptr_t)kernels,
          (uintptr_t)num_kernels_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateCreateKernelsInProgram(context, program, num_kernels, kernels,
                                                           num_kernels_ret));
        if (isCallValid)
        {
            returnValue =
                context->createKernelsInProgram(program, num_kernels, kernels, num_kernels_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLCreateKernelsInProgram, cl_int>();
        }
        ANGLE_CAPTURE(CreateKernelsInProgram, isCallValid, context, program, num_kernels, kernels,
                      num_kernels_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateKernelsInProgram, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainKernel(cl_kernel kernel)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainKernel, "context = %d, kernel = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)kernel);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainKernel(context, kernel));
        if (isCallValid)
        {
            returnValue = context->retainKernel(kernel);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainKernel, cl_int>();
        }
        ANGLE_CAPTURE(RetainKernel, isCallValid, context, kernel, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainKernel, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseKernel(cl_kernel kernel)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseKernel, "context = %d, kernel = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)kernel);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseKernel(context, kernel));
        if (isCallValid)
        {
            returnValue = context->releaseKernel(kernel);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseKernel, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseKernel, isCallValid, context, kernel, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseKernel, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_SetKernelArg(cl_kernel kernel,
                                   cl_uint arg_index,
                                   size_t arg_size,
                                   const void *arg_value)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLSetKernelArg,
          "context = %d, kernel = 0x%016" PRIxPTR
          ", arg_index = %u, arg_size = %u, arg_value = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)kernel, arg_index, arg_size, (uintptr_t)arg_value);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateSetKernelArg(context, kernel, arg_index, arg_size, arg_value));
        if (isCallValid)
        {
            returnValue = context->setKernelArg(kernel, arg_index, arg_size, arg_value);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLSetKernelArg, cl_int>();
        }
        ANGLE_CAPTURE(SetKernelArg, isCallValid, context, kernel, arg_index, arg_size, arg_value,
                      returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLSetKernelArg, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetKernelInfo(cl_kernel kernel,
                                    cl_kernel_info param_name,
                                    size_t param_value_size,
                                    void *param_value,
                                    size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetKernelInfo,
          "context = %d, kernel = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)kernel, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetKernelInfo(context, kernel, param_name, param_value_size,
                                                  param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getKernelInfo(kernel, param_name, param_value_size, param_value,
                                                 param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetKernelInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetKernelInfo, isCallValid, context, kernel, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetKernelInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetKernelWorkGroupInfo(cl_kernel kernel,
                                             cl_device_id device,
                                             cl_kernel_work_group_info param_name,
                                             size_t param_value_size,
                                             void *param_value,
                                             size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetKernelWorkGroupInfo,
          "context = %d, kernel = 0x%016" PRIxPTR ", device = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)kernel, (uintptr_t)device, param_name, param_value_size,
          (uintptr_t)param_value, (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetKernelWorkGroupInfo(context, kernel, device, param_name, param_value_size,
                                            param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getKernelWorkGroupInfo(
                kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLGetKernelWorkGroupInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetKernelWorkGroupInfo, isCallValid, context, kernel, device, param_name,
                      param_value_size, param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetKernelWorkGroupInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_WaitForEvents(cl_uint num_events, const cl_event *event_list)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLWaitForEvents, "context = %d, num_events = %u, event_list = 0x%016" PRIxPTR "",
          CID(context), num_events, (uintptr_t)event_list);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateWaitForEvents(context, num_events, event_list));
        if (isCallValid)
        {
            returnValue = context->waitForEvents(num_events, event_list);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLWaitForEvents, cl_int>();
        }
        ANGLE_CAPTURE(WaitForEvents, isCallValid, context, num_events, event_list, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLWaitForEvents, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetEventInfo(cl_event event,
                                   cl_event_info param_name,
                                   size_t param_value_size,
                                   void *param_value,
                                   size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetEventInfo,
          "context = %d, event = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)event, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateGetEventInfo(context, event, param_name, param_value_size,
                                                 param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getEventInfo(event, param_name, param_value_size, param_value,
                                                param_value_size_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetEventInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetEventInfo, isCallValid, context, event, param_name, param_value_size,
                      param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetEventInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_RetainEvent(cl_event event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLRetainEvent, "context = %d, event = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateRetainEvent(context, event));
        if (isCallValid)
        {
            returnValue = context->retainEvent(event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainEvent, cl_int>();
        }
        ANGLE_CAPTURE(RetainEvent, isCallValid, context, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLRetainEvent, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_ReleaseEvent(cl_event event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLReleaseEvent, "context = %d, event = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateReleaseEvent(context, event));
        if (isCallValid)
        {
            returnValue = context->releaseEvent(event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseEvent, cl_int>();
        }
        ANGLE_CAPTURE(ReleaseEvent, isCallValid, context, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLReleaseEvent, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_GetEventProfilingInfo(cl_event event,
                                            cl_profiling_info param_name,
                                            size_t param_value_size,
                                            void *param_value,
                                            size_t *param_value_size_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetEventProfilingInfo,
          "context = %d, event = 0x%016" PRIxPTR
          ", param_name = %u, param_value_size = %u, param_value = 0x%016" PRIxPTR
          ", param_value_size_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)event, param_name, param_value_size, (uintptr_t)param_value,
          (uintptr_t)param_value_size_ret);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetEventProfilingInfo(context, event, param_name, param_value_size,
                                           param_value, param_value_size_ret));
        if (isCallValid)
        {
            returnValue = context->getEventProfilingInfo(event, param_name, param_value_size,
                                                         param_value, param_value_size_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLGetEventProfilingInfo, cl_int>();
        }
        ANGLE_CAPTURE(GetEventProfilingInfo, isCallValid, context, event, param_name,
                      param_value_size, param_value, param_value_size_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLGetEventProfilingInfo, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_Flush(cl_command_queue command_queue)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLFlush, "context = %d, command_queue = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)command_queue);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateFlush(context, command_queue));
        if (isCallValid)
        {
            returnValue = context->flush(command_queue);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLFlush, cl_int>();
        }
        ANGLE_CAPTURE(Flush, isCallValid, context, command_queue, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLFlush, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_Finish(cl_command_queue command_queue)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLFinish, "context = %d, command_queue = 0x%016" PRIxPTR "", CID(context),
          (uintptr_t)command_queue);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateFinish(context, command_queue));
        if (isCallValid)
        {
            returnValue = context->finish(command_queue);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLFinish, cl_int>();
        }
        ANGLE_CAPTURE(Finish, isCallValid, context, command_queue, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLFinish, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueReadBuffer(cl_command_queue command_queue,
                                        cl_mem buffer,
                                        cl_bool blocking_read,
                                        size_t offset,
                                        size_t size,
                                        void *ptr,
                                        cl_uint num_events_in_wait_list,
                                        const cl_event *event_wait_list,
                                        cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueReadBuffer,
          "context = %d, command_queue = 0x%016" PRIxPTR ", buffer = 0x%016" PRIxPTR
          ", blocking_read = %u, offset = %u, size = %u, ptr = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)buffer, blocking_read, offset, size,
          (uintptr_t)ptr, num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueReadBuffer(context, command_queue, buffer, blocking_read, offset, size,
                                       ptr, num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue =
                context->enqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr,
                                           num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueReadBuffer, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueReadBuffer, isCallValid, context, command_queue, buffer, blocking_read,
                      offset, size, ptr, num_events_in_wait_list, event_wait_list, event,
                      returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueReadBuffer, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueWriteBuffer(cl_command_queue command_queue,
                                         cl_mem buffer,
                                         cl_bool blocking_write,
                                         size_t offset,
                                         size_t size,
                                         const void *ptr,
                                         cl_uint num_events_in_wait_list,
                                         const cl_event *event_wait_list,
                                         cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueWriteBuffer,
          "context = %d, command_queue = 0x%016" PRIxPTR ", buffer = 0x%016" PRIxPTR
          ", blocking_write = %u, offset = %u, size = %u, ptr = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)buffer, blocking_write, offset, size,
          (uintptr_t)ptr, num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateEnqueueWriteBuffer(
                                context, command_queue, buffer, blocking_write, offset, size, ptr,
                                num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue =
                context->enqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size,
                                            ptr, num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWriteBuffer, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueWriteBuffer, isCallValid, context, command_queue, buffer,
                      blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list,
                      event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWriteBuffer, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueCopyBuffer(cl_command_queue command_queue,
                                        cl_mem src_buffer,
                                        cl_mem dst_buffer,
                                        size_t src_offset,
                                        size_t dst_offset,
                                        size_t size,
                                        cl_uint num_events_in_wait_list,
                                        const cl_event *event_wait_list,
                                        cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueCopyBuffer,
          "context = %d, command_queue = 0x%016" PRIxPTR ", src_buffer = 0x%016" PRIxPTR
          ", dst_buffer = 0x%016" PRIxPTR
          ", src_offset = %u, dst_offset = %u, size = %u, num_events_in_wait_list = %u, "
          "event_wait_list = 0x%016" PRIxPTR ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)src_buffer, (uintptr_t)dst_buffer,
          src_offset, dst_offset, size, num_events_in_wait_list, (uintptr_t)event_wait_list,
          (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateEnqueueCopyBuffer(
                                context, command_queue, src_buffer, dst_buffer, src_offset,
                                dst_offset, size, num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueCopyBuffer(
                command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size,
                num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyBuffer, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueCopyBuffer, isCallValid, context, command_queue, src_buffer,
                      dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list,
                      event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyBuffer, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueReadImage(cl_command_queue command_queue,
                                       cl_mem image,
                                       cl_bool blocking_read,
                                       const size_t *origin,
                                       const size_t *region,
                                       size_t row_pitch,
                                       size_t slice_pitch,
                                       void *ptr,
                                       cl_uint num_events_in_wait_list,
                                       const cl_event *event_wait_list,
                                       cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueReadImage,
          "context = %d, command_queue = 0x%016" PRIxPTR ", image = 0x%016" PRIxPTR
          ", blocking_read = %u, origin = 0x%016" PRIxPTR ", region = 0x%016" PRIxPTR
          ", row_pitch = %u, slice_pitch = %u, ptr = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)image, blocking_read,
          (uintptr_t)origin, (uintptr_t)region, row_pitch, slice_pitch, (uintptr_t)ptr,
          num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueReadImage(context, command_queue, image, blocking_read, origin, region,
                                      row_pitch, slice_pitch, ptr, num_events_in_wait_list,
                                      event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueReadImage(
                command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr,
                num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueReadImage, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueReadImage, isCallValid, context, command_queue, image, blocking_read,
                      origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list,
                      event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueReadImage, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueWriteImage(cl_command_queue command_queue,
                                        cl_mem image,
                                        cl_bool blocking_write,
                                        const size_t *origin,
                                        const size_t *region,
                                        size_t input_row_pitch,
                                        size_t input_slice_pitch,
                                        const void *ptr,
                                        cl_uint num_events_in_wait_list,
                                        const cl_event *event_wait_list,
                                        cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueWriteImage,
          "context = %d, command_queue = 0x%016" PRIxPTR ", image = 0x%016" PRIxPTR
          ", blocking_write = %u, origin = 0x%016" PRIxPTR ", region = 0x%016" PRIxPTR
          ", input_row_pitch = %u, input_slice_pitch = %u, ptr = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)image, blocking_write,
          (uintptr_t)origin, (uintptr_t)region, input_row_pitch, input_slice_pitch, (uintptr_t)ptr,
          num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueWriteImage(context, command_queue, image, blocking_write, origin,
                                       region, input_row_pitch, input_slice_pitch, ptr,
                                       num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueWriteImage(
                command_queue, image, blocking_write, origin, region, input_row_pitch,
                input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWriteImage, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueWriteImage, isCallValid, context, command_queue, image, blocking_write,
                      origin, region, input_row_pitch, input_slice_pitch, ptr,
                      num_events_in_wait_list, event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWriteImage, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueCopyImage(cl_command_queue command_queue,
                                       cl_mem src_image,
                                       cl_mem dst_image,
                                       const size_t *src_origin,
                                       const size_t *dst_origin,
                                       const size_t *region,
                                       cl_uint num_events_in_wait_list,
                                       const cl_event *event_wait_list,
                                       cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueCopyImage,
          "context = %d, command_queue = 0x%016" PRIxPTR ", src_image = 0x%016" PRIxPTR
          ", dst_image = 0x%016" PRIxPTR ", src_origin = 0x%016" PRIxPTR
          ", dst_origin = 0x%016" PRIxPTR ", region = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)src_image, (uintptr_t)dst_image,
          (uintptr_t)src_origin, (uintptr_t)dst_origin, (uintptr_t)region, num_events_in_wait_list,
          (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueCopyImage(context, command_queue, src_image, dst_image, src_origin,
                                      dst_origin, region, num_events_in_wait_list, event_wait_list,
                                      event));
        if (isCallValid)
        {
            returnValue = context->enqueueCopyImage(command_queue, src_image, dst_image, src_origin,
                                                    dst_origin, region, num_events_in_wait_list,
                                                    event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyImage, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueCopyImage, isCallValid, context, command_queue, src_image, dst_image,
                      src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list,
                      event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyImage, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueCopyImageToBuffer(cl_command_queue command_queue,
                                               cl_mem src_image,
                                               cl_mem dst_buffer,
                                               const size_t *src_origin,
                                               const size_t *region,
                                               size_t dst_offset,
                                               cl_uint num_events_in_wait_list,
                                               const cl_event *event_wait_list,
                                               cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueCopyImageToBuffer,
          "context = %d, command_queue = 0x%016" PRIxPTR ", src_image = 0x%016" PRIxPTR
          ", dst_buffer = 0x%016" PRIxPTR ", src_origin = 0x%016" PRIxPTR
          ", region = 0x%016" PRIxPTR
          ", dst_offset = %u, num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)src_image, (uintptr_t)dst_buffer,
          (uintptr_t)src_origin, (uintptr_t)region, dst_offset, num_events_in_wait_list,
          (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateEnqueueCopyImageToBuffer(
                                context, command_queue, src_image, dst_buffer, src_origin, region,
                                dst_offset, num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueCopyImageToBuffer(
                command_queue, src_image, dst_buffer, src_origin, region, dst_offset,
                num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyImageToBuffer, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueCopyImageToBuffer, isCallValid, context, command_queue, src_image,
                      dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list,
                      event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyImageToBuffer, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueCopyBufferToImage(cl_command_queue command_queue,
                                               cl_mem src_buffer,
                                               cl_mem dst_image,
                                               size_t src_offset,
                                               const size_t *dst_origin,
                                               const size_t *region,
                                               cl_uint num_events_in_wait_list,
                                               const cl_event *event_wait_list,
                                               cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueCopyBufferToImage,
          "context = %d, command_queue = 0x%016" PRIxPTR ", src_buffer = 0x%016" PRIxPTR
          ", dst_image = 0x%016" PRIxPTR ", src_offset = %u, dst_origin = 0x%016" PRIxPTR
          ", region = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)src_buffer, (uintptr_t)dst_image,
          src_offset, (uintptr_t)dst_origin, (uintptr_t)region, num_events_in_wait_list,
          (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueCopyBufferToImage(context, command_queue, src_buffer, dst_image,
                                              src_offset, dst_origin, region,
                                              num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueCopyBufferToImage(
                command_queue, src_buffer, dst_image, src_offset, dst_origin, region,
                num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyBufferToImage, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueCopyBufferToImage, isCallValid, context, command_queue, src_buffer,
                      dst_image, src_offset, dst_origin, region, num_events_in_wait_list,
                      event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLEnqueueCopyBufferToImage, cl_int>();
    }
    return returnValue;
}

void *GL_APIENTRY GL_EnqueueMapBuffer(cl_command_queue command_queue,
                                      cl_mem buffer,
                                      cl_bool blocking_map,
                                      cl_map_flags map_flags,
                                      size_t offset,
                                      size_t size,
                                      cl_uint num_events_in_wait_list,
                                      const cl_event *event_wait_list,
                                      cl_event *event,
                                      cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueMapBuffer,
          "context = %d, command_queue = 0x%016" PRIxPTR ", buffer = 0x%016" PRIxPTR
          ", blocking_map = %u, map_flags = %u, offset = %u, size = %u, num_events_in_wait_list = "
          "%u, event_wait_list = 0x%016" PRIxPTR ", event = 0x%016" PRIxPTR
          ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)buffer, blocking_map, map_flags,
          offset, size, num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event,
          (uintptr_t)errcode_ret);

    void *returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueMapBuffer(context, command_queue, buffer, blocking_map, map_flags,
                                      offset, size, num_events_in_wait_list, event_wait_list, event,
                                      errcode_ret));
        if (isCallValid)
        {
            returnValue = context->enqueueMapBuffer(command_queue, buffer, blocking_map, map_flags,
                                                    offset, size, num_events_in_wait_list,
                                                    event_wait_list, event, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMapBuffer, void *>();
        }
        ANGLE_CAPTURE(EnqueueMapBuffer, isCallValid, context, command_queue, buffer, blocking_map,
                      map_flags, offset, size, num_events_in_wait_list, event_wait_list, event,
                      errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMapBuffer, void *>();
    }
    return returnValue;
}

void *GL_APIENTRY GL_EnqueueMapImage(cl_command_queue command_queue,
                                     cl_mem image,
                                     cl_bool blocking_map,
                                     cl_map_flags map_flags,
                                     const size_t *origin,
                                     const size_t *region,
                                     size_t *image_row_pitch,
                                     size_t *image_slice_pitch,
                                     cl_uint num_events_in_wait_list,
                                     const cl_event *event_wait_list,
                                     cl_event *event,
                                     cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueMapImage,
          "context = %d, command_queue = 0x%016" PRIxPTR ", image = 0x%016" PRIxPTR
          ", blocking_map = %u, map_flags = %u, origin = 0x%016" PRIxPTR ", region = 0x%016" PRIxPTR
          ", image_row_pitch = 0x%016" PRIxPTR ", image_slice_pitch = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)image, blocking_map, map_flags,
          (uintptr_t)origin, (uintptr_t)region, (uintptr_t)image_row_pitch,
          (uintptr_t)image_slice_pitch, num_events_in_wait_list, (uintptr_t)event_wait_list,
          (uintptr_t)event, (uintptr_t)errcode_ret);

    void *returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueMapImage(context, command_queue, image, blocking_map, map_flags, origin,
                                     region, image_row_pitch, image_slice_pitch,
                                     num_events_in_wait_list, event_wait_list, event, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->enqueueMapImage(
                command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch,
                image_slice_pitch, num_events_in_wait_list, event_wait_list, event, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMapImage, void *>();
        }
        ANGLE_CAPTURE(EnqueueMapImage, isCallValid, context, command_queue, image, blocking_map,
                      map_flags, origin, region, image_row_pitch, image_slice_pitch,
                      num_events_in_wait_list, event_wait_list, event, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMapImage, void *>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueUnmapMemObject(cl_command_queue command_queue,
                                            cl_mem memobj,
                                            void *mapped_ptr,
                                            cl_uint num_events_in_wait_list,
                                            const cl_event *event_wait_list,
                                            cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueUnmapMemObject,
          "context = %d, command_queue = 0x%016" PRIxPTR ", memobj = 0x%016" PRIxPTR
          ", mapped_ptr = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)memobj, (uintptr_t)mapped_ptr,
          num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueUnmapMemObject(context, command_queue, memobj, mapped_ptr,
                                           num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueUnmapMemObject(
                command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLEnqueueUnmapMemObject, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueUnmapMemObject, isCallValid, context, command_queue, memobj,
                      mapped_ptr, num_events_in_wait_list, event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueUnmapMemObject, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueNDRangeKernel(cl_command_queue command_queue,
                                           cl_kernel kernel,
                                           cl_uint work_dim,
                                           const size_t *global_work_offset,
                                           const size_t *global_work_size,
                                           const size_t *local_work_size,
                                           cl_uint num_events_in_wait_list,
                                           const cl_event *event_wait_list,
                                           cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueNDRangeKernel,
          "context = %d, command_queue = 0x%016" PRIxPTR ", kernel = 0x%016" PRIxPTR
          ", work_dim = %u, global_work_offset = 0x%016" PRIxPTR
          ", global_work_size = 0x%016" PRIxPTR ", local_work_size = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)kernel, work_dim,
          (uintptr_t)global_work_offset, (uintptr_t)global_work_size, (uintptr_t)local_work_size,
          num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueNDRangeKernel(context, command_queue, kernel, work_dim,
                                          global_work_offset, global_work_size, local_work_size,
                                          num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueNDRangeKernel(
                command_queue, kernel, work_dim, global_work_offset, global_work_size,
                local_work_size, num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLEnqueueNDRangeKernel, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueNDRangeKernel, isCallValid, context, command_queue, kernel, work_dim,
                      global_work_offset, global_work_size, local_work_size,
                      num_events_in_wait_list, event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueNDRangeKernel, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueNativeKernel(cl_command_queue command_queue,
                                          void(CL_CALLBACK *user_func)(void *),
                                          void *args,
                                          size_t cb_args,
                                          cl_uint num_mem_objects,
                                          const cl_mem *mem_list,
                                          const void **args_mem_loc,
                                          cl_uint num_events_in_wait_list,
                                          const cl_event *event_wait_list,
                                          cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueNativeKernel, "context = %d, command_queue = 0x%016" PRIxPTR ", ) = 0x%016" PRIxPTR ", args = 0x%016" PRIxPTR ", cb_args = %u, num_mem_objects = %u, mem_list = 0x%016" PRIxPTR ", args_mem_loc = 0x%016" PRIxPTR ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR ", event = 0x%016" PRIxPTR "", CID(context), (uintptr_t)command_queue, (uintptr_t)), (uintptr_t)args, cb_args, num_mem_objects, (uintptr_t)mem_list, (uintptr_t)args_mem_loc, num_events_in_wait_list, (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateEnqueueNativeKernel(context, command_queue, ), args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueNativeKernel(command_queue, ), args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueNativeKernel, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueNativeKernel, isCallValid, context, command_queue, ), args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueNativeKernel, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_SetCommandQueueProperty(cl_command_queue command_queue,
                                              cl_command_queue_properties properties,
                                              cl_bool enable,
                                              cl_command_queue_properties *old_properties)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLSetCommandQueueProperty,
          "context = %d, command_queue = 0x%016" PRIxPTR
          ", properties = %u, enable = %u, old_properties = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, properties, enable, (uintptr_t)old_properties);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateSetCommandQueueProperty(context, command_queue, properties,
                                                            enable, old_properties));
        if (isCallValid)
        {
            returnValue =
                context->setCommandQueueProperty(command_queue, properties, enable, old_properties);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLSetCommandQueueProperty, cl_int>();
        }
        ANGLE_CAPTURE(SetCommandQueueProperty, isCallValid, context, command_queue, properties,
                      enable, old_properties, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLSetCommandQueueProperty, cl_int>();
    }
    return returnValue;
}

cl_mem GL_APIENTRY GL_CreateImage2D(cl_context context,
                                    cl_mem_flags flags,
                                    const cl_image_format *image_format,
                                    size_t image_width,
                                    size_t image_height,
                                    size_t image_row_pitch,
                                    void *host_ptr,
                                    cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateImage2D,
          "context = %d, context = 0x%016" PRIxPTR ", flags = %u, image_format = 0x%016" PRIxPTR
          ", image_width = %u, image_height = %u, image_row_pitch = %u, host_ptr = 0x%016" PRIxPTR
          ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, flags, (uintptr_t)image_format, image_width,
          image_height, image_row_pitch, (uintptr_t)host_ptr, (uintptr_t)errcode_ret);

    cl_mem returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateCreateImage2D(context, context, flags, image_format, image_width, image_height,
                                   image_row_pitch, host_ptr, errcode_ret));
        if (isCallValid)
        {
            returnValue =
                context->createImage2D(context, flags, image_format, image_width, image_height,
                                       image_row_pitch, host_ptr, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateImage2D, cl_mem>();
        }
        ANGLE_CAPTURE(CreateImage2D, isCallValid, context, context, flags, image_format,
                      image_width, image_height, image_row_pitch, host_ptr, errcode_ret,
                      returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateImage2D, cl_mem>();
    }
    return returnValue;
}

cl_mem GL_APIENTRY GL_CreateImage3D(cl_context context,
                                    cl_mem_flags flags,
                                    const cl_image_format *image_format,
                                    size_t image_width,
                                    size_t image_height,
                                    size_t image_depth,
                                    size_t image_row_pitch,
                                    size_t image_slice_pitch,
                                    void *host_ptr,
                                    cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateImage3D,
          "context = %d, context = 0x%016" PRIxPTR ", flags = %u, image_format = 0x%016" PRIxPTR
          ", image_width = %u, image_height = %u, image_depth = %u, image_row_pitch = %u, "
          "image_slice_pitch = %u, host_ptr = 0x%016" PRIxPTR ", errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, flags, (uintptr_t)image_format, image_width,
          image_height, image_depth, image_row_pitch, image_slice_pitch, (uintptr_t)host_ptr,
          (uintptr_t)errcode_ret);

    cl_mem returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateCreateImage3D(context, context, flags, image_format, image_width, image_height,
                                   image_depth, image_row_pitch, image_slice_pitch, host_ptr,
                                   errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createImage3D(context, flags, image_format, image_width,
                                                 image_height, image_depth, image_row_pitch,
                                                 image_slice_pitch, host_ptr, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateImage3D, cl_mem>();
        }
        ANGLE_CAPTURE(CreateImage3D, isCallValid, context, context, flags, image_format,
                      image_width, image_height, image_depth, image_row_pitch, image_slice_pitch,
                      host_ptr, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateImage3D, cl_mem>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueMarker(cl_command_queue command_queue, cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueMarker,
          "context = %d, command_queue = 0x%016" PRIxPTR ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateEnqueueMarker(context, command_queue, event));
        if (isCallValid)
        {
            returnValue = context->enqueueMarker(command_queue, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMarker, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueMarker, isCallValid, context, command_queue, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueMarker, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueWaitForEvents(cl_command_queue command_queue,
                                           cl_uint num_events,
                                           const cl_event *event_list)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueWaitForEvents,
          "context = %d, command_queue = 0x%016" PRIxPTR
          ", num_events = %u, event_list = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, num_events, (uintptr_t)event_list);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateEnqueueWaitForEvents(context, command_queue, num_events, event_list));
        if (isCallValid)
        {
            returnValue = context->enqueueWaitForEvents(command_queue, num_events, event_list);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWaitForEvents, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueWaitForEvents, isCallValid, context, command_queue, num_events,
                      event_list, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueWaitForEvents, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueBarrier(cl_command_queue command_queue)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueBarrier, "context = %d, command_queue = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateEnqueueBarrier(context, command_queue));
        if (isCallValid)
        {
            returnValue = context->enqueueBarrier(command_queue);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueBarrier, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueBarrier, isCallValid, context, command_queue, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueBarrier, cl_int>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_UnloadCompiler()
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLUnloadCompiler, "context = %d", CID(context));

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUnloadCompiler(context));
        if (isCallValid)
        {
            returnValue = context->unloadCompiler();
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLUnloadCompiler, cl_int>();
        }
        ANGLE_CAPTURE(UnloadCompiler, isCallValid, context, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLUnloadCompiler, cl_int>();
    }
    return returnValue;
}

void *GL_APIENTRY GL_GetExtensionFunctionAddress(const char *func_name)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLGetExtensionFunctionAddress, "context = %d, func_name = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)func_name);

    void *returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetExtensionFunctionAddress(context, func_name));
        if (isCallValid)
        {
            returnValue = context->getExtensionFunctionAddress(func_name);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLGetExtensionFunctionAddress, void *>();
        }
        ANGLE_CAPTURE(GetExtensionFunctionAddress, isCallValid, context, func_name, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLGetExtensionFunctionAddress, void *>();
    }
    return returnValue;
}

cl_command_queue GL_APIENTRY GL_CreateCommandQueue(cl_context context,
                                                   cl_device_id device,
                                                   cl_command_queue_properties properties,
                                                   cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateCommandQueue,
          "context = %d, context = 0x%016" PRIxPTR ", device = 0x%016" PRIxPTR
          ", properties = %u, errcode_ret = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, (uintptr_t)device, properties, (uintptr_t)errcode_ret);

    cl_command_queue returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateCreateCommandQueue(context, context, device, properties, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createCommandQueue(context, device, properties, errcode_ret);
        }
        else
        {
            returnValue =
                GetDefaultReturnValue<angle::EntryPoint::GLCreateCommandQueue, cl_command_queue>();
        }
        ANGLE_CAPTURE(CreateCommandQueue, isCallValid, context, context, device, properties,
                      errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue =
            GetDefaultReturnValue<angle::EntryPoint::GLCreateCommandQueue, cl_command_queue>();
    }
    return returnValue;
}

cl_sampler GL_APIENTRY GL_CreateSampler(cl_context context,
                                        cl_bool normalized_coords,
                                        cl_addressing_mode addressing_mode,
                                        cl_filter_mode filter_mode,
                                        cl_int *errcode_ret)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLCreateSampler,
          "context = %d, context = 0x%016" PRIxPTR
          ", normalized_coords = %u, addressing_mode = %u, filter_mode = %u, errcode_ret = "
          "0x%016" PRIxPTR "",
          CID(context), (uintptr_t)context, normalized_coords, addressing_mode, filter_mode,
          (uintptr_t)errcode_ret);

    cl_sampler returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateCreateSampler(context, context, normalized_coords,
                                                  addressing_mode, filter_mode, errcode_ret));
        if (isCallValid)
        {
            returnValue = context->createSampler(context, normalized_coords, addressing_mode,
                                                 filter_mode, errcode_ret);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateSampler, cl_sampler>();
        }
        ANGLE_CAPTURE(CreateSampler, isCallValid, context, context, normalized_coords,
                      addressing_mode, filter_mode, errcode_ret, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLCreateSampler, cl_sampler>();
    }
    return returnValue;
}

cl_int GL_APIENTRY GL_EnqueueTask(cl_command_queue command_queue,
                                  cl_kernel kernel,
                                  cl_uint num_events_in_wait_list,
                                  const cl_event *event_wait_list,
                                  cl_event *event)
{
    Context *context = GetValidGlobalContext();
    EVENT(context, GLEnqueueTask,
          "context = %d, command_queue = 0x%016" PRIxPTR ", kernel = 0x%016" PRIxPTR
          ", num_events_in_wait_list = %u, event_wait_list = 0x%016" PRIxPTR
          ", event = 0x%016" PRIxPTR "",
          CID(context), (uintptr_t)command_queue, (uintptr_t)kernel, num_events_in_wait_list,
          (uintptr_t)event_wait_list, (uintptr_t)event);

    cl_int returnValue;
    if (context)
    {
        std::unique_lock<angle::GlobalMutex> shareContextLock = GetContextLock(context);
        bool isCallValid                                      = (context->skipValidation() ||
                            ValidateEnqueueTask(context, command_queue, kernel,
                                                num_events_in_wait_list, event_wait_list, event));
        if (isCallValid)
        {
            returnValue = context->enqueueTask(command_queue, kernel, num_events_in_wait_list,
                                               event_wait_list, event);
        }
        else
        {
            returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueTask, cl_int>();
        }
        ANGLE_CAPTURE(EnqueueTask, isCallValid, context, command_queue, kernel,
                      num_events_in_wait_list, event_wait_list, event, returnValue);
    }
    else
    {
        GenerateContextLostErrorOnCurrentGlobalContext();
        returnValue = GetDefaultReturnValue<angle::EntryPoint::GLEnqueueTask, cl_int>();
    }
    return returnValue;
}

}  // extern "C"
