{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1fceb788_8b13577f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-06-14T21:08:49Z",
      "side": 1,
      "message": "I don\u0027t think this is true. glReadPixels is not a slow call if the resource being read back is not in-use by the GPU. With this change, you will unconditionally incur a GPU bubble.\n\nThere are improvements possible to the code as is, but a high level feedback first. Why not do the color-space conversion on the CPU after readback has been done?",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43df9bc7_27b4870b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-06-14T22:27:10Z",
      "side": 1,
      "message": "\u003e With this change, you will unconditionally incur a GPU bubble.\n\nonly for those usecases that have colorspace overrides applied to them, right?\n\n\nthe other paths available were compute shader based conversion and CPU path but the GPU path was the quickest in terms of implementation and verification without hand-writing a piecewise function.\n\nAre there helpers already present that does all this math on the CPU?",
      "parentUuid": "1fceb788_8b13577f",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "023a1de0_fa5c51d0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-06-15T04:11:56Z",
      "side": 1,
      "message": "\u003e only for those usecases that have colorspace overrides applied to them, right?\n\nYes of course.\n\n\u003e Are there helpers already present that does all this math on the CPU?\n\nDoes PackPixels() work for you?",
      "parentUuid": "43df9bc7_27b4870b",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9da03514_e00b0218",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-06-15T17:30:46Z",
      "side": 1,
      "message": "\u003e Does PackPixels() work for you?\n\ni see, so basically add a `sRGBToLinear(...)` method to `struct R8G8B8A8SRGB` and call that in packpixels\n\nthat takes care of RGBA8 format, but there are tons of other formats that have srgb variants. Do you suggest writing such CPU funcs for each of those formats (including compressed)?",
      "parentUuid": "023a1de0_fa5c51d0",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42ad7204_882e6602",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-06-15T17:57:11Z",
      "side": 1,
      "message": "\u003e i see, so basically add a `sRGBToLinear(...)` method to `struct R8G8B8A8SRGB` and call that in packpixels\n\nNot sure to be honest. I was looking at the part of the function that says:\n\n    pixelReadFunction(src, temp);\n    pixelWriteFunction(temp, dest);\n\nI imagine if one format is sRGB and the other isn\u0027t that one of those functions will do the conversion automatically?\n\n\u003e that takes care of RGBA8 format, but there are tons of other formats that have srgb variants.\n\nAgain, depends on whether the pixelRead/WriteFunction above already take care of it. If not, we could add a flag to PackPixelsParams to do sRGB conversion, and implement that in a generic way (like always convert to float, convert to the other space and back to original type).\n\n\u003e Do you suggest writing such CPU funcs for each of those formats (including compressed)?\n\nCan\u0027t glReadPixels compressed textures ;)",
      "parentUuid": "9da03514_e00b0218",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f722f8aa_8f78b843",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-06-14T18:56:07Z",
      "side": 1,
      "message": "PTAL",
      "revId": "123ed8e757fb29220daa955e5a3f589ba3906127",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}