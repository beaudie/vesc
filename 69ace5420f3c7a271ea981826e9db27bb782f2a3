{
  "comments": [
    {
      "key": {
        "uuid": "f356b1ec_f83c8581",
        "filename": "src/compiler/translator/Cache.cpp",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T14:07:31Z",
      "side": 1,
      "message": "nit: alignment",
      "range": {
        "startLine": 47,
        "startChar": 18,
        "endLine": 47,
        "endChar": 20
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f80dae2c_ba198d81",
        "filename": "src/compiler/translator/Cache.h",
        "patchSetId": 6
      },
      "lineNbr": 72,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T14:07:31Z",
      "side": 1,
      "message": "I\u0027m not 100% sure if it\u0027s necessary, but it might be wise to add padding, and zero-initialize the padding at the end of the struct. In some implementation it might be junk, and mess up the comparator.",
      "range": {
        "startLine": 72,
        "startChar": 12,
        "endLine": 72,
        "endChar": 40
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93201584_27a194f7",
        "filename": "src/compiler/translator/Cache.h",
        "patchSetId": 6
      },
      "lineNbr": 72,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T16:58:49Z",
      "side": 1,
      "message": "Instead of padding I set \u0027value\u0027 to 0 before setting components in TypeKey constructor, so any unused space is initialized to 0. I feel like having to manually calculate padding negates advantage union gives us.",
      "parentUuid": "f80dae2c_ba198d81",
      "range": {
        "startLine": 72,
        "startChar": 12,
        "endLine": 72,
        "endChar": 40
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f356b1ec_1856a952",
        "filename": "src/compiler/translator/Cache.h",
        "patchSetId": 6
      },
      "lineNbr": 72,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T17:13:59Z",
      "side": 1,
      "message": "Right, SGTM.",
      "parentUuid": "93201584_27a194f7",
      "range": {
        "startLine": 72,
        "startChar": 12,
        "endLine": 72,
        "endChar": 40
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93201584_47505054",
        "filename": "src/compiler/translator/PoolAlloc.h",
        "patchSetId": 6
      },
      "lineNbr": 250,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T16:58:49Z",
      "side": 1,
      "message": "Change in pool_allocator is also something I found in the last minute. Without this change pool_allocator was copying TPoolAllocator it was created with, and that was causing cache allocator to spread through copies. For example, copying cached TString also copied cache allocator. This is bad because cache allocator is not pushed/poped as compiler ones, so essentially without this change every time we copy cached string (getName() from cached TType for example) we leak memory.\n\nBut there is actually no point in storing TPoolAllocator inside pool_allocator anyway, since by design we don\u0027t deallocate, and compiler\u0027s allocator is the one global allocator we use. Also, \u0027operator new\u0027 in some types rely on the global allocator already.",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f80dae2c_ba42adbd",
        "filename": "src/compiler/translator/PoolAlloc.h",
        "patchSetId": 6
      },
      "lineNbr": 250,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T17:13:59Z",
      "side": 1,
      "message": "I\u0027m pretty fuzzy on what\u0027s going on here. What\u0027s a pool_allolcator vs a TPoolAllocator? Does removing the stored variable change any behaviour?",
      "parentUuid": "93201584_47505054",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3260d9c_6612ae0d",
        "filename": "src/compiler/translator/PoolAlloc.h",
        "patchSetId": 6
      },
      "lineNbr": 250,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T17:35:38Z",
      "side": 1,
      "message": "pool_allocator is std::allocator-compatible allocator for use in std containers. For example, TString is std::basic_string\u003cchar, pool_allocator\u003cchar\u003e\u003e. pool_allocator makes sure std containers allocate from TPoolAllocator instead of the heap. All containers store allocator by value and copy it when they are copied.\n\nPreviously pool_allocator was saving global TPoolAllocator pointer in the constructor, and was copying it in the copy-constructor and the assignment operator. All allocations done by pool_allocator were routed to the saved TPoolAllocator pointer. That was causing issues with cached objects which live in their own \u0027cache\u0027 allocator, because when those objects were copied they were also copying cache allocator. So we ended up with TStrings which were using cache allocator outside of TCache class.\n\nHowever, pool_allocator doesn\u0027t actually need to store TPoolAllocator pointer. It should just use current global allocator, as \u0027operator new\u0027 in several types does (see POOL_ALLOCATOR_NEW_DELETE).",
      "parentUuid": "f80dae2c_ba42adbd",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "736d61b3_280b0fdf",
        "filename": "src/compiler/translator/PoolAlloc.h",
        "patchSetId": 6
      },
      "lineNbr": 283,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T17:13:59Z",
      "side": 1,
      "message": "do we even need these anymore? where do we use them?",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 283,
        "endChar": 70
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93201584_ea2ca3d3",
        "filename": "src/compiler/translator/PoolAlloc.h",
        "patchSetId": 6
      },
      "lineNbr": 283,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T17:35:38Z",
      "side": 1,
      "message": "Yes, they are actually required. For example std::string in libc++ uses operator !\u003d.",
      "parentUuid": "736d61b3_280b0fdf",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 283,
        "endChar": 70
      },
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3260d9c_8616ca04",
        "filename": "src/compiler/translator/Types.cpp",
        "patchSetId": 6
      },
      "lineNbr": 145,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T16:58:49Z",
      "side": 1,
      "message": "Have you noted this change? Without this debug build asserts, because TType::realize() indirectly calls this function for the mentioned types. I wasn\u0027t sure what was the right thing to do, and this change was the simplest I could come up with (and besides it mimics what happens in release).",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "135425e3_bf3ca3f2",
        "filename": "src/compiler/translator/Types.cpp",
        "patchSetId": 6
      },
      "lineNbr": 145,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-07-07T17:13:59Z",
      "side": 1,
      "message": "Which values hit the default case now? I\u0027m actually not sure.",
      "parentUuid": "d3260d9c_8616ca04",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "731ba15b_e625c06d",
        "filename": "src/compiler/translator/Types.cpp",
        "patchSetId": 6
      },
      "lineNbr": 145,
      "author": {
        "id": 1129096
      },
      "writtenOn": "2015-07-07T17:35:38Z",
      "side": 1,
      "message": "For me it asserted on EbtVoid and EbtGVec4. But most of the types are covered in that switch, except for non-types and EbtVoid, EbtAddress.",
      "parentUuid": "135425e3_bf3ca3f2",
      "revId": "69ace5420f3c7a271ea981826e9db27bb782f2a3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}