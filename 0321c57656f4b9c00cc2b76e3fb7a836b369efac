{
  "comments": [
    {
      "key": {
        "uuid": "b30a2afc_8c24c083",
        "filename": "src/libANGLE/renderer/gl/StateManagerGL.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1330,
      "author": {
        "id": 1165541
      },
      "writtenOn": "2017-09-20T07:30:51Z",
      "side": 1,
      "message": "Why you still need this dirtybit since you already called gl API glEnable/glDisable? \nI think you should write it like below:\nvoid StateManagerGL::setSampleMaskEnabled()\n{\n    if (!mSampleMaskEnabled)\n    {\n        mSampleMaskEnabled \u003d true;\n        mLocalDirtyBits.set(gl::State::DIRTY_BIT_SAMPLE_MASK_ENABLED);\n    }\n}\n\nvoid StateManagerGL::setSampleMaskDisabled()\n{\n    if (mSampleMaskEnabled)\n    {\n        mSampleMaskEnabled \u003d false;\n        mLocalDirtyBits.set(gl::State::DIRTY_BIT_SAMPLE_MASK_DISABLED);\n    }\n}\n\nThen in the syncState function, add something like below:\ncase: gl::State::DIRTY_BIT_SAMPLE_MASK_ENABLED\n    mFunctions-\u003eenable(GL_SAMPLE_MASK);\ncase: gl::State::DIRTY_BIT_SAMPLE_MASK_DISABLED\n    mFunctions-\u003edisable(GL_SAMPLE_MASK);",
      "range": {
        "startLine": 1330,
        "startChar": 8,
        "endLine": 1330,
        "endChar": 70
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7dcc1246_ee170e10",
        "filename": "src/libANGLE/renderer/gl/StateManagerGL.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1330,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-09-20T08:47:05Z",
      "side": 1,
      "message": "All StateManagerGL::set functions are public, and they can be called both inside and outside ANGLE. mLocalDirtyBits indicates this gl state has been updated internally.\n\nAs all setXX calls outside ANGLE will set the corresponding dirty bit \u0027glDirtyBits\u0027 in the parameter of syncState, mLocalDirtyBits can avoid the mismatch of a gl state, which is updated internally but isn\u0027t updated from outside of ANGLE.\n\ne.g.\n1. setSampleMaskEnabled(true) is called internally. mLocalDirtyBits[DIRTY_BIT_SAMPLE_MASK_ENABLED] is set.\n2. In ANGLE user\u0027s program glEnable(GL_SAMPLE_MASK) is never called, so glDirtyBits[DIRTY_BIT_SAMPLE_MASK_ENABLED] is not set, and the cached mGLState::mSampleMask is still false.\n3. StateMAnagerGL::syncState is executed before draw. In this draw, the user wants sample mask to be disabled, but glEnable(GL_SAMPLE_MASK) has already been called internally in step 1, so this time we should call setSampleMaskEnabled(false) again to disable sample mask.\n\nI just follow the coding style in other setXXEnabled functions in this file\ne.g.\n1. setScissorTestEnabled\n2. setBlendEnabled\n3. setDepthTestEnabled",
      "parentUuid": "b30a2afc_8c24c083",
      "range": {
        "startLine": 1330,
        "startChar": 8,
        "endLine": 1330,
        "endChar": 70
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ce1d18b_b8b7fdec",
        "filename": "src/libANGLE/renderer/gl/StateManagerGL.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1342,
      "author": {
        "id": 1165541
      },
      "writtenOn": "2017-09-20T07:30:51Z",
      "side": 1,
      "message": "Same here. I always think there should be two functions. One is to set dirty bit and cache the value. Other is really sync them to driver.",
      "range": {
        "startLine": 1342,
        "startChar": 8,
        "endLine": 1342,
        "endChar": 82
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0507e52d_ccef7f77",
        "filename": "src/libANGLE/renderer/gl/StateManagerGL.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1342,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-09-20T08:47:05Z",
      "side": 1,
      "message": "Same response above.",
      "parentUuid": "3ce1d18b_b8b7fdec",
      "range": {
        "startLine": 1342,
        "startChar": 8,
        "endLine": 1342,
        "endChar": 82
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdaf36bb_48cd2d50",
        "filename": "src/libANGLE/validationES3.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2326,
      "author": {
        "id": 1165541
      },
      "writtenOn": "2017-09-20T07:30:51Z",
      "side": 1,
      "message": "ANGLE_VALIDATION_ERR(context, InvalidEnum(), EnumRequiresGLES31);",
      "range": {
        "startLine": 2325,
        "startChar": 0,
        "endLine": 2326,
        "endChar": 95
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8206dfa_4e47df83",
        "filename": "src/libANGLE/validationES3.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2326,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-09-20T08:47:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bdaf36bb_48cd2d50",
      "range": {
        "startLine": 2325,
        "startChar": 0,
        "endLine": 2326,
        "endChar": 95
      },
      "revId": "0321c57656f4b9c00cc2b76e3fb7a836b369efac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}