{
  "comments": [
    {
      "key": {
        "uuid": "8ac10281_262fe1f9",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "I thought this would only require having multiple version of the BitSetIterator::Iterator to optimize for small sizes, and not having to reimplement our own small std::bitset. What we really want is for BitSetIterator\u003cN\u003e::Iterator::getNextBit() to be a call to builtin_clz when N is small.\n\nBy only adding specializations of the BitSetIterator::Iterator, most of the other changes in this patch would not be required.\n\nAm I missing something?",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57c03878_e1bef735",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-04-18T17:05:08Z",
      "side": 1,
      "message": "It\u0027s possible we could get most of the benefit from iteration as you suggest, but I think for small operations like copies, any(), none(), etc, all of which we do internally in many places, this will be the faster implementation. Take a look throughout the code and you\u0027ll see what I mean.",
      "parentUuid": "8ac10281_262fe1f9",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8b50202_7bcd38b5",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-18T17:55:34Z",
      "side": 1,
      "message": "I took a look at the implementation of bitsets, they are almost as good as BitSetT except:\n - MSVC\u0027s implementation of bitset::all isn\u0027t very good and I\u0027m not sure if the compiler is able to optimize it [4]. We don\u0027t seem to use all() very much though.\n - libc++\u0027s implementation does some additional masking when not 64 and 32 bit [5]\n\nGoing one way or the other LGTM.\n\n[4]\tbool all() const _NOEXCEPT\n\t\t{\t// test if all bits set\n\t\treturn (count() \u003d\u003d size());\n\t\t}\n\n\tsize_t count() const _NOEXCEPT\n\t\t{\t// count number of set bits\n\t\tconst char *const _Bitsperbyte \u003d\n\t\t\t\"\\0\\1\\1\\2\\1\\2\\2\\3\\1\\2\\2\\3\\2\\3\\3\\4\"\n\t\t\t\"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\"\n\t\t\t\"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\"\n\t\t\t\"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\"\n\t\t\t\"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\"\n\t\t\t\"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\"\n\t\t\t\"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\"\n\t\t\t\"\\4\\5\\5\\6\\5\\6\\6\\7\\5\\6\\6\\7\\6\\7\\7\\x8\";\n\t\tconst unsigned char *_Ptr \u003d\n\t\t\t(const unsigned char *)(const void *)_Array;\n\t\tconst unsigned char *const _End \u003d _Ptr + sizeof (_Array);\n\t\tsize_t _Val \u003d 0;\n\t\tfor ( ; _Ptr !\u003d _End; ++_Ptr)\n\t\t\t_Val +\u003d _Bitsperbyte[*_Ptr];\n\t\treturn (_Val);\n\t\t}\n\n[5] https://github.com/llvm-mirror/libcxx/blob/master/include/bitset#L390",
      "parentUuid": "57c03878_e1bef735",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ba1dfa1_4a8775f6",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 59,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "I don\u0027t think the iterator needs to keep mCurrentBit, and it should be free to recompute it everytime as it is just one assembly instruction to do __builtin_clz or ScanForward. Also it would remove the need to branch on mBitsCopy.none()\n\nSee [1], [2] and [3]",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc7fb2d6_dcb66326",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 59,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-04-18T17:05:08Z",
      "side": 1,
      "message": "Hm, I\u0027m not sure it would be much faster. What do you think?\n\nI think we still need the none() check in all cases, see the docs for __builtin_clz:\n\nhttps://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\n\nBuilt-in Function: int __builtin_clz (unsigned int x)\nReturns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.",
      "parentUuid": "3ba1dfa1_4a8775f6",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3bc06f13_3d10203a",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 59,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-18T17:55:34Z",
      "side": 1,
      "message": "The goal of this CL is to optimize bitsets, and this should be at least as fast while being simpler :)\n\noperator++ wouldn\u0027t need to check for none() as currently done in its call to getNextBit() because operator++ should not be called if *this \u003d\u003d end() (which is 0) though we should probably have an assert.",
      "parentUuid": "fc7fb2d6_dcb66326",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae2c9d24_b74946d7",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 386,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "[1] This would become empty.",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f11b0c7_c96e3abe",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 395,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "[2] It is invalid to call operator++ on the end() so it is valid to call ScanForward.",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e758a57_c5f8445e",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 416,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "[3] It is invalid to call operator* on end() so it is valid to call ScanForward.",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "606dff24_db9d4b91",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 473,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-04-13T15:45:00Z",
      "side": 1,
      "message": "You can keep these inside the namespace, even the priv one.",
      "revId": "2414c086799f9b7321fdd3661c96b07952021ce5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}