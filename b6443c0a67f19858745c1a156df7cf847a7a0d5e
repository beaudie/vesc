{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d7e1baba_5e07f28c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-21T16:44:04Z",
      "side": 1,
      "message": "The wait stages is the \"second scope\" of synchronization. TOP_OF_PIPE in the second scope \u003d\u003d ALL_COMMANDS, so it seems to me that this is actually making the barriers worse.",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a1a5595_dab937de",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-21T16:51:32Z",
      "side": 1,
      "message": "No exactly.\n\nI\u0027m talking about barrier and not a wait semaphore.\n\nBarrier will have TOP_OF_PIPE as a source stage - first scope. So barrier will be relaxed within the command buffer.\n\nBut wait semaphores will be added to the TOP_OF_PIPE. So that command buffer will not start execution until semaphore is signaled. But this only adds latency. Imagine we just delay submission after semaphore already signaled, for example. The global end result is slightly shifted execution on GPU compared to CPU. Depending on the Application, such shift may affect performance.",
      "parentUuid": "d7e1baba_5e07f28c",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d228402a_22eca070",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-21T17:15:18Z",
      "side": 1,
      "message": "I don\u0027t understand how this helps CPU though?",
      "parentUuid": "2a1a5595_dab937de",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "280f9017_3c253182",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-21T17:25:40Z",
      "side": 1,
      "message": "\u003e I don\u0027t understand how this helps CPU though?\n\nUsage of TOP_OF_PIPE?\n\nIf yes - it does not help. It may be opposite. It is hard to predict how exactly.\n\nUsage TOP_OF_PIPE may help GPU by relaxing barrier inside the command buffer. This is good.\n\nHowever, wait semaphore with TOP_OF_PIPE may delay execution on GPU. This delay may affect CPU waits for the GPU. Because of that - we may become CPU bound. This is bad.\n\nProblem is that we must use same stages for the barrier source stages and the wait semaphore - otherwise layout transition may happen before semaphore is signaled.\n\nThere is no clear winner.",
      "parentUuid": "d228402a_22eca070",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54cdb98f_09215028",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-21T19:02:10Z",
      "side": 1,
      "message": "Oh I see, it\u0027s TOP_OF_PIPE as src stage in the command buffer.\n\nLet\u0027s just stick with having the stages be precise.",
      "parentUuid": "280f9017_3c253182",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2453c67_1af83e0b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-21T19:10:36Z",
      "side": 1,
      "message": "`kSwapchainAcquireImageWaitStageFlags` is used for both: acquire semaphore wait flags and source stages in the barrier inside command buffer.\n\nThis option allows using `TOP_OF_PIPE` for both (relaxed barrier vs added latency).\n\n\u003e Let\u0027s just stick with having the stages be precise.\n\nThis is default behavior.\n\nI added this option as experimental feature for testing purposes and at the same time provide alternative fix.",
      "parentUuid": "54cdb98f_09215028",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85d5358f_75a87852",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-21T19:14:59Z",
      "side": 1,
      "message": "\u003e I added this option as experimental feature for testing purposes and at the same time provide alternative fix.\n\nYes I understand. What I meant is, you can put this change to WIP (instead of Active), which means it\u0027s not meant to land, but can be referred to if and when anyone wants to experiment with it.",
      "parentUuid": "f2453c67_1af83e0b",
      "range": {
        "startLine": 14,
        "startChar": 2,
        "endLine": 14,
        "endChar": 26
      },
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "530fcaf6_a88e0b1c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2023-02-20T16:43:42Z",
      "side": 1,
      "message": "Shabi, WDYT about this Gold diff here:\nhttps://angle-gold.skia.org/detail?grouping\u003dname%3Dsolar_smash%26source_type%3Dangle\u0026digest\u003dd271efff08939d94145e8e691d2bb039\u0026changelist_id\u003d4272186\u0026crs\u003dgerrit\n\nIt\u0027s more than 1 that we\u0027ve agreed upon in anglebug.com/7985.\nIt\u0027s actually 10, which I wanted to have originally.",
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "23c2f1fc_7c1e520e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-21T17:15:18Z",
      "side": 1,
      "message": "It doesn\u0027t look normal TBH. _Could_ be noise in vertex shader output (but still looks too big for that), but in that case it\u0027s just lucky that the foreground and background colors are similar enough for the diff to be low (i.e. 10).",
      "parentUuid": "530fcaf6_a88e0b1c",
      "revId": "b6443c0a67f19858745c1a156df7cf847a7a0d5e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}