{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "669e46ee_bdc21219",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-04-07T00:56:47Z",
      "side": 1,
      "message": "PTAL",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30457fe6_dfc972c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-12T22:45:13Z",
      "side": 1,
      "message": "@Igor please take a look as well",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f2eaf30_68cb899e",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-13T15:19:35Z",
      "side": 1,
      "message": "Suggest adding `if (thread-\u003egetContext() \u003d\u003d nullptr)` for clarity and to avoid possible bugs.\n\nHowever, everything will still work fine without the `if`, because thread will be **reactivated** in the `ScopedSyncCurrentContextFromThread` destructor:\n```\nScopedSyncCurrentContextFromThread::~ScopedSyncCurrentContextFromThread()\n{\n    SetContextCurrent(mThread, mThread-\u003egetContext());\n}\n```\n\nI do not know if this CL takes into account `ScopedSyncCurrentContextFromThread` or not.\n\nBut I was confused by this change and suspected a bug: thread may be not active while context is current, this may cause forced context invalidation (`TerminateReason::NoActiveThreads`) and then destruction (in `destroyInvalidEglObjects()`). Thanks to `ScopedSyncCurrentContextFromThread` this should not be possible.",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7daf9be5_d836e9fe",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-06T15:49:32Z",
      "side": 1,
      "message": "\u003e I do not know if this CL takes into account `ScopedSyncCurrentContextFromThread`\n\nthe changes related to active threads was added much later and testing / verification was done assuming behavior changes introduced by `ScopedSyncCurrentContextFromThread`\n\nhaving said that, im not sure i see the bug given that forced context invalidation due to `TerminateReason::NoActiveThreads` happens **after** acquiring the global mutex",
      "parentUuid": "0f2eaf30_68cb899e",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bcde0f9_29f93372",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-06T16:46:40Z",
      "side": 1,
      "message": "\u003e having said that, im not sure i see the bug ...\n\nThere is no bug in this CL. But this is thanks to `ScopedSyncCurrentContextFromThread`.\n\nI just saying that this change confused me and may also confuse others, and potentially cause bugs in the future.\n\nI will try to explain:\n- This CL adds `mActiveThreads.erase(thread);`;\n- This will deactivate the thread while Context may still be current on this thread;\n- The `~ScopedSyncCurrentContextFromThread` will reactivate the thread: `Thread::setCurrent(gl::Context *context)` -\u003e `Display::addActiveThread(Thread *thread)` -\u003e `mActiveThreads.insert(thread)`\n\nIn the above situation will will have:\n- `mActiveThreads.erase(thread);` - added in this CL\n- `mActiveThreads.insert(thread);` - from `~ScopedSyncCurrentContextFromThread`\n\nThis is confusing. And I asked if this CL considered the fact that `ScopedSyncCurrentContextFromThread` will reactivate the thread. If this CL did not took this into account, then it might have introduced a bug if there was no `ScopedSyncCurrentContextFromThread` class.\n\nTherefore I suggested to add `if (thread-\u003egetContext() \u003d\u003d nullptr)` before deactivating the thread for clarity, and so there is no confusing \"deactivate -\u003e activate\" cycle.",
      "parentUuid": "7daf9be5_d836e9fe",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8761e793_adde3a3d",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-06T16:51:02Z",
      "side": 1,
      "message": "\u003e then it might have introduced a bug if there was no `ScopedSyncCurrentContextFromThread` class\n\nhypothetically speaking, if there was no `ScopedSyncCurrentContextFromThread` class what would that bug be?",
      "parentUuid": "0bcde0f9_29f93372",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a8ef296_80d2820c",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-06T17:13:55Z",
      "side": 1,
      "message": "It is in the first comment:\n\u003e thread may be not active while context is current, this may cause forced context invalidation (TerminateReason::NoActiveThreads) and then destruction (in destroyInvalidEglObjects()).\n\nI first did not notice that `ScopedSyncCurrentContextFromThread` will reactivate the thread, so I assumed a possible bug. I investigated code (except stubs...) and wrote test in order to reproduce the bug. However I failed. I investigated why there is no bug and found `ScopedSyncCurrentContextFromThread`.\n\nTest has 2 threads.\nThread 1:\n- `eglInitialize()`\n- `createContext()`\n- `createPbufferSurface()`\n- `eglMakeCurrent(mDisplay, srf, srf, ctx1)`\n- `eglTerminate()` (context will be deactivated if no `ScopedSyncCurrentContextFromThread`)\n- sleep while Thread 2 finishes.\n- `ctx1` will be destroyed because `terminate(TerminateReason::NoActiveThreads)` from Thread 2.\n- `eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)`\n- Above may access deleted `ctx1`.\n\nThread 2:\n- `createContext()`\n- `createPbufferSurface()`\n- `eglMakeCurrent(mDisplay, srf, srf, ctx2)`\n- wait for `eglTerminate()`\n- `eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)`\n- Thread exit will call `terminate(TerminateReason::NoActiveThreads)` and destroy `ctx1`.\n\n---\n\nRegardless of the possible bug it is not clear that thread will be reactivated later in the `ScopedSyncCurrentContextFromThread`. And why have this \"deactivate-\u003eactivate\" cycle? IMO it is better to not deactivate thread if it will be activated again for clarity and safety.",
      "parentUuid": "8761e793_adde3a3d",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}