{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "669e46ee_bdc21219",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-04-07T00:56:47Z",
      "side": 1,
      "message": "PTAL",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30457fe6_dfc972c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-12T22:45:13Z",
      "side": 1,
      "message": "@Igor please take a look as well",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f2eaf30_68cb899e",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-13T15:19:35Z",
      "side": 1,
      "message": "Suggest adding `if (thread-\u003egetContext() \u003d\u003d nullptr)` for clarity and to avoid possible bugs.\n\nHowever, everything will still work fine without the `if`, because thread will be **reactivated** in the `ScopedSyncCurrentContextFromThread` destructor:\n```\nScopedSyncCurrentContextFromThread::~ScopedSyncCurrentContextFromThread()\n{\n    SetContextCurrent(mThread, mThread-\u003egetContext());\n}\n```\n\nI do not know if this CL takes into account `ScopedSyncCurrentContextFromThread` or not.\n\nBut I was confused by this change and suspected a bug: thread may be not active while context is current, this may cause forced context invalidation (`TerminateReason::NoActiveThreads`) and then destruction (in `destroyInvalidEglObjects()`). Thanks to `ScopedSyncCurrentContextFromThread` this should not be possible.",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7daf9be5_d836e9fe",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-06T15:49:32Z",
      "side": 1,
      "message": "\u003e I do not know if this CL takes into account `ScopedSyncCurrentContextFromThread`\n\nthe changes related to active threads was added much later and testing / verification was done assuming behavior changes introduced by `ScopedSyncCurrentContextFromThread`\n\nhaving said that, im not sure i see the bug given that forced context invalidation due to `TerminateReason::NoActiveThreads` happens **after** acquiring the global mutex",
      "parentUuid": "0f2eaf30_68cb899e",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bcde0f9_29f93372",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-06T16:46:40Z",
      "side": 1,
      "message": "\u003e having said that, im not sure i see the bug ...\n\nThere is no bug in this CL. But this is thanks to `ScopedSyncCurrentContextFromThread`.\n\nI just saying that this change confused me and may also confuse others, and potentially cause bugs in the future.\n\nI will try to explain:\n- This CL adds `mActiveThreads.erase(thread);`;\n- This will deactivate the thread while Context may still be current on this thread;\n- The `~ScopedSyncCurrentContextFromThread` will reactivate the thread: `Thread::setCurrent(gl::Context *context)` -\u003e `Display::addActiveThread(Thread *thread)` -\u003e `mActiveThreads.insert(thread)`\n\nIn the above situation will will have:\n- `mActiveThreads.erase(thread);` - added in this CL\n- `mActiveThreads.insert(thread);` - from `~ScopedSyncCurrentContextFromThread`\n\nThis is confusing. And I asked if this CL considered the fact that `ScopedSyncCurrentContextFromThread` will reactivate the thread. If this CL did not took this into account, then it might have introduced a bug if there was no `ScopedSyncCurrentContextFromThread` class.\n\nTherefore I suggested to add `if (thread-\u003egetContext() \u003d\u003d nullptr)` before deactivating the thread for clarity, and so there is no confusing \"deactivate -\u003e activate\" cycle.",
      "parentUuid": "7daf9be5_d836e9fe",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8761e793_adde3a3d",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-06T16:51:02Z",
      "side": 1,
      "message": "\u003e then it might have introduced a bug if there was no `ScopedSyncCurrentContextFromThread` class\n\nhypothetically speaking, if there was no `ScopedSyncCurrentContextFromThread` class what would that bug be?",
      "parentUuid": "0bcde0f9_29f93372",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a8ef296_80d2820c",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-06T17:13:55Z",
      "side": 1,
      "message": "It is in the first comment:\n\u003e thread may be not active while context is current, this may cause forced context invalidation (TerminateReason::NoActiveThreads) and then destruction (in destroyInvalidEglObjects()).\n\nI first did not notice that `ScopedSyncCurrentContextFromThread` will reactivate the thread, so I assumed a possible bug. I investigated code (except stubs...) and wrote test in order to reproduce the bug. However I failed. I investigated why there is no bug and found `ScopedSyncCurrentContextFromThread`.\n\nTest has 2 threads.\nThread 1:\n- `eglInitialize()`\n- `createContext()`\n- `createPbufferSurface()`\n- `eglMakeCurrent(mDisplay, srf, srf, ctx1)`\n- `eglTerminate()` (context will be deactivated if no `ScopedSyncCurrentContextFromThread`)\n- sleep while Thread 2 finishes.\n- `ctx1` will be destroyed because `terminate(TerminateReason::NoActiveThreads)` from Thread 2.\n- `eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)`\n- Above may access deleted `ctx1`.\n\nThread 2:\n- `createContext()`\n- `createPbufferSurface()`\n- `eglMakeCurrent(mDisplay, srf, srf, ctx2)`\n- wait for `eglTerminate()`\n- `eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)`\n- Thread exit will call `terminate(TerminateReason::NoActiveThreads)` and destroy `ctx1`.\n\n---\n\nRegardless of the possible bug it is not clear that thread will be reactivated later in the `ScopedSyncCurrentContextFromThread`. And why have this \"deactivate-\u003eactivate\" cycle? IMO it is better to not deactivate thread if it will be activated again for clarity and safety.",
      "parentUuid": "8761e793_adde3a3d",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d3db0e1_0506fd6f",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-06T21:28:12Z",
      "side": 1,
      "message": "i\u0027m not surprised your test din\u0027t fail since a call to `terminate` with `TerminateReason::NoActiveThreads` marks the display as unitialized making all subsequent calls as noops\n\nre: \"deactivate-\u003eactivate cycle\" - a clearer code would be to have `~ScopedSyncCurrentContextFromThread` set context without marking the thread as active (since \"active thread\" is from an API perspective)",
      "parentUuid": "5a8ef296_80d2820c",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a05871c_c7b957cd",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-07T15:54:51Z",
      "side": 1,
      "message": "\u003e i\u0027m not surprised your test din\u0027t fail since a call to terminate with TerminateReason::NoActiveThreads marks the display as unitialized making all subsequent calls as noops\n\nYour are correct, there will be no failure in `eglMakeCurrent()` even when `ctx1` was destroyed. I\u0027m sorry. It was a long time ago when I wrote the test and forget that I also added `glReadPixels()` after before `eglMakeCurrent()`.\n\nIf there is no `ScopedSyncCurrentContextFromThread`\n- terminate with `TerminateReason::NoActiveThreads` will put `ctx1` to `mInvalidContextMap` and later in the same `Display::terminate()` call will destroy the `ctx1` in the `destroyInvalidEglObjects()`.\n- using `ctx1` after this may cause crash (in `glReadPixels()` for example).\n- even calling `context-\u003eskipValidation()` from entry points is unsafe because accesses dealllocated memory.\n\n\u003e re: \"deactivate-\u003eactivate cycle\" - a clearer code would be to have ~ScopedSyncCurrentContextFromThread set context without marking the thread as active (since \"active thread\" is from an API perspective)\n\nIf `~ScopedSyncCurrentContextFromThread` will not have activation then this CL will introduce a bug. IMO making thread as inactive while there is still context current is incorrect in the first place.\n\n---\n\nThis CL removes `ScopedSyncCurrentContextFromThread` from `egl::Terminate()` and tests the bug:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/4577777/4?checksPatchset\u003d4\u0026tab\u003dchecks\nhttps://chromium-swarm.appspot.com/task?id\u003d62af096ae4d50911\u0026w\u003dtrue\n\nIn patchset 5 I added suggested `if (thread-\u003egetContext() \u003d\u003d nullptr)` condition while `ScopedSyncCurrentContextFromThread` is still removed:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/4577777/4..5?tab\u003dchecks",
      "parentUuid": "0d3db0e1_0506fd6f",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4c0fea7_a8c5b1e9",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-07T16:08:58Z",
      "side": 1,
      "message": "\u003e I also added `glReadPixels()` after before `eglMakeCurrent`\n\nthis is a violation of spec, please refer here -\u003e https://registry.khronos.org/EGL/specs/eglspec.1.5.pdf\n\n```\nTermination marks all EGL-specific resources, such as contexts and surfaces,\nassociated with the specified display for deletion ... Applications should not try\nto perform useful work with such resources following eglTerminate...\n```",
      "parentUuid": "2a05871c_c7b957cd",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "066b05ce_b1f0f684",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-07T16:18:28Z",
      "side": 1,
      "message": "I\u0027m not expert on reading the EGL/GLES specification.\n\nAs I understand \"such resources\" is context/surface.\n\nAlso it is not clear for me if calling a GL API is performing a useful work with such resources. I assume calling GL API is performing a work using `EGLContext` resource.\n\n\u003e if contexts or surfaces, created with respect to dpy are current (see sec-\ntion 3.7.3) to any thread, then they are not actually destroyed while they remain\ncurrent. If other resources created with respect to dpy are in use by any current\ncontext or surface, then they are also not destroyed until the corresponding context\nor surface is no longer current.\n\n\u003eAll such resources will be destroyed as soon as eglReleaseThread is called\nfrom the thread they are bound to, or eglMakeCurrent is called from that thread\nwith the current rendering API (see section 3.7) set such that the current context\nis affected. Use of bound contexts and surfaces (that is, continuing to issue com-\nmands to a bound client API context) **will not result** in interruption or termination\nof applications, but rendering results are undefined, and client APIs may generate\nerrors.\n\nEven when it is a violation - app should not crash. It is not a Vulkan.\nImplementation must work as expected even if app misbehave.",
      "parentUuid": "b4c0fea7_a8c5b1e9",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c25d5469_d30545b5",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-07T16:20:11Z",
      "side": 1,
      "message": "Want to highlught:\n\n\u003e if **contexts or surfaces**, created with respect to dpy are current (see sec-\ntion 3.7.3) to any thread, **then they are not actually destroyed** while they remain current.\n\nIn case of a bug context is actually destroyed.",
      "parentUuid": "066b05ce_b1f0f684",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2328e2b9_ce412ec9",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-07T18:25:10Z",
      "side": 1,
      "message": "I leave final decision to you.",
      "parentUuid": "c25d5469_d30545b5",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e06b6f77_45898f22",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1134,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-06-07T23:21:40Z",
      "side": 1,
      "message": "this wording in the spec will require us to not mark the thread as inactive while a context is current\n```\n... continuing to issue commands to a bound client API context) will not result\nin interruption or termination of applications ...\n```\nthanks, will update change along with changes to some tests",
      "parentUuid": "2328e2b9_ce412ec9",
      "revId": "50542363d43f8896ae050485584a74980958f41b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}