{
  "comments": [
    {
      "key": {
        "uuid": "13bf8e65_4abf30eb",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 4
      },
      "lineNbr": 24,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-06-22T16:50:11Z",
      "side": 1,
      "message": "This is already included above on line 9.",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfdff276_a9e72b85",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1404,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-06-22T16:50:11Z",
      "side": 1,
      "message": "Since we aren\u0027t too concerned with which member is different, can you just do a memcmp() of the entire struct?   It doesn\u0027t look like we need to worry about any padding being uninitialized values, since all of the members are words and should pack tightly.",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac336305_5badade2",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1404,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-22T17:03:32Z",
      "side": 1,
      "message": "Agree.",
      "parentUuid": "bfdff276_a9e72b85",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea078a31_34217b3a",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1531,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-06-22T16:50:11Z",
      "side": 1,
      "message": "How does this work with Jamie\u0027s CLs that defers clears?   Can they work together better to handle this case (merge the deferred clears), or does the deferred clears stuff not get invoked due to how gfxbench is doing things?\n\nJamie\u0027s CL:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/2142711",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d366c39_1c5e1d25",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1531,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-22T16:56:10Z",
      "side": 1,
      "message": "This seems like a pretty narrow optimization. Why don\u0027t you store a dictionary that indexes similarly to ImageDesc and stores the flushed clear value for a particular level? Also writes to the texture would have to invalidate this cache - it gets tricky.\n\nI wanted to wait on review and became concerned you might go down a different direction if I didn\u0027t speak up. Similar to the problem ddocs attempt to solve.",
      "parentUuid": "ea078a31_34217b3a",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69c400ad_22a3d45f",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1531,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-22T17:03:32Z",
      "side": 1,
      "message": "This build on top of Jamie\u0027s CL. Jamie\u0027s CL makes the clear to a vkCmdClear call and helped me to detect that this is a standalone clear.\n\nwrites to textures will trigger releaseStagingBuffer() which also clears this cache.",
      "parentUuid": "ea078a31_34217b3a",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7799aeb7_4ffa5aa9",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1531,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-22T17:17:01Z",
      "side": 1,
      "message": "\"store a dictionary that indexes similarly to ImageDesc...\", I guess you are thinking cases that this repeated clear pattern occur on the different layer/level and want to optimize that as well? I intended this to be a narrow optimization though, mainly because gfxbench is doing this. There is no evidence that this usage pattern occurred on multi-level/layer textures and alternatively clearing different levels. It is pretty silly thing for app to do it this way and I would hesitate to optimize that. But we are talking about gfxbench, so it worth it. If we use a dictionary etc, now the cost is a bit higher (due to dictionary lookup) and a bit more complicated, all for an unknown benefit. That is why I picked a solution I think is simple and effective and solve the specific perf issue we have.",
      "parentUuid": "69c400ad_22a3d45f",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f53cc52f_4e50fb36",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 4
      },
      "lineNbr": 1531,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-22T17:56:39Z",
      "side": 1,
      "message": "There\u0027s nearly zero additional cost to the dictionary lookup. An add and possibly a multiply. A ddoc might be in order.",
      "parentUuid": "7799aeb7_4ffa5aa9",
      "revId": "37b4b53941a00d2e4aa416b203881c21d21458fb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}