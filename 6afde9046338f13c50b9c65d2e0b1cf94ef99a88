{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "11f4ebe4_63760008",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-05-21T16:35:10Z",
      "side": 1,
      "message": "IIRC this was done because Manhattan was attempting to overwrite the same buffer every frame (instead of cycling through 2~3 buffers). Could you please make sure there\u0027s no regression in Manhattan?\n\nMohan, you probably remember better. It would be helpful if you gave this a try as well to make sure there are no regressions.",
      "range": {
        "startLine": 14,
        "startChar": 18,
        "endLine": 15,
        "endChar": 67
      },
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d23c243c_9c617c0e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-21T17:23:14Z",
      "side": 1,
      "message": "Manhattan is cycling 2 sets of buffers. This CL not just reduce the unnecessary transfer to transfer barrier, but reduces memcpy and vkCmdCopyBuffer for one g{lMap|UnMap}Buffer call, so actually reduces CPU and GPU workload.\n\nIn case of any real application actually use mapBuffer call for every frame, the better fix is to track a queue serial for GPU write operation and you acquire a new buffer and wait for GPU write to finish and memcpy from old buffer to new buffer and return new buffer to user. The old buffer is then released. Since this kind of usage GPU almost never write to it, you basically never need to wait, essentially ping-pong two GPU accessible buffers. This approach you only have one memcpy, instead of memcpy+VkCmdCopyBuffer. As I mentioned earlier, there is no evidence any real app is using this (mapBuffer is not designed for this kind of usage), so we can save that effort until we actually find such need.\n\nBut yes, Mohan please do verify it did not regress on your side and let me know any issue you may find.",
      "parentUuid": "11f4ebe4_63760008",
      "range": {
        "startLine": 14,
        "startChar": 18,
        "endLine": 15,
        "endChar": 67
      },
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd0173e0_1b7ffe2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-20T21:09:22Z",
      "side": 1,
      "message": "The original CL that added this is crrev.com/c/2116874, citing the reason \"removes the latency caused by waiting for the in-flight GPU commands to be complete before handing over the buffer to the app.\" I think most of time the wait is harmless. If CPU gets too ahead of GPU, somewhere you have to wait. If you end up doing two copies here on the PBO and then end up reduced wait time for a swap buffer, you probably want to wait at mapBuffer time and save two data copy. Most app calls mapBuffer usually already doing two/triple buffering (Manhattan is using double buffering i.e., use buffer 2/4/6 for one frame and 1/3/5 for next frame), so the slight wait in mapBuffer is just fine. If there is some bad app is calling mapBuffer on the same buffer for every frame, the better fix is to call acquireNextBuffer and copy data to new buffer and map and return the new buffer to user. That way, there is only one copy instead of two copy right now. But I would rather save that effort for now until we find such a usage case in real app that we have to deal with it.\n\nFor now, I am just disabling the shadowBuffer. Once settled, I do want to delete all the related code. ",
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd47cdc1_7e15de0e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-05-20T22:42:26Z",
      "side": 1,
      "message": "\u003e make sure to create the buffer as CPU mappable\n\nExternal buffers have no guarantee to be CPU mappable",
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08373379_c3cc200d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-05-20T22:43:59Z",
      "side": 1,
      "message": "is there is a specific platform you are targeting this for? if so could you disable only for that platform? or enable only for (amd || samsung). Either works",
      "parentUuid": "fd0173e0_1b7ffe2f",
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "83ffddd7_8142a58f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-20T23:03:27Z",
      "side": 1,
      "message": "I think this applies to your GPU as well. You should try it again with your GPU and tell me which test/metric gets better :-).",
      "parentUuid": "08373379_c3cc200d",
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63d9976c_d93ca38b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-05-20T23:13:01Z",
      "side": 1,
      "message": "The main point here is that the time spent in glMapBuffer() call is not the metric you should target for. Because somewhere it will have to wait if CPU goes too much ahead of GPU. The real metric should be if it improves fps or not. I can hardly believe doing two data copy is a good ting on integrated memory system.",
      "parentUuid": "83ffddd7_8142a58f",
      "revId": "6afde9046338f13c50b9c65d2e0b1cf94ef99a88",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}