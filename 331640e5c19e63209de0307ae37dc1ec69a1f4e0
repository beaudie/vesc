{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8b59dacd_54f8a1d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-10T15:42:32Z",
      "side": 1,
      "message": "FYI, it doesn\u0027t look like this fixed any of the issues in https://chromium-review.googlesource.com/c/angle/angle/+/2738650, so a regression test is in order once that CL lands.",
      "revId": "331640e5c19e63209de0307ae37dc1ec69a1f4e0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "150013a1_09ab7f37",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-03-10T15:46:16Z",
      "side": 1,
      "message": "as mentioned earlier, even with various combinations og glBuffer* APIs couldn\u0027t get the failure. Brandon mentioned that if we remove the \"SubDataSizeMeetsThreshold\" check and force it down the allocation path we will see the error but the intent of the acquireAndUpdate function is to alloc a full buffer\u0027s worth of bufferhelper so, not a valid usecase. Do you have ideas for a regression test?",
      "parentUuid": "8b59dacd_54f8a1d4",
      "revId": "331640e5c19e63209de0307ae37dc1ec69a1f4e0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21c2e31c_99de15e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-10T15:59:21Z",
      "side": 1,
      "message": "\u003e Technically the only issue this will have is \"mNextAllocationOffset\" will have a bad value and since we only use acquireBufferHelper to allocate a full buffer (for now), \"mNextAllocationOffset\" will not be involved.\n\nI understand the limitation (which made the test impossible) is that BufferVk\u0027s mBufferPool is not really suballocating, so it\u0027s always using offset 0. Is that not right?\n\nWhen [1] lands we will use `mNextAllocationOffset`, so you should be able to come up with something. We can talk about it more when that lands.\n\n[1]:  https://chromium-review.googlesource.com/c/angle/angle/+/2738650",
      "parentUuid": "150013a1_09ab7f37",
      "revId": "331640e5c19e63209de0307ae37dc1ec69a1f4e0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "343cf779_c67c5779",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-03-10T16:28:54Z",
      "side": 1,
      "message": "\u003e BufferVk\u0027s mBufferPool is not really suballocating, so it\u0027s always using offset 0. Is that not right?\n\nexactly. We treat mBufferPool as a full buffer size allocator which means start offset of the new buffer memory is always 0. That was by design though, not happenstance",
      "parentUuid": "21c2e31c_99de15e4",
      "revId": "331640e5c19e63209de0307ae37dc1ec69a1f4e0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}