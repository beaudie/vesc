{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5f13a6f3_8f18d321",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 298,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-04-07T21:35:36Z",
      "side": 1,
      "message": "Bear with me that I am still thinking alternative solution to consolidate two cases into one, mainly because it is complicated. \n\nHow about we create a VkFence and import inFd into VkFence, and then pass the VkFence to flushImpl? The inFd\u003d\u003dkInvalidFenceFd case, you create fence, and export to mNativeFenceFd, and then you create another VkFence and then import mNativeFenceFd into VkFence. Now two usage cases are consolidated: both have mNativeFenceFd and mFenceWithFd and both are valid and can wait on. Then you Create SharedFence (lets call it mSharedFenceWithFd) out of mFenceWithFd, and pass mSharedFenceWithFd to CommandQueue via flushImpl/submitCommands, and it will be stored to CommandBatch with another refcount. The rest of code will see no difference, it is just another SharedFence.\n\nThe trick here is that there is limitation of fence export (that you can\u0027t wait on the vkFence after export), but import native fence into VkFence does not have this limitation and we can use that to our advantage. With this approach, you will only have much smaller diff and the code mostly is going to be here. CommandQueue will have very small changes. What do you think?",
      "range": {
        "startLine": 298,
        "startChar": 8,
        "endLine": 298,
        "endChar": 35
      },
      "revId": "950b6278f23933418e3785a0e391b6ceccf767ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8efb4de_8aa94a9f",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 298,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-10T13:47:28Z",
      "side": 1,
      "message": "First, lets make sure I understand everything. Because it is sounds a lot more complicated for me.\n\nThere are two cases:\n1) `inFd !\u003d kInvalidFenceFd`.\nIn this case `initializeWithFd()` does not need to insert `inFd` into the command stream at all, so no need to call `flushImpl()` or pass any fence.\n```\n    \"When a fence sync object is created or when an EGL native fence sync\n    object is created with the EGL_SYNC_NATIVE_FENCE_FD_ANDROID attribute set\n    to EGL_NO_NATIVE_FENCE_FD_ANDROID, eglCreateSyncKHR also inserts a fence\n    command into the command stream of the bound client API\u0027s current context\n    (i.e., the context returned by eglGetCurrentContext), and associates it\n    with the newly created sync object.\n```\nDescription has **\"also inserts\"** when no FD is provided (`inFd \u003d\u003d kInvalidFenceFd`), therefore if FD is provided, no fence command is inserted.\n\n2) `inFd \u003d\u003d kInvalidFenceFd`.\n\u003e you create fence, and export to mNativeFenceFd, and then you create another VkFence and then import mNativeFenceFd into VkFence. \n\nIn order to do this, **first fence must be already submitted** as far as I know.\n\n\u003e Then you Create SharedFence (lets call it mSharedFenceWithFd) out of mFenceWithFd, and pass mSharedFenceWithFd to CommandQueue via flushImpl/submitCommands, and it will be stored to CommandBatch with another refcount.\n\nThis will not be possible because of the above.\n\nI think alternative may be possible:\n`initializeWithFd()` creates `SharedFence` from `VkFence` that can be exported and passes to `flushImpl()`. Then after `queueSubmit()`, `CommandQueue` will export handle (as in this CL), then create another `VkFence`, import FD into that fence, replace `VkFence` in the `SharedFence` with that fence, and use it in the `CommandBatch`. However, need to also keep first fence around for cleanup.\n\n\u003e but import native fence into VkFence does not have this limitation and we can use that to our advantage. \n\nI have doubts regarding this. This is from spec:\n```\n Importing a payload using handle types with copy transference creates a duplicate\ncopy of the payload at the time of import, but makes no further reference to it.\nFence signaling, waiting, and resetting operations performed on the target of copy\nimports must not affect any other fence or payload.\n```\nBut I do not completely understand this. Form spec when exporting:\n```\nIf handleType refers to a handle type with copy payload transference semantics,\nfence must be signaled, or have an associated fence signal operation pending\nexecution\n```\nIf we export already signaled fence, then importing will creates a signaled fence. Manually signaling should be No-op and it is not allowed to submit in signaled state. Waiting should be read only operation. Resting possible only for *persistent transference*, we have *temporary transference* and reset will revert to the persistent payload.\n\nWe more likely to export pending signal fence, then importing will create a pending signal fence. We can\u0027t submit, manually signal or reset such fence. Waiting is read only.\n\nI have a question for: *\"copy transference creates a duplicate copy of the payload at the time of import\"*. What should happen with payload copy when original FD is signaled?\n\nAdditionally:\n```\nImporting a fence payload from a file descriptor transfers ownership of the file\ndescriptor from the application to the Vulkan implementation. The application must\nnot perform any operations on the file descriptor after a successful import.\n\nApplications can import the same fence payload into multiple instances of Vulkan,\ninto the same instance from which it was exported, and multiple times into a given\nVulkan instance.\n```\nSo it is looks like we need `dup()` in order to use `mNativeFenceFd`.\nThis is also confusing. What happens with dupped FD after import? It will be closed by Vulkan and when? If so, then how can we use same fence payload multiple times? Is using as payload for import is *\"any operation\"* that must not be performed?\n\nWe already use import FD for Semaphore in `SyncHelperNativeFence::serverWait()` and we are using `dup()`. Dupped FD never closed even if import fails (leak in case of failure?). Logic assumes, that signal of `mNativeFenceFd` will cause signal of the `VkSemaphore`. If this code written and works correctly, then similar should be true for importing into `VkFence`.\n\nWill try to check how everything is actually working on device, because it is rather confusing in the spec.",
      "parentUuid": "5f13a6f3_8f18d321",
      "range": {
        "startLine": 298,
        "startChar": 8,
        "endLine": 298,
        "endChar": 35
      },
      "revId": "950b6278f23933418e3785a0e391b6ceccf767ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fb4c62b_2a0d6d5d",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 298,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-10T19:00:15Z",
      "side": 1,
      "message": "\u003e Will try to check how everything is actually working on device, because it is rather confusing in the spec.\n\nI checked and there are a lot of results)\n\nDuring testing I used slightly modified `AndroidNativeFence_WaitSync` test and added fence dup/import code to the `if (externalFence !\u003d nullptr)` section after the `queueSubmit()` of this CL. In the test I inserted 1000 `drawQuad()` calls, otherwise fence was immediately signaled after the `queueSubmit()`.\n\nReceived `VUID-vkResetCommandBuffer-commandBuffer-00045` validation error.\n```\nAttempt to reset VkCommandBuffer 0x7a756e6110[] which is in use.\n```\n\nI think the problem because VVL has a bug and can\u0027t work normally when exported fence is used to tell if command buffers is finished or not. I want to investigate this later.\n\n---\n\nNow results of exporting, duping and importing the FD.\nI tested 3 Android devices with 3 different GPUs: S906B, G996B, G991U.\nAll have different behavior)\n\nWhen `externalFence` is signaled right after the `queueSubmit()`.\n```\nOperation                                      S906B    G996B    G991U\nexternalFence status (mFence)  before export       0        0        0\nexternalFence status (mFenceFd) after export       0        0        0\nexternalFence mFence status after export           1        1        0\n0 - VK_SUCCESS\n1 - VK_NO_READY\n```\n\nWhen `externalFence` is NOT signaled right after the `queueSubmit()`.\n```\nOperation                                      S906B    G996B    G991U\nexternalFence status (mFence)  before export       1        1        1\nexternalFence status (mFenceFd) after export       1        1        1\nexternalFence mFence status after export           1        1        1\n\nexternalFence mFenceFd value                     117      119      121\ndupFD \u003d dup(mFenceFd)                            118      118      122\nSyncWaitFd(dupFD, 0, VK_NOT_READY)                 1        1        1\n\nCreate importFence and import dupFD\nimportFence status                                 1        1        1\nSyncWaitFd(dupFD, 0, VK_NOT_READY)               -13        1        1\n\nWAIT on externalFence \n\nexternalFence status (mFenceFd) after export       0        0        0\nexternalFence mFence status after export           1        1        0\nimportFence status                                 0        0        0\nSyncWaitFd(dupFD, 0, VK_NOT_READY)               -13        0        0\n\nOne of the below:\na) close(dupFD) before importFence destroy        -1        0        0\nb) close(dupFD) after importFence destroy         -1       -1       -1\n```\n\nFrom the above `G991U` (Adreno) not resetting original `mFence` handle after the export operation, also status of the `mFence` is updated after waiting on `mFenceFd`. Other devices perform reset and remain that state after wait.\n\n`S906B` generates error in `SyncWaitFd()` after import. Other devices allow using handle. Spec. forbids the usage after import (but allows import multiple times, how?).\n\n`S906B` also does not allow `close` on `dupFD` after the import, before destroying the `importFence`. Other devices allow that and it seems that `importFence` destruction works fine after that.\n\nAll devices generate error `-1` when call `close(dupFD)` after `importFence` destruction. This means that duplicate fence really was consumed by the Vulkan.\n\n---\n\nDespite the differences in the Vulkan implementations, I think it is possible to use `importFence` in the `CommandBatch` as a normal fence. However, we still need to preserve original `VkFence` that was used in submission and from which we exported the FD. We can encapsulate everything into the `SharedFence`. Can add export method that will export, dup, create new fence, import and use new fence.\n\nI will try to do above tomorrow. Interested to see how much time will it take for these extra steps and how will VVL behave.",
      "parentUuid": "f8efb4de_8aa94a9f",
      "range": {
        "startLine": 298,
        "startChar": 8,
        "endLine": 298,
        "endChar": 35
      },
      "revId": "950b6278f23933418e3785a0e391b6ceccf767ca",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}