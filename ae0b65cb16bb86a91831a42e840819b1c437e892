{
  "comments": [
    {
      "key": {
        "uuid": "02fda3e8_3cfd31be",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 6
      },
      "lineNbr": 65,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2015-02-27T00:15:01Z",
      "side": 1,
      "message": "I think these repeated state transitions are likely to impose significant overhead. Do you see a path forward where they might be eliminated?\n\nSpecifically, is it really necessary to always unbind the VAO at the end of all of these routines? Could this be left up to the calling code higher up?",
      "range": {
        "startLine": 65,
        "startChar": 23,
        "endLine": 65,
        "endChar": 38
      },
      "revId": "ae0b65cb16bb86a91831a42e840819b1c437e892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "428f9bad_1e1ccd64",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 6
      },
      "lineNbr": 65,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2015-02-27T17:34:35Z",
      "side": 1,
      "message": "The thing I\u0027m most worried about is leaving the vertex array bound and then binding an element array buffer somewhere else in the code causing the vertex array to be updated.\n\nIt could also be possible to defer the updates to the VAO until draw time because we already need to bind it for the draw call.  Given that we may need to do special processing to handle client data at that time, it might work out pretty well.",
      "parentUuid": "02fda3e8_3cfd31be",
      "range": {
        "startLine": 65,
        "startChar": 23,
        "endLine": 65,
        "endChar": 38
      },
      "revId": "ae0b65cb16bb86a91831a42e840819b1c437e892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62d57f78_87998663",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 6
      },
      "lineNbr": 65,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2015-02-27T18:18:39Z",
      "side": 1,
      "message": "I share your concern.\n\nThe primary reason this method would be called is in response to the user calling glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buf). This means the VAO is already bound in the GL context.\n\nMaybe the contract in the implementation should be that it always binds whatever state is needed for the current call and never unbinds it, and the state manager should swallow redundant calls and not send them to the driver.\n\nLet\u0027s discuss more. Not necessary to make any changes in this CL.",
      "parentUuid": "428f9bad_1e1ccd64",
      "range": {
        "startLine": 65,
        "startChar": 23,
        "endLine": 65,
        "endChar": 38
      },
      "revId": "ae0b65cb16bb86a91831a42e840819b1c437e892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2b4e2b1_884f778d",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 6
      },
      "lineNbr": 65,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2015-03-02T15:22:03Z",
      "side": 1,
      "message": "If zero is already bound, wouldn\u0027t it also call:\n\n bindVertexArray(0)\n bindBuffer\n bindVertexArray(0)\n\nI was sort of expecting that we\u0027d translate a user\u0027s BindBuffer calls to a glBindBuffer on the driver, but I guess this isn\u0027t the case.",
      "parentUuid": "62d57f78_87998663",
      "range": {
        "startLine": 65,
        "startChar": 23,
        "endLine": 65,
        "endChar": 38
      },
      "revId": "ae0b65cb16bb86a91831a42e840819b1c437e892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d2b7deb3_87b0c6c2",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 6
      },
      "lineNbr": 65,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2015-03-02T16:57:48Z",
      "side": 1,
      "message": "Two things:\n- The mVertexArrayID that\u0027s held by VertexArrayGL will never be zero, it\u0027s always gen\u0027d in the constructor.\n- The StateManagerGL class won\u0027t do redundant bind calls, it tracks the currently bound objects.\n\nWe arn\u0027t able to directly mirror all GL calls (binding, state setting, etc) because as soon as we need to do any emulation or special behaviour, we need to do all sorts of unbinding and rebinding of state behind the scenes to preseve the guarentee.  It also lets us optimize a bit by only applying state when it\u0027s needed and not making redundant calls.\n\nThis class isn\u0027t doing a great job of optimizing yet.  When I get to implementing the client data vertex attributes, I\u0027m going to move the application of vertex attributes to the draw call so we only have to make sure the currently used VAO is up to date for the current draw call and it only needs to be bound once.",
      "parentUuid": "f2b4e2b1_884f778d",
      "range": {
        "startLine": 65,
        "startChar": 23,
        "endLine": 65,
        "endChar": 38
      },
      "revId": "ae0b65cb16bb86a91831a42e840819b1c437e892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}