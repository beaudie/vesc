{
  "comments": [
    {
      "key": {
        "uuid": "10a29569_67fa2292",
        "filename": "src/tests/deqp_support/deqp_gles3_test_expectations.txt",
        "patchSetId": 6
      },
      "lineNbr": 578,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-14T23:56:03Z",
      "side": 1,
      "message": "vkCmdCopyBuffer() doesn\u0027t seem to work on pixel 2 while these tests pass on linux and other pixel devices.   If the code looks good I\u0027ll open a bug to QC once this is ready to merge (so we have stable code) and ask them to take a look.",
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88240825_966d559d",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 434,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-15T04:07:39Z",
      "side": 1,
      "message": "GL_STATIC_READ as it\u0027s the GPU that does the copy and there\u0027s a host read-back.",
      "range": {
        "startLine": 434,
        "startChar": 71,
        "endLine": 434,
        "endChar": 85
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5dfff7a_30fafa7b",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 434,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-17T18:33:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "88240825_966d559d",
      "range": {
        "startLine": 434,
        "startChar": 71,
        "endLine": 434,
        "endChar": 85
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27b88835_1f95d8c5",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 442,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-15T04:07:39Z",
      "side": 1,
      "message": "I don\u0027t think GL_MAP_WRITE_BIT would mean you cannot read data (unless paired with GL_MAP_INVALIDATE_RANGE/BUFFER_BIT). The spec says it can be used to \"modify\" the data. Well, doing data[i] |\u003d 0x20 is a modification and necessarily requires the memory to be readable.",
      "range": {
        "startLine": 440,
        "startChar": 31,
        "endLine": 442,
        "endChar": 15
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a95393f_d5560c53",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 442,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-17T18:33:33Z",
      "side": 1,
      "message": "It\u0027s not so much that we specify GL_MAP_WRITE_BIT, but that we don\u0027t specify GL_MAP_READ_BIT.\n\n\u003e GL_MAP_READ_BIT indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\nThat\u0027s where the undefined behavior piece comes from when reading the data, like in your example.",
      "parentUuid": "27b88835_1f95d8c5",
      "range": {
        "startLine": 440,
        "startChar": 31,
        "endLine": 442,
        "endChar": 15
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a5bd211_c09b13f4",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 442,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-18T15:24:10Z",
      "side": 1,
      "message": "Ok I see what you mean. I guess GL_MAP_READ_BIT would be the equivalent of vkInvalidateMappedMemoryRanges, which means without it we may be reading stale data already in the CPU cache, which would indeed make this test incorrectly pass (because the stale data _is_ the old data).\n\nI don\u0027t have another solution to test this!",
      "parentUuid": "1a95393f_d5560c53",
      "range": {
        "startLine": 440,
        "startChar": 31,
        "endLine": 442,
        "endChar": 15
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d19b042_52a8e3c9",
        "filename": "src/tests/gl_tests/BufferDataTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 442,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-18T15:46:09Z",
      "side": 1,
      "message": "Ha, yeah, this is a tough one.   I think this test is still better than nothing for now though, since it\u0027s able to catch the case where GL_MAP_UNSYNCHRONIZED_BIT is ignored and the glCopyBufferSubData() is finished without being explicitly told to do so.\n\nHacking BufferVk.cpp to ignore GL_MAP_UNSYNCHRONIZED_BIT:\n\nangle::Result BufferVk::mapRangeImpl(ContextVk *contextVk,\n                                     VkDeviceSize offset,\n                                     VkDeviceSize length,\n                                     GLbitfield access,\n                                     void **mapPtr)\n{\n    ASSERT(mBuffer.valid());\n\n//    if ((access \u0026 GL_MAP_UNSYNCHRONIZED_BIT) \u003d\u003d 0)\n//    {\n        // If there are pending commands for the buffer, flush them.\n        if (mBuffer.isResourceInUse(contextVk))\n        {\n            ANGLE_TRY(contextVk-\u003eflushImpl(nullptr));\n        }\n        // Make sure the GPU is done with the buffer.\n        ANGLE_TRY(contextVk-\u003efinishToSerial(mBuffer.getStoredQueueSerial()));\n//    }\n\n    ANGLE_VK_TRY(contextVk, mBuffer.getDeviceMemory().map(contextVk-\u003egetDevice(), offset, length, 0,\n                                                          reinterpret_cast\u003cuint8_t **\u003e(mapPtr)));\n    return angle::Result::Continue;\n}\n\n\nCauses the test to fail, since the glCopyBufferSubData() was finished:\n\n[ RUN      ] BufferDataTestES3.MapBufferRangeUnsynchronizedBit/ES3_Vulkan\n../../third_party/angle/src/tests/gl_tests/BufferDataTest.cpp:448: Failure\nExpected equality of these values:\n  dstData[i]\n    Which is: \u0027\\n\u0027 (10, 0xA)\n  data[i]\n    Which is: \u0027\\0\u0027\n\n\nI can pull this test out though if you think it\u0027s too hacky and isn\u0027t really getting us anything.\n\nI\u0027ll chat with some people here to see if they can make sense of Mohan\u0027s sequence that may cause a hang if there\u0027s a bug in this code.   I\u0027m not sure I want to hold up this CL for that though, since dEQP and the other end2end tests are passing.",
      "parentUuid": "1a5bd211_c09b13f4",
      "range": {
        "startLine": 440,
        "startChar": 31,
        "endLine": 442,
        "endChar": 15
      },
      "revId": "057cf67dfd30ba5faf57d06079e98c611c9ae206",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}