{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9d72b3f3_fd5380bd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2022-05-31T15:13:11Z",
      "side": 1,
      "message": "Looks good, see my comment below as to one alternative way to do this.",
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "888aabf5_79f8dac8",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2022-05-31T15:13:11Z",
      "side": 1,
      "message": "I don\u0027t think you have to pass it around, you should always be able to retrieve it from ContextVk.\n\nI wonder if you could make a small RAII type where you could acquire a locked reference to the PipelineCache. e.g. a class that wraps a lock and a reference to the Vk object, and you get one of these from the RendererVk. Instead of exposing access to the mutex itself. And that way we\u0027d ensure every access is safe.",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a3c2a3a_ad438734",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-05-31T16:37:06Z",
      "side": 1,
      "message": "See next change. `ProgramExecutableVk` will make this call as well without needing to hold a mutex.\n\nI could wrap it in a class that wraps the `vkCreateGraphicsPipelines` call (but not `vkMergePipelineCaches`), but that sounds like a hack TBH.",
      "parentUuid": "888aabf5_79f8dac8",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8ecd53c_b8fefc60",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2022-05-31T16:39:02Z",
      "side": 1,
      "message": "Can you tl;dr on what makes it so we need a mutex in some places and not in others?\n\nIn either case you shouldn\u0027t need to pass this stuff around.",
      "parentUuid": "2a3c2a3a_ad438734",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8dccc2fc_2f6fb282",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-05-31T16:47:43Z",
      "side": 1,
      "message": "In the next change there will be multiple caches. One in the renderer (used at draw time), one in each program executable. The one in program executable is warmed up (and returned for program binary) and merged into the renderer\u0027s. This merge is not internally synchronized with the cache look up per Vulkan.\n\nWhen creating pipelines in the program\u0027s cache, there\u0027s no need for a mutex. When creating pipelines in the renderer\u0027s cache, we need the mutex to synchronize with program\u0027s cache merging into the renderer\u0027s.\n\nWhen VK_EXT_graphics_pipeline_library is implemented, more of the pipeline creation will use the program\u0027s cache, which means there would be more opportunity to avoid the mutex.",
      "parentUuid": "b8ecd53c_b8fefc60",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81c2e698_b1c28d87",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-05-31T18:37:05Z",
      "side": 1,
      "message": "+1 against passing mutex around. It breaks encapsulation and introduces risk of dead lock.",
      "parentUuid": "8dccc2fc_2f6fb282",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f74d66e_e24a64c0",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1822,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-06-01T02:02:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "81c2e698_b1c28d87",
      "range": {
        "startLine": 1822,
        "startChar": 53,
        "endLine": 1822,
        "endChar": 62
      },
      "revId": "e6c8786f4c8fb900ad40d7e3224ae1c5680dfde0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}