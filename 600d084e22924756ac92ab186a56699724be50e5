{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d7f93946_422189bf",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 131,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-28T15:34:56Z",
      "side": 1,
      "message": "I think this can also be written as:\n\n```\npostAsyncTask(std::shared_ptr\u003cAsyncTask\u003e(asyncTask));\n\nreturn asyncTask;\n```\n\nThis avoids the std::move / aliasing awkwardness.. I\u0027m undecided if this makes it more clear though, up to you",
      "range": {
        "startLine": 130,
        "startChar": 4,
        "endLine": 131,
        "endChar": 40
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe465e4b_000a9d8e",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 131,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-28T16:31:58Z",
      "side": 1,
      "message": "`return asyncTask` will create new temporary object, so extra atomic increment.\n\nTo avoid this, need to write:\n```\npostAsyncTask(std::shared_ptr\u003cAsyncTask\u003e(asyncTask));\n\nreturn std::static_pointer_cast\u003cWaitableEvent\u003e(std::move(asyncTask));\n```\n\nBut I\u0027m not sure that this is cleaner than the original code...\n\nI guess I will use the above version, since it is closer to the other method, that will be added in the `Add dependency graph into the WorkerThread` CL.",
      "parentUuid": "d7f93946_422189bf",
      "range": {
        "startLine": 130,
        "startChar": 4,
        "endLine": 131,
        "endChar": 40
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a68e1bf0_4b1876c2",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 131,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T15:23:25Z",
      "side": 1,
      "message": "\u003e `return asyncTask` will create new temporary object, so extra atomic increment.\n\nSorry, I was wrong. In the above case move-convert constructor will be used without adding extra reference.\n\nI also removed usage of `std::static_pointer_cast` where it was unnecessary.",
      "parentUuid": "fe465e4b_000a9d8e",
      "range": {
        "startLine": 130,
        "startChar": 4,
        "endLine": 131,
        "endChar": 40
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8820ed1b_91689bae",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-28T15:34:56Z",
      "side": 1,
      "message": "I understand that this is done for future flexibility, but could we hold off on this until we actually get to the point where it is useful, and maybe consider alternatives at that point? Currently it\u0027s difficult to reason about whether this class structure is the way to go.",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74b29d66_99905241",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-28T16:31:58Z",
      "side": 1,
      "message": "I may remove `WorkerThreadLoopPolicy` class, but this will increase diff in the future CL (that I wanted to avoid by splitting into multiple CLs).\n\n`Update DelegateWorkerPool to be a MultiThreadedWorkerPool` is the CL where `WorkerThreadLoopPolicy` class is really required.\n\n\u003e but could we hold off on this until we actually get to the point where \nit is useful, and maybe consider alternatives at that point? \n\nIf do that, then CL, where these classes will be really useful will include not only refactoring, but also a functional updates. This will make this CL larger and harder to review.",
      "parentUuid": "8820ed1b_91689bae",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78cfa8db_56ec7a54",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-28T17:00:48Z",
      "side": 1,
      "message": "Roman, I was hoping you could eventually review the rest of the CLs too, they can be tricky I\u0027m sure. Would you mind looking ahead (especially to the last CL) to see how this all comes together?",
      "parentUuid": "74b29d66_99905241",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "749b47b9_8e78e439",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-28T17:08:32Z",
      "side": 1,
      "message": "Sure, I will have a look. I just wasn\u0027t aware of the other CLs and commented on this one in isolation.",
      "parentUuid": "78cfa8db_56ec7a54",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c144d29_317bc0a6",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-28T22:55:40Z",
      "side": 1,
      "message": "Looking at the CL chain, this is quite convoluted.. I think I understand this implementation but I find it quite difficult to reason about due to:\n\n* the conditional locked/unlocked state of the luck when the function returns\n* `Locked` suffix in the function name when only _some_ of the code in the function is executed under lock.\n\nIgor, have you considered\n\n1) Splitting the `startThreadLocked` function into two parts, one locked and one unlocked, and adjusting the caller to make the two calls accordingly (possibly carrying the return value from the locked call over the unlock boundary)\n\n2) Using templates instead of polymorphism (not insisting, but wondering if this would be better/worse/infeasible)\n\n?",
      "parentUuid": "749b47b9_8e78e439",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bb016a6_f0a22777",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T12:16:36Z",
      "side": 1,
      "message": "\u003e the conditional locked/unlocked state of the luck when the function returns\n\nThe `startThreadLocked()` **must** always be executed when the lock is held (this is indicated by the `Locked` suffix). However, it may or may not unlock the lock inside the call. This is not the problem for the caller, because it calls it in the end of the locking scope, where unlock will happen (in other words - it does not care). Description in `startThreadLocked()` only says that it may unlock the lock early, and the caller should expect that, and place the call at the end of the locked scope as one way to handle this.\n\n\u003e `Locked` suffix in the function name when only some of the code in the function is executed under lock.\n\nThe `Locked` suffix means that the function itself **must** be executed under the lock. Passing `lock` inside a function is separate from the having the suffix. There are other `Locked` function that do not have `lock` parameter.\n\nI seen this suffix used in other places in ANGLE (`SharedGarbageList` or in `CommandQueue`)\n\n\u003e 1) Splitting the startThreadLocked function into two parts,\n one locked and one unlocked, and adjusting the caller to make the two \ncalls accordingly (possibly carrying the return value from the locked \ncall over the unlock boundary)\n\nNow we have:\n```\nvoid MultiThreadedWorkerPool::postAsyncTask(std::shared_ptr\u003cAsyncTask\u003e \u0026\u0026task)\n{\n    std::unique_lock\u003cstd::mutex\u003e lock(mMutex);\n    //...\n    startThreadIfNeededLocked(\u0026lock);\n}\n\nvoid MultiThreadedWorkerPool::startThreadIfNeededLocked(std::unique_lock\u003cstd::mutex\u003e *lock)\n{\n    if (mTaskQueue.size() \u003e mFreeThreadCount.load(std::memory_order_relaxed))\n    {\n        startThreadLocked(lock);\n    }\n}\n\nvoid AsyncWorkerPool::startThreadLocked(std::unique_lock\u003cstd::mutex\u003e *lock)\n{\n    // Try to wake a waiting thread.\n    if (mWaitingThreadCount \u003e mNotifiedThreadCount)\n    {\n        incrementNotifiedThreadCountLocked(1);\n        lock-\u003eunlock();\n        mCondVar.notify_one();\n        return;\n    }\n\n    // Otherwise, try to create a new thread.\n    if (mThreads.size() \u003c mDesiredThreadCount)\n    {\n        incrementFreeThreadCount(1);\n        mThreads.emplace_back(\u0026AsyncWorkerPool::threadLoop, this);\n        return;\n    }\n\n    // All threads are created and running, so nothing to do.\n}\n```\nSo the `AsyncWorkerPool::startThreadLocked()` may unlock or not unlock the thread, depending if it wakes existing thread or creates new thread.\n\nWe can rewrite into 2 methods (as I understand you suggesting):\n```\nvoid MultiThreadedWorkerPool::postAsyncTask(std::shared_ptr\u003cAsyncTask\u003e \u0026\u0026task)\n{\n    bool needStartThreadUnlocked \u003d false;\n    {\n        std::unique_lock\u003cstd::mutex\u003e lock(mMutex);\n        //...\n        needStartThreadUnlocked \u003d !startThreadIfNeededLocked();\n    }\n    if (needStartThreadUnlocked)\n    {\n        startThreadUnlocked();\n    }\n}\n\nbool AsyncWorkerPool::startThreadLocked()\n{\n    // Try to wake a waiting thread.\n    if (mWaitingThreadCount \u003e mNotifiedThreadCount)\n    {\n        incrementNotifiedThreadCountLocked(1);\n        // Notify expected to be called in |startThreadUnlocked| because of the\n        // returned false.\n        return false;\n    }\n\n    // Otherwise, try to create a new thread.\n    if (mThreads.size() \u003c mDesiredThreadCount)\n    {\n        incrementFreeThreadCount(1);\n        mThreads.emplace_back(\u0026AsyncWorkerPool::threadLoop, this);\n        return true;\n    }\n\n    // All threads are created and running, so nothing to do.\n    return true;\n}\nvoid AsyncWorkerPool::startThreadUnlocked()\n{\n    mCondVar.notify_one();\n}\n```\nMy opinion, is the second version is more complex, and more error prone.\n\nThe `DelegateWorkerPool::startThreadLocked()` after split will mostly do it\u0027s work in the unlocked function.\n\n\u003e 2) Using templates instead of polymorphism (not insisting, but wondering if this would be better/worse/infeasible)\n\nGenerally, templates a harder to understand vs polymorphism by most programmers. I even once had a boss that banned templates because of complexity). Templates are generally used for performance and not for clarity.\n\nRegardless, of the above. It is hard to imagine what will be the template(s).\n\nI\u0027m agree to make it simpler, but I spend a lot of time so all things come together, and not sure that I can make everything simpler.\n\nI can simplify `startThreadLocked()` by passing lock **by value**, so the caller will know, that the lock will be **always** unlocked.\n\nI can also make same thing for the `ensureHasNextTaskToRunLocked()`, but then I will need to change return value from `bool` to `std::pair\u003cbool, std::unique_lock\u003cstd::mutex\u003e\u003e`, where in case of `result.first \u003d\u003d true`, the `result.second` will be a **valid locked lock**, otherwise - **empty lock object**.\n\nI will do the above, so you can compare differences and see which is better in your opinion.",
      "parentUuid": "4c144d29_317bc0a6",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a5283d3_6d3e8445",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-10-29T14:47:40Z",
      "side": 1,
      "message": "re: templates in general, I disagree with blindly applying that sentiment to everything. I think there are cases where they actually make things both simpler (by avoiding inheritance chains) and faster. They can absolutely be overused and misused though, we agree there. This case feels like maybe some templates and composition could simplify things but I\u0027m not sure, and the sunk cost argument is fair.\n\n\u003e The Locked suffix means that the function itself must be executed under the lock\n\nThat\u0027s not the only meaning that this \"intuitively\" conveys though. Example:\n\n```\nfLocked() {\n  gLocked();\n  hLocked();\n}\n```\n\nThis code looks totally innocuous, but if `gLocked` can sometimes unlock then it\u0027s incorrect. I understand that this isn\u0027t how your code is *currently* written, but there is a risk of future code changes leading to this kind issues.\n\nIf you prefer this behavior over splitting into two parts that I suggested (I think you got the idea right), then we should definitely have comments about this at the call spots and also consider changing the `Locked` suffix to something that hints at this behavior (I know naming is hard...).",
      "parentUuid": "9bb016a6_f0a22777",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb139be4_6e5c8a17",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T15:23:25Z",
      "side": 1,
      "message": "Updated `startThreadLocked()`, `startThreadIfNeededLocked()`, and `ensureHasNextTaskToRunLocked()` to accept `lock` by value.\n\nFor `startThreadLocked()` and `startThreadIfNeededLocked()` now it is clear, that the lock will be always unlocked.\n\nBut the `ensureHasNextTaskToRunLocked()` may return the `lock` argument back depending on the result. So there is explicit ownership change for the `lock` object.\n\n---\n\n\u003e but if `gLocked` can sometimes unlock then it\u0027s incorrect\n\nI disagree, because it is subjective. There is no such standard about what `Locked` means.\n\nIncorrect is to call `hLocked()` if `gLocked()` unlocked the mutex.\n\nWith my last update to the code there is no need to comment this, because `hLocked()` will consume the lock like this: `hLocked(std::move(lock))`. So above example will not compile, need rewrite:\n```\nfLocked(lock) {\n  gLocked(move(lock));\n  // Can\u0027t call because no longer have the lock.\n  //hLocked();}\n```\nIf `hLocked()` need to be called in some cases, then:\n```\nfLocked(lock) {\n  newLock \u003d gLocked(move(lock)); // need to check documentation of gLocked\n  if (newLock.locked)\n      hLocked();\n}\n```\nIMO, `Locked` means that the method must be called while the mutex is locked - that is it. Anyway, in this code the `Locked` means exactly this and not more.\n\nIf a `Locked` function is waiting on a conditional variable it unlocks the mutex in order to wait. In your opinion `Locked` here also incorrect?\n\nIn my cases, these function accepting the `lock` specifically to be able to do early unlock. In both these cases, these functions a last functions that a called.\n\nWith my last update this is clear, because `lock` is moved inside the functions. For the caller now it is clear that there will be no lock after `startThreadLocked()` for example. In case of `ensureHasNextTaskToRunLocked()` we moving old lock inside, while obtaining new lock in return - we always need to check documentation to what function returns.\n\n---\n\n\u003e This case feels like maybe some templates and composition could simplify\n things but I\u0027m not sure, and the sunk cost argument is fair.\n\nI do not see how I can do this. I can try, but not sure if it will be worth the wasted time.\n\n\u003e and also consider changing the Locked suffix to something that hints at this behavior (I know naming is hard...).\n\nAgain, I think it is subjective.\nI can remove `Locked` from all functions, so there is no confusion. Not sure if this will be better.",
      "parentUuid": "9bb016a6_f0a22777",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "deb04d4f_bd9619de",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-29T19:20:09Z",
      "side": 1,
      "message": "\u003e  This case feels like maybe some templates and composition could simplify things but I\u0027m not sure,\n\nI tried to do as you asked. Here is the result: https://chromium-review.googlesource.com/c/angle/angle/+/5973180\n\nIt is applied to the final CL, because spreading changes across all CLs is too much work. If it is better that the current version, than I will update other CLs and remove the DRAFT. If no - I will simply remove the DRAFT.",
      "parentUuid": "fb139be4_6e5c8a17",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e2df278_dd7a8199",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 4
      },
      "lineNbr": 167,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T01:16:09Z",
      "side": 1,
      "message": "\u003e Looking at  the CL chain, this is quite convoluted.. I think I understand this implementation but I find it quite difficult to reason about due to:\n- the conditional locked/unlocked state of the luck when the function returns\n- `Locked` suffix in the function name when only some of the code in the function is executed under lock.\n\nI have updated the code in all CLs of the chain. Now `Locked` means, that the function must be called while the mutex is locked and the mutex will be locked when the call ends.\n\nHowever function is still allowed to unlock the mutex *temporarily* inside the call. I asked you if this is OK, but did not found the answer. Is using `Locked` suffix is OK in this case?\n\nIs updated implementation more clear now?\n\n\u003e Igor, have you considered\n\u003e\n\u003e 1) Splitting the `startThreadLocked` function into two parts, one locked and one unlocked, and adjusting the caller to make the two calls accordingly (possibly carrying the return  value from the locked call over the unlock boundary)\n\nDone.\n\n\u003e 2) Using templates instead of polymorphism (not insisting, but wondering if this would be better/worse/infeasible)?\n\nDone.\n\n---\n\nOne question. Will it be clear if I simply remove the `Locked` suffix and only pass the `lock`. Then I will write in the documentation that the lock must be locked when calling the function, but may be unlocked when call ends in some cases?\n\nThis way there will be no `Locked` promise, and whoever will be using that function will not assume anything. It will also see that lock is passed as pointer `\u0026lock`, indicating that the lock may change inside.\n\nI really do not see that splitting functions making code clearer.",
      "parentUuid": "deb04d4f_bd9619de",
      "range": {
        "startLine": 167,
        "startChar": 4,
        "endLine": 167,
        "endChar": 86
      },
      "revId": "600d084e22924756ac92ab186a56699724be50e5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}