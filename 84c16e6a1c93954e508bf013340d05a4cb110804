{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9d865c57_5b1b1281",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 18,
        "startChar": 52,
        "endLine": 18,
        "endChar": 59
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d254cc2_8d16e481",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "Can you add the commands for how you\u0027re \"modifying\" the ToT commit?",
      "range": {
        "startLine": 17,
        "startChar": 61,
        "endLine": 18,
        "endChar": 59
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfaa703c_5e659b69",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "Yeah, I\u0027ve just been doing \"git commit --amend\" and adding some characters to the commit message.  I won\u0027t need to mention this with the approach Jamie suggested of modifying MemoryProgramCache::ComputeHash.",
      "parentUuid": "5d254cc2_8d16e481",
      "range": {
        "startLine": 17,
        "startChar": 61,
        "endLine": 18,
        "endChar": 59
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "970c7e16_4aded4e6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-26T22:35:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9d865c57_5b1b1281",
      "range": {
        "startLine": 18,
        "startChar": 52,
        "endLine": 18,
        "endChar": 59
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e4c0df25_7f3bfd86",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-26T22:35:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dfaa703c_5e659b69",
      "range": {
        "startLine": 17,
        "startChar": 61,
        "endLine": 18,
        "endChar": 59
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ea780a6_cecd3cac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T03:13:37Z",
      "side": 1,
      "message": "I\u0027ll update this CL with an example of what the generated sequence looks like vs what the app sent down, but wanted to start the discussion on a couple points.",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "189f1bb4_65b2bd6e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-19T11:21:28Z",
      "side": 1,
      "message": "Nice stuff Cody.",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98b4560f_622f21fa",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T03:13:37Z",
      "side": 1,
      "message": "Debatable whether this makes sense, to only serialize source when capture is enabled.  Since we can enable capture via GN args, there could be program binaries that would still be submitted given their format is still compatible.  Locally I\u0027ve been changing ANGLE_COMMIT_HASH which changes our binary format, so new binaries are created.\n\nWould there be big push back to enabling this all the time?",
      "range": {
        "startLine": 4709,
        "startChar": 19,
        "endLine": 4709,
        "endChar": 79
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08dd412c_bbb0d990",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-19T11:21:28Z",
      "side": 1,
      "message": "is context ever nullptr? seems unlikely.",
      "range": {
        "startLine": 4709,
        "startChar": 8,
        "endLine": 4709,
        "endChar": 16
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e121c918_ba955f95",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-19T11:21:28Z",
      "side": 1,
      "message": "Just embed this bit into MemoryProgramCache::ComputeHash. Strong push back on enabling this everywhere because of the limited cache space on Android.",
      "parentUuid": "98b4560f_622f21fa",
      "range": {
        "startLine": 4709,
        "startChar": 19,
        "endLine": 4709,
        "endChar": 79
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb56d43c_06db8621",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "See above:\n\n    // nullptr context is supported when computing binary length.\n    if (context)\n    {\n        stream.writeInt(context-\u003egetClientVersion().major);\n        stream.writeInt(context-\u003egetClientVersion().minor);\n    }\n    else\n    {\n        stream.writeInt(2);\n        stream.writeInt(0);\n    }",
      "parentUuid": "08dd412c_bbb0d990",
      "range": {
        "startLine": 4709,
        "startChar": 8,
        "endLine": 4709,
        "endChar": 16
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c96e052_7113aa95",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "Good idea, will do.",
      "parentUuid": "e121c918_ba955f95",
      "range": {
        "startLine": 4709,
        "startChar": 19,
        "endLine": 4709,
        "endChar": 79
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21d56d56_04a4638d",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4709,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8c96e052_7113aa95",
      "range": {
        "startLine": 4709,
        "startChar": 19,
        "endLine": 4709,
        "endChar": 79
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71189c00_c3669a5b",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "This can be simplified, since we only care about recreating the linked program:\n\n        ProgramExecutable \u0026getExecutable \u003d getExecutable();\n        for (ShaderType shaderType : getExecutable.getLinkedShaderStages())\n        {\n            gl::Shader *shader \u003d getAttachedShader(shaderType);\n            ASSERT(shader);\n            stream.writeString(shader-\u003egetSourceString());\n        }\n        \nA similar update can be made to Program::deserialize(), since the ProgramExecutable knows which shader stages are linked by the end of deserialize().\n\nThere also aren\u0027t any worries about getLinkedShaderStages() returning compute vs draw stages, since Programs can only be one or the other, never both.",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1752e365_a84add46",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "Good idea, will give it a try.  Updating serialized formats is always tricky.",
      "parentUuid": "71189c00_c3669a5b",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1aad7fb_a9881df7",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "This didn\u0027t pan out. I think its because even linked stages can have empty shaders, i.e. VS only programs.  When I switched to the getLinkedShaderStages method the app would hang in LinkProgram.  I didn\u0027t debug it all the way, but I did print out the lengths of shaders and saw 0 sized fragment shaders paired with non-zero vertex shaders.",
      "parentUuid": "1752e365_a84add46",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cd845dc_cb174fdd",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-24T16:52:41Z",
      "side": 1,
      "message": "If the assert isn\u0027t being hit when using getLinkedShaderStages(), then the same number of shader stages and strings should be output in both cases.   Additionally, if there isn\u0027t any source to compile, it shouldn\u0027t be possible to recreate the program with all of the necessary shader stages.\n\n\u003e I didn\u0027t debug it all the way, but I did print out the lengths of shaders and saw 0 sized fragment shaders paired with non-zero vertex shaders.\n\nThis is invalid GLSL, so it wouldn\u0027t compile when recreating the programs from the source in the program binaries.   For example:\n\n\u003e The #version directive must be present in the first line of a shader and must be followed by a newline. \n\nSo the version string must at least be present, which makes the source string non-zero.\n\nIt looks like we\u0027re seeing behavior we don\u0027t quite understand.   Can you take a closer look at what may be going on here?",
      "parentUuid": "e1aad7fb_a9881df7",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b0ed673_4f68bb39",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-24T21:19:47Z",
      "side": 1,
      "message": "\u003e This is invalid GLSL, so it wouldn\u0027t compile when recreating the programs from the source in the program binaries.\nIt is possible have a program that is VS only.  I\u0027m not sure why the program thought it had a linked fragment stage though.  Trying to keep the investigation germane.  I can debug a bit more, but this is really just an optimization.  I only care about stages that have source we can re-use.",
      "parentUuid": "3cd845dc_cb174fdd",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45faa5b7_1630176e",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-24T23:54:10Z",
      "side": 1,
      "message": "\u003e It is possible have a program that is VS only.  I\u0027m not sure why the program thought it had a linked fragment stage though. \n\nRight, my concern is this may be indicating a bug somewhere since a Program shouldn\u0027t think it has a linked shader stage that it doesn\u0027t actually have.   We\u0027re pretty reliant on getLinkedShaderStages() being accurate, so it would be good to understand what\u0027s going on here.",
      "parentUuid": "9b0ed673_4f68bb39",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8596fb8_dac83957",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-25T05:08:02Z",
      "side": 1,
      "message": "Spent some time on this again.  Using code similar to what you\u0027ve got above, the assert does fire:\n\n        for (ShaderType shaderType : mState.mExecutable-\u003egetLinkedShaderStages())\n        {\n            gl::Shader *shader \u003d getAttachedShader(shaderType);\n            ASSERT(shader);\n            if (shader)\n            {\n                stream.writeString(shader-\u003egetSourceString());\n            }\n        }\n\nThe calls leading to this are:\n\n glCreateProgram(context\u003d3)\n glProgramBinary(context\u003d3, program\u003d7, binaryFormat \u003d GL_PROGRAM_BINARY_ANGLE,\n                 binary \u003d ..., length \u003d 17790)\n glGetProgramiv(context\u003d3, program\u003d7, pname \u003d GL_LINK_STATUS, params \u003d ...)\n glGetProgramiv(context\u003d3, program\u003d7, pname \u003d GL_PROGRAM_BINARY_LENGTH,\n                params \u003d ...)\n ! Assert failed in serialize (../../src/libANGLE/Program.cpp:4728): shader\n\nThe stack leading up to the assert is:\n\n gl::LogMessage::~LogMessage()+260) \n gl::Program::serialize(gl::Context const*, angle::MemoryBuffer*) +916) \n gl::Program::saveBinary(gl::Context*, unsigned int*, void*, int, int*) +256)\n gl::Program::getBinaryLength(gl::Context*) +240) \n gl::QueryProgramiv(gl::Context*, gl::Program const*, unsigned int, int*)+828) \n gl::Context::getProgramiv(gl::ShaderProgramID, unsigned int, int*)+284) \n GL_GetProgramiv+232) \n\nSo we can see that serialize is called when the app checks the size of the binary.  If I add some logging instead of the assert, I can see that... no programs are attached to the executable in this scenario... ever:\n \n glCreateProgram(context \u003d 3)\n glProgramBinary(context \u003d 3, program \u003d 7, binaryFormat \u003d GL_PROGRAM_BINARY_ANGLE,\n                 binary \u003d ..., length \u003d 17790)\n CLN: deserialize: Shader length of 1678 was read from binary for\n                   stage\u003dGL_VERTEX_SHADER in program\u003d7\n CLN: deserialize: Shader length of 1885 was read from binary for \n                   stage\u003dGL_FRAGMENT_SHADER in program\u003d7\n glGetProgramiv(context \u003d 3, program \u003d 7, pname \u003d GL_LINK_STATUS, params \u003d ...)\n glGetProgramiv(context \u003d 3, program \u003d 7, pname \u003d GL_PROGRAM_BINARY_LENGTH, \n                params \u003d ...)\n CLN: serialize: No shader attached for stage\u003dGL_VERTEX_SHADER in program\u003d7\n CLN: serialize: No shader attached for stage\u003dGL_FRAGMENT_SHADER in program\u003d7\n glGetProgramiv(context \u003d 3, program \u003d 7, pname \u003d GL_LINK_STATUS, params \u003d ...)\n glUseProgram(context \u003d 3, program \u003d 7)\n \nIf I browse through the source a bit, I don\u0027t see where Program::attachShader is ever called when ProgramBinary is used.  So maybe this is WAI?  It does throw off the binary size calculation though, so I also hooked up the ability to load the shader source from cache. \n\nI did go ahead and move to using getLinkedShaderStages instead of looping through all shader types.  LMKWYT.",
      "parentUuid": "45faa5b7_1630176e",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c292083_0cc98e15",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-25T16:24:15Z",
      "side": 1,
      "message": "I\u0027m still not fully understanding this implementation, due to the cachedSourceString.empty() check.\n\n\u003e To support this, we will embed program source into ANGLE\u0027s binary\nformat. This will allow us to parse it out again when the app submits\nthe binary.\n\nThis change requires the source for all shaders stages in a program to be present so we can recreate the program later with them.  If there are any stages missing, then we can\u0027t fully recreate the program, so the trace won\u0027t be correct/complete.\n\nWhile I understand that it\u0027s possible to create and link separable programs with missing shader stages, that\u0027s not what the app is doing here.   It has linked a full program with all of the necessary shader stages, but we can\u0027t embed the source for them since they aren\u0027t present.   Rather than returning an partial program binary, it seems we should instead be ASSERT()\u0027ing that there is missing shader source and the trace will be incomplete.\n\nMaybe there\u0027s something else I\u0027m misunderstanding, but how does the recreated program with missing shader stages link and execute correctly in your trace?",
      "parentUuid": "b8596fb8_dac83957",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1dbfc689_f8d5d4e7",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-25T18:37:45Z",
      "side": 1,
      "message": "\u003e I\u0027m still not fully understanding this implementation, due to the cachedSourceString.empty() check.\n\nThat is just a fail safe, it should never be empty.\n\n\u003e This change requires the source for all shaders stages in a program to be present so we can recreate the program later with them.  If there are any stages missing, then we can\u0027t fully recreate the program, so the trace won\u0027t be correct/complete.\n\nThe binaries containing strings will have been created after a full sequence of shader create/source/compile/attach/delete run by the app, so we won\u0027t be missing any shaders when glGetProgramBinary is called.  Note that the app calls glGetProgramBinary during its \"Optimization\" phase and stashes them away for the next run.\n\nPrograms created from binaries via glProgramBinary will never have shaders attached, but we can always look up the source.  I\u0027ll update the comments to make all of this clearer, and include the full override call sequence like I said I would.  This might be worth a doc too, for posterity.\n\n\u003e While I understand that it\u0027s possible to create and link separable programs with missing shader stages, that\u0027s not what the app is doing here.   It has linked a full program with all of the necessary shader stages, but we can\u0027t embed the source for them since they aren\u0027t present.   Rather than returning an partial program binary, it seems we should instead be ASSERT()\u0027ing that there is missing shader source and the trace will be incomplete.\n\nI can certainly change the cachedSourceString.empty() check to be an ASSERT.\n\nI think the key thing to remember here is, when the app is first creating a linked program, it *does* attach shaders for each stage, and we stash them away during glGetProgramBinary.  On the next run, when the app uses glProgramBinary, ANGLE does *not* attach shaders for each stage, and FrameCapture has to look up the source from the binary we just parsed.  We then use that source to recreate the full sequence in the resulting trace.",
      "parentUuid": "3c292083_0cc98e15",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2eac000e_92bc5250",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-26T00:28:23Z",
      "side": 1,
      "message": "Ah, right, there 2 cases where this would be called during MEC:\n\n1.) The first time the app is run with capture enabled, in which case the source is present since the app created the program from scratch and the shaders are still around.\n2.) The next time the app is run with capture enabled and the branch wasn\u0027t \"modified\", so the same binaries (containing the source) can be re-uploaded to ANGLE.   However, the program never had shaders attached, so we can\u0027t get source from them.\n\nThat should explain both paths through here and why we wouldn\u0027t always have shaders attached.\n\nRegardless of which it is though, we always need to be certain there is shader source available for each linked stage in the program so the capture can be replayed correctly.   Whether it\u0027s an ASSERT() or UNREACHABLE() doesn\u0027t really matter, as long as we error out when we don\u0027t have shader source.\n\nThanks for bearing with me on this one.   I think you\u0027ve got something that works here now.",
      "parentUuid": "1dbfc689_f8d5d4e7",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c46fc638_88bfd6d5",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-26T22:35:45Z",
      "side": 1,
      "message": "No problem, I appreciate your thorough review, its part of what makes this a strong project.\n\nI did some more cleanup and commenting, including the resulting override GL sequence.  Local testing shows this working solidly.",
      "parentUuid": "2eac000e_92bc5250",
      "range": {
        "startLine": 4712,
        "startChar": 0,
        "endLine": 4724,
        "endChar": 9
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dc01820_27425a43",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T03:13:37Z",
      "side": 1,
      "message": "Commented this out locally so this will compile.  As the comment says, not clear why we need this.  In the ProgramBinary case (i.e. not the MEC case), we get the state by calling context-\u003egetState() [ref1] which returns a const gl:State\u0026.  We could potentially add a context-\u003egetStateForCapture() which would return a mutable state, but it isn\u0027t clear to me why we need to modify the state passed in.",
      "range": {
        "startLine": 1724,
        "startChar": 0,
        "endLine": 1724,
        "endChar": 57
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95131350_0c279254",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1724,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-19T11:21:28Z",
      "side": 1,
      "message": "The State parameter should always be the MEC replay state, not the API state. The gl::Program *program itself is the only thing we pull from the API state. Maybe turn the replayState into a nullable pointer and ignore the checks when not in MEC.\n\nWe need this to ensure the code for the setup function can track what we set in MEC so it can restore the state after updating uniforms properly.",
      "parentUuid": "7dc01820_27425a43",
      "range": {
        "startLine": 1724,
        "startChar": 0,
        "endLine": 1724,
        "endChar": 57
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff898a94_86f379c3",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "I\u0027m trying an approach that provides a default state inside overrideProgramBinary and sends a non-const reference to that.",
      "parentUuid": "95131350_0c279254",
      "range": {
        "startLine": 1724,
        "startChar": 0,
        "endLine": 1724,
        "endChar": 57
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78f7bfd1_5077743f",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1724,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "We spoke offline and agreed to hoist the modification of replayState out of the helper, with comments explaining why.  This allows the references to remain const.",
      "parentUuid": "ff898a94_86f379c3",
      "range": {
        "startLine": 1724,
        "startChar": 0,
        "endLine": 1724,
        "endChar": 57
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7982c67d_1241953b",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1724,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-24T14:19:02Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "78f7bfd1_5077743f",
      "range": {
        "startLine": 1724,
        "startChar": 0,
        "endLine": 1724,
        "endChar": 57
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd0a180e_2297f45e",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2238,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "Maybe I\u0027m missing how this \u0027tempShaderID\u0027 is being used, but it looks like this is reusing the same shader ID for every shader stage in the program.\n\n\u003e If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted).\n\nIn this case, the shader is not being detached, since the program has not been linked yet, so the shader ID cannot be recycled yet.",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94f388cd_5ec6a0b7",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2238,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "Interesting.  This is carry-over from the existing LinkProgram support in MEC.  No driver has ever complained about re-using the same ID.  If we can never detach any of these shaders until the program itself is deleted, we\u0027ll need to increment this value continuously.",
      "parentUuid": "cd0a180e_2297f45e",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "143dfdb9_f51a9883",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2238,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:40:05Z",
      "side": 1,
      "message": "Oh, I know.  We\u0027re using the temp ID as a lookup into the map.  The actual ID used by the app will be incrementing, we just never look at it, keep overwriting the entry in the map.",
      "parentUuid": "94f388cd_5ec6a0b7",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b3b69ee_f8b6fd41",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2238,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T20:28:08Z",
      "side": 1,
      "message": "Ah, yeah, that makes sense once I saw your sample GL commands in the other comment.   I was misunderstanding how it\u0027s used.\n\nIt\u0027s probably worth a comment on what this \"ID\" actually is (an index into gShaderProgramMap) and not the actual ID returned by glCreateShader(), since it tripped us both up.",
      "parentUuid": "143dfdb9_f51a9883",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97f00001_8e22aca2",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2238,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0b3b69ee_f8b6fd41",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f29d7959_6dc52426",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4560,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T03:13:37Z",
      "side": 1,
      "message": "ref",
      "range": {
        "startLine": 4560,
        "startChar": 35,
        "endLine": 4560,
        "endChar": 54
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "283e3703_9eff8c34",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4560,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-19T11:21:28Z",
      "side": 1,
      "message": "Try nullptr here after changing this to a pointer.",
      "parentUuid": "f29d7959_6dc52426",
      "range": {
        "startLine": 4560,
        "startChar": 35,
        "endLine": 4560,
        "endChar": 54
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c6918e80_c4b28f50",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4560,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "283e3703_9eff8c34",
      "range": {
        "startLine": 4560,
        "startChar": 35,
        "endLine": 4560,
        "endChar": 54
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14bb4c83_61af8a64",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4833,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "ref1",
      "range": {
        "startLine": 4832,
        "startChar": 0,
        "endLine": 4833,
        "endChar": 27
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3dbcc88b_1b7e9b6f",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4833,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "14bb4c83_61af8a64",
      "range": {
        "startLine": 4832,
        "startChar": 0,
        "endLine": 4833,
        "endChar": 27
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20b13c34_94e351dd",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "We just got back a valid Shader* from getAttachedShader() above [ref1].   How can we not have an attached shader here?\n\nAdditionally, GenerateLinkedProgram() never generates a glDetachShader() call, so it should still be attached.   Where is the shader detached?",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76e98e38_90b3870a",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "We\u0027re generating calls to glAttachShader that will be executed in the future, not executing them during capture.  So they aren\u0027t attached when this code is run.\n\nFor reference (and I\u0027ll add this to the CL as a comment) here\u0027s what the app is submitting, and ANGLE is executing before capturing each call.  This is pulled from a trace before adding the override:\n\n  gShaderProgramMap[5349] \u003d glCreateProgram();\n  glProgramBinary(gShaderProgramMap[5349], GL_PROGRAM_BINARY_ANGLE, gBinaryData[99422352], 82291);\n  glGetProgramiv(gShaderProgramMap[5349], GL_LINK_STATUS, gReadBuffer);\n  glGetProgramiv(gShaderProgramMap[5349], GL_PROGRAM_BINARY_LENGTH, gReadBuffer);\n    \nFrameCaptureShared::overrideProgramBinary will insert the following sequence *instead* of what you see above:\n\n  gShaderProgramMap[5349] \u003d glCreateProgram();\n  // Begin override\n  gShaderProgramMap[5350] \u003d glCreateShader(GL_VERTEX_SHADER);\n  glShaderSource(gShaderProgramMap[5350], 1, string_0, \u0026gBinaryData[76656032]);\n  glCompileShader(gShaderProgramMap[5350]);\n  glAttachShader(gShaderProgramMap[5349], gShaderProgramMap[5350]);\n  glDeleteShader(gShaderProgramMap[5350]);\n  gShaderProgramMap[5350] \u003d glCreateShader(GL_FRAGMENT_SHADER);\n  glShaderSource(gShaderProgramMap[5350], 1, string_1, \u0026gBinaryData[76656048]);\n  glCompileShader(gShaderProgramMap[5350]);\n  glAttachShader(gShaderProgramMap[5349], gShaderProgramMap[5350]);\n  glDeleteShader(gShaderProgramMap[5350]);\n  glBindAttribLocation(gShaderProgramMap[5349], 0, \"in_ATTRIBUTE0\");\n  ...\n  glBindAttribLocation(gShaderProgramMap[5349], 4, \"in_ATTRIBUTE4\");\n  glLinkProgram(gShaderProgramMap[5349]);\n  UpdateUniformLocation(gShaderProgramMap[5349], \"vc0_h\", 0, 20);\n  ...\n  UpdateUniformLocation(gShaderProgramMap[5349], \"ps7\", 72, 1);\n  glUseProgram(gShaderProgramMap[5349]);\n  UpdateCurrentProgram(gShaderProgramMap[5349]);\n  UpdateCurrentProgram(gShaderProgramMap[5349]);\n  glUniform4fv(gUniformLocations[gCurrentProgram][0], 20, \u0026gBinaryData[76656064]);\n  ...\n  glUniform1iv(gUniformLocations[gCurrentProgram][72], 1, \u0026gBinaryData[76657216]);\n  // End override\n  glGetProgramiv(gShaderProgramMap[5349], GL_LINK_STATUS, gReadBuffer);\n  glGetProgramiv(gShaderProgramMap[5349], GL_PROGRAM_BINARY_LENGTH, gReadBuffer);",
      "parentUuid": "20b13c34_94e351dd",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e413f529_41ee1e1b",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T20:28:08Z",
      "side": 1,
      "message": "A few things here:\n\n1.) Thanks for the GL commands, that\u0027s helpful to see what this change is doing with real output.\n\n2.) This case statement is handling glCreateShaderProgramv(), which the trace is not using.   glCreateShaderProgramv() is used for PPOs, since it generates separable programs that only contain a single shader stage.   In this example, the app is uploading a program binary, though that program may have been created with glCreateShaderProgramv() (though that seems unlikely, since I haven\u0027t heard anything about Fortnite using PPOs yet).\n\n3.) \n\u003e We\u0027re generating calls to glAttachShader that will be executed in the future, not executing them during capture.  So they aren\u0027t attached when this code is run.\n\nI don\u0027t understand.   It\u0027s the same \u0027gl::Program *program\u0027 pointer for both calls here, without the Program it\u0027s pointing to having any shaders attached/detached in between.   The \u0027program\u0027 here is an already linked Program in the app\u0027s currently active API State.\n\nI\u0027m still not sure it\u0027s possible for program-\u003egetState().hasAttachedShader() to ever be false here.   Can you try removing this conditional and see if it still works?",
      "parentUuid": "76e98e38_90b3870a",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "787fddd8_2facf405",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T21:41:09Z",
      "side": 1,
      "message": "2) re: glCreateShaderProgramv:  I proactively added this check just based on the code pattern.  I can drop that one.\n\n3) re: program pointers:  By both calls, I presume you mean the handling of GLCreateShaderProgramv and GLLinkProgram here.  For the latter, when we are running the real app which just created a program and populated it with ProgramBinary, I don\u0027t think it will have attached shaders.  I\u0027ll do another run to verify once I get some of the other feedback cleared up.",
      "parentUuid": "e413f529_41ee1e1b",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "469165c4_9ab5e2c4",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "I tried removing the GLLinkProgram check and we do end up capturing empty strings.  I believe that\u0027s because we populate the correct string during deserialize, but then overwrite it here when processing the LinkProgram we added.  We can\u0027t use the program\u0027s state here because it was populated with ProgramBinary and doesn\u0027t have attached shader source.",
      "parentUuid": "787fddd8_2facf405",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "219a0018_74bf6efb",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4836,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-24T16:52:41Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "469165c4_9ab5e2c4",
      "range": {
        "startLine": 4835,
        "startChar": 0,
        "endLine": 4836,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a103f7d_61a4431f",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4868,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "nit: The Shader is being created, it\u0027s just being immediately deleted.",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee856bcc_7e8e13b6",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4868,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-19T19:30:43Z",
      "side": 1,
      "message": "This is the current context, which just executed glProgramBinary, not the result of the new sequence we generate and write to the trace, for future execution.  I agree this is tricky and took me a while to get this straight on Android.",
      "parentUuid": "9a103f7d_61a4431f",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3a1f08d_d6f1b4f1",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4868,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T20:28:08Z",
      "side": 1,
      "message": "Ah, right.",
      "parentUuid": "ee856bcc_7e8e13b6",
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4106b5d0_5183ca8d",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4884,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-19T18:00:32Z",
      "side": 1,
      "message": "Ditto above.\n\nGenerateLinkedProgram() never generates a glDetachShader() call, so it should still be attached.",
      "range": {
        "startLine": 4883,
        "startChar": 0,
        "endLine": 4884,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f66ed611_f9c9767e",
        "filename": "src/libANGLE/capture/FrameCapture.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4884,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2021-08-21T01:09:51Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4106b5d0_5183ca8d",
      "range": {
        "startLine": 4883,
        "startChar": 0,
        "endLine": 4884,
        "endChar": 56
      },
      "revId": "84c16e6a1c93954e508bf013340d05a4cb110804",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}