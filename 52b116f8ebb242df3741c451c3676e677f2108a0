{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "46426781_11230eef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-25T22:22:42Z",
      "side": 1,
      "message": "need to skip tests for pixel4 and pixel6",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9f3616d_fb9e9132",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-25T22:38:18Z",
      "side": 1,
      "message": "What\u0027s special about level 0? Say an EGL image has multiple levels, base level is 1, and someone calls glGenerateMipmap, is that supposed to orphan the image or generate mipmaps in the rest of the existing image?",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5231dd3_d29ff35f",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-26T01:03:44Z",
      "side": 1,
      "message": "\u003e is that supposed to orphan the image\n\ncurrent code will orphan for EGLImages not created using `EGL_ANDROID_image_native_buffer` extension, thus defeating the purpose of the `GL_EXT_EGL_image_storage` extension\n\nPS:\n\nCurrent usage of `GL_EXT_EGL_image_storage` is for EGLImages backed by AHBs using `EGL_ANDROID_image_native_buffer` extension. There is no mechanism to specify baseLevel for such EGLImages and `imageTarget-\u003egetLevelCount()` returns the levelCount of the AHB. These prevent orphaning during mipmap generation\n\nI am just expanding this to texture types other than AHB backed EGLImages under specific conditions -\n1. EGLImage source must be an immutable format GL texture (its storage will never be respecified)\n2. EGLImage was created with `EGL_GL_TEXTURE_LEVEL_KHR \u003d\u003d 0` (mirroring AHB backed EGLImage usecase)\n\nWe can definitely have a follow up change that explores expanding this optimization to usecases like the one you mentioned",
      "parentUuid": "d9f3616d_fb9e9132",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c22424fa_d4ce41a4",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-26T01:48:01Z",
      "side": 1,
      "message": "What I\u0027m trying to understand is what the GL rules are; should glGenerateMipmap orphan the image or not, is that based on whether new mips need to be created or not?\n\nBecause the way I see it, this cannot be an _optimization_, if we were orphaning an image that we shouldn\u0027t have, this is a(n incomplete) fix. If we _should_ be orphaning the image, then this is introducing a bug.",
      "parentUuid": "e5231dd3_d29ff35f",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6fc282a_02bd1bb7",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-26T02:35:59Z",
      "side": 1,
      "message": "\u003e is that based on whether new mips need to be created or not?\n\n`GL_EXT_EGL_image_storage` spec says - `calling GenerateMipmap on a texture created with EGLImageTarget*StorageEXT never causes orphaning`\n\nin that sense it is more appropriate to call this an incomplete fix but i dont know what the expected behavior for this usecase is -\n1. EGLImage source is a GL texture with size 40X32 with 1 mip level (baseLevel \u003d\u003d 0)\n2. EGLImage is created with `EGL_GL_TEXTURE_LEVEL_KHR \u003d\u003d 0`\n3. EGLImage target is created with `glEGLImageTargetTexStorageEXT`\n4. App calls `glGenerateMipmap` on EGLImage target\n\nthe spec says we shouldn\u0027t orphan but it is impossible to do that, right?",
      "parentUuid": "c22424fa_d4ce41a4",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3bcfd27b_d5d2327f",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-26T03:20:34Z",
      "side": 1,
      "message": "Shouldn\u0027t that do the same thing that glGenerateMipmap does for a texture created with glTexStorage2D with 1 mip (or a few mips that don\u0027t go all the way down to 1x1)?\n\nI suspect in that case `glGenerateMipmap` would just fill in as many mips as it can?",
      "parentUuid": "a6fc282a_02bd1bb7",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e6e930b_cb394cbe",
        "filename": "src/libANGLE/Texture.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2097,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-26T12:59:55Z",
      "side": 1,
      "message": "well, then we need update `isMipComplete` so that we dont orphan. let me split this part into a separate change and work on it later",
      "parentUuid": "3bcfd27b_d5d2327f",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e629046e_d50e3d1e",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2430,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-25T22:38:18Z",
      "side": 1,
      "message": "Are all these copies just so that there is a format change? Why not use UtilsVk\u0027s blit shader and use a view that overrides the format?",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a83b259b_957f84d1",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2430,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-26T01:03:44Z",
      "side": 1,
      "message": "\u003e Are all these copies just so that there is a format change? Why not use UtilsVk\u0027s blit shader and use a view that overrides the format?\n\nwhen generating mipmaps with filtering enabled the math for an image that is in sRGB colorspace vs. linear colorspace is different, e.g, 128 in linear is actually a 188 in sRGB. As long as the image\u0027s format is sRGB Vulkan automatically handles the math\n\n\u003e Why not use UtilsVk\u0027s blit shader and use a view that overrides the format?\n\ni am aware of the blitresolve code but dont see a method for a simple blit in `UtilsVk`?",
      "parentUuid": "e629046e_d50e3d1e",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "938960bd_2021cc7f",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2430,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-10-26T01:45:28Z",
      "side": 1,
      "message": "\u003e As long as the image\u0027s format is sRGB Vulkan automatically handles the math\n\nYes, and choosing the right view for the sampler and color attachment in a draw call would also let the device handle sRGB\u003c-\u003eLinear conversions, right?\n\n\u003e i am aware of the blitresolve code but dont see a method for a simple blit in UtilsVk?\n\nIt won\u0027t be the blitResolve() function, but you can use the BlitResolve.frag shader for this; bind mip 0 as sampler, use either the point or linear sampler, bind mip 1 as color attachment, draw, repeat for next mip.",
      "parentUuid": "a83b259b_957f84d1",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b7bd0f7_637d3961",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2430,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2024-10-26T12:59:55Z",
      "side": 1,
      "message": "will give this a try",
      "parentUuid": "938960bd_2021cc7f",
      "revId": "52b116f8ebb242df3741c451c3676e677f2108a0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}