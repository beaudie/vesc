{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e61a294f_debae46e",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-06-27T16:56:00Z",
      "side": 1,
      "message": "Not questioning your result here, but this change effectively changed spinlock to mutex lock, right? Maybe you should check the usage of spinlock and change that to use mutex instead of spinlock.",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6649c69_2a35f9f5",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-27T17:27:39Z",
      "side": 1,
      "message": "\u003e Not questioning your result here, but this change effectively changed spinlock to mutex lock, right? \n\nI do not think so. Performance of `Spinlock` (when no contention) is a lot faster than `std::mutex`. This change only affects waiting when lock is failed (when there is contention). `Spinlock` is still spins, but now uses `std::this_thread::yield()` in the loop instead of `ANGLE_SMT_PAUSE()`. Number of spins on Windows on my laptop is around 7000 spins/ms. On Android 1000-2000 spins/ms. I think this resolution is good enough.\n\n\u003e Maybe you should check the usage of spinlock and change that to use mutex instead of spinlock.\n\nActually we already using `std::mutex` and trying to use `Spinlock`.\n\nCurrently we are using `SingleContextMutex` (not actual mutex) and `SharedContextMutex\u003cstd::mutex\u003e`. However, changing Context mutex from `SingleContextMutex` to `SharedContextMutex\u003cstd::mutex\u003e` is not 100% safe. Therefore, I preparing changes that will remove `SingleContextMutex`. New solution will use `TypedContextMutex\u003cangle::Spinlock\u003e` and `TypedContextMutex\u003cstd::mutex\u003e` instead.\n\nNext step is try to remove `TypedContextMutex\u003cstd::mutex\u003e` and only use `TypedContextMutex\u003cangle::Spinlock\u003e` because overhead of `Spinlock` when there is no contention is a lot less (28.312ms vs 12.196ms for 1000\u0027000 `glGetError()` calls on S906B). However, after I did this - mentioned tests started to fail (TIMEOUT).\n\nAfter investigation I concluded that `ANGLE_SMT_PAUSE()` does absolutely nothing useful. But `std::this_thread::yield()` in contrast, slows down waiting thread instead of blocking useful worker threads.\n\nI do not understand what is the point of `ANGLE_SMT_PAUSE()`?\nIn my understanding it should do same thing what `std::this_thread::yield()` does, but perhaps with less overhead.",
      "parentUuid": "e61a294f_debae46e",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccf64b71_c250b0c9",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-06-27T21:33:22Z",
      "side": 1,
      "message": "I think spinLock means keep CPU core busy and not intentionally let scheduler try to swap out the calling thread (like what mutex does). Or in other word, spinlock means to tell scheduler that I am still busy. Calling yield violates this, since it tells scheduler that I am willing to yield. That is why I am not fan of this change, But what you try to do with SingleContextMutex and SharedContextMutex transition is fine, maybe you should wrap it in a separate function that calls yield instead of using spinLock.",
      "parentUuid": "c6649c69_2a35f9f5",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96abc43d_03beb51f",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-27T21:54:01Z",
      "side": 1,
      "message": "ANGLE_SMT_PAUSE() is a hint to the CPU that this is a busy loop, so that it can continue its busy loop but save power. It has nothing to do with the OS scheduler.\n\nI was just looking at this again the other day: https://www.realworldtech.com/forum/?threadid\u003d189711\u0026curpostid\u003d189723 which doesn\u0027t particularly put spinlock-in-user-space in a good light. It\u0027s probably still fine for ANGLE\u0027s particular use case, but that\u0027s to be seen.\n\nI\u0027m not sure yield() is always a good idea though, it behaves very differently between Linux and windows for example. I\u0027m sorry I\u0027ve been slow to get to anglebug.com/8224, but would you give me a few days to take care of that, and we can see how the numbers look like when we don\u0027t actually take the lock half of the times?",
      "parentUuid": "ccf64b71_c250b0c9",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18d9e735_0d2dc8e8",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-06-28T00:02:57Z",
      "side": 1,
      "message": "Right, my point is exactly this: the spinlock is supposed to tell scheduler that \"I am busy\", but calling yield is doing the opposite. Maybe we should rename spinLock to \"FastLock\" or other names, then this CL itself will be less controversial, and we can focus on SingleContextMutex to SharedContextMutex transition, which is what actually matters.",
      "parentUuid": "96abc43d_03beb51f",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4363b57_8dcfa83c",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-28T01:49:04Z",
      "side": 1,
      "message": "Yes I agree that if we want yield(), it should be in a separate class. I still think it\u0027s worth waiting for the lockless state setting entry points changes to come about and re-evaluate which option is better.",
      "parentUuid": "18d9e735_0d2dc8e8",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f089745_8c1a236d",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-29T17:39:18Z",
      "side": 1,
      "message": "\u003e I think spinLock means keep CPU core busy and not intentionally let scheduler try to swap out the calling thread (like what mutex does). Or in other word, spinlock means to tell scheduler that I am still busy.\n\nI see. I was thinking that spinlock is a lock that simply spins regardless if it let cheduler to swap out the spinning thread...\n\n\u003e I was just looking at this again the other day: https://www.realworldtech.com/forum/?threadid\u003d189711\u0026curpostid\u003d189723 which doesn\u0027t particularly put spinlock-in-user-space in a good light. It\u0027s probably still fine for ANGLE\u0027s particular use case, but that\u0027s to be seen.\n\nRead the post by Linus Torvalds.\nFrom what I understand, current `Spinlock` is the wort possible lock from the latency stand point, and caused a problem mentioned: \"busy-looping while somebody else has been scheduled out\".\nHe also says that using `sched_yield()` will not fix everything and may cause \"scheduling storms\". But at least it is batter, than busy spinning.\n\n\u003e I\u0027m not sure yield() is always a good idea though, it behaves very differently between Linux and windows for example.\n\nI only checked `yield()` on windows in end2end tests and on Android in my test app. At least `yield()` did not cause severe performance problems. I did not tried in Linux though. I will also check Linux.\n\n\u003e I\u0027m sorry I\u0027ve been slow to get to anglebug.com/8224, but would you give me a few days to take care of that, and we can see how the numbers look like when we don\u0027t actually take the lock half of the times?\n\nIt is OK, take your time.\n\n\u003eMaybe we should rename spinLock to \"FastLock\" or other names, then this CL itself will be less controversial, and we can focus on SingleContextMutex to SharedContextMutex transition, which is what actually matters.\n\nI already has similar CL with `FastMutex`:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/4401941\nI used `Spinlock` here because we was discussing to using it. I also suggested `FastMutex`  instead, but it was ignored.\nI guess I will base removal of SingleContextMutex on `FastMutex1` then...\n\n\u003e Yes I agree that if we want yield(), it should be in a separate class. I still think it\u0027s worth waiting for the lockless state setting entry points changes to come about and re-evaluate which option is better.\n\nRemoval of SingleContextMutex it is more about safety then performance regression. So I think we should apply this change eventually. But for that we need the most efficient replacement for SingleContextMutex.\n\nOnly possible performance benefit is that there is not need to switch to `std::mutex` when Contexts use EGLImage. However, if we decide to switch to `std::mutex` then we may use `Spinlock` instead of `SingleContextMutex`, since there will be no real concurrencly (except when switching the mutex type).\n\nAnyway, I will update CLs to use `FastMutex1` and leave `Spinlock` alone.\nAfter performance testing with lockless state setting entry points we will have more information to decide what to do with mutexes.",
      "parentUuid": "d4363b57_8dcfa83c",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60c2fa13_afa809b1",
        "filename": "src/common/Spinlock.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-07-03T18:52:18Z",
      "side": 1,
      "message": "\u003e I did not tried in Linux though. I will also check Linux.\n\nChecked on VM with 16 CPUs (real CPU is 8/16). Test is end2end SwiftShader.\n\nRunning on 16 processes many tests timeout no matter what mutex is used (even `std::mutex`.\n\nIf run 8 processes:\n- `Spinlock` with `ANGLE_SMT_PAUSE` - one time out of 4 attempts I got timeout\n- `Spinlock` with `yield()` - no timeout but maybe just a lucky run.\n\nAt the end. I did not see much difference between `ANGLE_SMT_PAUSE` and `std::this_thread::yield()`. I guess the problem is that I tested on the VM.",
      "parentUuid": "4f089745_8c1a236d",
      "range": {
        "startLine": 47,
        "startChar": 30,
        "endLine": 47,
        "endChar": 35
      },
      "revId": "821d77e0b218589e2479b21b8eeb3a161fdf7995",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}