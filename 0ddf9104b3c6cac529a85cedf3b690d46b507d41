{
  "comments": [
    {
      "key": {
        "uuid": "c6a62a4d_1662e2d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-08-07T15:24:43Z",
      "side": 1,
      "message": "Looks like I forgot to hit Reply. Had written this a few days back.",
      "revId": "0ddf9104b3c6cac529a85cedf3b690d46b507d41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "92c65cd5_ad2d7911",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1256245
      },
      "writtenOn": "2020-08-07T15:28:24Z",
      "side": 1,
      "message": "Alright, this is better. Give it a look and let me know how I can make it better.\n\nOpenGL layer input from Courtney is good. This is not intended to be an endpoint, but a starting point. This will be a start to get OGL calls into AGI, and plan to grow it from there. OGL layer is one good idea. Can also add more mappings and data into the debug string that AGI can then parse and display to use to help with debug and perf analysis.",
      "revId": "0ddf9104b3c6cac529a85cedf3b690d46b507d41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecceded7_52751dc2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1256237
      },
      "writtenOn": "2020-08-07T15:57:24Z",
      "side": 1,
      "message": "Is there any chance of using ANGLE\u0027s pushDebugGroup/popDebugGroup to capture this information instead?  RendeDoc already supports displaying VK calls nested under a debug group.  You could set the message to the API entry point and parameters.",
      "revId": "0ddf9104b3c6cac529a85cedf3b690d46b507d41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cafad32d_481ce631",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1256245
      },
      "writtenOn": "2020-08-07T18:42:34Z",
      "side": 1,
      "message": "Response to Shabi on vnsprintf() error",
      "revId": "0ddf9104b3c6cac529a85cedf3b690d46b507d41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7e73fb83_d3988897",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1256245
      },
      "writtenOn": "2020-08-07T21:58:11Z",
      "side": 1,
      "message": "More info for Shabi.\n\n@Cody, ContextVk-\u003einsertEventMarker() resolves to the same vkCmdInsertDebugUtilsLabelEXT() that I\u0027m using. However that and the push/popGroupMarker() calls all put the debug label into the outsideRenderPassCommand buffer.\nI currently put the commands immediately into the renderPassCommand buffer prior to the Draw cmd.\nSo, it\u0027s no problem to pass the OGL command strings via push/popGroupMarker() calls. I could just surround the Draw call as a starting point.\nRenderDoc will already give special treatment to the existing vkCmdInsertDebugUtilsLabelEXT() usage and should display the OGL API calls inline in the api stream in the same manner as the \"setBaseLevel\" debug code from contextVk-\u003einsertEventMarker() in your Debug Markers in VK doc.",
      "revId": "0ddf9104b3c6cac529a85cedf3b690d46b507d41",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}