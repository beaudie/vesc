{
  "comments": [
    {
      "key": {
        "uuid": "41621ea7_3a135226",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T17:53:51Z",
      "side": 1,
      "message": "PTAL",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0557f5ce_f6614017",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-09-24T18:32:10Z",
      "side": 1,
      "message": "I am a bit concerned that these counters are in draw time (as oppsed to per renderpass of other counters) and eating some CPU cycles unnecessarily. Should we guard all the counters in a specific config bit that will disabled in end user build?",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0da57926_357c2924",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T18:44:45Z",
      "side": 1,
      "message": "Definitely a valid concern.   Would it be better to make little helper functions that increment the counts with the contents #ifdef\u0027ed?",
      "parentUuid": "0557f5ce_f6614017",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ad7d7b5_d0551174",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T18:44:45Z",
      "side": 1,
      "message": "Definitely a valid concern.   Would it be better to make little helper functions that increment the counts with the contents #ifdef\u0027ed?",
      "parentUuid": "0557f5ce_f6614017",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4718c07c_11dcd2c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-24T19:02:03Z",
      "side": 1,
      "message": "I\u0027m not super concerned about the overhead as it only occurs on set allocations. e.g. in all of Manhattan it would be like 12 times, right? More concerned about adding hashmaps into a simple array.",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d636d252_51230545",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-09-24T20:07:07Z",
      "side": 1,
      "message": "Tim probably can easily print out the number ContextVk::onDestroy to see. If only a dozen, not real concern. I was under impression it is much bigger.",
      "parentUuid": "4718c07c_11dcd2c2",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbbb0152_da9b7cd9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T23:39:19Z",
      "side": 1,
      "message": "Charlie - I pasted the descriptor set allocation counts to the chat: https://paste.googleplex.com/4876405205630976\n\nGenerally, there are very few allocations.   However, we suspect atomic counter buffers are allocating tons of descriptors (and may be partially to blame for why MH3.1 is lagging so far behind?).",
      "parentUuid": "d636d252_51230545",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "674482ea_35da3e33",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-09-25T16:25:18Z",
      "side": 1,
      "message": "Sounds good to me. The finding on MH31 is also good.",
      "parentUuid": "fbbb0152_da9b7cd9",
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7170f50_4a2c25c1",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 307,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-24T19:02:03Z",
      "side": 1,
      "message": "regarding cumulative, I was thinking we\u0027d have two sets of counters - per-frame and per-context. and we\u0027d accumulate the per-frame into the per-context counters on flushes.",
      "range": {
        "startLine": 307,
        "startChar": 5,
        "endLine": 307,
        "endChar": 33
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d1755d8b_60e1987f",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 307,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-09-24T20:07:07Z",
      "side": 1,
      "message": "The counter clear at flushImpl time always bothers me a bit. I have to be careful that I did not trigger a flush before reading out the counter. Is it possible that  we always maintain the umulative counter. Then in the overlay code, it calculate the delta between two frames for the per frame data? The way it is right now, for example, you would also have issue that manhattan may not display accurate RP counts when we did honor the glFlush call.",
      "parentUuid": "b7170f50_4a2c25c1",
      "range": {
        "startLine": 307,
        "startChar": 5,
        "endLine": 307,
        "endChar": 33
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4be0b2f6_3d3dd975",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 307,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-24T20:32:08Z",
      "side": 1,
      "message": "Yeah I\u0027m fine with something that only stores cumulative and the overlay computes the delta or something like that. I was thinking two sets, and adding the \"current frame\" ones to the \"cumulative\" one was basically a way to implement that.",
      "parentUuid": "d1755d8b_60e1987f",
      "range": {
        "startLine": 307,
        "startChar": 5,
        "endLine": 307,
        "endChar": 33
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfe676e1_7bf7595a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 307,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T23:39:19Z",
      "side": 1,
      "message": "Something like that could work, though I\u0027m not sure how the per-frame counters would be exposed for these particular counters.   There are a lot of programs, and no good way to fill the screen with an unknown number of graphs (~50 for benchmarks, but essentially unbounded), let alone any way to label them in a meaningful way to the user.\n\nOne answer to get a fixed number of graphs would be to add the totals from all of the programs each frame and display that.   We would want to do something similar for UtilsVk, since that has 20 Functions that can allocate.   Maybe even do the same for ContextVk, and end up with just 3 graphs in the overlay.",
      "parentUuid": "4be0b2f6_3d3dd975",
      "range": {
        "startLine": 307,
        "startChar": 5,
        "endLine": 307,
        "endChar": 33
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9684574_ade40176",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 799,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-24T19:02:03Z",
      "side": 1,
      "message": "would prefer if we keep hashmaps out of the perf counters. it\u0027s really meant to be something we can expose as a GL extension and not something that needs a pointer to query.",
      "range": {
        "startLine": 798,
        "startChar": 4,
        "endLine": 799,
        "endChar": 39
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dec30354_27ab3a11",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 799,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T23:39:19Z",
      "side": 1,
      "message": "The counts themselves only make sense per program, for example when trying to determine the sizes of descriptor pools (which are owned by ProgramExecutableVk).\n\nThere are a couple issues that hash maps solve for us nicely:\n1.) We don\u0027t know how many programs there will be.\n2.) We don\u0027t have a way to uniquely ID instances of ProgramExecutableVk.\n\nWe can create a fixed-size array, but that has other downsides:\n- If it\u0027s too small, we lose counts for those extra programs\n- If it\u0027s too large, we waste memory\n\nWe would also need to add some kind of ID to ProgramExecutableVk that increments per instantiation.   For that approach we have a couple options:\n1.) Add a HandleAllocator to ContextVk, which passes the handle to the ProgramVk when it\u0027s created and then is set in the ProgramExecutableVk.\n- This is more robust\n- More complex to implement\n2.) A static variable in ProgramExecutableVk which is incremented during each ProgramExecutableVk construction.\n- Much simpler to implement\n- Allows for multiple ProgramExecutableVks to share the same index since there\u0027s no synchronizations when they are created\n- The values leak across ContextVks, eating up extra entries in the array and reducing the overall number of programs that can be counted\n\nBeing able to easily expose the via GL extensions sounds like a good goal.   Thoughts on a good answer here?   Or should we have some counters that are entirely internal to ANGLE?",
      "parentUuid": "b9684574_ade40176",
      "range": {
        "startLine": 798,
        "startChar": 4,
        "endLine": 799,
        "endChar": 39
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2505d4e8_34e9288f",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 799,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-25T16:16:19Z",
      "side": 1,
      "message": "Why not have per object perf counters? The extension could query global or per-object perf counters.",
      "parentUuid": "dec30354_27ab3a11",
      "range": {
        "startLine": 798,
        "startChar": 4,
        "endLine": 799,
        "endChar": 39
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2c32de6_5b784a9a",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 799,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-25T16:53:27Z",
      "side": 1,
      "message": "What are we considering \"per-object\"?   Would these have to correlate to GLES objects, or can they be anything we want?   In particular, the UtilsVk is ANGLE-specific (no corresponding GLES object) but the instance is owned by the ContextVk so we could add it to the list of ContextVk\u0027s counters.\n\nAssuming we have per-object counters, how do we return those to the caller?   For example, the ContextVk doesn\u0027t have a way to iterate through the various Programs (which owns ProgramExecutableVks with the counts), so it can\u0027t respond to any queries for the data.   The front end has a list of programs, so it could query its backend for data, but I\u0027m not sure what the data collection process from the backend objects would look like (would the ContextVk be the central way to the backed, or do we query all objects that have a backend?).\n\nThat\u0027s all beyond the scope of this CL though.\n\nRegarding this CL, the descriptor set allocation counts can be moved into ProgramExecutableVk and output during its dtor easily enough.   Since the ContextVk doesn\u0027t have any way to collect the data per program, we won\u0027t have any per-frame counts, so we\u0027d just stick with outputting them during the ProgramExecutableVk dtor.   That would likely happen at app termination, but I\u0027m not sure of the details of how glDeleteProgram() is handled and if the various objects are destroyed then too (so we could get output in the middle of a run).\n\nIs moving them to ProgramExecutableVk the approach we want here?",
      "parentUuid": "2505d4e8_34e9288f",
      "range": {
        "startLine": 798,
        "startChar": 4,
        "endLine": 799,
        "endChar": 39
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea5709b7_573caffc",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 800,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-24T19:02:03Z",
      "side": 1,
      "message": "same here.",
      "range": {
        "startLine": 800,
        "startChar": 4,
        "endLine": 800,
        "endChar": 27
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11d9197d_218fb412",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 800,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-24T23:39:19Z",
      "side": 1,
      "message": "The context and utils lists can be converted to arrays easily enough, since the enums we index into them with are well defined.\n\nThe only issue is space, since for UtilsVk the Function::EnumCount \u003d 20, which means a lot of counters that are rarely used (and why a hash map is nice here too).",
      "parentUuid": "ea5709b7_573caffc",
      "range": {
        "startLine": 800,
        "startChar": 4,
        "endLine": 800,
        "endChar": 27
      },
      "revId": "7f052a40e04cbf64e7cf0757161652ea63057436",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}