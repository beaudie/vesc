{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8ed1a4be_88cb8a4e",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-08-17T00:58:59Z",
      "side": 1,
      "message": "absolute path?",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 28
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eee9541d_5ce3a36f",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8ed1a4be_88cb8a4e",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 28
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2baa414_a194d651",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-08-17T00:58:59Z",
      "side": 1,
      "message": "I have a question here. If we are here, we never merged the current `clearValue` into `mDeferredClears`. But then after running `flushDeferredClears()` we return from this function and don\u0027t do anything with `clearValue`. This is probably just me being confused by the deferred clear optimization, but shouldn\u0027t we always be doing something with `clearValue` on a glClear() call?",
      "range": {
        "startLine": 182,
        "startChar": 22,
        "endLine": 182,
        "endChar": 41
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4028e64f_114a0d0b",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Ah, yes, you\u0027re right, we should do something with `clearValue`. I\u0027m going to now merge it with the deferred clears if there\u0027s any deferred clears at all, and either flush them or stage them as necessary.",
      "parentUuid": "d2baa414_a194d651",
      "range": {
        "startLine": 182,
        "startChar": 22,
        "endLine": 182,
        "endChar": 41
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18ff6302_7c9519e6",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 201,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-08-17T00:58:59Z",
      "side": 1,
      "message": "This confuses me a little, aren\u0027t we looping through each of the color render targets (`mDeferredClears.getColorMask()` and `mRenderTargetCache.getColorDraw()`)? Why do they get a depth stencil clear value?",
      "range": {
        "startLine": 201,
        "startChar": 46,
        "endLine": 201,
        "endChar": 55
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33268ace_06ecea3a",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 201,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Yes, you are right. They should not get a depth/stencil value that is my mistake ðŸ˜Š\n\nI added a conditional outside this loop to check if the deferred clears have a depth or stencil value deferred, and am staging that appropriately now.",
      "parentUuid": "18ff6302_7c9519e6",
      "range": {
        "startLine": 201,
        "startChar": 46,
        "endLine": 201,
        "endChar": 55
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "414081eb_9188e1f5",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 209,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-08-17T00:58:59Z",
      "side": 1,
      "message": "Off topic but isn\u0027t this if() statement unnecessary? The condition on line 159 (`!isActiveRenderPass`) means `mDeferredClears` will always have something stored to it (I think?). That means the statement on line 178 (`mDeferredClears.any()`) is always going to pass, and therefore we will always hit the return on line 206. So if we make it here to line 209, `isActiveRenderPass` has to be true or we would\u0027ve hit the line 206 return.\n\n\nRight now we have\n```\nif (!isActiveRenderPass) {\n  // block A, which makes mDeferredClears.any() \u003d\u003d true\n}\n\nif (mDeferredClears.any())\n  if (isActiveRenderPass) {\n    // block B\n  } else {\n    // block C\n  }\n  return;\n}\n\nif (isActiveRenderPass) {\n  // block D\n}\n```\n\nMaybe we can do\n```\nif (!isActiveRenderPass) {\n  // block A\n  // block C\n  return;\n}\n\nif (isActiveRenderPass \u0026\u0026 mDeferredClears.any()) {\n  // block B\n  return;\n}\n\n// now we know isActiveRenderPass \u0026\u0026 !mDeferredClears.any()\n// block D\n```\n\nDo you think that\u0027s clearer?",
      "range": {
        "startLine": 209,
        "startChar": 4,
        "endLine": 209,
        "endChar": 27
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3d68039_15d50c48",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 209,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Since I\u0027m now always merge the current clear command with deferred clears if there are any the blocks look a bit different.\n\n```\nif (mDeferredClears.any() {\n    if (isActiveRenderPass){\n    // block A \n    }\n    else {\n    // block B\n    }\n    return\n}\n\nif (isActiveRenderPass){\nend the current render pass\n}\nstart a new render pass\n```\n\nI think I can fully get rid of the second conditional to check if there\u0027s an active render pass since it also checks if there\u0027s a current render pass before trying to end it, but I think first checking if there are any deferred clears before checking if there\u0027s an active render pass makes more sense. Wdyt?",
      "parentUuid": "414081eb_9188e1f5",
      "range": {
        "startLine": 209,
        "startChar": 4,
        "endLine": 209,
        "endChar": 27
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b1a1371_ec710446",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 209,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-09-10T10:30:14Z",
      "side": 1,
      "message": "Sounds good!",
      "parentUuid": "c3d68039_15d50c48",
      "range": {
        "startLine": 209,
        "startChar": 4,
        "endLine": 209,
        "endChar": 27
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f65901d5_1fcd46bf",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 493,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-08-16T14:05:07Z",
      "side": 1,
      "message": "There\u0027s nothing special about color attachments, if there\u0027s a new depth/stencil attachment, the same thing should be done. The `startRenderPassNewColorAttachments` name hints at a logical bug, could it be made more general to say `startRenderPassNewAttachments` and covers depth/stencil too?",
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cb3e2aa_a100a4c6",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 493,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Ah, yes, that\u0027s true, I just overcomplicated this when adding the depth/stencil attachment support. I moved updating color and depth/stencil attachments into a new method `flushAttachmentUpdates` and made a more general `startRenderPassNewAttachments` as well. So now a new render pass is started if either the color attachments or depth/stencil attachment was changed.",
      "parentUuid": "f65901d5_1fcd46bf",
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f7e0ff8_74a6b37d",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 623,
      "author": {
        "id": 1297347
      },
      "writtenOn": "2024-08-17T00:58:59Z",
      "side": 1,
      "message": "maybe std::move()?",
      "range": {
        "startLine": 623,
        "startChar": 56,
        "endLine": 623,
        "endChar": 78
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "675c8880_21f9c0e2",
        "filename": "src/libANGLE/renderer/wgpu/FramebufferWgpu.cpp",
        "patchSetId": 6
      },
      "lineNbr": 623,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-09-06T14:54:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5f7e0ff8_74a6b37d",
      "range": {
        "startLine": 623,
        "startChar": 56,
        "endLine": 623,
        "endChar": 78
      },
      "revId": "c90312d0a55ca84b484c199b3436517f8283a2b0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}