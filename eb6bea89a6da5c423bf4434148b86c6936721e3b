{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f389333_dae4cef2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-13T23:52:42Z",
      "side": 1,
      "message": "@Shahbaz\nNote, the added flushStagedUpdates2 only returned immediately with nothing to do.\nTo flush the deferred clear, I think we need to be sure its part of the unMakeCurrent when the surface is made uncurrent. This way its part of that context and the surface and put in a known state. I haven\u0027t found the right spot yet.",
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7ad2309_f430ecc1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-15T16:27:51Z",
      "side": 1,
      "message": "Question for Shahbaz.",
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11fd7507_8f5fff3b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-25T17:20:06Z",
      "side": 1,
      "message": "Not going to work. Removed.",
      "parentUuid": "7f389333_dae4cef2",
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6f7e07c_119f00fa",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-14T16:40:02Z",
      "side": 1,
      "message": "We should try to refactor as much as possible so this function doesn\u0027t use anything but the renderer. Then we wouldn\u0027t need a `flushStagedUpdates2`. In the worst case, we could have an \"Impl\" function that takes a `vk::Context` and a `ContextVk` and make the ContextVk-dependent stuff be optional, like the perf warnings.\n\nAlternatively, given that only Clear updates are valid here, and given that the image is single level/layer, maybe we should just handle this in a special way, like:\n\n    if (thereIsClearStaged())\n    {\n        ASSERT(noOtherUpdateStaged());\n        memset(buffer, clearColor);\n    }\n    else\n    {\n        getCommandBufferOneOff();\n        doTheCopy();\n        submitOneOff();\n    }",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2323712_fe3b05c8",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-15T16:27:51Z",
      "side": 1,
      "message": "@Shahbaz.\nI removed any checks with early return from flushStagedUpdates2, but still no clear.\nI\u0027m hesitant to do a CPU blit to the buffer - extra work. But that may have to happen. This glClear no draw, might actually be a small corner case. \n\nI\u0027m wondering about putting the equivalent of glReadPixels(0,0,1,1) at makeUncurrent IFF, a clear is pending, provided I can detect pending clear (uncurrent should cause a implicit flush anyways). This will cause the flush, and should be more efficient, event with staging buffer for readpixels (1 pixel). What do you think? pitfalls? Worth trying before blit?\n\nI\u0027m going to add initializing Surface with a texture contents to one for the test cases, to get that scenario.",
      "parentUuid": "a6f7e07c_119f00fa",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1271dbc_ae560081",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-25T17:20:06Z",
      "side": 1,
      "message": "Mohan and I have a new path to handle deferred clear. Cache clear info. Then fill lock buffer with clear color. And second part, Is at make current, flush the deferred Clear, and then write back the lock buffer info to the surface.\n\nOtherwise, the app must always, have a draw after glClear and before LockSurface.",
      "parentUuid": "b2323712_fe3b05c8",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42fb4821_0b30b18c",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T03:59:50Z",
      "side": 1,
      "message": "\u003e Then fill lock buffer with clear color.\n\nIs that different from my suggestion above?\n\n    if (thereIsClearStaged())\n    {\n        ASSERT(noOtherUpdateStaged());\n        memset(buffer, clearColor);\n    }\n    else\n    {\n        getCommandBufferOneOff();\n        doTheCopy();\n        submitOneOff();\n    }\n\n\u003e at make current, flush the deferred Clear, and then write back the lock buffer info to the surface.\n\nIt sounds like then you should be able to *drop* the deferred clear since you are overwriting the results? Maybe I misunderstood.",
      "parentUuid": "a1271dbc_ae560081",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "820dc197_ac89a33e",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-26T15:34:28Z",
      "side": 1,
      "message": "So, If there is a glClear before the lock-unlock sequence, we need a draw and a glFinish. If we don\u0027t have these, what happens is the deferred glClear happens after the lock-unlock sequence, and thus overwrites the EGL Surface/Image.\nTo support a glClear without draw; at makeUncurrent, we cache the clear color, and if deferredClears are pending and save that in the Surface State. Lock-Unlock happens. When the Surface is made current again, if there is pending deferredClears, we flush the clear (hopefully that is doable), then do the unlock step of writing the BufferHelper to the Image.\nMohan thinks this needed, I am concerned about complexity and possible interaction elsewhere. I am staging this as the 4th commit.",
      "parentUuid": "42fb4821_0b30b18c",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2805628c_4300ac66",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T15:57:23Z",
      "side": 1,
      "message": "Let\u0027s talk about this on Thursday. The situation is still not very clear to me, in particular, how does makeUncurrent come into play? Is the mutable surface somehow accessible when it\u0027s not current? If not, the deferred clear can remain staged.\n\nAnd my suggestion is, to apply the staged clear on lock(), so the application can see the clear applied to the buffer. When the buffer is copied back during unlock() everything Just Works (TM).",
      "parentUuid": "820dc197_ac89a33e",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "081395ed_7b804f99",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-26T16:31:57Z",
      "side": 1,
      "message": "\"how does unMakeCurrent come into play\"? The surface must be uncurrent to any api/context before lockSurface/unlockSurface can be called. So at unMakeUncurrent, before locksurface, we still have the context, thus the clearColor, and framebuffer, thus the deferredClear state. So cache that.\n(Correction) And then at LockSurface we fill the BufferHelper with clear color, if deferredClear, and provide buffer to app. App fills it with pixels.\nAt UnlockBuffer we wait to write buffer back to Image until MakeCurrent is called and then flush the clear to Image or discard, then write BufferHelper to Image.\nIt needs to be made Current again, after UnlockSurface, to use with swapbuffers, or any other use.\n\nTo me its a bit overly complex and I am concerned. We are delaying 2 operations.\n\nTheoretically, If the app wants to prefill a Surface, then use LockSurface, I guess glClear would be common use case?. Requiring a glFinish makes sense just for timing. Should we also require a draw with clear before LockSurface?\n\nAlso, I think win-test failure above is failing even with a draw and glFinish before eglLockSurface. So there may be platform differences here with deferredClear?\n\nTalking thursday would be good, I am also am under pressure to finish soon because I\u0027m on to another task with a pressing schedule.",
      "parentUuid": "2805628c_4300ac66",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7598cf9_76d09ec8",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T16:50:25Z",
      "side": 1,
      "message": "\u003e The surface must be uncurrent to any api/context before lockSurface/unlockSurface can be called.\n\nAh ok.\n\n\u003e And then at LockSurface we fill the BufferHelper with clear color, if deferredClear, and provide buffer to app. App fills it with pixels.\n\nOk that is in line with what I had in mind!\n\nYou don\u0027t need to cache anything in unmakeCurrent IMO. The ImageHelper has the clear staged, and that remains so after unmakeCurrent. You can just leave it untouched until lock(), then extract the clear at lock()-time.\n\n\u003e At UnlockBuffer we wait to write buffer back to Image until MakeCurrent is called and then flush the clear to Image or discard, then write BufferHelper to Image.\n\nSure, staging the buffer to be flushed to the image is an option, but I think your current solution of doing a one-off submission to do the copy is simpler. Staging the update adds more complexity for example if the application does unlock/lock without any make/unmake current.\n\n\u003e Talking thursday would be good, I am also am under pressure to finish soon because I\u0027m on to another task with a pressing schedule.\n\nOk let\u0027s sync on Thursday and see what we can do about landing this.",
      "parentUuid": "081395ed_7b804f99",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "536358bc_5ee65966",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-26T17:05:40Z",
      "side": 1,
      "message": "\"Ok that is in line with what I had in mind!\" - Yes\n\n\"You don\u0027t need to cache anything in unmakeCurrent\" after that point the context and the Framebuffer are inaccessible from the Surface, so no clearColor or hasDeferredClears\n\n\"one-off submission to do the copy is simpler\" - I need to be sure the copy is after the clear. Unfortunately right now, unlockSurface does the copy, and then the first draw after the MakeCurrent cause the clear to flush.",
      "parentUuid": "e7598cf9_76d09ec8",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4afcda76_5a3479e6",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T18:05:35Z",
      "side": 1,
      "message": "\u003e \"You don\u0027t need to cache anything in unmakeCurrent\" after that point the context and the Framebuffer are inaccessible from the Surface, so no clearColor or hasDeferredClears\n\nYou don\u0027t need the context or the framebuffer. The clear is staged in the ImageHelper, and you have access to that!",
      "parentUuid": "536358bc_5ee65966",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "694ce79d_c9531979",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T18:07:55Z",
      "side": 1,
      "message": "FYI, if at any moment you see FramebufferVk::syncState hoisting the clear out of the ImageHelper but the entry point that caused the syncState doesn\u0027t end up flushing that clear, that\u0027s a separate bug that needs fixing.\n\nIn other words (bugs aside), you should find the clear in ImageHelper::mSubresourceUpdates and **NOT** FramebufferVk::mDeferredClears.",
      "parentUuid": "4afcda76_5a3479e6",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b9f6dd2_dc2f3fa0",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-10-26T20:28:06Z",
      "side": 1,
      "message": "OK, I see SubresourceUpdates now. Thank you. effort save!",
      "parentUuid": "694ce79d_c9531979",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "946c4e75_62e5e6c4",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-26T20:37:08Z",
      "side": 1,
      "message": "üëç\n\nMaybe too late, but there\u0027s this doc that describes the high level of how clears are deferred: https://chromium.googlesource.com/angle/angle/+/main/src/libANGLE/renderer/vulkan/doc/DeferredClears.md",
      "parentUuid": "4b9f6dd2_dc2f3fa0",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c249ecfc_f18260e8",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 5
      },
      "lineNbr": 7166,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-11-10T00:48:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "946c4e75_62e5e6c4",
      "range": {
        "startLine": 7166,
        "startChar": 20,
        "endLine": 7166,
        "endChar": 39
      },
      "revId": "eb6bea89a6da5c423bf4434148b86c6936721e3b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}