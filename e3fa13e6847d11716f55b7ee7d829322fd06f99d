{
  "comments": [
    {
      "key": {
        "uuid": "77bad0e2_1834d859",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-14T19:01:12Z",
      "side": 1,
      "message": "Please add the `if ((access \u0026 GL_MAP_UNSYNCHRONIZED_BIT) \u003d\u003d 0)` call before the finish. Same with mapImpl (where access should be forwarded to). Adding a generic test for this may be difficult, as there is no guarantee any backend is not going to flush anyway. However, you can add a Vulkan-specific test where you do this:\n\n- Create buffer1, map it, and write 1 2 3 4\n- Create buffer2, map it, and write 5 6 7 8\n- Call copy buffer1 into buffer2\n- Map buffer2 with the flag set, read back and expect 5 6 7 8\n- Map buffer2 without the flag, read back and expect 1 2 3 4\n\nThis can only be non-flaky if we know exactly when the backend can flush (hence it being a Vulkan-only test).\n\n---\n\nAlso, super important, this should be a `finishToSerial` call with the serial of the buffer. It\u0027s possible a triple-buffered application knows the buffer hasn\u0027t been used in the past few frames so it can always map it without incurring a GPU bubble. This would kill that application\u0027s performance.",
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5553b6b3_84645132",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-14T22:52:57Z",
      "side": 1,
      "message": "The test you\u0027re describing is similar to BufferDataTestES3.BufferResizing/ES3_Vulkan, which is failing without the full contextVk-\u003efinishImpl().   Adding a test that does what you\u0027re describing specifically should be easy enough.\n\nHowever, if I do a contextVk-\u003efinishToSerial(mBuffer.getStoredQueueSerial()) instead, I need to add a contextVk-\u003eflushImpl(nullptr) also, which is essentially what contextVk-\u003efinishImpl() does anyway.\n\nTo help clarify that a bit, there are 2 versions that work:\n\ncontextVk-\u003efinishImpl()\nOR\ncontextVk-\u003eflushImpl(nullptr)\ncontextVk-\u003efinishToSerial(mBuffer.getStoredQueueSerial())\n\nOtherwise, the commands are never sent to the GPU and BufferDataTestES3.BufferResizing/ES3_Vulkan fails:\n\nTEST_P(BufferDataTestES3, BufferResizing)\n{\n[[[...]]]\n    glBufferData(GL_COPY_WRITE_BUFFER, numBytes, zeros, GL_STATIC_DRAW);\n    glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, numBytes);\n\n    ASSERT_GL_NO_ERROR();\n\n    // Read back the data and compare it to the original\n    uint8_t *data \u003d reinterpret_cast\u003cuint8_t *\u003e(\n        glMapBufferRange(GL_COPY_WRITE_BUFFER, 0, numBytes, GL_MAP_READ_BIT));\n\n    ASSERT_GL_NO_ERROR();\n\n    for (size_t i \u003d 0; i \u003c numBytes; ++i)\n    {\n        EXPECT_EQ(srcBytes[i], data[i]);  \u003c\u003c--- data[i] is all 0s\n    }\n    glUnmapBuffer(GL_COPY_WRITE_BUFFER);\n\n\nBased on the spec, this appears to be the expected outcome:\n\n\u003e If no error occurs, a pointer to the beginning of the mapped range is returned once all pending operations on that buffer have completed\n\nThis means we need to perform a finishImpl() to wait for all GPU commands to complete and become visible to the CPU.   To handle the triple-buffering scenario you described, the caller should be expected to specify GL_MAP_UNSYNCHRONIZED_BIT for us to skip the finishImpl().   That\u0027s still a dangerous plan for them though since there may be queued GPU work still in flight that will modify that buffer, which we have no guarantee of when they will finish relative to any modifications the CPU makes to the map()\u0027ed buffer:\n\n\u003e No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.\n\nIs the flushImpl()/finishToSerial(mBuffer.getStoredQueueSerial()) still better or should I keep the full finishImpl() call to make sure all of the related work is done also?",
      "parentUuid": "77bad0e2_1834d859",
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cca4c27_b7aac14d",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-14T23:56:03Z",
      "side": 1,
      "message": "The other piece is that the test you describe makes sense intuitively, but GL_MAP_UNSYNCHRONIZED_BIT only applies when mapping a buffer to write it (GL_MAP_WRITE_BIT):\n\n\u003e GL_INVALID_OPERATION is generated for any of the following conditions:\n\u003e GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT, GL_MAP_INVALIDATE_BUFFER_BIT, or GL_MAP_UNSYNCHRONIZED_BIT is set.\n\nThis means we can\u0027t test GL_MAP_UNSYNCHRONIZED_BIT is implemented correctly by reading back data from a buffer, which makes things a bit more difficult.   I\u0027ll have to see if something pops into mind over the weekend that could work.   Since we are the GL driver, we may be able to bend the rules a bit and read the buffer anyway, even if we only specify GL_MAP_WRITE_BIT.   The spec indicates this isn\u0027t an error, just undefined behavior:\n\n\u003e GL_MAP_READ_BIT indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\nOtherwise, I\u0027ll probably need some help coming up with a sequence that matches Mohan\u0027s description in anglebug.com/3213:\n\n\u003e otherwise, flushing a pipeline prematurely might result in a deadlock. in the hypothetical case i mentioned ([draw frame n] [buffer map for frame n+1] [prep for frame n+1] *[more work on draw n]* [swap frame n]) the highlighted command may have resources needed by \"draw n\"",
      "parentUuid": "5553b6b3_84645132",
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3027f4c_155f8018",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-15T03:29:04Z",
      "side": 1,
      "message": "\u003e To help clarify that a bit, there are 2 versions that work:\n\u003e\n\u003e contextVk-\u003efinishImpl()\n\u003e OR\n\u003e contextVk-\u003eflushImpl(nullptr)\n\u003e contextVk-\u003efinishToSerial(mBuffer.getStoredQueueSerial())\n\u003e\n\u003e Otherwise, the commands are never sent to the GPU and BufferDataTestES3.BufferResizing/ES3_Vulkan fails\n\nDefinitely the second method, though with a modificaiton. You should add a function similar to QueryHelper::hasPendingWork() to CommandGraphResource, and then do this:\n\nif (mBuffer.hasPendingWork(contextVk))\n{\n    contextVk-\u003eflushImpl(nullptr);\n}\ncontextVk-\u003efinishToSerial(mBuffer.getStoredQueueSerial);\n\nThe point here is to only flush if the buffer has recorded commands in this frame (and thus haven\u0027t submitted yet)\n\n\u003e The other piece is that the test you describe makes sense intuitively, but GL_MAP_UNSYNCHRONIZED_BIT only applies when mapping a buffer to write it (GL_MAP_WRITE_BIT)\n\nI see. One way to test this that I can think of is this:\n\neglSwapInterval(1)\nstartTime \u003d getTime()\nfor (500 times)\n{\n  Draw\n  glMapBufferRanges(UNSYNCHRONIZED)\n  glUnmap\n}\nendTime \u003d getTime()\nASSERT(endTime - startTime \u003c 1 second)\n\nIf `glMapBufferRanges(UNSYNCHRONIZED)` does a finish, this would run for 500 vsyncs which could be detected by the execution length of the test. The test is definitely going to fail on some platforms though, like mac+gl.",
      "parentUuid": "7cca4c27_b7aac14d",
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2853e4d2_cad6f340",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 5
      },
      "lineNbr": 206,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-17T18:33:33Z",
      "side": 1,
      "message": "Building on your changes is helpful for seeing what\u0027s necessary.   This CL isn\u0027t much code, but I\u0027m definitely learning a lot.   Thanks for your help in building up the surrounding pieces.\n\n\nI think my current implementation that\u0027s slightly abusing the undefined behavior is more straightforward than timing submissions, so I\u0027d prefer to keep that version if there aren\u0027t any objections.",
      "parentUuid": "d3027f4c_155f8018",
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d4ac3f1_9d4d73fa",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 5
      },
      "lineNbr": 256,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-14T19:01:12Z",
      "side": 1,
      "message": "I would complain about having same-buffer copies be handled especially in the respective function, though the command graph rework would make that moot. I could live with this.",
      "range": {
        "startLine": 256,
        "startChar": 31,
        "endLine": 256,
        "endChar": 67
      },
      "revId": "e3fa13e6847d11716f55b7ee7d829322fd06f99d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}