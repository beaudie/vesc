{
  "comments": [
    {
      "key": {
        "uuid": "191d0d95_19e1884e",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-03-07T03:17:58Z",
      "side": 1,
      "message": "Is this the best way? The ProgramExecutable belongs to a Program or a ProgramPipeline, changing the bindings in glState doesn\u0027t affect that (but this code suggests it does). I\u0027m guessing changing glState makes things work in such a way that only the ProgramExecutable of the Program or ProgramPipeline that\u0027s bound will be accessed, but this feels very fragile.\n\nIs this a temporary measure and will be fixed in a future CL? I\u0027d be ok with that. It seems to me that something is backwards here though, like the information queried here should reside in ProgramExecutable, with Program accessing it through mExecutable when necessary, instead of the other way around.",
      "range": {
        "startLine": 71,
        "startChar": 13,
        "endLine": 72,
        "endChar": 16
      },
      "revId": "23aebb1fb110fa66df07dfc84db6651ad5e249f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "775924d9_b25cd8c3",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-03-09T18:22:32Z",
      "side": 1,
      "message": "I agree that this looks a bit goofy.\n\nThe problem is that the ProgramExecutable doesn\u0027t know what it\u0027s inside of (Program or ProgramPipeline) so it has to do some extra checking to handle both.   In this case the ContextVk doesn\u0027t know/care whether it\u0027s dealing with a Program or PPO, it just needs to know from the GL frontend if there are default uniforms:\n\nvoid ContextVk::invalidateCurrentDefaultUniforms()\n{\n...\n    if (executable-\u003ehasDefaultUniforms(mState))\n    {\n...\n    }\n}\n\nThis ends up taking the following path:\n\nContextVk -\u003e gl::ProgramExecutable -\u003e gl::State -\u003e Program/ProgramPipeline -\u003e ProgramState(s):\nhttps://chromium-review.googlesource.com/c/angle/angle/+/2072652/37/src/libANGLE/ProgramExecutable.cpp\n\nThis is complicated by a couple things:\n- The relevant information resides in the ProgramState.\n- gl::Program and gl::ProgramPipeline require different approaches to answer the same query.\n  - PPOs have to check each of the Programs in the PPO.\n\nOne approach would be to have a shadow boolean that\u0027s updated whenever necessary to indicate the current state.   For example:\n\nbool hasDefaultUniforms() const { return !getDefaultUniformRange().empty(); }\n\nWhenever mDefaultUniformRange is no longer empty, we could update a new ProgramExecutable::mHasDefaultUniforms boolean to the correct value.   This gets a little tricker for PPOs, since the Program will need to update each of the PPOs its in, but not too big of a deal.   I\u0027m not a big fan of this approach though, since it\u0027s possible for these to get out of sync whenever mDefaultUniformRange is used in new places (or modified/removed from existing ones).   \n\nAnother approach is for the ProgramExecutable to have a pointer back to the corresponding ProgramState or ProgramPipelineState that it\u0027s associated with.   This would allow it to respond to these types of queries without necessarily caring which it\u0027s in, it just calls the method on the first non-null pointer it finds.   For example:\n\nclass ProgramExecutable\n{\n...\n  private:\n    ProgramState         *mProgramState;\n    ProgramPipelineState *mProgramPipelineState;\n}\n\nbool ProgramExecutable::hasDefaultUniforms(const gl::State \u0026glState) const\n{\n    ASSERT(mProgramState || mProgramPipelineState);\n    if (mProgramState)\n    {\n        return mProgramState-\u003ehasDefaultUniforms();\n    }\n\n    [[[ ProgramPipelineState would contain the PPO-specific looping ]]]\n    return mProgramPipelineState-\u003ehasDefaultUniforms();\n}\n\nThis is my preference, but I\u0027m not sure how ugly it is to have the ProgramState instantiate the ProgramExecutable which then points back to the ProgramState (and same for PPOs).",
      "parentUuid": "191d0d95_19e1884e",
      "range": {
        "startLine": 71,
        "startChar": 13,
        "endLine": 72,
        "endChar": 16
      },
      "revId": "23aebb1fb110fa66df07dfc84db6651ad5e249f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b8e68b2_68da252f",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-03-09T18:39:25Z",
      "side": 1,
      "message": "Ok I see. I haven\u0027t given it much thought, but I personally prefer the ProgramExecutable having a pointer to Program/ProgramPipeline than letting it try to infer it from the context. Either that, or use virtual functions and have them inherit ProgramExecutable.",
      "parentUuid": "775924d9_b25cd8c3",
      "range": {
        "startLine": 71,
        "startChar": 13,
        "endLine": 72,
        "endChar": 16
      },
      "revId": "23aebb1fb110fa66df07dfc84db6651ad5e249f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9f71ea9_df7ea399",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-03-09T19:06:03Z",
      "side": 1,
      "message": "So far they just need to be able to see the ProgramState or ProgramPipelineState, but that can move up a level to Program/ProgramPipeline if necessary (since those give access to the corresponding States).\n\nTake a look at the latest patchset to see what you think while I apply this to the PPO implementation.   I think it will make things a lot cleaner this way.   The only iffy part is having both pointers in ProgramExecutable, when only one will ever be non-null:\n\n    ProgramState *mProgramState;\n    ProgramPipelineState *mProgramPipelineState;\n\nI think we\u0027re stuck with that without some kind of subclassing or RTTI that Cody mentioned to me (unless you can come up with something of course).",
      "parentUuid": "1b8e68b2_68da252f",
      "range": {
        "startLine": 71,
        "startChar": 13,
        "endLine": 72,
        "endChar": 16
      },
      "revId": "23aebb1fb110fa66df07dfc84db6651ad5e249f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a08e544_a9f94140",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 7
      },
      "lineNbr": 72,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-03-27T16:42:28Z",
      "side": 1,
      "message": "I\u0027ve opened anglebug.com/4520 to come back and take a look at this.",
      "parentUuid": "e9f71ea9_df7ea399",
      "range": {
        "startLine": 71,
        "startChar": 13,
        "endLine": 72,
        "endChar": 16
      },
      "revId": "23aebb1fb110fa66df07dfc84db6651ad5e249f5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}