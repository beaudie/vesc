{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "58dccb44_2f9b9ce5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-02-08T21:34:51Z",
      "side": 1,
      "message": "LGTM once bots are sorted out.",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c339ed0c_d94cd11e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-08T21:43:25Z",
      "side": 1,
      "message": "this is interesting, even though we have this template specialization -\n\n template \u003csize_t N, typename Enable \u003d void\u003e\n struct GetBitSet\n {\n     using Type \u003d BitSetArray\u003cN\u003e;\n };\n\n // Prefer 64-bit bitsets on 64-bit CPUs. They seem faster than 32-bit.\n #if defined(ANGLE_IS_64_BIT_CPU)\n template \u003csize_t N\u003e\n struct GetBitSet\u003cN, EnableIfBitsFit\u003cN, uint64_t\u003e\u003e\n {\n     using Type \u003d BitSet64\u003cN\u003e;\n };\n\nit looks like this member -\u003e \"using DirtyBits \u003d angle::BitSet\u003cDIRTY_BIT_MAX\u003e;\" of State.h\nis resolving as BitSetArray\u003c\u003e type instead, per error -\n ../../src\\libANGLE/State.h(702): note: while trying to match the argument list \u0027(const gl::State::DirtyBits)\u0027\n ../../src\\libANGLE/State.h(702): error C2088: \u0027~\u0027: illegal for class\n ../../src\\libANGLE/State.h(705): error C2660: \u0027angle::BitSetArray\u003c64\u003e::set\u0027: function does not take 0 arguments\n\nim missing some template incantation. jamie help?",
      "parentUuid": "58dccb44_2f9b9ce5",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba371fde_a1ac2af2",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-02-08T21:48:16Z",
      "side": 1,
      "message": "Evidently this class is missing implementation for all the functions in BitSetT.\n\nYou can emulate building for 32-bit simply by making ANGLE temporarily use BitSetArray everywhere and work through build failures on a 64-bit build.",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f22aedd_71f366e0",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-08T21:51:07Z",
      "side": 1,
      "message": "given my bandwidth i was going for make the CPU overhead due to 96bits go away and nothing more but scope has increased. still doesn\u0027t explain why any type wanting \u003c\u003d 64bits (like the state dirty bit type) would resolve to BitSetArray instead of BitSet64",
      "parentUuid": "ba371fde_a1ac2af2",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0e62ffe_e90bd428",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-02-08T21:55:36Z",
      "side": 1,
      "message": "On 32-bit systems, they were using IterableBitSet.",
      "parentUuid": "3f22aedd_71f366e0",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30138800_75873388",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-08T21:58:29Z",
      "side": 1,
      "message": "but this bot \"android_angle_vk64_rel_ng\" failed too with log here -\u003e https://ci.chromium.org/ui/p/chromium/builders/try/android_angle_vk64_rel_ng/19369/overview -\n\n Step compile (with patch) failed. Error logs are shown below:\n [2616/3253] CXX android_clang_arm/obj/third_party/angle/src/libANGLE/renderer/gl/angle_gl_backend/SamplerGL.o\n FAILED: \n android_clang_arm/obj/third_party/angle/src/libANGLE/renderer/gl/angle_gl_backend/SamplerGL.o\n/b/s/w/ir/cache/goma/client/gomacc ../../third_party/llvm-build/Release+Asserts/bin/clang++ -MMD -MF...(too long)\nIn file included from ../../third_party/angle/src/libANGLE/renderer/gl/SamplerGL.cpp:12:\nIn file included from ../../third_party/angle/src/libANGLE/renderer/gl/StateManagerGL.h:14:\n../../third_party/angle/src/libANGLE/State.h:702:66: error: invalid argument type \u0027const gl::State::DirtyBits\u0027 (aka \u0027const BitSetArray\u003c64U\u003e\u0027) to unary expression\n\nfeel dumb but im missing something",
      "parentUuid": "c0e62ffe_e90bd428",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87aa015a_a0478230",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-02-08T22:39:46Z",
      "side": 1,
      "message": "There\u0027s no mystery here Mohan - on Android we cross-compile 32 and 64 bit versions to make a single APK that supports both arch. It\u0027s a 32-bit issue that you can easily reproduce locally using target_cpu \u003d \"x86\" in your gn args.",
      "parentUuid": "30138800_75873388",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3fcbe20_24d64973",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 10
      },
      "lineNbr": 554,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-08T23:05:48Z",
      "side": 1,
      "message": "is splitting the CL acceptable? land just the 96bit data types first and then tackle all other data types?",
      "parentUuid": "87aa015a_a0478230",
      "revId": "1efce28d7e9f26d38e303cc7b48b9bd4c3c090b1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}