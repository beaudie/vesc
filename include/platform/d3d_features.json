{
    "description": [
        "Copyright 2022 The ANGLE Project Authors. All rights reserved.",
        "Use of this source code is governed by a BSD-style license that can be",
        "found in the LICENSE file.",
        "",
        "d3d_features.json: Features and workarounds for D3D driver bugs and other issues."
    ],
    "features": [
        {
            "comment": [
                "On some systems, having extra rendertargets than necessary slows down the shader.",
                "We can fix this by optimizing those out of the shader. At the same time, we can",
                "work around a bug on some nVidia drivers that they ignore 'null' render targets",
                "in D3D11, by compacting the active color attachments list to omit null entries."
            ],
            "name": "mrtPerfWorkaround",
            "display_name": "mrt_perf_workaround",
            "category": "D3DWorkarounds",
            "description": [
                "Some drivers have a bug where they ignore null render targets"
            ]
        },

        {
            "name": "setDataFasterThanImageUpload",
            "display_name": "set_data_faster_than_image_upload",
            "category": "D3DWorkarounds",
            "description": [
                "Set data faster than image upload"
            ]
        },

        {
            "comment": [
                "Some renderers can't disable mipmaps on a mipmapped texture (i.e. solely sample",
                "from level zero, and ignore the other levels). D3D11 Feature Level 10+ does",
                "this by setting MaxLOD to 0.0f in the Sampler state. D3D9 sets",
                "D3DSAMP_MIPFILTER to D3DTEXF_NONE. There is no equivalent to this in D3D11",
                "Feature Level 9_3. This causes problems when (for example) an application",
                "creates a mipmapped texture2D, but sets GL_TEXTURE_MIN_FILTER to GL_NEAREST",
                "(i.e disables mipmaps). To work around this, D3D11 FL9_3 has to create two",
                "copies of the texture. The textures' level zeros are identical, but only one",
                "texture has mips."
            ],
            "name": "zeroMaxLodWorkaround",
            "display_name": "zero_max_lod",
            "category": "D3DWorkarounds",
            "description": [
                "Missing an option to disable mipmaps on a mipmapped texture"
            ]
        },

        {
            "comment": [
                "Some renderers do not support Geometry Shaders so the Geometry Shader-based",
                "PointSprite emulation will not work. To work around this, D3D11 FL9_3 has to use",
                "a different pointsprite emulation that is implemented using instanced quads."
            ],
            "name": "useInstancedPointSpriteEmulation",
            "display_name": "use_instanced_point_sprite_emulation",
            "category": "D3DWorkarounds",
            "description": [
                "Some D3D11 renderers do not support geometry shaders for pointsprite emulation"
            ]
        },

        {
            "comment": [
                "A bug fixed in NVIDIA driver version 347.88 < x <= 368.81 triggers a TDR when",
                "using CopySubresourceRegion from a staging texture to a depth/stencil in D3D11.",
                "The workaround is to use UpdateSubresource to trigger an extra copy. We disable",
                "this workaround on newer NVIDIA driver versions because of a second driver bug",
                "present with the workaround enabled."
            ],
            "name": "depthStencilBlitExtraCopy",
            "display_name": "depth_stencil_blit_extra_copy",
            "category": "D3DWorkarounds",
            "description": [
                "Bug in some drivers triggers a TDR when using CopySubresourceRegion from a staging ",
                "texture to a depth/stencil"
            ],
            "issue": "http://anglebug.com/1452"
        },

        {
            "comment": [
                "The HLSL optimizer has a bug with optimizing 'pow' in certain integer-valued",
                "expressions.  We can work around this by expanding the pow into a series of",
                "multiplies if we're running under the affected compiler."
            ],
            "name": "expandIntegerPowExpressions",
            "display_name": "expand_integer_pow_expressions",
            "category": "D3DWorkarounds",
            "description": [
                "The HLSL optimizer has a bug with optimizing 'pow' in certain integer-valued expressions"
            ]
        },

        {
            "comment": [
                "NVIDIA drivers sometimes write out-of-order results to StreamOut buffers when",
                "transform feedback is used to repeatedly write to the same buffer positions."
            ],
            "name": "flushAfterEndingTransformFeedback",
            "display_name": "flush_after_ending_transform_feedback",
            "category": "D3DWorkarounds",
            "description": [
                "Some drivers sometimes write out-of-order results to StreamOut buffers when transform ",
                "feedback is used to repeatedly write to the same buffer positions"
            ]
        },

        {
            "comment": [
                "Some drivers (NVIDIA) do not take into account the base level of the texture in",
                "the results of the HLSL GetDimensions builtin."
            ],
            "name": "getDimensionsIgnoresBaseLevel",
            "display_name": "get_dimensions_ignores_base_level",
            "category": "D3DWorkarounds",
            "description": [
                "Some drivers do not take into account the base level of the ",
                "texture in the results of the HLSL GetDimensions builtin"
            ]
        },

        {
            "comment": [
                "On some Intel drivers, HLSL's function texture.Load returns 0 when the parameter",
                "Location is negative, even if the sum of Offset and Location is in range. This",
                "may cause errors when translating GLSL's function texelFetchOffset into",
                "texture.Load, as it is valid for texelFetchOffset to use negative texture",
                "coordinates as its parameter P when the sum of P and Offset is in range. To work",
                "around this, we translate texelFetchOffset into texelFetch by adding Offset",
                "directly to Location before reading the texture."
            ],
            "name": "preAddTexelFetchOffsets",
            "display_name": "pre_add_texel_fetch_offsets",
            "category": "D3DWorkarounds",
            "description": [
                "HLSL's function texture.Load returns 0 when the parameter Location is negative, even if ",
                "the sum of Offset and Location is in range"
            ]
        },

        {
            "comment": [
                "On some AMD drivers, 1x1 and 2x2 mips of depth/stencil textures aren't sampled",
                "correctly.  We can work around this bug by doing an internal blit to a temporary",
                "single-channel texture before we sample."
            ],
            "name": "emulateTinyStencilTextures",
            "display_name": "emulate_tiny_stencil_textures",
            "category": "D3DWorkarounds",
            "description": [
                "1x1 and 2x2 mips of depth/stencil textures aren't sampled correctly"
            ]
        },

        {
            "comment": [
                "In Intel driver, the data with format DXGI_FORMAT_B5G6R5_UNORM will be parsed",
                "incorrectly.  This workaroud will disable B5G6R5 support when it's Intel driver.",
                "By default, it will use R8G8B8A8 format. This bug is fixed in version 4539 on",
                "Intel drivers.  On older AMD drivers, the data in DXGI_FORMAT_B5G6R5_UNORM",
                "becomes corrupted for unknown reasons."
            ],
            "name": "disableB5G6R5Support",
            "display_name": "disable_b5g6r5_support",
            "category": "D3DWorkarounds",
            "description": [
                "Textures with the format ",
                "DXGI_FORMAT_B5G6R5_UNORM have incorrect data"
            ]
        },

        {
            "comment": [
                "On some Intel drivers, evaluating unary minus operator on integer may get wrong",
                "answer in vertex shaders. To work around this bug, we translate -(int) into",
                "~(int)+1.  This driver bug is fixed in 20.19.15.4624."
            ],
            "name": "rewriteUnaryMinusOperator",
            "display_name": "rewrite_unary_minus_operator",
            "category": "D3DWorkarounds",
            "description": [
                "Evaluating unary minus operator on integer may get wrong answer in vertex shaders"
            ]
        },

        {
            "comment": [
                "On some Intel drivers, using isnan() on highp float will get wrong answer. To",
                "work around this bug, we use an expression to emulate function isnan().  This",
                "driver bug is fixed in 21.20.16.4542."
            ],
            "name": "emulateIsnanFloat",
            "display_name": "emulate_isnan_float",
            "category": "D3DWorkarounds",
            "description": [
                "Using isnan() on highp float will get wrong answer"
            ],
            "issue": "https://crbug.com/650547"
        },

        {
            "comment": [
                "On some Intel drivers, using clear() may not take effect. To work around this",
                "bug, we call clear() twice on these platforms."
            ],
            "name": "callClearTwice",
            "display_name": "call_clear_twice",
            "category": "D3DWorkarounds",
            "description": [
                "Using clear() may not take effect"
            ],
            "issue": "https://crbug.com/655534"
        },

        {
            "comment": [
                "On some Intel drivers, copying from staging storage to constant buffer storage",
                "does not seem to work. Work around this by keeping system memory storage as a",
                "canonical reference for buffer data.  D3D11-only workaround."
            ],
            "name": "useSystemMemoryForConstantBuffers",
            "display_name": "use_system_memory_for_constant_buffers",
            "category": "D3DWorkarounds",
            "description": [
                "Copying from staging storage to constant buffer ",
                "storage does not work"
            ],
            "issue": "https://crbug.com/593024"
        },

        {
            "comment": [
                "This workaround is for the ANGLE_multiview extension. If enabled the viewport or",
                "render target slice will be selected in the geometry shader stage. The workaround",
                "flag is added to make it possible to select the code path in end2end and",
                "performance tests."
            ],
            "name": "selectViewInGeometryShader",
            "display_name": "select_view_in_geometry_shader",
            "category": "D3DWorkarounds",
            "description": [
                "The viewport or render target slice will be selected in the geometry shader stage for ",
                "the ANGLE_multiview extension"
            ]
        },

        {
            "comment": [
                "When rendering with no render target on D3D, two bugs lead to incorrect behavior",
                "on Intel drivers < 4815. The rendering samples always pass neglecting discard",
                "statements in pixel shader.",
                "1. If rendertarget is not set, the pixel shader will be recompiled to drop",
                "'SV_TARGET'.  When using a pixel shader with no 'SV_TARGET' in a draw, the pixels",
                "are always generated even if they should be discard by 'discard' statements.",
                "2. If ID3D11BlendState.RenderTarget[].RenderTargetWriteMask is 0 and rendertarget",
                "is not set, then rendering samples also pass neglecting discard statements in",
                "pixel shader.  So we add a mock texture as render target in such case."
            ],
            "name": "addMockTextureNoRenderTarget",
            "display_name": "add_mock_texture_no_render_target",
            "category": "D3DWorkarounds",
            "description": [
                "On some drivers when rendering with no render target, two bugs lead to incorrect behavior"
            ],
            "issue": "http://anglebug.com/2152"
        },

        {
            "comment": [
                "Don't use D3D constant register zero when allocating space for uniforms in the",
                "vertex shader.  This is targeted to work around a bug in NVIDIA D3D driver",
                "version 388.59 where in very specific cases the driver would not handle constant",
                "register zero correctly."
            ],
            "name": "skipVSConstantRegisterZero",
            "display_name": "skip_vs_constant_register_zero",
            "category": "D3DWorkarounds",
            "description": [
                "In specific cases the driver doesn't handle constant register zero correctly"
            ]
        },

        {
            "comment": [
                "Forces the value returned from an atomic operations to be always be resolved.",
                "This is targeted to workaround a bug in NVIDIA D3D driver where the return value",
                "from RWByteAddressBuffer.InterlockedAdd does not get resolved when used in the",
                ".yzw components of a RWByteAddressBuffer.Store operation. Only has an effect on",
                "HLSL translation."
            ],
            "name": "forceAtomicValueResolution",
            "display_name": "force_atomic_value_resolution",
            "category": "D3DWorkarounds",
            "description": [
                "On some drivers the return value from RWByteAddressBuffer.InterlockedAdd does not resolve ",
                "when used in the .yzw components of a RWByteAddressBuffer.Store operation"
            ],
            "issue": "http://anglebug.com/3246"
        },

        {
            "comment": [
                "Match chromium's robust resource init behaviour by always prefering to upload",
                "texture data instead of clearing. Clear calls have been observed to cause texture",
                "corruption for some formats."
            ],
            "name": "allowClearForRobustResourceInit",
            "display_name": "allow_clear_for_robust_resource_init",
            "category": "D3DWorkarounds",
            "description": [
                "Some drivers corrupt texture data when clearing for robust resource initialization."
            ],
            "issue": "http://crbug.com/941620"
        },

        {
            "comment": [
                "Allow translating uniform block to StructuredBuffer. This is targeted to work",
                "around a slow fxc compile performance issue with dynamic uniform indexing."
            ],
            "name": "allowTranslateUniformBlockToStructuredBuffer",
            "display_name": "allow_translate_uniform_block_to_structured_buffer",
            "category": "D3DWorkarounds",
            "description": [
                "There is a slow fxc compile performance issue with dynamic uniform indexing if ",
                "translating a uniform block with a large array member to cbuffer."
            ],
            "issue": "http://anglebug.com/3682"
        },

        {
            "name": "allowES3OnFL10_0",
            "display_name": "allowES3OnFL10_0",
            "category": "D3DWorkarounds",
            "description": [
                "Allow ES3 on 10.0 devices"
            ]
        }
    ]
}
