#! /usr/bin/python3

# Copyright 2022 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_features.py:
#  Code generation for ANGLE features.
#  NOTE: don't run this script directly. Run scripts/run_code_generation.py.

from collections import namedtuple
import json
import os
import sys

feature_files = {
    'frontend_features.json': 'FrontendFeatures.h',
    'd3d_features.json': 'FeaturesD3D.h',
    'gl_features.json': 'FeaturesGL.h',
    'mtl_features.json': 'FeaturesMtl.h',
    'vk_features.json': 'FeaturesVk.h',
}
overrides_file = '../../src/tests/test_utils/angle_test_feature_overrides_autogen.h'

template_header = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {input_file_name}.
//
{description}

#ifndef ANGLE_PLATFORM_{NAME}_H_
#define ANGLE_PLATFORM_{NAME}_H_

#include "platform/Feature.h"

namespace angle
{{

struct {name} : FeatureSetBase
{{
    {name}();
    ~{name}();

{features}
}};

inline {name}::{name}()  = default;
inline {name}::~{name}() = default;

}}  // namespace angle

#endif  // ANGLE_PLATFORM_{NAME}_H_
"""

template_feature = u"""Feature {name} = {{
     "{display_name}", FeatureCategory::{category},
     {description},
     &members, {bug}
}};
"""

template_override_header = u"""// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {input_file_name}.
//
// Copyright 2022 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// angle_test_feature_overrides_autogen.h: Helpers to enable/disable features.

#ifndef ANGLE_SRC_TESTS_TEST_UTILS_ANGLE_TEST_FEATURE_OVERRIDES_H_
#define ANGLE_SRC_TESTS_TEST_UTILS_ANGLE_TEST_FEATURE_OVERRIDES_H_

bool HasFeatureOverride(const std::vector<std::string> &overrides, const char *feature);

{overrides}

#endif  // TESTS_TEST_UTILS_ANGLE_TEST_FEATURE_OVERRIDES_H_
"""

template_override = u"""inline PlatformParameters With{Name}(const PlatformParameters &pin)
{{
    PlatformParameters pout = pin;
    pout.eglParameters.enabledFeatureOverrides.push_back("{display_name}");
    return pout;
}}

inline PlatformParameters WithNo{Name}(const PlatformParameters &pin)
{{
    PlatformParameters pout = pin;
    pout.eglParameters.disabledFeatureOverrides.push_back("{display_name}");
    return pout;
}}

inline bool IsWith{Name}(const PlatformParameters &params)
{{
    return HasFeatureOverride(params.eglParameters.enabledFeatureOverrides, "{display_name}");
}}

inline bool IsWithNo{Name}(const PlatformParameters &params)
{{
    return HasFeatureOverride(params.eglParameters.disabledFeatureOverrides, "{display_name}");
}}
"""


def main():
    if len(sys.argv) == 2 and sys.argv[1] == 'inputs':
        print(','.join(list(feature_files.keys())))
        return
    if len(sys.argv) == 2 and sys.argv[1] == 'outputs':
        print(','.join(list(feature_files.values())) + ',' + overrides_file)
        return

    name_map = {}

    for src_file, header_file in feature_files.items():
        with open(src_file) as fin:
            src = json.loads(fin.read())

        features_json = src['features']
        features = []

        # Go over the list of features and write the header file that declares the features struct
        for feature_json in features_json:
            name = feature_json['name']
            display_name = feature_json['display_name']
            bug = feature_json['bug']
            feature = template_feature.format(
                name=name,
                display_name=display_name,
                category=feature_json['category'],
                description='\n'.join('"' + line + '"' for line in feature_json['description']),
                bug='' if bug == 'None' else '"' + bug + '"')

            features.append(feature)

            # Keep track of the feature names.  Sometimes the same feature name is present in
            # multiple backends.  That's ok for the purposes of feature overriding as long as the
            # display names match.
            if name in name_map:
                assert (display_name == name_map[name])
            else:
                name_map[name] = display_name

        description = '\n'.join(['// ' + line for line in src['description']])
        name = header_file[:-2]

        header = template_header.format(
            script_name=os.path.basename(__file__),
            input_file_name=src_file,
            description=description,
            name=name,
            NAME=name.upper(),
            features='\n'.join(features))

        with open(header_file, 'w') as fout:
            fout.write(header)
            fout.close()

    # Generate helpers for use by tests to override a feature or not.
    overrides = []
    for name, display_name in sorted(name_map.items()):
        overrides.append(
            template_override.format(Name=name[0].upper() + name[1:], display_name=display_name))

    with open(overrides_file, 'w') as fout:
        fout.write(
            template_override_header.format(
                script_name=os.path.basename(__file__),
                input_file_name='*_features.json',
                overrides='\n'.join(overrides)))
        fout.close()


if __name__ == '__main__':
    sys.exit(main())
