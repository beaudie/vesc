{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "66f97f47_ac146416",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "I highly suggest moving this to _after_ the next CL. I would very much like to have all the locking stuff finalized before we move on to using custom implementations of mutex.\n\nThe reason I\u0027m asking is that these need a _lot_ of testing to both ensure robustness and performance, including w.r.t power usage. I wouldn\u0027t want to block the next change on it. I also wouldn\u0027t want to have to repeat these tests as locking in ANGLE keeps changing.",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79ea2bbb_adc97061",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T22:07:49Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "66f97f47_ac146416",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bce82ba_4c558b9b",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "I\u0027d just drop the 1ms sleep. If it happens, it\u0027s too huge!\n\nAnd the 1us sleep and yield don\u0027t feel any different. I\u0027d probably just use yield on windows, 1us sleep everywhere else and call it a day.",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee964946_63792144",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T21:50:24Z",
      "side": 1,
      "message": "1ms sleep used on 0.02176% of all cases in the above test.\n\nIn case if ANI or other long wait would block we may waste a lot of CPU power...\nThe std::mutex wake up time also not small... (easily may be 0.5ms)",
      "parentUuid": "5bce82ba_4c558b9b",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6535c191_fb725efa",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "nit: you may get better perf using two specialized functions (doSpinWaitWithYield/Sleep) and avoiding lambdas\u0027 type erasure overhead (assuming the compiler is not inlining it all).",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f38719c_ca99fad0",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T21:50:24Z",
      "side": 1,
      "message": "I was not concerned with performance here, since we will call system function anyway.\n\nLong time ago I wrote function to process pixels of a buffer using lambda and compiler inlined everything. Performance was as if i wrote everything myself)\n\nSo I need to implement 2 almost same methods?",
      "parentUuid": "6535c191_fb725efa",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a1154f4_de1821fc",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 1169885
      },
      "writtenOn": "2023-06-28T18:55:59Z",
      "side": 1,
      "message": "Your spin-wait-with-yield approach should probably be using an architectural yield (ANGLE_SMT_PAUSE) rather than OS scheduler yield (std::this_thread::yield) -- otherwise you aren\u0027t spinning as I think you\u0027re intending to.\n\nAlso I don\u0027t know what platform you\u0027ve tuned these sleep times on, but I think you probably need more generalized numbers for it. I don\u0027t understand the choice of {20 loops @ 1us, 2 loops @ 1000us, 20 loops @ 1us}.\n\nAnd those sleep durations will work fine on non-Windows platforms, but they are too small for std::this_thread::sleep_for on Windows.\n\nOn Microsoft\u0027s STL std::this_thread::sleep_for is implemented with Sleep():\n\nhttps://github.com/microsoft/STL/blob/40640c6df9754ea031f8df7c720b89714d19df97/stl/src/cthread.cpp#L75-L82\n\nAnd on libc++, it\u0027s the same:\n\nhttps://github.com/llvm/llvm-project/blob/d7d4aa539c0d2f80c080a3b1e0fa45a78d5e9bfc/libcxx/src/support/win32/thread_win32.cpp#L243-L249\n\nThis means that std::this_thread::sleep_for has a minimum sleep duration of 1ms, but it\u0027s not a very punctual 1ms sleep either.\n\nYou *can* get pretty close to 0.5ms precision with a waitable timer with the flag CREATE_WAITABLE_TIMER_HIGH_RESOLUTION but it\u0027s still not great. I have some tests illustrating the behavior here:\n\nhttps://github.com/tycho/scratch/blob/f31479dc622d1f280e14da1911a34d334c4ef1a2/README.md\n\nThe \"precise_sleep\" results are using the waitable timer API, and you can see that it does a much better job for sub-millisecond sleep durations, but it\u0027s still not as good as clock_nanosleep on Linux for example.\n\nSo all that to say: keep in mind that when you request even a sleep of 1 microsecond on Windows, you\u0027ll get around 1300-1400 microseconds (1.3-1.4ms!) instead.",
      "parentUuid": "0f38719c_ca99fad0",
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e831dab9_b1a1ec12",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 39,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "What (in the C++ spec) is stopping this load from getting hoisted out of the loop? It\u0027s not synchronizing with anything else.",
      "range": {
        "startLine": 39,
        "startChar": 29,
        "endLine": 39,
        "endChar": 49
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2732baef_51f00e10",
        "filename": "src/common/FastMutex.cpp",
        "patchSetId": 9
      },
      "lineNbr": 39,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T21:50:24Z",
      "side": 1,
      "message": "I guess the fact that it is a function that must be executed in any case:\n```\nAtomically loads and returns the current value of the atomic variable.\nMemory is affected according to the value of order. \n```\nMemory order affect only memory ordering. Load must still be performed.",
      "parentUuid": "e831dab9_b1a1ec12",
      "range": {
        "startLine": 39,
        "startChar": 29,
        "endLine": 39,
        "endChar": 49
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a837271_f3d46a8e",
        "filename": "src/common/FastMutex.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "nit: we already have a `SpinLock` in `SpinLock.h`, you can merge with that.",
      "range": {
        "startLine": 22,
        "startChar": 6,
        "endLine": 22,
        "endChar": 16
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4209275f_62c71fae",
        "filename": "src/common/FastMutex.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T21:50:24Z",
      "side": 1,
      "message": "`SpinLock` has different wait logic, I do not understand how I can merge them...",
      "parentUuid": "9a837271_f3d46a8e",
      "range": {
        "startLine": 22,
        "startChar": 6,
        "endLine": 22,
        "endChar": 16
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1003d5ed_fdefb90b",
        "filename": "src/common/FastMutex.h",
        "patchSetId": 9
      },
      "lineNbr": 41,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "I don\u0027t think this is acceptable (no matter how unlikely it might be).",
      "range": {
        "startLine": 41,
        "startChar": 3,
        "endLine": 41,
        "endChar": 93
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f69eeb91_5f723344",
        "filename": "src/common/FastMutex.h",
        "patchSetId": 9
      },
      "lineNbr": 41,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T21:50:24Z",
      "side": 1,
      "message": "That is why wait uses 1ms timeout. During stress testing there was no missed notify calls at all.",
      "parentUuid": "1003d5ed_fdefb90b",
      "range": {
        "startLine": 41,
        "startChar": 3,
        "endLine": 41,
        "endChar": 93
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d0137c0_966e3cde",
        "filename": "src/common/FastMutex.h",
        "patchSetId": 9
      },
      "lineNbr": 141,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T21:12:47Z",
      "side": 1,
      "message": "I have to study a bit more to understand if these memory orderings are enough to satisfy what mutexes guarantee.",
      "range": {
        "startLine": 141,
        "startChar": 47,
        "endLine": 141,
        "endChar": 67
      },
      "revId": "5be760f05a9cc18c504db14e08c2ed1d12dff74c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}