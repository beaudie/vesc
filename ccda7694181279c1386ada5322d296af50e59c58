{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1e386ffc_c719d18b",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-25T18:12:31Z",
      "side": 1,
      "message": "GL_FRAMEBUFFER_BARRIER_BIT is not a write-after-access bit, it\u0027s strictly for fbo-access-after-write.\n\nOnly GL_SHADER_IMAGE_ACCESS_BARRIER_BIT and GL_SHADER_STORAGE_BARRIER_BIT are for write-after-access synchronization.",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cffd8c85_402872d4",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-25T19:28:35Z",
      "side": 1,
      "message": "Maybe the kWriteAfterAccessImageMemoryBarriers is incorrect. But we need to call imageWrite in ContextVk.cpp line 7595 if you call glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT) between imageStore and FBO read.",
      "parentUuid": "1e386ffc_c719d18b",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c51e26e_df03acfe",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-25T19:37:41Z",
      "side": 1,
      "message": "That sounds strange, why `imageWrite` before FBO _read_? And what about other image usages like image store followed by texture upload? Also `ContextVk::updateActiveImages` doesn\u0027t get called after the barrier and before the FBO read.\n\nIt sounds like instead we should instead trigger some dirty bit on the image? Just so that the next FBO read, texture upload, etc, would all syncState and do whatever is necessary.",
      "parentUuid": "cffd8c85_402872d4",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2928098d_85598ffd",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-25T22:24:35Z",
      "side": 1,
      "message": "See https://chromium-review.googlesource.com/c/angle/angle/+/5434967\nWhat happens is that the `glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT)` call gets skipped at ContextVk.cpp line 6747 without this.",
      "parentUuid": "2c51e26e_df03acfe",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53fb07be_45f08227",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-26T00:29:00Z",
      "side": 1,
      "message": "Ah ok, well that\u0027s a test bug. Between the glClear/glInvalidate and the second dispatch there\u0027s a missing `glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)` (because it\u0027s write-after-access).",
      "parentUuid": "2928098d_85598ffd",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2af86756_388a38e0",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-07-26T01:44:43Z",
      "side": 1,
      "message": "```\nOnly GL_SHADER_IMAGE_ACCESS_BARRIER_BIT and GL_SHADER_STORAGE_BARRIER_BIT are for write-after-access synchronization.\n```\n\nMaybe a very basic question, but can I ask why `GL_FRAMEBUFFER_BARRIER_BIT` is not a valid `write-after-access` synchronization? According to https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glMemoryBarrier.xhtml, under GL_FRAMEBUFFER_BARRIER_BIT:\n\n```\nReads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the barrier. \n```\n\nIt reads to me that it does ensure the \"writes to FBO attachments\" after the barrier will wait for the \"access to the FBO attachments\" prior to the barrier to  complete. Does `write-after-access` only refer to a specific type of resource and that does not include FBO attachments?",
      "parentUuid": "53fb07be_45f08227",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ac38655_f76b1f25",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-26T01:51:09Z",
      "side": 1,
      "message": "Sorry, I should clarify that the \"write\" in write-after-access refers to storage image/buffer write only. Not writes through texture upload, FBO draw, etc.\n\nIn general, there are two situations:\n\n1. Write to resource as storage image/buffer, then do something else\n2. Do something else, then write to resource as storage image/buffer\n\n#2 is what I referred to as write-after-access. To synchronize situation #2, only GL_SHADER_IMAGE_ACCESS_BARRIER_BIT and GL_SHADER_STORAGE_BARRIER_BIT works, while for #1 there are detailed enums for every kind of \"something else\".",
      "parentUuid": "2af86756_388a38e0",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "184a607f_a3f994fd",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-26T02:35:06Z",
      "side": 1,
      "message": "That will make test pass, but I don\u0027t think test is to be blamed. The spec only requires memoryBarrier *after* shader access. It does not require memoryBarrier *before* shader access. In this case, it is FBO clear followed by dispatchCompute, so memoryBarrier should not required.",
      "parentUuid": "53fb07be_45f08227",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "185baf34_afef08e6",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-26T02:42:39Z",
      "side": 1,
      "message": "No that\u0027s not true, the GL_SHADER_IMAGE_ACCESS_BARRIER_BIT and GL_SHADER_STORAGE_BARRIER_BIT bits specifically talk about storage image writes after _any access_ (emphasis mine):\n\n\u003e SHADER_IMAGE_ACCESS_BARRIER_BIT: Memory accesses using shader built-in image load and store functions issued after the barrier will reflect data written by shaders prior to the barrier. **Additionally, image stores issued after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.**\n\n(text for GL_SHADER_STORAGE_BARRIER_BIT is similar, but for buffers)\n\nThe overview of 7.11.2 Shader Memory Access Synchronization also calls this out (bold text mine):\n\n\u003e Explicit synchronization is required to ensure that the effects of buffer and texture data stores performed by shaders will be visible to subsequent operations **(writes visible to subsequent ops: this is case #1 in my comment above)** using the same objects and will not overwrite data still to be read by previously requested operations **(this is case #2)**.",
      "parentUuid": "184a607f_a3f994fd",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d160dcb7_31e8f864",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-26T02:43:49Z",
      "side": 1,
      "message": "In this specific case, I think the problem here is that the first glMemoryBarrier is ignored due to ContextVk.cpp:6747. That memory barrier is required because shader access followed by FBO access. Then the FBO access actually did not resault in rendering (because we defer the clear and then invalidate removes the staged clear). So the next dispatchCompute end up seeing ComputeWrite to ComputeWrite, there is no layout change, so it did not insert barrier. That causes the test failure since now there is no barrier between two dispatchCompute.  \n\nUsually you don\u0027t run into this kidn of bug because FBO access and computeWrite has different layout, so the barrier will always inserted to do layout change. So this GL_FRAMEBUFFER_BARRIER_BIT bit needs to be added into consideration to account for this special situation that FBO access may not result in a ColorWrite layout (in fact it may keep ComputeWrite layout).\n\nI should add more detailed comment here for sure.",
      "parentUuid": "184a607f_a3f994fd",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2952ad0_fdcea2cf",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-26T02:53:59Z",
      "side": 1,
      "message": "All of that happens because the test is missing the `glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)` before the second dispatch. For all the test cares, `glClear()` may actually be doing something, and `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT` is needed to synchronize the compute-write with whatever clear might have done.\n\nIf you do add `glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)` you\u0027ll find that it didn\u0027t matter that `glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT)` is ignored and that `glClear` didn\u0027t do anything.\n\n---\n\nFWIW, `glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT)` is not doing nothing, it still flushes RP/outside RP commands if necessary so the barriers we implicitly insert end up in the right place.",
      "parentUuid": "d160dcb7_31e8f864",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0b1da99_cce47ca3",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-26T16:43:17Z",
      "side": 1,
      "message": "If you read the first paragraph of `7.11.2 Shader Memory Access Synchronization`, it starts by explaining all normal GL operation will just work because GL can track it. Then it starts with shader memory store where driver can\u0027t track. So glMemoryBarrier call is the way to supplement the fact that driver don\u0027t know shader did memory write, thus only needed after shader memory write. Otherwise, all shader writes must wrapped by two glMemortyBarrier calls, one issued before dispatchCompute with GL_SHADER_IMAGE_ACCESS_BARRIER_BIT bit and another after the dispatchCompute. But that is not the case with all tests we have. Also if you look at https://www.khronos.org/opengl/wiki/Memory_Model section `Incoherent memory access` it also says the memoryBarrier is to resolve the issue `However, if memory has been modified in an incoherent fashion, any subsequent reads from that memory are not automatically guaranteed to see these changes.` Also, the existing test works on native gles. \n\nIs there a way to seek clarification from khronos? I don\u0027t want to just fix the test and then people run into weird rendering bugs that hard to track down.",
      "parentUuid": "f2952ad0_fdcea2cf",
      "range": {
        "startLine": 66,
        "startChar": 41,
        "endLine": 66,
        "endChar": 67
      },
      "revId": "ccda7694181279c1386ada5322d296af50e59c58",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}