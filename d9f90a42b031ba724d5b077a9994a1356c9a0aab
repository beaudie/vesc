{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "04fe4d99_772cdccb",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-30T17:53:13Z",
      "side": 1,
      "message": "Thought about this more, this optimization actually wont work. If you look at allocateStreamedVertexBuffer implementation, you can see that we have per attribute index dynamicBuffer: mStreamedVertexBuffers. The reason for this is that dynamic buffer is a linear allocation, i.e, when you allocate a new range, the previous range is automatically released. There is no way to retain a old range while allocate a new range. Lets say you have two attributes (A1 and A2), one attribute (A2) specify once and did not change. The other attribute A1 keep getting new data. Right now because they are independently allocated, it works fine. But if first time comes in you see A1 and A2 can be merged, and both allocated from A1\u0027s DynamiBuffer (i.e, mStreamedVertexBuffers[0]). Now next draw call app changes A1 to different data, now you allocate new range from mStreamedVertexBuffers[0]. Because it is linear allocation, previous allocation is released. But A2 is still pointing to it. Now you have bug that GPU may access a released buffer. Even if you tag A2\u0027s buffer for every draw call so that it wont get freed, you have other bug that because A2 holding onto one buffer, we will keep allocating new buffers since the DynamicBuffer assumes all usage is FIFO order.",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef2954e0_6da34e9f",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1517514
      },
      "writtenOn": "2023-10-30T18:03:36Z",
      "side": 1,
      "message": "is the dirty bit per attribute? it have to dirty for all the attributes,\nsince client buffer, you don\u0027t know the data is changed or not",
      "parentUuid": "04fe4d99_772cdccb",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c25668d_9ea19945",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-30T18:05:48Z",
      "side": 1,
      "message": "I think so. But now you have to copy data for every attributes even though only one changed, isn\u0027t that less efficient?",
      "parentUuid": "ef2954e0_6da34e9f",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b76084a0_451c07a5",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1517514
      },
      "writtenOn": "2023-10-30T18:07:20Z",
      "side": 1,
      "message": "if it dirty all the client buffer data. the orignal code also need to copy the old data too.",
      "parentUuid": "4c25668d_9ea19945",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72cc7441_9635ec5e",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-30T18:12:45Z",
      "side": 1,
      "message": "I mean dirty bit is per attribute. We should be only copying the data for attributes that has changed. If not, that is a bug that we should fix.",
      "parentUuid": "b76084a0_451c07a5",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe5b136c_c8853128",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1517514
      },
      "writtenOn": "2023-10-30T18:19:15Z",
      "side": 1,
      "message": "my understanding is the update is as whole. if there is one attribute chagned. it update all the data.",
      "parentUuid": "72cc7441_9635ec5e",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2a8603d_04569f0f",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-30T18:26:39Z",
      "side": 1,
      "message": "Mm, for streaming, looks you are right, we always go over all active attributes. But the mStreamedVertexBuffers also keeps data for the default attribute. If you disable the attrib and many frame later you re-enable the attrib, we retreive the default attribute value for that index in mStreamedVertexBuffers. Same bug will apply if this range has been released. I think a better optimization might be look at all app traces to see if usage pattern is that app always dirty all attribs or not, if not, then we should add dirty bits tracking it.",
      "parentUuid": "fe5b136c_c8853128",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb56c533_edc60816",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1517514
      },
      "writtenOn": "2023-10-30T18:38:05Z",
      "side": 1,
      "message": "change the default attirbute , will call glEnableVertexAttribArray or glDisableVertexAttribArray. in this case. it did affect the streaming (if it  the attribute index use streaming).  (ie need to update the client buffer data)",
      "parentUuid": "c2a8603d_04569f0f",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "adf82cde_b5451b11",
        "filename": "src/libANGLE/renderer/vulkan/VertexArrayVk.cpp",
        "patchSetId": 66
      },
      "lineNbr": 1131,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-31T16:52:50Z",
      "side": 1,
      "message": "I think the better optimization is to track per attribute index dirty bits so that you only copy dirty client array instead of always copy all of them. This CL will made such optimization impossible.",
      "parentUuid": "bb56c533_edc60816",
      "range": {
        "startLine": 1131,
        "startChar": 37,
        "endLine": 1131,
        "endChar": 65
      },
      "revId": "d9f90a42b031ba724d5b077a9994a1356c9a0aab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}