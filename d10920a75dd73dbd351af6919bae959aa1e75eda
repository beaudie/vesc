{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d1075e50_909c354d",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 25
      },
      "lineNbr": 693,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-12-08T21:57:54Z",
      "side": 1,
      "message": "\u0026\u0026 !mEGLSyncObjectPendingFlush",
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eff893d6_aac427fc",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 25
      },
      "lineNbr": 693,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-12-09T01:09:41Z",
      "side": 1,
      "message": "Oops, missed it. Done.",
      "parentUuid": "d1075e50_909c354d",
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b15d528_4e43e1df",
        "filename": "src/tests/egl_tests/EGLContextSharingTest.cpp",
        "patchSetId": 25
      },
      "lineNbr": 508,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-12-08T21:57:54Z",
      "side": 1,
      "message": "This doesn\u0027t sound right. Why is flush needed for fence creation?",
      "range": {
        "startLine": 507,
        "startChar": 8,
        "endLine": 508,
        "endChar": 18
      },
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c591f23f_9f9bb51d",
        "filename": "src/tests/egl_tests/EGLContextSharingTest.cpp",
        "patchSetId": 25
      },
      "lineNbr": 508,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-12-09T01:09:41Z",
      "side": 1,
      "message": "\u003e glFenceSync â€” create a new sync object and insert it into the GL command stream\n\nThe flush forces the sync to land in ANGLE\u0027s command stream in the correct place when multiple contexts are generating commands.   I discovered this is necessary with the tests MultithreadingTestES3::MultithreadFenceDraw() and MultithreadFenceTexImage().\n\nIt\u0027s possible ANGLE\u0027s glFenceSync() implementation should include a flush internally, since it only creates the sync object today.   I can open a bug to fix that with a separate CL if you think this is a bug.",
      "parentUuid": "1b15d528_4e43e1df",
      "range": {
        "startLine": 507,
        "startChar": 8,
        "endLine": 508,
        "endChar": 18
      },
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0aabd912_16dc8db3",
        "filename": "src/tests/egl_tests/EGLContextSharingTest.cpp",
        "patchSetId": 25
      },
      "lineNbr": 508,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-12-09T01:21:06Z",
      "side": 1,
      "message": "Not sure flush at line 508 and line 526 both required, but I can see you do need one flush (likely keep line 526 one) there since continuingThread will not issue flush for deletingThread before wait.",
      "parentUuid": "c591f23f_9f9bb51d",
      "range": {
        "startLine": 507,
        "startChar": 8,
        "endLine": 508,
        "endChar": 18
      },
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b04a61e8_d4f47fc4",
        "filename": "src/tests/egl_tests/EGLContextSharingTest.cpp",
        "patchSetId": 25
      },
      "lineNbr": 508,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-12-09T04:09:15Z",
      "side": 1,
      "message": "That would be a pretty bad bug.\n\n    angle::Result SyncHelper::initialize(ContextVk *contextVk)\n    {\n        ...\n        ANGLE_VK_TRY(contextVk, event.get().init(device, eventCreateInfo));\n\n        mEvent \u003d event.release();\n\n        vk::CommandBuffer *commandBuffer;\n        ANGLE_TRY(contextVk-\u003egetOutsideRenderPassCommandBuffer({}, \u0026commandBuffer));\n        commandBuffer-\u003esetEvent(mEvent.getHandle(), VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT);\n        retain(\u0026contextVk-\u003egetResourceUseList());\n\n        ...\n    }\n\nIt _is_ recording the command. Are you saying that command should reach the primary command buffer right away? That makes sense actually. You can add a call to ContextVk::flushCommandsAndEndRenderPass() automatically after the above setEvent() call.",
      "parentUuid": "0aabd912_16dc8db3",
      "range": {
        "startLine": 507,
        "startChar": 8,
        "endLine": 508,
        "endChar": 18
      },
      "revId": "d10920a75dd73dbd351af6919bae959aa1e75eda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}