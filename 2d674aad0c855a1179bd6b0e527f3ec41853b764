{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d4e8aed5_da756e65",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-01-20T09:07:22Z",
      "side": 1,
      "message": "Update handling image layout transition validation fail issue.\n\nList again of the failed case api sequence:\ndispatch write image  (layout: TRANSFER-\u003eGENERAL)\ngraphics read texture (layout: GENERAL-\u003eSHADER_READONLY)\ndispatch write image  (layout: SHADER_READONLY-\u003eGENERAL)\ngraphics read texture (layout: GENERAL-\u003eSHADER_READONLY)\nSeems there are at least two opportunities to endRP:\n1) when switching program from hasImage() to !hasImage(), in the handleDirtyTextureImpl, close the RP after issued the image read barrier. This is the frontest opportunity to endRP.\n2) Or we can defer the closure operation on RP, till the next outsiderRP command is requested. The trigger of outsiderRP commands seems include two types. one is the compute commands, and the other cases which have already handled by flushCommandBuffersIfNecessary().\nFor compute command case, when image used as shader resource, the write operation needs a layout transition (dst layout as GENERAL). We can do the closure RP here by checking if necessary, as this commit code shows, handle in ContextVk::invalidateCurrentShaderResources, and add new RPclosureReason: ImageReadThenComputeWrite.\n\nFurthermore, if the compute read image based read-after-write, the api sequence as:\ndispatch read texture (layout: TRANSFER-\u003eSHADER_READONLY)\ngraphics write image  (layout: SHADER_READONLY-\u003eGENERAL)\ndispatch read texture (layout: GENERAL-\u003eSHADER_READONLY)\ngraphics write image  (layout: SHADER_READONLY-\u003eGENERAL)\nBefore do the second dispatch read texture, an endRP is also needed, and this has been already handled in ContextVk::invalidateCurrentTextures.\n\n\n\n",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fa83aec_bd6a9bbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-21T05:46:45Z",
      "side": 1,
      "message": "Please take a look at how `endRenderPassIfComputeReadAfterAttachmentWrite` is used. That\u0027s a very similar situation. We should make a similar `endRenderPassIfComputeAccessAfterTextureSample` (or something like that) that\u0027s triggered by hasImage() \u003c-\u003e !hasImage() switches.",
      "parentUuid": "d4e8aed5_da756e65",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73942de8_5a0e204e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-01-21T06:25:59Z",
      "side": 1,
      "message": "Shahbaz, thanks for comment. One more question is that when the switch between hasImages() and !hasImages() happens, can we trigger  `endRenderPassIfComputeAccessAfterTextureSample` directly in ContextVk::invalidateProgramExecutableHelper when current program has linked compute shader?",
      "parentUuid": "1fa83aec_bd6a9bbe",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdfebdb8_e0b7b670",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-21T17:17:47Z",
      "side": 1,
      "message": "You could, but note that when `invalidateProgramExecutableHelper` is called, we also set `DIRTY_BIT_TEXTURE_BINDINGS`, which means `invalidateCurrentTextures` will be called after that. It should be ok then to put the call to `endRenderPassIfComputeAccessAfterTextureSample()` somewhere close to `endRenderPassIfComputeReadAfterAttachmentWrite()`. I suspect you also need to make that call inside `invalidateCurrentShaderResources` as well if the executable has images.\n\nTo make sure we cover all bases, can you please make sure the tests cover all these cases?\n\n- FS texture sample followed by CS texture sample, followed by FS texture sample\n- FS texture sample followed by CS storage image read, followed by FS texture sample\n- FS texture sample followed by CS storage image write, followed by FS texture sample",
      "parentUuid": "73942de8_5a0e204e",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b83af448_db9587c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-02-08T04:16:18Z",
      "side": 1,
      "message": "Hi Shahbaz,\nSorry for delayed responding for holiday.\n\n\u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 seems include two parts content: one is for texture, refer to the first case you mentioned; another is for image, refers to the next two cases.\n\nFor the case \u0027FS texture sample followed by CS texture sample, followed by FS texture sample\u0027, if each program !hasImages, then the current logic is fine; if the graphics program hasImages (like VS has store image write, FS texture sample it?), then do the \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 (for texture) in invalidateCurrentTextures before dispatch, and seems angle_end2end test not covers this scenario.\n\nFurther, seems ANGLE use \u0027mRenderPassUsedImages\u0027 to tracing the image usage in renderpass for both write and read. So the implementation of \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 for texture is almost the same with \u0027endRenderPassIfComputeReadAfterAttachmentWrite\u0027? Although the latter is originated from the image write. Maybe we can distinguish the mRenderPassUsedImages more detailed, like mRenderPassUsedReadImages/mRenderPassUsedWriteImages?\n\nFor the next two cases, no matter the CS use storage image write or read, the cs program hasImages and no texture, when program switch from Graphics-\u003eCompute (!hasImage -\u003ehasImages), endRP can be trigger by endRenderPassIfComputeAccessAfterTextureSample (for image) at invalidateCurrentShaderResources before dispatch. But for the following Compute-\u003eGraphics (hasImages -\u003e !hasImages), if no glMemoryBarrier be called after dispatch, seems we needs to call \u0027flushOutsideRenderPassCommands\u0027 in invalidateCurrentTextures; if glMemoryBarrier has been called before, nothing to do.",
      "parentUuid": "fdfebdb8_e0b7b670",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}