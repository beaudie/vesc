{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d4e8aed5_da756e65",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-01-20T09:07:22Z",
      "side": 1,
      "message": "Update handling image layout transition validation fail issue.\n\nList again of the failed case api sequence:\ndispatch write image  (layout: TRANSFER-\u003eGENERAL)\ngraphics read texture (layout: GENERAL-\u003eSHADER_READONLY)\ndispatch write image  (layout: SHADER_READONLY-\u003eGENERAL)\ngraphics read texture (layout: GENERAL-\u003eSHADER_READONLY)\nSeems there are at least two opportunities to endRP:\n1) when switching program from hasImage() to !hasImage(), in the handleDirtyTextureImpl, close the RP after issued the image read barrier. This is the frontest opportunity to endRP.\n2) Or we can defer the closure operation on RP, till the next outsiderRP command is requested. The trigger of outsiderRP commands seems include two types. one is the compute commands, and the other cases which have already handled by flushCommandBuffersIfNecessary().\nFor compute command case, when image used as shader resource, the write operation needs a layout transition (dst layout as GENERAL). We can do the closure RP here by checking if necessary, as this commit code shows, handle in ContextVk::invalidateCurrentShaderResources, and add new RPclosureReason: ImageReadThenComputeWrite.\n\nFurthermore, if the compute read image based read-after-write, the api sequence as:\ndispatch read texture (layout: TRANSFER-\u003eSHADER_READONLY)\ngraphics write image  (layout: SHADER_READONLY-\u003eGENERAL)\ndispatch read texture (layout: GENERAL-\u003eSHADER_READONLY)\ngraphics write image  (layout: SHADER_READONLY-\u003eGENERAL)\nBefore do the second dispatch read texture, an endRP is also needed, and this has been already handled in ContextVk::invalidateCurrentTextures.\n\n\n\n",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fa83aec_bd6a9bbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-21T05:46:45Z",
      "side": 1,
      "message": "Please take a look at how `endRenderPassIfComputeReadAfterAttachmentWrite` is used. That\u0027s a very similar situation. We should make a similar `endRenderPassIfComputeAccessAfterTextureSample` (or something like that) that\u0027s triggered by hasImage() \u003c-\u003e !hasImage() switches.",
      "parentUuid": "d4e8aed5_da756e65",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73942de8_5a0e204e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-01-21T06:25:59Z",
      "side": 1,
      "message": "Shahbaz, thanks for comment. One more question is that when the switch between hasImages() and !hasImages() happens, can we trigger  `endRenderPassIfComputeAccessAfterTextureSample` directly in ContextVk::invalidateProgramExecutableHelper when current program has linked compute shader?",
      "parentUuid": "1fa83aec_bd6a9bbe",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdfebdb8_e0b7b670",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-21T17:17:47Z",
      "side": 1,
      "message": "You could, but note that when `invalidateProgramExecutableHelper` is called, we also set `DIRTY_BIT_TEXTURE_BINDINGS`, which means `invalidateCurrentTextures` will be called after that. It should be ok then to put the call to `endRenderPassIfComputeAccessAfterTextureSample()` somewhere close to `endRenderPassIfComputeReadAfterAttachmentWrite()`. I suspect you also need to make that call inside `invalidateCurrentShaderResources` as well if the executable has images.\n\nTo make sure we cover all bases, can you please make sure the tests cover all these cases?\n\n- FS texture sample followed by CS texture sample, followed by FS texture sample\n- FS texture sample followed by CS storage image read, followed by FS texture sample\n- FS texture sample followed by CS storage image write, followed by FS texture sample",
      "parentUuid": "73942de8_5a0e204e",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b83af448_db9587c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-02-08T04:16:18Z",
      "side": 1,
      "message": "Hi Shahbaz,\nSorry for delayed responding for holiday.\n\n\u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 seems include two parts content: one is for texture, refer to the first case you mentioned; another is for image, refers to the next two cases.\n\nFor the case \u0027FS texture sample followed by CS texture sample, followed by FS texture sample\u0027, if each program !hasImages, then the current logic is fine; if the graphics program hasImages (like VS has store image write, FS texture sample it?), then do the \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 (for texture) in invalidateCurrentTextures before dispatch, and seems angle_end2end test not covers this scenario.\n\nFurther, seems ANGLE use \u0027mRenderPassUsedImages\u0027 to tracing the image usage in renderpass for both write and read. So the implementation of \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 for texture is almost the same with \u0027endRenderPassIfComputeReadAfterAttachmentWrite\u0027? Although the latter is originated from the image write. Maybe we can distinguish the mRenderPassUsedImages more detailed, like mRenderPassUsedReadImages/mRenderPassUsedWriteImages?\n\nFor the next two cases, no matter the CS use storage image write or read, the cs program hasImages and no texture, when program switch from Graphics-\u003eCompute (!hasImage -\u003ehasImages), endRP can be trigger by endRenderPassIfComputeAccessAfterTextureSample (for image) at invalidateCurrentShaderResources before dispatch. But for the following Compute-\u003eGraphics (hasImages -\u003e !hasImages), if no glMemoryBarrier be called after dispatch, seems we needs to call \u0027flushOutsideRenderPassCommands\u0027 in invalidateCurrentTextures; if glMemoryBarrier has been called before, nothing to do.",
      "parentUuid": "fdfebdb8_e0b7b670",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69c78818_e4b748d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-02-08T08:57:14Z",
      "side": 1,
      "message": "Thanks for the discussion! These interactions can get very tricky, but we can have a much better confidence in correctness with the right tests in place. Thanks for driving this work ðŸ˜Š",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84b02a2e_d6c2d334",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-02-08T08:57:14Z",
      "side": 1,
      "message": "Hi,\n\n\u003e For the case \u0027FS texture sample followed by CS texture sample, followed by FS texture sample\u0027, if each program !hasImages, then the current logic is fine; if the graphics program hasImages (like VS has store image write, FS texture sample it?), then do the \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 (for texture) in invalidateCurrentTextures before dispatch, and seems angle_end2end test not covers this scenario.\n\nFirst off, \"VS writes to image, then FS reads it\" is not valid GL. That\u0027s a race condition by nature and no `glMemoryBarrier` is possible to resolve it. But ok, you are right that the scenario should be a little more complicated. Since this change is about `textureVk-\u003ehasBeenBoundAsImage()` being true, you can make sure that\u0027s the case (which is unnecessary), and have the CS for example include an unrelated image. That should hit the if in ContextVk.cpp:375.\n\nYou could also add an opposite test where in sampleFS-\u003esampleCS-\u003esampleFS, both FS calls have an unrelated image but not the CS.\n\n\u003e Further, seems ANGLE use \u0027mRenderPassUsedImages\u0027 to tracing the image usage in renderpass for both write and read. So the implementation of \u0027endRenderPassIfComputeAccessAfterTextureSample\u0027 for texture is almost the same with \u0027endRenderPassIfComputeReadAfterAttachmentWrite\u0027? Although the latter is originated from the image write.\n\nThey may indeed look similar in structure. However, `endRenderPassIfComputeReadAfterAttachmentWrite` is *not* originated from image writes, but rather framebuffer attachment writes. They are very different scenarios because the former requires a glMemoryBarrier while the latter is implicitly synchronized.\n\n\u003e Maybe we can distinguish the mRenderPassUsedImages more detailed, like mRenderPassUsedReadImages/mRenderPassUsedWriteImages?\n\nThe purpose of `mRenderPassUsedImages` is really to track \"write\" images, because it\u0027s used to implement `glMemoryBarrier`. \"Read\" images don\u0027t really need to be there, but were placed for simplicity. If `endRenderPassIfComputeAccessAfterTextureSample` needs tracking image usage, sure you can make it more detailed, but I suspect you don\u0027t actually need it. If you look at `endRenderPassIfComputeReadAfterAttachmentWrite`, it\u0027s iterating over the textures of the current program and checks if they are used in the render pass, you don\u0027t need to know anything about the _images_ in the render pass, but rather textures.\n\n\u003e For the next two cases, no matter the CS use storage image write or read, the cs program hasImages and no texture, when program switch from Graphics-\u003eCompute (!hasImage -\u003ehasImages), endRP can be trigger by endRenderPassIfComputeAccessAfterTextureSample (for image) at invalidateCurrentShaderResources before dispatch. But for the following Compute-\u003eGraphics (hasImages -\u003e !hasImages), if no glMemoryBarrier be called after dispatch, seems we needs to call \u0027flushOutsideRenderPassCommands\u0027 in invalidateCurrentTextures; if glMemoryBarrier has been called before, nothing to do.\n\nFor the last test (sampleFS-\u003ewriteCS-\u003esampleFS) we actually need a `glMemoryBarrier` both before and after the CS, so looking back, that test is not going add anything new here. You can ignore it.\n\nFor the second test (sampleFS-\u003ereadCS-\u003esampleFS), no `glMemoryBarrier` is needed, so we need `endRenderPassIfComputeAccessAfterTextureSample` to close the render pass. And you are right, `invalidateCurrentShaderResources` is enough for that. However, we still need that call in `invalidateCurrentTextures` I believe in the following scenario:\n\n* FS image read followed by CS texture sample",
      "parentUuid": "b83af448_db9587c4",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a99afb6e_0c738f9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1524687
      },
      "writtenOn": "2022-02-08T10:58:09Z",
      "side": 1,
      "message": "hi Shahbaz,\nThanks for so detailed explanation! I think something becomes more clearly:)\n\nFor the new test you mentioned (FS image read-\u003eCS texture read), yes, we need to do the closure of renderpass in invalidateCurrentTexture.\n\nFor the test (sampleFS-\u003ewriteCS-\u003esampleFS), I find some test only call glMemoryBarrier *after* CS, which makes the endRP *before* CS being necessary? Although this scenario also can be handled by close it at invalidateCurrentShaderResources.\n\nFor the \u0027mRenderPassUsedImages\u0027ï¼Œmaybe I have a confusion firstly. I guess the \u0027Image\u0027 here refers to the vulkan\u0027s image and corresponding to GL_texture and GL_image based on the texture unit and image unit respectively? For GL_texture, it is imageRead, and for GL_image or fbo texture write, it is imageWrite. For the write case, the implicit read-after-write hazards needs to close the RP (like endRenderPassIfComputeReadAfterAttachmentWrite); and for some imageRead case caused layout transition needs close RP too, as the sample faulty test. Seems currently mRenderPassUsedImages include all of the types?\n\nThe pseudocode of endRenderPassIfComputeAccessAfterTextureSample I consider as:\nendRenderPassIfComputeAccessAfterTextureSample ()\n{\n   foreach textureUnit\n   {\n      get vk::ImageHelper image from textureUnit; \n      if (IsRenderPassStartedAndUsesImage(*mRenderPassCommands, image))\n      {\n         flushCommandsAndEndRenderPass(ComputeAccessAfterTextureSample)\n      }\n    }\n \n   foreach imageUnit\n   {\n      get vk::ImageHelper image from imageUnit; \n      if (IsRenderPassStartedAndUsesImage(*mRenderPassCommands, image))\n      {\n         flushCommandsAndEndRenderPass(ComputeAccessAfterTextureSample)\n      }\n   }\n}",
      "parentUuid": "84b02a2e_d6c2d334",
      "revId": "2d674aad0c855a1179bd6b0e527f3ec41853b764",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}