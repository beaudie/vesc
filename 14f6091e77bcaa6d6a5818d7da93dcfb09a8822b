{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2db72ed7_10fc8d5c",
        "filename": "src/libANGLE/renderer/wgpu/TextureWgpu.cpp",
        "patchSetId": 12
      },
      "lineNbr": 107,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-17T02:39:19Z",
      "side": 1,
      "message": "This is both out of place and incorrect. For one, this function is uploading a subsection of the image, so area and index have no bearing on the actual size and mip count of the image.\n\nIn GL, unfortunate as it is, it\u0027s frequently the case that applications use `glTexImage*` to define the image level by level. So we can\u0027t really afford to create the image as soon as we see a level specified. Following the way we\u0027ve dealt with this in vulkan/:\n\n- Make sure TextureWgpu always has an `mImage` allocated. This image is not actually initialized\n- When data is uploaded (like with `setImage` or `setSubImage`), stage the update in a GPU buffer ready to be copied to the image, but stash it in an update list in the ImageHelper (See `SubresourceUpdate` in vk_helpers.cpp and the per-mip vector of it)\n- In TextureWgpu::syncState, initialize the image with an appropriate mip range (which depends on many factors, see `TextureVk::respecifyImageStorageIfNecessary`) and then flush the updates to that range.\n  - Because GL allows applications to define mips arbitrarily, you shouldn\u0027t expect to be able to flush _all_ staged updates; just the ones that apply to the allocated range of the image.",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 107,
        "endChar": 5
      },
      "revId": "14f6091e77bcaa6d6a5818d7da93dcfb09a8822b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e4affed_47fce476",
        "filename": "src/libANGLE/renderer/wgpu/TextureWgpu.cpp",
        "patchSetId": 12
      },
      "lineNbr": 107,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-04-23T17:03:28Z",
      "side": 1,
      "message": "Made a bunch of changes based on this feedback I\u0027ll highlight here, also let me know if you want me to split this CL up even more as it\u0027s now much larger.\n\n* I copied over a lot of the logic from `TextureVk::respecifyImageStorageIfNecessary` but removed a lot regarding tracking vulkan specific usage flags as I didn\u0027t see similar flags in webgpu. I also am for now just resetting mImage (see `ImageHelper::resetImage` for what\u0027s being reset) instead of fully respecifying the storage as I saw that required copying textures and it\u0027s not implemented yet, so I\u0027m leaving that as a TODO\n* The bulk of the new changes are in `TextureWgpu::respecifyImageStorageIfNecessary` and various methods it calls. I also moved `hasAnyRedefinedLevels` and `isRedefinedLevel` out of TextureVk and into render_utils. \n* Updated `ImageHelper::initImage` to now get called when syncing the state, and in `TextureWgpu::getAttachmentRenderTarget`. Flushing updates also happens in both places for now as I do think it makes more sense to keep deferring clears out of scope for this specific CL, but I want to add it after we confirm the initial implementation of clears is working.\n* Staged updates are currently fairly simple as they\u0027re stored in a `wgpu::ImageCopyBuffer` along with the target mip level, `ImageHelper::flushStagedUpdates` already checks that a staged update is within the allocated mip range, but now that initialization happens after `TextureWgpu::respecifyImageStorageIfNecessary` the allocated range should be correct and not based on whatever updates were staged earlier, like they were in the previous patchset.",
      "parentUuid": "2db72ed7_10fc8d5c",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 107,
        "endChar": 5
      },
      "revId": "14f6091e77bcaa6d6a5818d7da93dcfb09a8822b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a61dba1_50f23d41",
        "filename": "src/libANGLE/renderer/wgpu/TextureWgpu.cpp",
        "patchSetId": 12
      },
      "lineNbr": 107,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-25T05:11:15Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "7e4affed_47fce476",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 107,
        "endChar": 5
      },
      "revId": "14f6091e77bcaa6d6a5818d7da93dcfb09a8822b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba585c43_cf8ebc24",
        "filename": "src/libANGLE/renderer/wgpu/wgpu_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 126,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-17T02:39:19Z",
      "side": 1,
      "message": "Add `wgpu::TextureUsages::TextureBinding` while you\u0027re at it!",
      "revId": "14f6091e77bcaa6d6a5818d7da93dcfb09a8822b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b985d3fd_7d23b784",
        "filename": "src/libANGLE/renderer/wgpu/wgpu_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 126,
      "author": {
        "id": 1516597
      },
      "writtenOn": "2024-04-23T17:03:28Z",
      "side": 1,
      "message": "I got rid of this helper method and moved creating the TextureDescriptor to `TextureWgpu::initializeImage`, added `wgpu::TextureUsage::TextureBinding` there",
      "parentUuid": "ba585c43_cf8ebc24",
      "revId": "14f6091e77bcaa6d6a5818d7da93dcfb09a8822b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}