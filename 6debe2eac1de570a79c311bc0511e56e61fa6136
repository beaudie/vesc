{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7bcbd66e_76c337d9",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-08-28T01:55:43Z",
      "side": 1,
      "message": "I think the reason for the failures is that this code is calling flush for the readRT unconditionally, even when readRT \u003d\u003d drawRT.\n\nThe logic should be inverted in my opinion, i.e. the defer vs not should apply to drawRT, and then readRT would flush without deferring and only when readRT !\u003d drawRT:\n\n    // Draw\n    drawRenderTarget \u003d mRenderTargetCache.getColorDraw(mState, colorIndexGL);\n    if (deferClears \u0026\u0026 mState.getEnabledDrawBuffers().test(colorIndexGL))\n    {\n        ANGLE_TRY(drawRenderTarget-\u003eflushStagedUpdates(contextVk, \u0026mDeferredClears, colorIndexGL,\n                  mCurrentFramebufferDesc.getLayerCount()));\n    }\n    else\n    {\n        ANGLE_TRY(drawRenderTarget-\u003eflushStagedUpdates(contextVk, nullptr, 0,\n                  mCurrentFramebufferDesc.getLayerCount()));\n    }\n\n    // Read\n    if (mState.getReadBufferState() !\u003d GL_NONE \u0026\u0026 mState.getReadIndex() \u003d\u003d colorIndexGL)\n    {\n        // flush staged updates to the read render target as well, but only if it\u0027s\n        // not the same as the draw render target.  This can happen when the\n        // read render target is bound to another surface.\n        readRenderTarget \u003d mRenderTargetCache.getColorRead(mState);\n        if (readRenderTarget \u0026\u0026 readRenderTarget !\u003d drawRenderTarget)\n        {\n            ANGLE_TRY(readRenderTarget-\u003eflushStagedUpdates(\n                contextVk, nullptr, 0, mCurrentFramebufferDesc.getLayerCount()));\n        }\n    }\n\n    return angle::Result::Continue;",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fa32f92_03e3e141",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-30T22:51:55Z",
      "side": 1,
      "message": "Done\n\nWith the addition of checking the \u0027drawRenderTarget\u0027 pointer to handle when there are no attachments.",
      "parentUuid": "7bcbd66e_76c337d9",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f5855bfa_9becffa7",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-08-31T02:41:21Z",
      "side": 1,
      "message": "Excellent, thanks Tim. A regression test might be tricky, but maybe something like this works?\n\n    Bind surface 1 (maybe pbuffer is easier?) for read and draw\n    glClear red\n    EXPECT_PIXEL_COLOR_EQ(red) -\u003e flushes the clear to red\n\n    glClear green -\u003e this gets deferred\n\n    Bind surface 2 for draw (surface 1 still as read)\n    blit from surface 1 to surface 2\n    EXPECT_PIXEL_COLOR_EQ(green)\n\nWhat the old code did was collect deferred clears from both surfaces and apply them to surface 2. I expect before this change the last line would fail by reading red.",
      "parentUuid": "9fa32f92_03e3e141",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce4c66b0_055497c3",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-08-31T11:33:15Z",
      "side": 1,
      "message": "Test would be welcome.",
      "parentUuid": "f5855bfa_9becffa7",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b23e494b_a070c8de",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-08-31T17:21:50Z",
      "side": 1,
      "message": "I added the test, but it passes with and without the fix.\n\nWhile the new version does look cleaner, I\u0027m still not entirely understanding what the bug was in the initial version, so I\u0027m not sure what case I should be trying to hit.\n\nLet me know if there are any tweaks you\u0027d like to it.",
      "parentUuid": "ce4c66b0_055497c3",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21215e9f_711972ac",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1749,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-08-31T17:50:17Z",
      "side": 1,
      "message": "Ok I diagnosed your test, and it passes because blit is calling syncState first for the READ framebuffer (where deferClears\u003dfalse) and then for the DRAW framebuffer.\n\nThat works sort of by luck. If the DRAW framebuffer was synced first (which I intend to do: anglebug.com/5266#c2), you would have got a failure.",
      "parentUuid": "b23e494b_a070c8de",
      "revId": "6debe2eac1de570a79c311bc0511e56e61fa6136",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}