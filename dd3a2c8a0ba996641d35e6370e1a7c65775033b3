{
  "comments": [
    {
      "key": {
        "uuid": "5a8db45f_ff768f2e",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2872,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "Seems like the only difference between this function and gatherUniformBlockInfo is getUniformBlocks vs getShaderStorageBlocks. Maybe make these 2 a parameter to 1 function?",
      "range": {
        "startLine": 2872,
        "startChar": 14,
        "endLine": 2872,
        "endChar": 42
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d5c80b0_9f4fc82b",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2872,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "I agree it\u0027s not perfect to have the code duplication between the two, but there are enough differences that making a shared function might be harder to maintain than a single one. I\u0027d need to parameterize the type of the InterfaceBlockLinker, the member pointer to querying size and layout info, and the member function for the shader query for the shader blocks.\n\nI think another way to make these functions a bit simpler is to store attached shaders in an array, and iterate over the array. This could be something we look at doing for Geometry shaders (or in general when we have more than three shader attachment points).",
      "parentUuid": "5a8db45f_ff768f2e",
      "range": {
        "startLine": 2872,
        "startChar": 14,
        "endLine": 2872,
        "endChar": 42
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "372cc339_e5fbf1b1",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 606,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "I think the intended usage is clearer if you use * instead of \u0026.\nHave you considered to store some kind of smart pointer in mShaderBlocks, so that we won\u0027t have dangling references and the ownership of blocks will be clear?\nNow it\u0027s relatively safe, since all instances of InterfaceBlockLinker are local to a function. But you can\u0027t keep it this way, can you?",
      "range": {
        "startLine": 606,
        "startChar": 81,
        "endLine": 606,
        "endChar": 82
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "285c3e2b_a61da714",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 606,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "Done, I added more comments and made this take a pointer. This class should never be used longer than the duration of a Program::link. If we did want to support that we could copy the contents of the blocks, but I\u0027d like to keep it taking a pointer/reference for speed.",
      "parentUuid": "372cc339_e5fbf1b1",
      "range": {
        "startLine": 606,
        "startChar": 81,
        "endLine": 606,
        "endChar": 82
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc388346_928b5f25",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "Old logic called defineInterfaceBlock unconditionally.\nAnd visitedList count was checked only for fragment blocks.\nI think this may work correctly only if you call addShaderBlocks first for vertex and only then for fragment. There is no way to enforce this condition with the current API.",
      "range": {
        "startLine": 635,
        "startChar": 12,
        "endLine": 635,
        "endChar": 16
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fb07e6d_c6def63e",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "I can\u0027t think of any reason why it wouldn\u0027t work correctly. I\u0027m not sure what you mean by \u0027no way to enforce this condition with the current API\u0027. I think this design is a bit more flexible since it will facilitate adding more shader types, like Geometry shaders, or tessellation shaders if we get that far.",
      "parentUuid": "fc388346_928b5f25",
      "range": {
        "startLine": 635,
        "startChar": 12,
        "endLine": 635,
        "endChar": 16
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6708d23b_557b9352",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 635,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-07T01:03:30Z",
      "side": 1,
      "message": "I\u0027m not really familiar with this code, but I observed 2 differences between the old and the new code:\n\n1. Old code called defineInterfaceBlock() unconditionally, for first and for all subsequent visits of block.name. New code will call it only for the first visit. I don\u0027t know if the end result will be the same, or what code is correct - old or new.\n\n2. Old code was iterating over vertex shader first and then over fragment shader. block.staticUse was backwards propagated from fragment shader to vertex shader. The new code will continue doing the same, if addShaderBlocks was called for vertex first and then for fragment. If the order was reversed, it will start propagating block.static use from vertex to fragment. What I\u0027ve meant by \"no way to enforce this condition with the current API\" is that you don\u0027t have control over the order in which addShaderBlocks is called. Again, I don\u0027t know if it\u0027s good or bad, just pointing out the difference.",
      "parentUuid": "9fb07e6d_c6def63e",
      "range": {
        "startLine": 635,
        "startChar": 12,
        "endLine": 635,
        "endChar": 16
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f41d24f_7c786de4",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 645,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "Old name was defineUniformBlockMembers, and I think the new function can still handle only uniforms. See my next comment, I think you\u0027ll only need this function in Uniform sub-class.",
      "range": {
        "startLine": 645,
        "startChar": 27,
        "endLine": 645,
        "endChar": 45
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0dae40bb_7050c3ec",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 645,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4f41d24f_7c786de4",
      "range": {
        "startLine": 645,
        "startChar": 27,
        "endLine": 645,
        "endChar": 45
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "755afa5d_e87d5e8c",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 698,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "This check is not as straightforward as \"interfaceBlock.blockType \u003d\u003d sh::BlockType::BLOCK_UNIFORM\". I prefer the old check and assert(mUniformsOut) in it if you\u0027d like. Ideally, you\u0027d use inheritance to distinguish between UniformBlocks and ShaderStorageBlocks, instead of relying on passing mUniformsOut \u003d\u003d null parameter in constructor.",
      "range": {
        "startLine": 698,
        "startChar": 8,
        "endLine": 698,
        "endChar": 20
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7054205a_1f557d27",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 698,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "I like the inheritance idea, I implemented it for SSB and UB varieties. This should make the SSBO implementation easier. Note that SSBs have a member variable type called Buffer Variables, so they share some commonalities with UBOs and Uniforms.",
      "parentUuid": "755afa5d_e87d5e8c",
      "range": {
        "startLine": 698,
        "startChar": 8,
        "endLine": 698,
        "endChar": 20
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb9799a0_5e85d417",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 753,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2017-11-04T01:57:22Z",
      "side": 1,
      "message": "Can you put the following block in a helper function and call it from the array for() loop?",
      "range": {
        "startLine": 753,
        "startChar": 4,
        "endLine": 753,
        "endChar": 8
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "181a2b0d_26b8f1e0",
        "filename": "src/libANGLE/UniformLinker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 753,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-11-06T00:57:31Z",
      "side": 1,
      "message": "Refactored for more code re-use.",
      "parentUuid": "cb9799a0_5e85d417",
      "range": {
        "startLine": 753,
        "startChar": 4,
        "endLine": 753,
        "endChar": 8
      },
      "revId": "dd3a2c8a0ba996641d35e6370e1a7c65775033b3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}