{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "03196402_e9aa7271",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T18:24:45Z",
      "side": 1,
      "message": "I don\u0027t know if there is a bug here, but sounds a bit suspicious, given mNumSyncs is 3. The way I was thinking this:\n```\n    std::array\u003cGLsync, mMaxOffscreenBufferCount\u003e mOffscreenSyncs                       \u003d {};\n```\nAnd then you just wait for `mOffscreenSyncs[(mTotalFrameCount-2) % mMaxOffscreenBufferCount]`",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 231,
        "endChar": 0
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e28cb8b_2b2a74d8",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T19:11:52Z",
      "side": 1,
      "message": "This doesn\u0027t work, mMaxOffscreenBufferCount is 2 so mTotalFrameCount-2 % 2 is just mTotalFrameCount % 2.\n\nThe way I understood your suggestion is:\n\n1. current frame N\n2. previous frame N-1\n3. frame N-2\n\nWhich is why I have 3 syncs (but I might be getting something backwards).",
      "parentUuid": "03196402_e9aa7271",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 231,
        "endChar": 0
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b6917d_660cecc9",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T19:34:15Z",
      "side": 1,
      "message": "This is exactly what you want: Its is ping-pong between two buffers. Before you encode a frame that renders to buffer i (i being 0 or 1), you need to wait previous render to finish. So you end up waiting for mOffscreenSyncs[mTotalFrameCount % 2] is correct.",
      "parentUuid": "5e28cb8b_2b2a74d8",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 231,
        "endChar": 0
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b865bca_e6cbb11f",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T19:37:39Z",
      "side": 1,
      "message": "You can make it a struct\n```\nstruct OffscreenFrameBuffer {\nGLuint mFramebuffer;\nGLuint mTexture;\nGLsync mSync;\n};\nstd::array\u003cOffscreenFrameBuffer, mMaxOffscreenBufferCount\u003e mOffscreenFramebuffers;\n```\nIt will be cleaner and easier to understand as well, I think.",
      "parentUuid": "e6b6917d_660cecc9",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 231,
        "endChar": 0
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fab8146_585182df",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T22:23:22Z",
      "side": 1,
      "message": "I kept data as is for now to keep CL simple, as e.g. `mOffscreenFramebuffers.data()` is used directly in a couple of places, but I can refactor in a follow up CL.",
      "parentUuid": "4b865bca_e6cbb11f",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 231,
        "endChar": 0
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1315cc6d_2ef5d72c",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2167,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T18:24:45Z",
      "side": 1,
      "message": "This is redundant",
      "range": {
        "startLine": 2167,
        "startChar": 70,
        "endLine": 2167,
        "endChar": 79
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "011a16c9_3a8d4f41",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2167,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T19:11:52Z",
      "side": 1,
      "message": "That\u0027s to account for negative numbers, -1 % N is -1",
      "parentUuid": "1315cc6d_2ef5d72c",
      "range": {
        "startLine": 2167,
        "startChar": 70,
        "endLine": 2167,
        "endChar": 79
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e48aefb7_1a007b4d",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2170,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T18:24:45Z",
      "side": 1,
      "message": "-1. You should keep waiting until it is done.",
      "range": {
        "startLine": 2170,
        "startChar": 67,
        "endLine": 2170,
        "endChar": 85
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1bf359ac_b1f421d6",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2170,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T19:11:52Z",
      "side": 1,
      "message": "It does block until it\u0027s done. Actually GL_TIMEOUT_IGNORED might not be meant to be used with this call. Replaced with a 1s constant. Same behavior.",
      "parentUuid": "e48aefb7_1a007b4d",
      "range": {
        "startLine": 2170,
        "startChar": 67,
        "endLine": 2170,
        "endChar": 85
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91f3684e_e1b5127c",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T18:24:45Z",
      "side": 1,
      "message": "To simulate native_surface\u0027s behavior, you should add sync here, and wait at line 2119.",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "fixSuggestions": [
        {
          "fixId": "2654b077_62f83ff3",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "src/tests/perf_tests/TracePerfTest.cpp",
              "range": {
                "startLine": 2173,
                "startChar": 0,
                "endLine": 2173,
                "endChar": 0
              },
              "replacement": "           GLsync sync \u003d\n               mOffscreenSyncs[(mTotalFrameCount - (mNumSyncs - 1) + mNumSyncs) % mNumSyncs];\n           if (sync)\n           {\n               glClientWaitSync(sync, GL_SYNC_FLUSH_COMMANDS_BIT, GL_TIMEOUT_IGNORED);\n               glDeleteSync(sync);\n           }\n"
            }
          ]
        }
      ],
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "132b2f94_6260815d",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T19:11:52Z",
      "side": 1,
      "message": "oh, I thought we need to wait right before glBlitFramebuffer, as that\u0027s where we\u0027ll be reading the offscreen frame pixels. Line 2119 binds the offscreen framebuffer for writing. So we want blocking to happen before we start _writing_ not reading?",
      "parentUuid": "91f3684e_e1b5127c",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8563905e_6f225d02",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T19:34:15Z",
      "side": 1,
      "message": "Right. Before we call replayFrame (which end up using CPU to write to buffer).\n\nAlso, you don\u0027t need to glDeleteSync. You can keep reusing them",
      "parentUuid": "132b2f94_6260815d",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfe6d1dc_ad399162",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T20:36:09Z",
      "side": 1,
      "message": "(as discussed offline need the delete sync stuff as it seems sync objects can\u0027t be un-signaled)\n\nI\u0027m still unsure at which point I need to insert the fence. Waiting before writing to the offscreen framebuffer makes sense, so that we don\u0027t corrupt the data that is currently being used. But does this mean we need to insert the fence _after_ glBlitFramebuffer? Or maybe even further down, like after glFlush? glBlitFramebuffer grabs pixels from the offscreen framebuffer, so we don\u0027t want those to be changed until glBlitFramebuffer completely finishes.. right? (I feel I might missing some details about CPU vs GPU completion to reason about this)",
      "parentUuid": "8563905e_6f225d02",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e00ce92_69a42571",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-09-27T20:46:37Z",
      "side": 1,
      "message": "\u003e does this mean we need to insert the fence after glBlitFramebuffer? Or maybe even further down, like after glFlush?\nBefore or after blitFB is all fine. I personally prefer before blitFB, mainly because that is the point of time where the fence would be inserted if you are running on screen. But either way will give you correct result.\n\n\u003e so we don\u0027t want those to be changed until glBlitFramebuffer completely finishes.. right? \nRight, but no matter where you insert fence, they will not change. Everything you call in a single context should be serialized. BlitFB implementation (i.e, ANGLE) will ensure it the blit does not occur after rendering. The problem we try to fix here is the application\u0027s CPU access to buffer, which is out of ANGLE\u0027s control.",
      "parentUuid": "cfe6d1dc_ad399162",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6044d98_385829ac",
        "filename": "src/tests/perf_tests/TracePerfTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2172,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-09-27T22:23:22Z",
      "side": 1,
      "message": "Thanks for the explanation! I did as you suggested.",
      "parentUuid": "7e00ce92_69a42571",
      "range": {
        "startLine": 2166,
        "startChar": 12,
        "endLine": 2172,
        "endChar": 13
      },
      "revId": "f5d7fe30ce46e485c07312d4be89718777ec2b39",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}