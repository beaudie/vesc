{
  "comments": [
    {
      "key": {
        "uuid": "7c56de1e_1a07b619",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 14
      },
      "lineNbr": 208,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "nit: you should be able to use AllShaderTypes for this purpose instead of making the custom type?",
      "range": {
        "startLine": 206,
        "startChar": 0,
        "endLine": 208,
        "endChar": 89
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "120aea16_e7b4eb93",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 14
      },
      "lineNbr": 613,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "again, why not use the manager like we do for Framebuffers?",
      "range": {
        "startLine": 606,
        "startChar": 0,
        "endLine": 613,
        "endChar": 32
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "65fcaafd_a2f4f85f",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 14
      },
      "lineNbr": 1187,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "Would it make sense for the program to create a PPO that points to itself, and bind it instead of recreating the PPO on every program change? That would make program switching faster.",
      "range": {
        "startLine": 1185,
        "startChar": 0,
        "endLine": 1187,
        "endChar": 29
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c71e082e_c0583971",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 14
      },
      "lineNbr": 676,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "I\u0027m not sure why you needed to add a handle allocator and map here when we already have a resource manager type for program pipelines. What features or tests did this add/fix?",
      "range": {
        "startLine": 673,
        "startChar": 0,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac7c39cd_2d7e7b23",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 14
      },
      "lineNbr": 676,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-01-21T22:38:48Z",
      "side": 1,
      "message": "The first problem I hit was that the *TypedResourceManager::checkObjectAllocation() doesn\u0027t allow allocating an object with an ID of \u00270\u0027:\nhttps://cs.corp.google.com/cobalt/third_party/angle/src/libANGLE/ResourceManager.h?rcl\u003d4958bb9377ab7ee580a8c993f31eb14d2a57d91a\u0026l\u003d96\n\nRather than trying to workaround this within TypedResourceManager, I took your suggestion to follow the default vertex array implementation a bit further by mirroring it as closely as possible with the hope that that code has been pretty well hardened by now.   This lets me essentially copy what\u0027s already being done for vertex arrays in places like the declaration, how the default program pipeline is allocated when the Context is init\u0027ed, and so on:\n\n    ResourceMap\u003cVertexArray, VertexArrayID\u003e mVertexArrayMap;\n    HandleAllocator mVertexArrayHandleAllocator;\n...\n    bindVertexArray({0});\n    bindProgramPipeline({0});",
      "parentUuid": "c71e082e_c0583971",
      "range": {
        "startLine": 673,
        "startChar": 0,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51acc5b6_4c09b435",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 533,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "how come you need to store the translated sources in the state now?",
      "range": {
        "startLine": 533,
        "startChar": 4,
        "endLine": 533,
        "endChar": 50
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a98bff3_1ef1821c",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 533,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-01-21T22:38:48Z",
      "side": 1,
      "message": "(The following will be updated in the doc.)\n\nWith the change to get the translated source at draw time, rather than link time, we need to keep the source around in case the shader is detached before the draw call is issued.   The glCreateShaderProgramv() documentation gives a good example how this scenario:\n\n    const GLuint shader \u003d glCreateShader(type);\n    if (shader) {\n        glShaderSource(shader, count, strings, NULL);\n        glCompileShader(shader);\n        const GLuint program \u003d glCreateProgram();\n        if (program) {\n            GLint compiled \u003d GL_FALSE;\n            glGetShaderiv(shader, GL_COMPILE_STATUS, \u0026compiled);\n            glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);\n            if (compiled) {\n                glAttachShader(program, shader);\n                glLinkProgram(program);\n                glDetachShader(program, shader);   \u003c\u003c---- The problem call.\n            }\n            /* append-shader-info-log-to-program-info-log */\n        }\n        glDeleteShader(shader);\n        return program;\n    } else {\n        return 0;\n    }\n\nWhile this is how glCreateShaderProgramv() is intended to behave (and so is specific to program pipelines), there are also several dEQP (and likely end2end) tests that behave this way as well - including some that are intended to specifically test that a program without any shaders attached can still be used to draw.\n\nUnfortunately, this causes problems in GlslangGetShaderSource() which assumes that the shaders are still attached when that\u0027s called:\nhttps://cs.corp.google.com/cobalt/third_party/angle/src/libANGLE/renderer/glslang_wrapper_utils.cpp?rcl\u003d4958bb9377ab7ee580a8c993f31eb14d2a57d91a\u0026l\u003d1056\n\nSo, we need to keep that source around when the shader is detached so we can come back later and re-generate the translated source code.   Note, there is a lot of other work that\u0027s required in the back end to get the rest of the functions in there (AssignUniformBindings, AssignTextureBindings, etc.) to work correctly, which is part of the actual program pipeline implementation CL.   This particular piece is just necessary for the changes to allow deferring getting the shader source until draw time.",
      "parentUuid": "51acc5b6_4c09b435",
      "range": {
        "startLine": 533,
        "startChar": 4,
        "endLine": 533,
        "endChar": 50
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "275d7ec4_ef23b8f1",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 533,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "As a transitory measure, I think it would be best if you kept the untranslated sources in ProgramVk itself at link time. Then the ProgramPipelineVk object can get those sources from ProgramVk.",
      "parentUuid": "6a98bff3_1ef1821c",
      "range": {
        "startLine": 533,
        "startChar": 4,
        "endLine": 533,
        "endChar": 50
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1102e0b5_6f68620b",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 1018,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "preference to make these just non-member normal global functions. Making them static members usually doesn\u0027t make them cleaner. Also statics should be Capitalized:\n\nhttps://chromium.googlesource.com/angle/angle/+/master/doc/CodingStandard.md#naming",
      "range": {
        "startLine": 1005,
        "startChar": 0,
        "endLine": 1018,
        "endChar": 62
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9af7bc92_5167829a",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 1159,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "hopefully we can find a design that doesn\u0027t need to keep this around.",
      "range": {
        "startLine": 1159,
        "startChar": 4,
        "endLine": 1159,
        "endChar": 59
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db2dd617_b9fff5a6",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 1159,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-01-21T22:38:48Z",
      "side": 1,
      "message": "Yeah, this is a tough one though.\n\nThe problem is that the ProgramLinkedResources is filled in by the front end during Program::link(), but is required by the program pipeline in the backend during draw time (just after creating the pipeline layout).   The shader\u0027s source needs to be updated after the pipeline layout is created, since that\u0027s how the descriptor set/binding values are determined.\n\nMaking this a member variable was the most straightforward way to keep this data around in a way that could be queried for each program in the pipeline when the draw command was eventually issued some time after the initial link.   Unfortunately, the program pipeline can\u0027t be used, since the glLinkProgram can occur before any glUseProgram, so the program isn\u0027t in any pipeline (default or otherwise) yet.",
      "parentUuid": "9af7bc92_5167829a",
      "range": {
        "startLine": 1159,
        "startChar": 4,
        "endLine": 1159,
        "endChar": 59
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7852110_c18ad566",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 14
      },
      "lineNbr": 1159,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "Doesn\u0027t the PPO kind of need to do a full relink? That is, it should create its own ProgramLinkedResources independently from the programs, shouldn\u0027t it?",
      "parentUuid": "db2dd617_b9fff5a6",
      "range": {
        "startLine": 1159,
        "startChar": 4,
        "endLine": 1159,
        "endChar": 59
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18032bbc_a07f7661",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 64,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "trying to understand what this corresponds to in the spec.",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 34
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4d80ff4_863dad4a",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 64,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-01-21T22:38:48Z",
      "side": 1,
      "message": "glActiveShaderProgram\nhttps://www.khronos.org/registry/OpenGL-Refpages/es3.1/html/glActiveShaderProgram.xhtml\n\nUsing a pointer (rather than storing the ID) just makes it easier to handle glUniform calls since it removes the need to loop through the programs in the pipeline to find the matching ID for each glUniform call.",
      "parentUuid": "18032bbc_a07f7661",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 34
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5d83354_c6839289",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 67,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "aren\u0027t the stages defined per program? i.e. we pull fragment from this program, vertex from another, etc.",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 37
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b9954a6_6d68ed61",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 67,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-01-21T22:38:48Z",
      "side": 1,
      "message": "This bitfield is intended to track which stages the program pipeline currently has programs bound for.   This CL doesn\u0027t require this information, however it is necessary for the full program pipeline implementation in the backend:\n\nProgramPipeline.h\n    size_t getLinkedShaderStageCount() const { return mState.mLinkedShaderStages.count(); }\n\nProgramPipelineVk::createPipelineLayout()\n{\n...\n    // Initialize descriptor pools.\n    std::array\u003cVkDescriptorPoolSize, 2\u003e uniformAndXfbSetSize \u003d {\n        {{VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,\n          static_cast\u003cuint32_t\u003e(glPipeline-\u003egetLinkedShaderStageCount())},\n         {VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, gl::IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS}}};\n...\n    mDynamicBufferOffsets.resize(glPipeline-\u003egetLinkedShaderStageCount());\n\nWe don\u0027t actually need to know the exact shader stages (the count is all we care about), but this mirrors what\u0027s currently being done in Program.h and ProgramVk::linkImpl().",
      "parentUuid": "b5d83354_c6839289",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 37
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85e0176c_52e7053d",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 125,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "Don\u0027t forget GEOMETRY!",
      "range": {
        "startLine": 125,
        "startChar": 8,
        "endLine": 125,
        "endChar": 39
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84e1ab64_0c402b1a",
        "filename": "src/libANGLE/ProgramPipeline.h",
        "patchSetId": 14
      },
      "lineNbr": 148,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-01-21T21:21:22Z",
      "side": 1,
      "message": "I was thinking a lot of ProgramState might move into ProgramPipelineState at some point. maybe in a later CL. Seems at least this should be in ProgramPipelineState rather than ProgramPipeline.",
      "range": {
        "startLine": 147,
        "startChar": 1,
        "endLine": 148,
        "endChar": 46
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b92909d4_011b1461",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 14
      },
      "lineNbr": 1065,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "You can enclose this in an `if (mProgramPipeline-\u003eneedsLink())` (with that function inline) to keep this as cheap as possible when no draw-time linking is needed.",
      "range": {
        "startLine": 1061,
        "startChar": 0,
        "endLine": 1065,
        "endChar": 49
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08a61fff_1fe8c224",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 14
      },
      "lineNbr": 1095,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "You probably don\u0027t want to be doing this on every bind. If you keep this call where it previously was, `updateUniforms` itself can check if needs to createLayout+relink.",
      "range": {
        "startLine": 1095,
        "startChar": 4,
        "endLine": 1095,
        "endChar": 54
      },
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1d667864_16d7d375",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 14
      },
      "lineNbr": 2766,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "Why?",
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6b5f851_e51eae1d",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 14
      },
      "lineNbr": 2799,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "Ideally shouldn\u0027t need these.",
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd210aef_ca8ef432",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 14
      },
      "lineNbr": 508,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-01-22T16:45:50Z",
      "side": 1,
      "message": "nit: Did you by any chance use a software that rewrapped the comments and maybe it didn\u0027t use 100 width?",
      "revId": "d33f2c406289664de50b99e8ee5c40116867f925",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}