{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e1117ede_1cf52f4b",
        "filename": "src/libANGLE/renderer/vulkan/ResourceVk.h",
        "patchSetId": 12
      },
      "lineNbr": 249,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-09-14T17:02:03Z",
      "side": 1,
      "message": "This should move to around line 199.",
      "range": {
        "startLine": 249,
        "startChar": 18,
        "endLine": 249,
        "endChar": 34
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff9964a2_3d93b733",
        "filename": "src/libANGLE/renderer/vulkan/ResourceVk.h",
        "patchSetId": 12
      },
      "lineNbr": 249,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-09-14T20:00:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e1117ede_1cf52f4b",
      "range": {
        "startLine": 249,
        "startChar": 18,
        "endLine": 249,
        "endChar": 34
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bd4a059_4bf0a251",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 991,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-09-14T17:02:03Z",
      "side": 1,
      "message": "This looks like redundent? since it is defined as:\nbool CommandBufferHelper::usesBuffer(const BufferHelper \u0026buffer) const\n{\n    return mUsedBuffers.contains(buffer.getBufferSerial().getValue());\n}",
      "range": {
        "startLine": 991,
        "startChar": 68,
        "endLine": 991,
        "endChar": 92
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9cbf900d_e1ee12ca",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 991,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-09-14T20:00:30Z",
      "side": 1,
      "message": "Yeah, I think it can be removed.",
      "parentUuid": "0bd4a059_4bf0a251",
      "range": {
        "startLine": 991,
        "startChar": 68,
        "endLine": 991,
        "endChar": 92
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ee44a8c_86be8f13",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-09-14T17:02:03Z",
      "side": 1,
      "message": "What if both mReadWriteUse and mReadOnlyUse are busy, but mReadWriteUse is after mReadOnlyUse? I think this will free memory based on mReadOnlyUse and causing mReadWriteUse to generate GPU fault. With your new model that tracks ReadOnly and ReadWrite completely independently, I think you need to find out which is the last use and call collectGarbageAndReinit on the very last use.",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d959c582_148d30b9",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-09-14T20:00:30Z",
      "side": 1,
      "message": "I initially went down that path also, but I don\u0027t think it\u0027s necessary based on Shabi\u0027s discussion about how/when BufferHelper::release() is called.\n\nBufferHelper::release() is only called during glDeleteBuffers(), after which the buffer can\u0027t be used anymore.   So, if the buffer is used at all (for either read or readWrite), we don\u0027t really care which it is since they\u0027ll both have to be as part of the \"next\" serial anyway (the serial generated in the next submission, which the buffer is used in).   This means both mReadOnlyUse and mReadWriteUse will have the same final serial value to indicate the buffer can be destroyed, since the buffer can\u0027t be retain()\u0027ed anymore after it\u0027s been glDeleteBuffers()\u0027ed.\n\nThat\u0027s my understanding of how things work anyway.   Let me know if there\u0027s a gap I\u0027m missing somewhere.",
      "parentUuid": "4ee44a8c_86be8f13",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c6df9da_de17c179",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-09-14T20:20:54Z",
      "side": 1,
      "message": "\u003e What if both mReadWriteUse and mReadOnlyUse are busy, but mReadWriteUse is after mReadOnlyUse?\n\nWithout having reviewed the latest changes, I imagine you still have the \"any\" use that\u0027s always retained, including when the buffer is used as read-write. So the mReadWriteUse\u0027s serial cannot be after that. Is that not the case? If not, it could be problematic; I think in the read-write case both \"use\"s should be retained.\n\nThen we can ASSERT that the read-write use\u0027s serial is always \u003c\u003d any use\u0027s serial.\n\n(sorry if that\u0027s completely wrong based on the latest changes. I\u0027ll review the change soon)",
      "parentUuid": "d959c582_148d30b9",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "966ca571_badd057c",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-09-14T20:21:59Z",
      "side": 1,
      "message": "\u003e This means both mReadOnlyUse and mReadWriteUse will have the same final serial value to indicate the buffer can be destroyed, since the buffer can\u0027t be retain()\u0027ed anymore after it\u0027s been glDeleteBuffers()\u0027ed.\n\nThis is the part I don\u0027t think it true though: Lets say this buffer is used in serial 10 as ReadOnly, flush, then used as ReadWrite in serial 11, flush, and then deleteBuffer. At this time, GPU is way behind, still working on serial 9. Now this if check will return true and collectGarbageAndReinit() is called on serial 10. This means as soon as serial 10 is finished, the buffer memory will be freed. Now GPU execute serial 11 and try to write to buffer and get access error.\n\nIn the past patchsets, mReadWriteUse was tracking read or write, then yes you only need to check mReadWriteUse, since this is always updated regardless it is read or write. But now mReadOnlyUse is tracking read and mReadWriteUse is tracking writes, and mReadOnlyUse is not being updated from retainReadWrite, I think you do need to figure out who is the last use, right?",
      "parentUuid": "d959c582_148d30b9",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6411883_3ca14bee",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-09-14T20:24:57Z",
      "side": 1,
      "message": "I think Shabi is saying the same thing. The problem is this patchset, there isn\u0027t a mUse that tracking \"Any\" use.",
      "parentUuid": "966ca571_badd057c",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "babbfc67_7cbf3f1a",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 12
      },
      "lineNbr": 3679,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-09-14T20:29:53Z",
      "side": 1,
      "message": "My fault, I had asked for this specifically to try and device the serials to be more singular.\n\nIs there a test that could reproduce any failure? Having one less retain call should save cycles if we retain more than we check if something is in use.",
      "parentUuid": "c6411883_3ca14bee",
      "range": {
        "startLine": 3674,
        "startChar": 4,
        "endLine": 3679,
        "endChar": 29
      },
      "revId": "d332b0a954815c43337abade0dd2ba86a4dbfee6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}