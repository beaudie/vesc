{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b5d9c6af_b92b493c",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-02T13:22:41Z",
      "side": 1,
      "message": "I might be missing something.. isn\u0027t this normally done via template specialization instead?",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fd48f4b_45402154",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-02T16:55:41Z",
      "side": 1,
      "message": "Not exactly sure what template specialization you mean here, but my understanding is that you will need to refactor the function etc. There maybe other ways to do this, but I think the way I am doing here is cleaner and less code diff and easier to read. The `if constexpr` check here will be compile time check, there is no run time cost here.",
      "parentUuid": "b5d9c6af_b92b493c",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e84692a8_4211bd44",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-02T18:10:56Z",
      "side": 1,
      "message": "I meant\n```\n\u003cA\u003e func { doAstuff(); }\n\u003cB\u003e func { doBstuff(); }\n```\nyeah with compile checks it will result in the same binary, just a matter of readability. No strong opinions, just wondering if having to resort to constexpr checks might be a sign that the code should be structured differently?..",
      "parentUuid": "4fd48f4b_45402154",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9f1363a_ce2af7f7",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-02T18:24:06Z",
      "side": 1,
      "message": "I could move `vk::CommandBufferAccess access` to ContextVk::handleDirtyComputeUniformBuffers() and then pass in commandBufferHelperOrAcess to this function, then I can remove this `if constexpr` check, but you will still have to have the if check in line 2820. It really did not save you from much code duplication. I tried this earlier, but personally I like this slightly better, mainly because it is a bit odd to define access and without using it, just pass to handleDirtyComputeUniformBuffers call is a bit wierd. And it did not make this function more cleaner since I still end up have to do this if constexpr check anway.",
      "parentUuid": "e84692a8_4211bd44",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcf91f9b_651f16fe",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-03T14:52:18Z",
      "side": 1,
      "message": "Hoping for input from Shabi here, I was thinking this could be split into specializations like\n```\n\u003cRenderPassCommandBufferHelper\u003ehandleDirtyUniformBuffersImpl() { ... }\n\u003cOutsideRenderPassCommandBufferHelper\u003ehandleDirtyUniformBuffersImpl() { ... }\n```\nwhich I think would avoid the constexpr spaghetti but cause some code duplication; unless there is a way to avoid this duplication yeah it might be close.",
      "parentUuid": "e9f1363a_ce2af7f7",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92005562_d7c056f8",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "I need to understand better what the problem is. What the description says is _exactly_ why `glMemoryBarrier` exists. There is a whole machinery for closing the render pass after a `glMemoryBarrier` and only when necessary so we don\u0027t have to have this complication and cost.\n\nIt may be that we need something special for atomic counter buffers if that needs automatic synchronization, but I\u0027d rather have specialized code for atomic counter buffers that do extra checks rather than something generic to redo what `glMemoryBarrier` does.\n\nMaybe the problem here then is that dawn is missing `glMemoryBarrier`.",
      "parentUuid": "bcf91f9b_651f16fe",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d4c498e_fef28722",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "Missing `glMemoryBarrier(SHADER_STORAGE_BARRIER_BIT)` here.",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "273fec2d_d762a2d3",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 964,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "I thought there\u0027d be a need for an explicit barrier here, but I guess not üòê",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}