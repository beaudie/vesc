{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b5d9c6af_b92b493c",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-02T13:22:41Z",
      "side": 1,
      "message": "I might be missing something.. isn\u0027t this normally done via template specialization instead?",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fd48f4b_45402154",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-02T16:55:41Z",
      "side": 1,
      "message": "Not exactly sure what template specialization you mean here, but my understanding is that you will need to refactor the function etc. There maybe other ways to do this, but I think the way I am doing here is cleaner and less code diff and easier to read. The `if constexpr` check here will be compile time check, there is no run time cost here.",
      "parentUuid": "b5d9c6af_b92b493c",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e84692a8_4211bd44",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-02T18:10:56Z",
      "side": 1,
      "message": "I meant\n```\n\u003cA\u003e func { doAstuff(); }\n\u003cB\u003e func { doBstuff(); }\n```\nyeah with compile checks it will result in the same binary, just a matter of readability. No strong opinions, just wondering if having to resort to constexpr checks might be a sign that the code should be structured differently?..",
      "parentUuid": "4fd48f4b_45402154",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9f1363a_ce2af7f7",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-02T18:24:06Z",
      "side": 1,
      "message": "I could move `vk::CommandBufferAccess access` to ContextVk::handleDirtyComputeUniformBuffers() and then pass in commandBufferHelperOrAcess to this function, then I can remove this `if constexpr` check, but you will still have to have the if check in line 2820. It really did not save you from much code duplication. I tried this earlier, but personally I like this slightly better, mainly because it is a bit odd to define access and without using it, just pass to handleDirtyComputeUniformBuffers call is a bit wierd. And it did not make this function more cleaner since I still end up have to do this if constexpr check anway.",
      "parentUuid": "e84692a8_4211bd44",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcf91f9b_651f16fe",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2023-10-03T14:52:18Z",
      "side": 1,
      "message": "Hoping for input from Shabi here, I was thinking this could be split into specializations like\n```\n\u003cRenderPassCommandBufferHelper\u003ehandleDirtyUniformBuffersImpl() { ... }\n\u003cOutsideRenderPassCommandBufferHelper\u003ehandleDirtyUniformBuffersImpl() { ... }\n```\nwhich I think would avoid the constexpr spaghetti but cause some code duplication; unless there is a way to avoid this duplication yeah it might be close.",
      "parentUuid": "e9f1363a_ce2af7f7",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92005562_d7c056f8",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 2800,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "I need to understand better what the problem is. What the description says is _exactly_ why `glMemoryBarrier` exists. There is a whole machinery for closing the render pass after a `glMemoryBarrier` and only when necessary so we don\u0027t have to have this complication and cost.\n\nIt may be that we need something special for atomic counter buffers if that needs automatic synchronization, but I\u0027d rather have specialized code for atomic counter buffers that do extra checks rather than something generic to redo what `glMemoryBarrier` does.\n\nMaybe the problem here then is that dawn is missing `glMemoryBarrier`.",
      "parentUuid": "bcf91f9b_651f16fe",
      "range": {
        "startLine": 2800,
        "startChar": 8,
        "endLine": 2800,
        "endChar": 93
      },
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d4c498e_fef28722",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "Missing `glMemoryBarrier(SHADER_STORAGE_BARRIER_BIT)` here.",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56f5ca90_30bb1125",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-03T17:20:52Z",
      "side": 1,
      "message": "That is not required based on my read of spec. https://registry.khronos.org/OpenGL/specs/es/3.2/es_spec_3.2.pdf\nSection 7.11.2 Shader Memory Access Synchronization\n```\nExplicit synchronization is required to ensure that the effects of buffer and texture data stores performed by shaders will be visible to subsequent operations using\nthe same objects and will not overwrite data still to be read by previously requested\noperations.\n```\nAnd\n```\nbarriers is a bitfield indicating\nthe set of operations that are synchronized with shader stores; the bits used in\nbarriers are as follows:\n```\nSo my understanding here is that glMemoryBarrier call is to ensure previous *shader store* is visible to the operation after barrier. In this case, there is no previus shader store. There is only shader reads (as uniform buffer). Thus glMemoryBarrier call is not required here. That is what dawn is doing. And this test also passes on all native GLES (except pixel4) on bots.\n\nAnd this usage case (read access in renderPass followed by compute write) is exactly this CL try to fix.",
      "parentUuid": "4d4c498e_fef28722",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c355410_95e3b591",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-03T17:26:19Z",
      "side": 1,
      "message": "And\n```\nGL_SHADER_STORAGE_BARRIER_BIT\nAccesses to shader storage blocks after the barrier will reflect writes prior to the barrier.\n```\n\nIt did not say \"Accesses to shader storage blocks after the barrier will occur after all reads before the barrier\". It only says `writes prior to the barrier`",
      "parentUuid": "56f5ca90_30bb1125",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d743aba_bc059fd8",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T17:39:09Z",
      "side": 1,
      "message": "That last quote is not complete. The spec itself says:\n\n\u003e SHADER_STORAGE_BARRIER_BIT: Memory accesses using shader buffer variables issued after the barrier will reflect data written by shaders prior to the barrier. Additionally, assignments to and atomic operations performed on shader buffer variables after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.\n\nThere\u0027s a similar one for image access (`SHADER_IMAGE_ACCESS_BARRIER_BIT`). Basically all the bits synchronize \"shader write, then something else\", except `SHADER_STORAGE_BARRIER_BIT` and `SHADER_IMAGE_ACCESS_BARRIER_BIT` also synchronize \"anything, then shader write\".",
      "parentUuid": "2c355410_95e3b591",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c472d91_b5315fa6",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 900,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-10-03T17:47:14Z",
      "side": 1,
      "message": "mm, I thought that later part was referring to atomic counter buffer operation.\nLets me send the bug back to dawn then and move this to WIP for now.",
      "parentUuid": "8d743aba_bc059fd8",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "273fec2d_d762a2d3",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 7
      },
      "lineNbr": 964,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-10-03T15:13:59Z",
      "side": 1,
      "message": "I thought there\u0027d be a need for an explicit barrier here, but I guess not 😐",
      "revId": "1c3de6102a8d2d8b11388092db343ccaacd1ccc1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}