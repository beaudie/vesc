{
  "comments": [
    {
      "key": {
        "uuid": "e2f5eb63_a2c556d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T14:40:57Z",
      "side": 1,
      "message": "This one I\u0027m not as sure about. It fixes the issues TSAN was complaining about and we probably do need to lock around writes to the serial info, but reads should be okay without locks. In the cases where we read the current serial we are just looking for something recent, doesn\u0027t have to be the latest.\nUnless it\u0027s possible to get interrupted during the read somehow, e.g. get half of one serial and other half of a different one.",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01568342_5039ccf2",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 508,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-18T14:46:20Z",
      "side": 1,
      "message": "same comment",
      "range": {
        "startLine": 508,
        "startChar": 24,
        "endLine": 508,
        "endChar": 32
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9b2e243_7d9f2ce9",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 508,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T17:14:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "01568342_5039ccf2",
      "range": {
        "startLine": 508,
        "startChar": 24,
        "endLine": 508,
        "endChar": 32
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef99c67b_da195146",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 577,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T15:46:24Z",
      "side": 1,
      "message": "Should we make these setters that live with the getters?   That may help in the future when someone is grepping the code and only sees them accessed via getters/setters that handle the locks for them.\n\nThe obvious drawback would be getting/releasing the lock multiple times to update each value in RendererVk::queueSubmit().",
      "range": {
        "startLine": 574,
        "startChar": 0,
        "endLine": 577,
        "endChar": 5
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3855cd7_6578a158",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 577,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T17:14:45Z",
      "side": 1,
      "message": "I thought about that, but there are only two places we set them and one of them touches multiple so figured it wasn\u0027t necessary.",
      "parentUuid": "ef99c67b_da195146",
      "range": {
        "startLine": 574,
        "startChar": 0,
        "endLine": 577,
        "endChar": 5
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b8a91059_6b5aa408",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2127,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-18T14:46:20Z",
      "side": 1,
      "message": "nit: probably can still inline these.",
      "range": {
        "startLine": 2112,
        "startChar": 0,
        "endLine": 2127,
        "endChar": 0
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3954846b_9fff4129",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2127,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T17:14:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b8a91059_6b5aa408",
      "range": {
        "startLine": 2112,
        "startChar": 0,
        "endLine": 2127,
        "endChar": 0
      },
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "32cf20a7_68769d71",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2297,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T15:46:24Z",
      "side": 1,
      "message": "This isn\u0027t holding the lock during the call to destroyIfComplete(), so either:\n\n1.) The lock isn\u0027t necessary here.\n- Hopefully this is the case, since it simplifies things a bit.\n\n2.) The lock is necessary, and needs to be acquired with the mGarbageMutex at the start of the function.\n- This exposes some trickiness that may come up in the future regarding the order that the mGarbageMutex and mQueueSerialMutex are acquired throughout the backend: they will always need to be acquired in the same order everywhere to avoid deadlocking.   I don\u0027t think we have any way to expose/enforce that to future developers, so hopefully we won\u0027t need both of these locks anywhere else.",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d955d59_37b43ab9",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2297,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T17:14:45Z",
      "side": 1,
      "message": "\u003e This isn\u0027t holding the lock during the call to destroyIfComplete(), so either:\nIt does, the lock(mGarbageMutex) at the top holds the lock for the duration of the function.\n\n\u003e This exposes some trickiness\nYeah. Truly you shouldn\u0027t need to lock around reading the last serial. As long as the read is an atomic operation at least. We don\u0027t need to have the absolute latest serial, just something recent.\nThat\u0027s why I made getters for these, that minimized the time the lock is held hopefully avoiding issues with multiple locks.\nIn a few cases I don\u0027t use the getter because I\u0027m accessing more than one element and didn\u0027t want to have to grab the lock multiple times.",
      "parentUuid": "32cf20a7_68769d71",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8e920f7_2b4271cc",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2297,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-18T20:49:50Z",
      "side": 1,
      "message": "\u003e We don\u0027t need to have the absolute latest serial, just something recent.\n\nThat doesn\u0027t sound right! Without a mutex, recent could potentially be as old as it can get.",
      "parentUuid": "6d955d59_37b43ab9",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0ef60cf_f91f3e2f",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2297,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T21:31:38Z",
      "side": 1,
      "message": "To catch you up Shabi, Courtney, Jamie, and I had a chat about this earlier this afternoon, and walked through the changes to get this more correct.   Courtney is going to put together a change that makes sure the accesses starting in ContextVk::flushImpl() are correctly locked, so we don\u0027t get interleaved Serial updates from multiple threads.",
      "parentUuid": "f8e920f7_2b4271cc",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ae0cd7c_47d1297b",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2297,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-21T15:54:45Z",
      "side": 1,
      "message": "Will do one getLastCompletedQueueSerial() outside the loop and use that value for the duration to reduce unnecessary locks to get the serial. We don\u0027t care about the exact value, just that it\u0027s recent.",
      "parentUuid": "6d955d59_37b43ab9",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6fb69d1_e99f18ff",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T15:46:24Z",
      "side": 1,
      "message": "Similar comment as above.   The lock is only held to get the current value, not while performing any logic based on that value.   Either the lock needs to be acquire for the duration of this block/function or mLastCompletedQueueSerial can be used directly.",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d191ea5e_5bf12337",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-18T17:14:45Z",
      "side": 1,
      "message": "I don\u0027t follow.\ngetLastCompletedQueueSerial will atomically grab the current serial which we use to compare with against mPendingOneOffCommands.front().serial. That\u0027s the only lock needed.\nWell, if multiple threads can call RendererVk::getCommandBufferOneOff may need to lock for mPendingOneOffCommands, I\u0027ll have to look at that.",
      "parentUuid": "d6fb69d1_e99f18ff",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f556ca8_419d9ad3",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T17:45:21Z",
      "side": 1,
      "message": "This version of the lock acquisition doesn\u0027t guarantee that mPendingOneOffCommands is being compared to a coherent value of mLastCompletedQueueSerial relative to all of the m*QueueSerial values.   Another thread could still sneak in between reading mPendingOneOffCommands and mLastCompletedQueueSerial with a call to RendererVk::queueSubmit(), making the value of mLastCompletedQueueSerial essentially random (but still \u0027good\u0027) in that regard.\n\nIf we really want a stable value of mLastCompletedQueueSerial, the lock needs to be acquired before the conditional.   However, I suspect the lock is not actually necessary at all and whatever value we get from mLastCompletedQueueSerial is fine, since it can always be updated the instant after it\u0027s used here anyway.",
      "parentUuid": "d191ea5e_5bf12337",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "596e415a_1d6e4dfe",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-18T20:49:50Z",
      "side": 1,
      "message": "One thing to note is that the with the mutex comes an implicit memory barrier. Without one, you could be reading an ancient value here while another thread is continuously updating it.",
      "parentUuid": "6f556ca8_419d9ad3",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fda4f3a1_69aa2f3c",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-18T21:31:38Z",
      "side": 1,
      "message": "That\u0027s also true, if the CPUs aren\u0027t sharing a coherent cache, and considering the breadth of devices that ANGLE runs on it\u0027s entirely possible.",
      "parentUuid": "596e415a_1d6e4dfe",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "078ef1f4_408a5095",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2367,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-21T15:54:45Z",
      "side": 1,
      "message": "Discussed offline.\nWe do need the lock to guarantee an atomic read of the value, that\u0027s not something C++ can do.\n\nJamie pointed out there is a related issue in ContextVk::flushImpl where the queueSerial applied to resources may not be the one that was actually used for the submit. Those operations need to be protected under a lock to ensure consistency.",
      "parentUuid": "6f556ca8_419d9ad3",
      "revId": "d6b553c76258daac82be7a8321f88c61dd908f72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}