{
  "comments": [
    {
      "key": {
        "uuid": "7ee41aea_c1220e15",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "It looks like the handling of atomics and SSBO access would be the same. Maybe we could have a single pass that simplifies uses of both atomics and ssbos? There shouldn\u0027t be any difference apart from the detection.",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1370a89f_7ce92bd5",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2018-09-14T08:05:51Z",
      "side": 1,
      "message": "As we decide to use RWByteAddressBuffer to implement SSBO now, actually we can avoid updating AST tree by using a wrapper function when treating atomic function calls on SSBO.\nThe wrapper function should be something like that:\n// https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sm5-object-rwbyteaddressbuffer-interlockedadd\nint atomicAdd(RWByteAddressBuffer buffer, uint offset, int val)\n{\n    int oldValue;\n    buffer.InterlockedAdd(offset, val, oldValue);\n    return oldValue;\n}",
      "parentUuid": "7ee41aea_c1220e15",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1df25753_2c766adf",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-17T09:08:22Z",
      "side": 1,
      "message": "I see, so that function combined with the comma operator removes the need for special transforms?",
      "parentUuid": "1370a89f_7ce92bd5",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "275d55cb_3d108ebe",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "instead of abusing the comma operator, would maybe we could separate the tempValue \u003d atomicAdd(counter, 1) statement like with case 1 and 3\n\nSame for array indexing",
      "range": {
        "startLine": 33,
        "startChar": 3,
        "endLine": 33,
        "endChar": 78
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb24c9af_c38eecd3",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "that seems reasonable",
      "parentUuid": "275d55cb_3d108ebe",
      "range": {
        "startLine": 33,
        "startChar": 3,
        "endLine": 33,
        "endChar": 78
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ab767d4_de2bc3e2",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2018-09-14T08:05:51Z",
      "side": 1,
      "message": "As we discussed https://bugs.chromium.org/p/angleproject/issues/detail?id\u003d2682\u0026desc\u003d2#c5, it should be much simpler to use comma operator when translating atomic function expressions in loop control statements (case 4), so shall we only use comma operator for case 4, and separate the tempValue \u003d atomicAdd(counter, 1) statement for case 1-3 as you mentioned?",
      "parentUuid": "fb24c9af_c38eecd3",
      "range": {
        "startLine": 33,
        "startChar": 3,
        "endLine": 33,
        "endChar": 78
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d38c2a8c_84a4540a",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-17T09:08:22Z",
      "side": 1,
      "message": "Sorry I didn\u0027t remember that discussion. Since comma would also be used for loops we should probably keep it for case 3 so we can test it in a simpler context too.",
      "parentUuid": "9ab767d4_de2bc3e2",
      "range": {
        "startLine": 33,
        "startChar": 3,
        "endLine": 33,
        "endChar": 78
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "deb27823_74968f3d",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "this should be false, false since we only do things on the PostVisit.",
      "range": {
        "startLine": 67,
        "startChar": 23,
        "endLine": 67,
        "endChar": 33
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86a7b128_538a8c5d",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "deb27823_74968f3d",
      "range": {
        "startLine": 67,
        "startChar": 23,
        "endLine": 67,
        "endChar": 33
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8773576_3cec80a2",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 76,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "nit: don\u0027t need auto here.",
      "range": {
        "startLine": 76,
        "startChar": 4,
        "endLine": 76,
        "endChar": 9
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d0f9a1f_f65bdbdb",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 94,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "As mentioned above, can we avoid using the comma operator and use a temporary variable instead?",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a71cfd87_065be14f",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "I\u0027m a bit worried about the caching of temporary node per type because it could break depending on how the operations are sequenced. If two atomics have the same type, then we could have the two atomic access done first then both values ued, which would give the wrong result.\n\nI don\u0027t think it would happen with the current code but it looks a bit fragile, and producing extra temporary variables should be fine. Can we remove caching?",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ff9bb0f_bf388cb4",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 135,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "Can you comment as to why we need this condition?",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57e02a14_7788b065",
        "filename": "src/compiler/translator/tree_ops/RewriteAtomicFunctionExpressions.cpp",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "nit: the chromium style guide asks simple types don\u0027t use auto.",
      "range": {
        "startLine": 152,
        "startChar": 4,
        "endLine": 152,
        "endChar": 8
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d60ae9a5_199250bc",
        "filename": "src/compiler/translator/tree_util/IntermTraverse.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "nit: you can use emplace_back",
      "range": {
        "startLine": 295,
        "startChar": 16,
        "endLine": 295,
        "endChar": 25
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cc7afd2_d64e6a3d",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1628,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "FYI \"can work\" would be \"works\" in idiomatic english, same thing with \"with this change the test can pass\" being \"with this change the test passes\".",
      "range": {
        "startLine": 1628,
        "startChar": 75,
        "endLine": 1628,
        "endChar": 83
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99e6a338_01cab95d",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1631,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "kCShader, kCSShader would mean kComputeShaderShader ^^ Same thing in other tests.",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f56d87f3_2805ad26",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1631,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "also this can be constexpr",
      "parentUuid": "99e6a338_01cab95d",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "396529b3_a6a18845",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1633,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "nitty, but you can unindent all this shader string block code. it makes the shader more readable when debugging too.",
      "range": {
        "startLine": 1633,
        "startChar": 0,
        "endLine": 1633,
        "endChar": 8
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13a34e4b_2a8f5759",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1680,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-09-11T20:59:41Z",
      "side": 1,
      "message": "nit: these can be constexpr too (and k prefixed)",
      "range": {
        "startLine": 1680,
        "startChar": 4,
        "endLine": 1680,
        "endChar": 10
      },
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6be0e9e_6b357c15",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1686,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "Verify using atomic functions inside expressions as unsigned int.",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "747f2c18_b380c652",
        "filename": "src/tests/gl_tests/ComputeShaderTest.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1734,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2018-09-11T11:54:41Z",
      "side": 1,
      "message": "Verify using nested atomic functions in expressions.",
      "revId": "7bbefacec78cb86c731e87b29e71954441c45069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}