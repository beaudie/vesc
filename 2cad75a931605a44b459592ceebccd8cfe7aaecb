{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0fc4f36f_29eb94ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-03-04T02:27:17Z",
      "side": 1,
      "message": "I am not sure if this is correct though: what if fence is not used, will this still get called? From what I read, it looks not.\n\nIf this hurts in fence status checking, I think we should pass in a flag to skip this if it get called from fence/query checking.",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b39fef8_1284ffb7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-03-04T02:28:11Z",
      "side": 1,
      "message": "Mark it unresolved",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33523228_0ce2b1d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-03-04T02:28:47Z",
      "side": 1,
      "message": "UnResolve",
      "parentUuid": "0fc4f36f_29eb94ef",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "596be522_18eb9c99",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-03-04T03:20:55Z",
      "side": 1,
      "message": "The very original change that added this excessive cmd buffer recycling at submitFrame was said to work around some long running test(didn’t say which). Later there was the throttling logic added below to force waiting if inflight is too high. IIUC, that throttle logic below should have covered the edge case that the app is neither doing on screen rendering nor checking syncs for offscreen rendering. It will retire those already waited being signaled. So I believe it’s never going to run unbound.",
      "tag": "mailMessageId\u003d\u003cCAKT\u003ddDkkfEaxjrgACfySSJ7PdAGVZOCWmxsMRvmQOdtsb2BOqA@mail.gmail.com\u003e",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fccd1d3_11899906",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-03-04T05:36:33Z",
      "side": 1,
      "message": "I was specifically referring to the lines below the one line removed by this CL:\n```\n    // CPU should be throttled to avoid mInFlightCommands from growing too fast. Important for\n    // off-screen scenarios.\n    if (mInFlightCommands.size() \u003e kInFlightCommandsLimit)\n    {\n        size_t numCommandsToFinish \u003d mInFlightCommands.size() - kInFlightCommandsLimit;\n        Serial finishSerial        \u003d mInFlightCommands[numCommandsToFinish].serial;\n        ANGLE_TRY(finishToSerial(context, finishSerial, renderer-\u003egetMaxFenceWaitTimeNs()));\n    }\n```\nIt caps the submited cmd batches at `50`. It\u0027s not big, and won\u0027t cause memory pressure for edge case tests that do not checking any syncs.\n\n`finishToSerial()` -\u003e `retireFinishedCommands()` \u003c- the same retire func used by `checkCompletedCommands()`.",
      "parentUuid": "33523228_0ce2b1d4",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54a0f24c_c30a4a1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-03-04T17:31:45Z",
      "side": 1,
      "message": "The problem is not just the memory pressure, it is also for performance. For example, bufferSubData code path check its\u0027 serial against mLastCompletedQueueSerial to see if previous GPU access is finished or not, if yes, then it go down the fast path. This CL will cause mLastCompletedQueueSerial 50 submissions behind, which means that code path will always go down the slow path. And also the garbage collection code rely on that to clean up garbages. There is strong motivation for ANGLE to know the GPU progress as much as possible. Right now this is the mechanism that ANGLE gets the GPU progress, so the implication is high.\n\nWe should look at the problem you ran into and see what\u0027s the best solution for you.",
      "parentUuid": "5fccd1d3_11899906",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ec2d7c1_9c73069e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-03-04T17:45:43Z",
      "side": 1,
      "message": "If the caller is something caring about performance, isn\u0027t the caller already doing onscreen rendering or offscreen with proper sync checking and latency control? which is the case for GFXBench and the various GL apps we care about.\n\nMy mental model is that this fallback throttle is for the mystery unknown test mentioned in the very original troduce of this check code in submitFrame. Later throttle logic added below should have already superceded the workaround to be removed here.\n\nThe main issue for virtualization is that we must try avoiding any Vulkan calls requiring synchronous true return from the host. This is the last piece in ANGLE causing trouble for us (I\u0027ve heard same happening for gfxstream as well, the overhead is ~300us per submit + the initial longer wait for the guest to catch up with host timeline. So on ARM with ANGLE\u0027s per pass submission, a complex app normally run into \u003e 10 submissions per frame. The performance delta is very non-trivial.)",
      "parentUuid": "54a0f24c_c30a4a1b",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "130bf605_7cbcd8bc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-05T07:23:21Z",
      "side": 1,
      "message": "Have you checked where `checkCompletedCommands` is called? It\u0027s in sync\u0027s `getStatus`, query\u0027s `getResult` and `submitFrame`. Basically if the application doesn\u0027t use sync or query objects (i.e. most apps with onscreen rendering), what this change removes was the only place we were checking for GPU progress. I think Charlie\u0027s concern is very real.\n\nI added a comment on the bug.",
      "parentUuid": "3ec2d7c1_9c73069e",
      "revId": "2cad75a931605a44b459592ceebccd8cfe7aaecb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}