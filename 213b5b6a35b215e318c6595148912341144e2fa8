{
  "comments": [
    {
      "key": {
        "uuid": "2b315e52_d1e46551",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-07-05T18:17:16Z",
      "side": 1,
      "message": "nit: it\u0027s -\u003e its",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3dc3c832_bce41369",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-05T19:21:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2b315e52_d1e46551",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "051956d3_90c1fbd1",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 130,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-07-05T18:17:16Z",
      "side": 1,
      "message": "If for any reason the key size changes (e.g. change of hash function), old disk cache entries will be invalid (that\u0027s fine), but we need to make sure we won\u0027t cause out-of-bounds accesses when trying to populate. We can of course add a check on the size in user code, but I wonder if we should pass the key size to eglQueryProgramCacheANGLE / eglPopulateProgramCacheANGLE (and have them issue errors if the key size doesn\u0027t match), to make it explicit?",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e6391fc_62dbf4dd",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 130,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-05T19:21:43Z",
      "side": 1,
      "message": "I don\u0027t think there\u0027s a good reason not to. I had it without the size to keep it a bit simpler, but you\u0027re right, the key size could change and there could be a mismatch. So I\u0027ll add it as a parameter and update the error text.",
      "parentUuid": "051956d3_90c1fbd1",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6ed24eb_af3371d6",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 201,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-07-05T18:17:16Z",
      "side": 1,
      "message": "Are there consequences that the user needs to deal with? Or is the query still guaranteed to return either a valid key/binary pair or an error?",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3085239a_05c463ac",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 201,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-05T19:21:43Z",
      "side": 1,
      "message": "No, there\u0027s no real consequences, at least for Chrome.\n\nI left this as undefined behaviour. For Chrome this isn\u0027t an issue, both because we don\u0027t use multithreading and we likely won\u0027t be using this API (I included it for completeness, and because it would seem odd to have just a populate without a query API). ANGLE will be passing binaries back to Chrome via the callback in the ANGLE platform.\n\nLMK if this seems reasonable. We could also look at including an internal mutex if necessary, which would allow us to generate an error if the cache changes, or the index becomes invalid.",
      "parentUuid": "e6ed24eb_af3371d6",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28dcf09e_f7c90b54",
        "filename": "extensions/EGL_ANGLE_program_cache_control.txt",
        "patchSetId": 3
      },
      "lineNbr": 201,
      "author": {
        "id": 1148065
      },
      "writtenOn": "2017-07-05T19:57:29Z",
      "side": 1,
      "message": "I think I would define it as \"always either return a valid key/binary pair, null, or an error, however that valid entry is not guaranteed to be in the cache nor a null key guaranteed to indicate an empty cache entry\".\nBasically, you can\u0027t know atomically the state of the cache, but a non-null key/binary is something valid and useful to store on disk (because it was in the cache at some point, even if it got evicted concurrently).\n\nNote that the callback would effectively have similar semantics.\n\nThis should be implementable with a mutex that has a very small scope (i.e. just accesses to the internal hash map), and whose cost is trivial compared to the cost of linking a program, but I\u0027ll leave it to you whether to actually do that or not in ANGLE given that it\u0027s only used single-threaded anyway.",
      "parentUuid": "3085239a_05c463ac",
      "revId": "213b5b6a35b215e318c6595148912341144e2fa8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}