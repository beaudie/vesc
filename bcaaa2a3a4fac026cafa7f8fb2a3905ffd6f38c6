{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "84e3a4a4_5195ed0a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-04T18:03:25Z",
      "side": 1,
      "message": "You don\u0027t need to do any such juggling! It should be much easier.\n\nFirst, observe ImageHelper::flushSingleSubresourceStagedUpdates, it does two things:\n\n1. Extract clears as \"deferred clears\" (only if clear is the only update)\n2. Flush staged updates (if no deferred clears were extracted)\n\nWhat this change is missing is that while the buffer is cleared, the clear update itself is not removed from ImageHelper, and that\u0027s what\u0027s causing all this trouble.\n\nSo my suggestion is to:\n\n-- Extract the first part of ImageHelper::flushSingleSubresourceStagedUpdates into its own function\n   * This function has only one job, and that\u0027s to extract deferred clears, if that\u0027s the only staged update\n-- In lock(), call this function, and if there\u0027s a clear staged, apply that to the buffer\n   * Note that the clear is no longer staged in the image\n   * You should ASSERT that there is no other update staged to the image\n-- Don\u0027t touch unlock()\n-- Nothing to do in makeCurrent()\n\nThat should do the trick.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 15,
        "endChar": 32
      },
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d6d39060_b8368ba4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 15,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-11-08T15:48:34Z",
      "side": 1,
      "message": "See new  ImageHelper::hasStagedClearUpdates.\nYep, we got too focused the late clear happening at the next draw.",
      "parentUuid": "84e3a4a4_5195ed0a",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 15,
        "endChar": 32
      },
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a265510f_8f6b5766",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 3867,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-04T18:03:25Z",
      "side": 1,
      "message": "I get the feeling we must have helpers for these. I don\u0027t see anything in src/image_util/ that would apply to all four cases though. Jamie?",
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10d7ac5a_70c5af30",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 3869,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-04T18:03:25Z",
      "side": 1,
      "message": "You should copy row-by-row and take rowStride into account.\n\nEither that, or (preferably) use mSize/pixelBytes instead of width*height.",
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b4898b0_2fb1f22e",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 3869,
      "author": {
        "id": 1359249
      },
      "writtenOn": "2021-11-08T15:48:34Z",
      "side": 1,
      "message": "I noticed that when the BufferHelper was filled from Surface that there was no row padding, they were packed. rowStride was always width*pixelBytes. Otherwise I expected to do a row by row copy/fill - hence the simple wxhxpb. I\u0027ll look into see if there are helpers first.\n\nAlso, the color I got from Clear Update was a colorF[4], I was expecting 0.0-1.0 UN float. But they are all 0.0 - 255.0!? and the int version of the color are not set - random nonsense.\n\n\u0027use mSize/pixelBytes instead\" - done",
      "parentUuid": "10d7ac5a_70c5af30",
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8a8b650_b3c67f35",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 3869,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-08T16:03:30Z",
      "side": 1,
      "message": "Ok, I was probably wrong. We are not filling the image, but rather the buffer. As long as the stride here is the same as the one put in VkBufferImageCopy::bufferRowLength, that\u0027s fine.\n\nIs it more robust to use `count / height` for stride? Or to simplify things, we can change it to ASSERT(width * height \u003d\u003d count) with a comment about stride.\n\n\u003e \u003e Also, the color I got from Clear Update was a colorF[4], I was expecting 0.0-1.0 UN float. But they are all 0.0 - 255.0!? and the int version of the color are not set - random nonsense\n\nThat\u0027s strange. Do you mean the value in ClearUpdate::value? I believe we use that directly to perform a clear, so if the values are wrong, something must have been broken. If that\u0027s really the case, please open a bug and I\u0027ll take a look at what\u0027s going on in a test that reproduces this (I presume one of the ones in EGLLockSurface3Test.cpp).",
      "parentUuid": "6b4898b0_2fb1f22e",
      "revId": "bcaaa2a3a4fac026cafa7f8fb2a3905ffd6f38c6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}