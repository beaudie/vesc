{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "62175995_09f502ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-01-05T16:58:00Z",
      "side": 1,
      "message": "all bots green - PTAL",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b90f86f_061286e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I think this is missing a validation language in the Vulkan spec which will require this CL to go through some redesign.\n\nLook at the validation language for `vkCmdDraw`:\n\n\u003e Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set\n\nWhich means that you can\u0027t decide to bind the input attachments when drawing with the program that uses it, but should rather do it from the very beginning of the subpass. I see two options:\n\n- Defer the binding of the input attachment desc set to the end of RP, accumulate all the necessary inputs during recording and when flushing the RP, bind the desc set right after beginning the subpass. This is probably complicated as the desc set for input attachments is shared with other program-specific stuff.\n- Use multiple subpasses. Instead of `ContextVk::framebufferFetchBarrier`, use `ContextVk::nextSubpass`. Every time you switch between a draw call that uses framebuffer fetch and one that doesn\u0027t (or vice versa), you switch to a new subpass. This is likely much simpler to implement.\n\nI would also ask you to add the following tests:\n\n- In FramebufferFetchTests.cpp: A test that draws with a non-fetch program, then a fetch program, then a non-fetch program and again a fetch program\n- In FramebufferFetchTests.cpp: A test that draws with a fetch program, then a non-fetch program, then a fetch program and again a non-fetch program (the difference with the other is that the RP is started with a fetch program or not)\n- In MultisampledRenderToTextureTest.cpp, add a test that does draw, copy then draw with fetch. You can take drawCopyDrawThenMaskedClearCommon as inspiration for framebuffer setup. The first draw initializes the color attachments, the copy breaks the render pass and the second draw adds an initial subpass for the sake of GL_EXT_multisampled_render_to_texture. This should catch the bug I mentioned below where the subpass self-dependency uses the wrong index. If you go with multiple subpasses, obviously the code changes, but this is still a good regression test for bugs that may appear in the new implementation.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43973596_dc0df187",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-12T10:05:30Z",
      "side": 1,
      "message": "@Shabi, let\u0027s discuss with the example below.\n----------------------------------------------------------\nglUseProgram(programNonFetch)\n...\nglBindFramebuffer()\n...\ndraw1()\nglUseProgram(programFetch)\ndraw2()\nglUseProgram(programNonFetch)\ndraw3()\n...\n-----------------------------------------------------------\nThis is a problematic case in my current patch. ANGLE creates a renderpass just before draw1 and the renderpass will not have input attachments because the program used in draw1 does not use framebuffer fetch. It will cause descriptor state mismatch in draw2.\n\nIIUC, your multiple subpasses approach needs to create additional subpass for every renderpass then call nextsubpass between framebuffer fetch and one that doesn\u0027t. In that case we will have 2 subpasses in a renderpass so we can\u0027t call nextsubpass before draw3. I don\u0027t think I understand properly. Can you explain details?\n\nOtherwise, how about this approach? When glUseProgram is called, if a program use framebuffer fetch, we add some codes to make following drawcall call startRenderPass(). It will create new renderpass which has proper input attachments so we can avoid state mismatch.\n\nplease give me feedback.",
      "parentUuid": "0b90f86f_061286e2",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4903c1a3_bd0e3d91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-12T15:23:21Z",
      "side": 1,
      "message": "I think it\u0027s important to avoid breaking the render pass. The entire raison-d\u0027etre of this extension is to avoid that.\n\nFrom your example, the render pass will have **3** subpasses, one for each draw call. In implementation, a subpass is added when switching between nonfetch and fetch and vice versa, also when changing the bindings for the input attachments even when using the same program (1). You would need to keep track of the number of subpasses in the render pass desc (there\u0027s already mechanism for that there), and when creating the render pass proper (InitializeRenderPassFromDesc()), build the dependencies. Probably not worth tracking the details of the dependency in render pass desc and just use \"color+depth+stencil write -\u003e color+depth+stencil\" read dependencies everywhere.\n\n(1) another test for this is needed: draw with non-fetch program, draw with fetch program using some input attachment, draw with fetch program using some other input attachment. Yet another test could be: draw with non-fetch program, draw with fetch program 1 using some input attachment, draw with fetch program 2 using same input attachment.\n\nBy the way, you can add a \"subpass count\" performance counter (struct RenderPassPerfCounters) and duplicate some of these tests in VulkanPerformanceCounterTest.cpp to verify that the number of subpasses that are generated are correct (for example, the second test in (1) should use 2 subpasses, not 3).",
      "parentUuid": "43973596_dc0df187",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "916cdc5c_2289cea9",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 8
      },
      "lineNbr": 278,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "the spec has no mention of input attachments:\n\nhttps://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_shader_framebuffer_fetch.txt\n\nthe word uniform doesn\u0027t occur in the spec at all. what GL concept do these correspond to?",
      "range": {
        "startLine": 278,
        "startChar": 19,
        "endLine": 278,
        "endChar": 49
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "562a8d96_7dd4ff8a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1341,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "why a dirty bit? can\u0027t you just enqueue this barrier immediately? the best thing to answer my concern is to tell me what would break if you were to make this immediate in framebufferFetchBarrierl",
      "range": {
        "startLine": 1341,
        "startChar": 25,
        "endLine": 1341,
        "endChar": 67
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad23624_b1d6a628",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1634,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "Maybe also conditional to the executable using framebuffer fetch? Otherwise it\u0027s inefficiency for no reason.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4587dd6_9ecdb2bc",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1636,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I suggest keeping `invalidateCurrentShaderResources` private in `ContextVk`, and adding some `onColorAttachmentChange` or something that calls this. It should also check for example that the framebuffer being changed is the draw framebuffer (per glState, not the cached member).",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28ffd68f_73cdb25b",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1636,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "Can it be a part of onFramebufferChange? What breaks if you make this internal to onFramebufferChange?",
      "parentUuid": "e4587dd6_9ecdb2bc",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e5bd158_67c1f503",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 576,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "The application subpass is not necessarily subpass 0. See `hasUnresolveAttachments` below.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1e17a005_ac9a3809",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 959,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I can\u0027t believe the spec is requiring this.",
      "range": {
        "startLine": 959,
        "startChar": 52,
        "endLine": 959,
        "endChar": 75
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}