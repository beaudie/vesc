{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "62175995_09f502ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-01-05T16:58:00Z",
      "side": 1,
      "message": "all bots green - PTAL",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0b90f86f_061286e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I think this is missing a validation language in the Vulkan spec which will require this CL to go through some redesign.\n\nLook at the validation language for `vkCmdDraw`:\n\n\u003e Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set\n\nWhich means that you can\u0027t decide to bind the input attachments when drawing with the program that uses it, but should rather do it from the very beginning of the subpass. I see two options:\n\n- Defer the binding of the input attachment desc set to the end of RP, accumulate all the necessary inputs during recording and when flushing the RP, bind the desc set right after beginning the subpass. This is probably complicated as the desc set for input attachments is shared with other program-specific stuff.\n- Use multiple subpasses. Instead of `ContextVk::framebufferFetchBarrier`, use `ContextVk::nextSubpass`. Every time you switch between a draw call that uses framebuffer fetch and one that doesn\u0027t (or vice versa), you switch to a new subpass. This is likely much simpler to implement.\n\nI would also ask you to add the following tests:\n\n- In FramebufferFetchTests.cpp: A test that draws with a non-fetch program, then a fetch program, then a non-fetch program and again a fetch program\n- In FramebufferFetchTests.cpp: A test that draws with a fetch program, then a non-fetch program, then a fetch program and again a non-fetch program (the difference with the other is that the RP is started with a fetch program or not)\n- In MultisampledRenderToTextureTest.cpp, add a test that does draw, copy then draw with fetch. You can take drawCopyDrawThenMaskedClearCommon as inspiration for framebuffer setup. The first draw initializes the color attachments, the copy breaks the render pass and the second draw adds an initial subpass for the sake of GL_EXT_multisampled_render_to_texture. This should catch the bug I mentioned below where the subpass self-dependency uses the wrong index. If you go with multiple subpasses, obviously the code changes, but this is still a good regression test for bugs that may appear in the new implementation.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43973596_dc0df187",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-12T10:05:30Z",
      "side": 1,
      "message": "@Shabi, let\u0027s discuss with the example below.\n----------------------------------------------------------\nglUseProgram(programNonFetch)\n...\nglBindFramebuffer()\n...\ndraw1()\nglUseProgram(programFetch)\ndraw2()\nglUseProgram(programNonFetch)\ndraw3()\n...\n-----------------------------------------------------------\nThis is a problematic case in my current patch. ANGLE creates a renderpass just before draw1 and the renderpass will not have input attachments because the program used in draw1 does not use framebuffer fetch. It will cause descriptor state mismatch in draw2.\n\nIIUC, your multiple subpasses approach needs to create additional subpass for every renderpass then call nextsubpass between framebuffer fetch and one that doesn\u0027t. In that case we will have 2 subpasses in a renderpass so we can\u0027t call nextsubpass before draw3. I don\u0027t think I understand properly. Can you explain details?\n\nOtherwise, how about this approach? When glUseProgram is called, if a program use framebuffer fetch, we add some codes to make following drawcall call startRenderPass(). It will create new renderpass which has proper input attachments so we can avoid state mismatch.\n\nplease give me feedback.",
      "parentUuid": "0b90f86f_061286e2",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4903c1a3_bd0e3d91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-12T15:23:21Z",
      "side": 1,
      "message": "I think it\u0027s important to avoid breaking the render pass. The entire raison-d\u0027etre of this extension is to avoid that.\n\nFrom your example, the render pass will have **3** subpasses, one for each draw call. In implementation, a subpass is added when switching between nonfetch and fetch and vice versa, also when changing the bindings for the input attachments even when using the same program (1). You would need to keep track of the number of subpasses in the render pass desc (there\u0027s already mechanism for that there), and when creating the render pass proper (InitializeRenderPassFromDesc()), build the dependencies. Probably not worth tracking the details of the dependency in render pass desc and just use \"color+depth+stencil write -\u003e color+depth+stencil\" read dependencies everywhere.\n\n(1) another test for this is needed: draw with non-fetch program, draw with fetch program using some input attachment, draw with fetch program using some other input attachment. Yet another test could be: draw with non-fetch program, draw with fetch program 1 using some input attachment, draw with fetch program 2 using same input attachment.\n\nBy the way, you can add a \"subpass count\" performance counter (struct RenderPassPerfCounters) and duplicate some of these tests in VulkanPerformanceCounterTest.cpp to verify that the number of subpasses that are generated are correct (for example, the second test in (1) should use 2 subpasses, not 3).",
      "parentUuid": "43973596_dc0df187",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef9d6c00_37cf7834",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-20T10:15:38Z",
      "side": 1,
      "message": "I implemented this using subpasses and resolved most of problems except for one Vulkan validation error. In the example below,\n----------------------------------------------------\nglUseProgram(programNonFetch)\ndraw1()\nglUseProgram(programFetch)\ndraw2()\nflush()\n----------------------------------------------------\nWhen the App switches fetch/nonfetch programs, ANGLE increases subpass number and  recreates renderPass, then updates objects which have renderPass(framebuffer, pipeline and so on) This must be done because Vulkan validation layer checks renderPass consistency for each objects.\n\nThe last problem I have is consistency between renderPass in the last bound pipeline and active renderpass received as a parameter in VkRenderPassBeginInfo. It causes a validation error in draw1. The active renderpass has 2 subpasses in a renderPass  because it is create with the descriptor at flush time. In other hand, renderPass in the last bound pipeline only has 1 subpasses.\n\nI don\u0027t think we can avoid it because Vulkan validation layer does not allow subpass number changes in a renderPass. In general, Vulkan application determine the number of subpasses in renderPass creation time. What do you think?",
      "parentUuid": "4903c1a3_bd0e3d91",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c6619b5_35df6045",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-20T16:02:51Z",
      "side": 1,
      "message": "Hmm... that\u0027s a complication I overlooked. I don\u0027t know if there\u0027s a way to make this work as long as we continue creating vulkan pipelines as we meet them, (because we don\u0027t know when the render pass is going to incompatibly change).\n\nThere was an idea we talked about a while back (for performance reasons actually) to defer the graphics pipeline creation to when the render pass ends, so we can hand that work off to the thread that does the submission. That could actually overcome this issue. But let\u0027s talk about it more tomorrow before we go ahead with any solution.\n\nIf you could summarize all these in a doc it would make it easier to continue with the discussion.",
      "parentUuid": "ef9d6c00_37cf7834",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "095b0bd3_168e181b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-20T19:51:08Z",
      "side": 1,
      "message": "The meeting is pushed back, so let\u0027s just continue here for now.\n\nI talked with Jamie and maybe it\u0027s best to go back to the previous implementation, with some simplification and break the render pass as a first step. The idea is to implement it with subpass self-dependencies (as it was), but like this:\n\n----------------------------------------------------\nglUseProgram(programNonFetch)\ndraw1()\nglUseProgram(programFetch1)  // use input attachment 0\ndraw2()\nglUseProgram(programFetch2)  // use input attachment 1\ndraw3()\nglUseProgram(programFetch3)  // use input attachment 0, 2\ndraw4()\nglUseProgram(programNonFetch)\ndraw5()\n// etc\nflush()\n----------------------------------------------------\n\n- Instead of binding the descriptor set with only the input attachments that are used, bind it with all attachments.\n- Generate the following render passes:\n\n    begin RP, single subpass, no self dependency\n    bind(programNonFetch)\n    draw 1\n    end RP\n\n    begin RP, single subpass, self dependency with all attachments\n    bind all attachments as input attachments\n    bind(programFetch1)\n    draw 2\n    barrier\n    bind(programFetch2)\n    draw 3\n    barrier\n    bind(programFetch3)\n    draw 4\n    end RP\n\n    begin RP, single subpass, no self dependency\n    bind(programNonFetch)\n    draw 5\n    end RP\n\nThis way, right when `programFetch1` is encountered, break the render pass and start a new one. At this point you already know input attachments are going to be used so you can set up the descriptor sets and render pass description correctly (because you assume all attachments will end up being used as input attachments).\n\nThere are ideas on how to avoid breaking the render pass as well, but we can look into that as a follow up whenever the need arises.",
      "parentUuid": "8c6619b5_35df6045",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f78915d_9f632438",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-21T01:27:56Z",
      "side": 1,
      "message": "\u003eInstead of binding the descriptor set with only the input attachments that are used, bind it with all attachments.\nThat\u0027s what ANGLE did in patchset8. It binds all input attachments to a subpass during Render pass creation then binds/updates input attachment descriptors later according to program state.\nThe remaining task is breaking the render pass when app switch the fetch/nonFetch program. Also I\u0027ll add more end2end tests for verification.",
      "parentUuid": "095b0bd3_168e181b",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "145d1314_13bebe24",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-21T02:54:44Z",
      "side": 1,
      "message": "\u003e then binds/updates input attachment descriptors later according to program state\n\nIsn\u0027t that unnecessary? If all attachments are bound as input attachment, then it doesn\u0027t matter if the program uses only a subset of them, as long as their input attachment index matches the color attachment index. If it doesn\u0027t, they can\u0027t use the same subpass.",
      "parentUuid": "6f78915d_9f632438",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "402069c6_1c475474",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-21T05:18:29Z",
      "side": 1,
      "message": "I thought mismatches between pipeline layout and actual shader code would cause problems(may be in the Vulkan validation layer). But in case shader uses subset of them, it seems to have no problem.",
      "parentUuid": "145d1314_13bebe24",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff671343_be423bf4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-21T05:54:25Z",
      "side": 1,
      "message": "Yeah, it doesn\u0027t. It\u0027s valid to have N input attachments bound with descriptors, while the shaders use any (or none) of them 😊. True with any resource type really.",
      "parentUuid": "402069c6_1c475474",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b30a79e2_e69a91a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1357791
      },
      "writtenOn": "2021-01-21T08:05:50Z",
      "side": 1,
      "message": "I\u0027ve encountered one problem. Pipeline layouts are created in program link time but framebuffer bind can be called later. How many input attachments should I bind to pipeline layout in this case?",
      "parentUuid": "ff671343_be423bf4",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "916cdc5c_2289cea9",
        "filename": "src/libANGLE/Program.h",
        "patchSetId": 8
      },
      "lineNbr": 278,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "the spec has no mention of input attachments:\n\nhttps://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_shader_framebuffer_fetch.txt\n\nthe word uniform doesn\u0027t occur in the spec at all. what GL concept do these correspond to?",
      "range": {
        "startLine": 278,
        "startChar": 19,
        "endLine": 278,
        "endChar": 49
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "562a8d96_7dd4ff8a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1341,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "why a dirty bit? can\u0027t you just enqueue this barrier immediately? the best thing to answer my concern is to tell me what would break if you were to make this immediate in framebufferFetchBarrierl",
      "range": {
        "startLine": 1341,
        "startChar": 25,
        "endLine": 1341,
        "endChar": 67
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad23624_b1d6a628",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1634,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "Maybe also conditional to the executable using framebuffer fetch? Otherwise it\u0027s inefficiency for no reason.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4587dd6_9ecdb2bc",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1636,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I suggest keeping `invalidateCurrentShaderResources` private in `ContextVk`, and adding some `onColorAttachmentChange` or something that calls this. It should also check for example that the framebuffer being changed is the draw framebuffer (per glState, not the cached member).",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28ffd68f_73cdb25b",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1636,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-07T19:46:38Z",
      "side": 1,
      "message": "Can it be a part of onFramebufferChange? What breaks if you make this internal to onFramebufferChange?",
      "parentUuid": "e4587dd6_9ecdb2bc",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e5bd158_67c1f503",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 576,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "The application subpass is not necessarily subpass 0. See `hasUnresolveAttachments` below.",
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1e17a005_ac9a3809",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 959,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-01-06T04:53:25Z",
      "side": 1,
      "message": "I can\u0027t believe the spec is requiring this.",
      "range": {
        "startLine": 959,
        "startChar": 52,
        "endLine": 959,
        "endChar": 75
      },
      "revId": "24d11dc5e1ab96a8c7aab2769411739c602b0e76",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}