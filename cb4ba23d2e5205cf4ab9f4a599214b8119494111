{
  "comments": [
    {
      "key": {
        "uuid": "af93ed99_da4bf25a",
        "filename": "BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 961,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "git cl format maybe?",
      "range": {
        "startLine": 961,
        "startChar": 69,
        "endLine": 961,
        "endChar": 100
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1138e1b9_9171b2b5",
        "filename": "src/feature_support_util/a4a_rules.json",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "can we run our json files through a standard formatter? something like https://jsonformatter.curiousconcept.com/",
      "range": {
        "startLine": 1,
        "startChar": 0,
        "endLine": 21,
        "endChar": 0
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0f106a0_d5ecd2fd",
        "filename": "src/feature_support_util/feature_support_util.cpp",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "nit: probably also a good time to take out any WIP comments you had",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 3
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8cb64b0c_a79efbca",
        "filename": "src/feature_support_util/feature_support_util.cpp",
        "patchSetId": 2
      },
      "lineNbr": 874,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "nit: std::list can be heavy weight. consider using std::vector unless you need to insert and delete in the middle of the list quite often.",
      "range": {
        "startLine": 874,
        "startChar": 4,
        "endLine": 874,
        "endChar": 13
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "259ce14b_f8ca8e38",
        "filename": "src/feature_support_util/feature_support_util.cpp",
        "patchSetId": 2
      },
      "lineNbr": 927,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "also in places like this you should prefer to use c++ classes with automatic memory management like std::vector. Or angle::MemoryBuffer if you want to be robust to error.",
      "range": {
        "startLine": 927,
        "startChar": 4,
        "endLine": 927,
        "endChar": 58
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec22c24b_682f7beb",
        "filename": "src/feature_support_util/feature_support_util.cpp",
        "patchSetId": 2
      },
      "lineNbr": 932,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "in cases like this we can use std::unique_ptr to avoid potential problems with object deletion.",
      "range": {
        "startLine": 932,
        "startChar": 4,
        "endLine": 932,
        "endChar": 19
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0535627e_dc0c149f",
        "filename": "src/feature_support_util/feature_support_util.h",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "nit: because this is un-namespaced I\u0027d probably qualify which utility (ANGLEGetFeatureSupportUtilAPI() for example).\n\nAlso, the decision of the \"best\" version to use seems like it doesn\u0027t have to be embedded into this API. You could make this API return the current version and make the logic about whether to use this library part of an inline helper function. The function would just take the two versions (or call GetAPI implicitly) and run the logic you describe above.\n\nAll that to say we can make the API contract slightly simpler this way.",
      "range": {
        "startLine": 35,
        "startChar": 18,
        "endLine": 35,
        "endChar": 36
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "744711b3_fa3751a2",
        "filename": "src/feature_support_util/feature_support_util.h",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2018-10-22T20:34:02Z",
      "side": 1,
      "message": "Hear me out, but I think we should make this more general.\n\nAlso we should probably take the API version as part of this API for validation purposes.\n\nOK, so I think we should call this ANGLEGetFeatureSupport. Arguments: API version, rules_FD + other file args, appName, and systemInfo. This would assume we can tag the systemInfo with the deviceMfr and deviceModel.\n\nOutputs: either an in/out for number of outputs, and an array of bools for rules results, if we need to return \"app choice\" vs \"system choice\". Or a single bool if we only want one result. This function currently doesn\u0027t seem to respect the app choice, but thinking ahead. If multiple choice, could be up to the caller to understand the array indexing scheme.\n\nOptionally we could return a code that indicates an unexpected error.\n\nThe reason I\u0027m proposing is that this could be future-proof towards using the exact same API for workaround selection. If we decide we want to go that way.\n\nIt would be nice if we could use the SystemInfo because it has a lot of other nice information other than deviceMfr and deviceModel. It shouldn\u0027t be hard to add a method to SystemInfo to patch in the device info. Or to just set it manually.\n\nWhat do you think? Maybe we should resolve some of this before moving on to the nitty gritty of the implementation details.\n\nI think either scheme work be forward-compatible with using protobufs as an optimization.",
      "range": {
        "startLine": 48,
        "startChar": 18,
        "endLine": 48,
        "endChar": 47
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b4d9d83_ea5842da",
        "filename": "src/feature_support_util/feature_support_util.h",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2018-10-23T17:38:24Z",
      "side": 1,
      "message": "I have lots of thoughts.  I\u0027m open.  Let\u0027s keep chatting ... perhaps in our meeting in a few minutes.  Here\u0027s some thoughts before then ...\n\nI\u0027d like to back up first, before getting into all of the details ...\n\nYou say \"... for workaround selection, if we decide we want to go that way.\"  I thought you did want to go that way.  It might be good to determine that before looking at modifying this API (e.g. if you decide to not \"to go that way\", we\u0027ll save time/effort).\n\nBTW, have you looked at this doc lately?: https://docs.google.com/document/d/1mdEPW25ZZPplRm5ybzYGye2oVxSqy-k9QkYpz2Rnt3s/edit?pli\u003d1#heading\u003dh.c0gzv7zc9e98\n\nIt has a section that looks at what \"functions\" are needed in terms of what-to-do, what inputs, what output, etc.  I was thinking of \"5. ANGLE determines what work-around(s) ANGLE will use for a given application and the current device\" as what ANGLE needed.  Is that close?\n\nJumping into some of the details...\n\nSomething that happened since Budapest is that Courtney put this into its own shared library that Android\u0027s EGL loader dlopen\u0027s and dlclose\u0027s.  Thus (I think--correct me if I\u0027m wrong), anything we pass down (like the deviceMfr and deviceModel, which can be queried by certain APIs that are above EGL) will be forgotten by the time ANGLE can call it.  I think that ANGLE needs to know that info, and we need to plumb it down to ANGLE.\n\nFrom our discussions in Budapest, I thought we agreed that we\u0027d have different functions for Android and for ANGLE calling into the rules processing.  The needs were different, and so different functions seemed appropriate.  This function is what Android needs now.  For example, the notion of an application preference was dropped strategically (we still encode any application-specific info into the rules file and not allow applications themselves to programmatically express a preference), and so it was dropped from this function signature as well.  It seems like ANGLE had different needs (less care for specific applications and more care for devices/drivers), and so a different function/signature is what I thought you preferred.  Do you really want to have one function that meets all needs?",
      "parentUuid": "744711b3_fa3751a2",
      "range": {
        "startLine": 48,
        "startChar": 18,
        "endLine": 48,
        "endChar": 47
      },
      "revId": "cb4ba23d2e5205cf4ab9f4a599214b8119494111",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}