{
  "comments": [
    {
      "key": {
        "uuid": "08733496_6160a8ac",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-22T19:40:26Z",
      "side": 1,
      "message": "OK, I finally had time to sit down and figure out the code. I understand we need to still have functional, but incomplete textures, when the base level is out of range. Using zero here isn\u0027t obviously clear what it\u0027s trying to do.\nMy solution is to instead, if baseLevel is out of range, immediately release the storage and mark the images dirty, update the cached baseLevel to 1000 or whatever is passed in, and return. Then, handle the size check as you have it below the out of range check.",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e89420c3_81287ec6",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2016-04-25T13:31:39Z",
      "side": 1,
      "message": "This will require expanding this patch quite a bit to make sure that all the other functions that rely on base level being in range work correctly. But if you think that this is the best way to go, I can do it.",
      "parentUuid": "08733496_6160a8ac",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08733496_797ccd8d",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-25T14:04:46Z",
      "side": 1,
      "message": "Interesting. I actually cherry-picked this patch locally, made the change I suggested, and tried running some tests. I didn\u0027t run into any failures. I guess that means either I missed some tests or we\u0027re missing coverage. I don\u0027t think it\u0027s critical, but do you know off the top which places those would be?",
      "parentUuid": "e89420c3_81287ec6",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e89420c3_e1e142b8",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2016-04-25T14:13:38Z",
      "side": 1,
      "message": "There\u0027s definitely missing coverage here. The complete list of places where at least additional asserts would make sense is too long to include here, but here are a couple of simple examples:\n\n1. Any function that changes texture images like texImage or copyTexImage typically checks whether the image fits the dimensions of the existing storage. All of these will need to have additional checks for out-of-range base level.\n2. GenerateMipmap entry point needs to validate the level correctly.",
      "parentUuid": "08733496_797ccd8d",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08733496_995609a9",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-25T15:25:47Z",
      "side": 1,
      "message": "It\u0027s currently impossible to make a base level image higher than 14 with any size other than zero. So I think that\u0027s why the tests worked. Does that agree with your assessment? \n\nThis probably is incorrect behaviour in ANGLE, but I\u0027d be fine with deprioritizing fully fixing it, because it\u0027s not a very useful feature, and also pretty tricky.\n\nAlso possibly I\u0027m still missing something, but I think the cases you mention wouldn\u0027t be easy to repro with a test.",
      "parentUuid": "e89420c3_e1e142b8",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e89420c3_0150eeaa",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2016-04-26T11:43:35Z",
      "side": 1,
      "message": "The issues don\u0027t happen when trying to access levels beyond 14 - they happen when accessing valid levels when base level is out of range. For example if base level is set to 1000 and then level 0 is changed with texImage. I can write tests for this kind of cases if you think they\u0027re necessary, it\u0027s just a lot of effort to spend on corner cases that you won\u0027t expect people to hit when writing sensible code.",
      "parentUuid": "08733496_995609a9",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "888725d1_a7f14ea7",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-26T17:24:54Z",
      "side": 1,
      "message": "OK thanks for clarifying the issues. I think there\u0027s a potential problem when setting the base level to zero, because getBaseLevelImage() will alias the image at level zero. Still using the above suggestion to return immediately after releasing the storage and setting mBaseLevel, you should also detect an out-of-range base level in TextureD3D::getBaseLevelImage and return nullptr. This should prevent the ASSERTs - this function is allowed to return nullptr, and this will preserve information and not alias.\n\nLet me know if this works in your mind - I can upload a CL with my proposed changes if you like.",
      "parentUuid": "e89420c3_0150eeaa",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08c41560_35093086",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2016-04-27T08:57:18Z",
      "side": 1,
      "message": "Ah, that\u0027s right, making getBaseLevelImage return nullptr if base level is out of range should work without any major changes. I should have seen that. I can upload a fixed version of the patch as soon as I have my Windows machine running again.",
      "parentUuid": "888725d1_a7f14ea7",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48560d47_b9cd5270",
        "filename": "src/libANGLE/renderer/d3d/TextureD3D.cpp",
        "patchSetId": 10
      },
      "lineNbr": 644,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-27T13:59:07Z",
      "side": 1,
      "message": "Great! Thanks.",
      "parentUuid": "08c41560_35093086",
      "range": {
        "startLine": 641,
        "startChar": 3,
        "endLine": 644,
        "endChar": 5
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08733496_618988aa",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 10
      },
      "lineNbr": 1691,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-22T19:40:26Z",
      "side": 1,
      "message": "realized we can clean this up. Make this\n\n GLColor green(0, 255, 0);\n std::vector\u003cGLColor\u003e texDataGreen(2 * 2, green);\n ...\n EXPECT_PIXEL_COLOR_EQ(0, 0, green);\n\nYou could also make the green/red/blue const statics exposed in the header.",
      "range": {
        "startLine": 1691,
        "startChar": 4,
        "endLine": 1691,
        "endChar": 39
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e89420c3_81c4fe5e",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 10
      },
      "lineNbr": 1691,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2016-04-25T13:31:39Z",
      "side": 1,
      "message": "This does have the downside that GLColor is less flexible, it doesn\u0027t currently allow other formats than 8-bit per channel RGBA, so if we need other formats in the tests some kind of changes are needed. It does make the code considerably cleaner, though.",
      "parentUuid": "08733496_618988aa",
      "range": {
        "startLine": 1691,
        "startChar": 4,
        "endLine": 1691,
        "endChar": 39
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08733496_9981a9c6",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 10
      },
      "lineNbr": 1691,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-25T14:04:46Z",
      "side": 1,
      "message": "If we do need those other formats, we could generalize ANGLEColor to be something like the color structs ANGLE uses internally.",
      "parentUuid": "e89420c3_81c4fe5e",
      "range": {
        "startLine": 1691,
        "startChar": 4,
        "endLine": 1691,
        "endChar": 39
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08733496_818ea4b0",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 10
      },
      "lineNbr": 1720,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2016-04-22T19:40:26Z",
      "side": 1,
      "message": "same for these guys",
      "range": {
        "startLine": 1720,
        "startChar": 4,
        "endLine": 1720,
        "endChar": 16
      },
      "revId": "3c8f475d384256f346cef50f0dca2a304d160028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}