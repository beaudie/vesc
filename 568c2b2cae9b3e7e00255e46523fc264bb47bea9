{
  "comments": [
    {
      "key": {
        "uuid": "19dfc824_bee199a2",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 239,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2014-07-15T14:10:29Z",
      "side": 1,
      "message": "do you need to clone original? why not just use original? that would allow you to remove the new clone() methods as well.",
      "range": {
        "startLine": 239,
        "startChar": 19,
        "endLine": 239,
        "endChar": 36
      },
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79d0c40f_8acf2a95",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 239,
      "author": {
        "id": 1003154
      },
      "writtenOn": "2014-07-15T20:03:07Z",
      "side": 1,
      "message": "Look at the RemoveTree code, if we use the original node, it will crash when we destruct the tree.",
      "parentUuid": "19dfc824_bee199a2",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39dacc33_05fb168b",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 239,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2014-07-15T20:55:55Z",
      "side": 1,
      "message": "Seems like it should not -- if original is only traversed once. And if original is not traversed once, mutable expressions like \"index++\" will be travesred multiple times as well? Apologies if I\u0027m missing something.",
      "parentUuid": "79d0c40f_8acf2a95",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "592060de_11f0ae41",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 239,
      "author": {
        "id": 1106294
      },
      "writtenOn": "2014-07-15T20:56:06Z",
      "side": 1,
      "message": "Ideally we\u0027d have a pool associated with the AST for all the nodes so we can freely reuse the weak pointers. I think that used to be the case but with a global pool and the nodes of the tree were deleted by traversing it to save memory after a compile? I wasn\u0027t very involved in that change. Alternatively during the destruction of the tree we could collect a set of unique pointers, although that seems a bit backwards.\n\nAnyway, there\u0027s no need to address that right now, but there have been a couple of situations already where nodes had to be cloned. We should really fix this properly one day.\n\nThat said, I\u0027m not sure if you really need the clone here, since we\u0027re removing the original constructor arguments and replacing them with scalars. The sequence.clear() leaves them in the global pool but unreferenced by the tree, and thus they\u0027re available here to add them to the tree again without the need to clone.",
      "parentUuid": "79d0c40f_8acf2a95",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9e8d0cd_1136f6d1",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 247,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2014-07-15T20:26:38Z",
      "side": 1,
      "message": "Does the temporary variable generation handle situations like this:\n\nvec3 row1 \u003d ...;\nvec3 row2 \u003d ...;\nvec3 row3 \u003d ...;\nfloat foo \u003d mat4(mat3(row1, row2, row3))[1][1];\n\nSpecifically, the situation where the matrix or vector that needs to be scalarized is a temporary value, allocated in the middle of a deeper expression?",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19c8a874_99acff24",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 247,
      "author": {
        "id": 1003154
      },
      "writtenOn": "2014-07-15T22:00:35Z",
      "side": 1,
      "message": "This case is handled, as we create a temporary variable and initialize it to whatever the node is, can be a temp value, or function call, or expression.  Doesn\u0027t matter.\n\nHowever, jmadill raised an interesting case, where mat4(index++, vec4(index++)\n\nSo to handle that case, and to not over-complicate things, I decided to just create a temp variable for each arg, in the situation where scalarization is necessary.",
      "parentUuid": "d9e8d0cd_1136f6d1",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9c4b462_9eace124",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 247,
      "author": {
        "id": 1003154
      },
      "writtenOn": "2014-07-16T00:26:50Z",
      "side": 1,
      "message": "jmadill: I just realized your corner case isn\u0027t valid, as vec4[index++] isn\u0027t allowed.  array index has to be constant or loop index.  Is this limitation still there in ES3?",
      "parentUuid": "19c8a874_99acff24",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19c8a874_6525b097",
        "filename": "src/compiler/translator/ScalarizeVecAndMatConstructorArgs.cpp",
        "patchSetId": 5
      },
      "lineNbr": 247,
      "author": {
        "id": 1003154
      },
      "writtenOn": "2014-07-16T01:09:30Z",
      "side": 1,
      "message": "Never mind, the case mat2(i++, vec4(i++)) still needs to be handled. So patch set 6 is necessary.",
      "parentUuid": "f9c4b462_9eace124",
      "revId": "568c2b2cae9b3e7e00255e46523fc264bb47bea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}