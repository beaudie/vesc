{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0f05e66c_e9321ee4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "First round of review! Thanks a lot for the excellent job, and sorry again this is going so slowly.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bae0dd1_83905304",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 18
      },
      "lineNbr": 9560,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "nit: this doesn\u0027t make sense outside the context of code review. It should describe what happens without reference to history of evolution of this code.",
      "range": {
        "startLine": 9560,
        "startChar": 45,
        "endLine": 9560,
        "endChar": 97
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf72f779_8093e643",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 18
      },
      "lineNbr": 9560,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "OK. My point was that before `mShared` was not atomic and everything was working fine and we was fine with this. Actually, I raised this problem to you (not personally to you) a long time ago (with a first batch of patches), and got a response that this is not a big problem in a real life - only during deliberate testing.\n\nCan describe what will happen instead, if will be still relevant.",
      "parentUuid": "8bae0dd1_83905304",
      "range": {
        "startLine": 9560,
        "startChar": 45,
        "endLine": 9560,
        "endChar": 97
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf849d13_aee55d15",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 18
      },
      "lineNbr": 9560,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added description.\nHope replacing with `SpinLock` will not add too much overhead.",
      "parentUuid": "cf72f779_8093e643",
      "range": {
        "startLine": 9560,
        "startChar": 45,
        "endLine": 9560,
        "endChar": 97
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63f5d561_c281a75b",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 18
      },
      "lineNbr": 9579,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "_Loving_ how simple this makes EGL images! Awesome!",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5538b034_d4ca3ac4",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 18
      },
      "lineNbr": 9579,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-08T20:02:01Z",
      "side": 1,
      "message": "I updated this part.\nNow margin happens in `SCOPED_EGL_IMAGE_SHARE_CONTEXT_LOCK` -  before validation.\n\nProblem with previous solution was that `SharedContextMutex::Merge()` may unlock the mutex resulting in unlock in the middle of the API call.\n\nNew solution also simplified merging logic as well as shared mutex activation (with new temp activation support), because now merging is done when `SingleContextMutex` is not locked.",
      "parentUuid": "63f5d561_c281a75b",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d70e4a11_797a399d",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "If I understand correctly, all these sleeps and uncertainties are because `SingleContextMutex` is not actually a lock, right? If it were a lock, wouldn\u0027t you be able to get rid of the sleeps, and also guarantee there wouldn\u0027t be a problem?\n\nIt seems to me like if you used `angle::Spinlock` inside `SingleContextMutex` that would do the trick. In normal single-context operation, it\u0027s exactly the same as the current `SingleContextMutex`, because it\u0027s just an atomic set/unset. When there\u0027s context merging going on, there\u0027s a bit of spinning, but that\u0027s a one time thing and it\u0027s totally worth not having to game the scheduler and rely on luck.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fff5f19d_47c20238",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e If I understand correctly, all these sleeps and uncertainties are because SingleContextMutex is not actually a lock, right? If it were a lock, wouldn\u0027t you be able to get rid of the sleeps, and also guarantee there wouldn\u0027t be a problem?\n\nCorrect.\n\n\u003e It seems to me like if you used angle::Spinlock inside SingleContextMutex that would do the trick. In normal single-context operation, it\u0027s exactly the same as the current SingleContextMutex, because it\u0027s just an atomic set/unset. When there\u0027s context merging going on, there\u0027s a bit of spinning, but that\u0027s a one time thing and it\u0027s totally worth not having to game the scheduler and rely on luck.\n\n`angle::Spinlock` is not exactly the same. It has different memory order that will affect Android performance in a measurable way. With `SingleContextMutex` performance is the same as before when `mShared \u003d\u003d false`.\n\nHere some test results:\n```\n    Some GFXBench \"1080p Driver Overhead 2 Offscreen\" performance numbers.\n    Tested on S906B (Samsung Galaxy S22+) on old ANGLE base:\n        https://chromium.googlesource.com/angle/angle/+/807c94ea85e046c6f279d081d99f0fb1bcf1191a\n        Capture/Replay: Adjust tests do adhere to capture limits\n    \n    Each test result is an average frame number from 6 runs.\n    \n        SingleContextMutex                            6579 ( +0.13%)\n        (old) GetContextLock() (mShared is false)     6570\n    \n    Forced `mShared \u003d true` or not using `SingleContextMutex`.\n    \n        SharedContextMutex\u003cFastMutex1\u003e FORCE          6299 ( -4.13%)\n        SharedContextMutex\u003cFastMutex2\u003e FORCE          6095 ( -7.23%)\n        SharedContextMutex\u003cFastMutex3\u003e FORCE          5963 ( -9.25%)\n        SharedContextMutex\u003cstd::mutex\u003e FORCE          5061 (-22.97%)\n        (old) GetContextLock() FORCE                  4766 (-27.46%)\n```\n\nHowever, the `SharedContextMutex\u003cFastMutex1\u003e` has more overhead than *proposed* `SingleContextMutex` that uses `angle::Spinlock` and so will have better performance. But it still be worse than we have now with `mShared \u003d\u003d false`. **I will do this test**\n\nMy guess is around 2% performance loss on Android with `angle::Spinlock` inside `SingleContextMutex` compared to current state with `mShared \u003d\u003d false`.\n\nI do not know if we will accept performance regression for tiny improvement in stability. Currently, `mShared` is not atomic at all, and it is working some how, for many year. I think not 100% safe solution in theory is not a big problem. I also did stress tests and there was no single case when mutex replacement failed. But test failed will less delay. Current `100ms` was taken with overhead.\n\nOne more possible positive using `angle::Spinlock`. Since it is a normal mutex we may use `SingleContextMutex` to temporary lock single Context from other threads. Currently we need to `ensureSharedMutexActive()` and only then lock that Context. Method of locking Context in such way will be not simple, but I think it is possible to encapsulate the logic.",
      "parentUuid": "d70e4a11_797a399d",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1617814d_c4e543f0",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-01T18:33:45Z",
      "side": 1,
      "message": "\u003e\u003e If I understand correctly, all these sleepd uncertainties are because SingleContextMutex is not actually a lock, right? If it were a lock, wouldn\u0027t you be able to get rid of the sleeps, and also guarantee there wouldn\u0027t be a problem?\n\u003e\n\u003eCorrect.\n\n**I was wrong...***\n\nWe need sleep not because `SingleContextMutex` is not actual mutex. If update `SingleContextMutex` to use `Spinlock` nothing will change for current Context, because no other Context will lock this mutex.\n\nWe need `activationDelayMicro` sleep **because of the `mState::mContextMutex` pointer caching** before taking the lock. Caching includes CPU cache and even local value on the stack. Example:\n```\nThread 1:\n    egl::ContextMutex *mutex \u003d Context::getContextMutex()\n        State::getContextMutex()\n            State::mContextMutex.load(std::memory_order_relaxed)\n\n    // Thread 2 updates State::mContextMutex, but \"mutex\" contains old value\n    std::lock_guard\u003cegl::ContextMutex\u003e(*mutex)\n        SingleContextMutex::lock()\n\nThread 2:\n    Context::ensureSharedMutexActive()\n        State::useSharedContextMutex()\n            State::mContextMutex.store(mSharedContextMutex)\n\n        // This sleep so that Thread 1 acquired SingleContextMutex lock.\n        // After this sleep we assume, that Thread 1 will not lock\n        // SingleContextMutex again, because it will load updated value next time.\n        this_thread::sleep_for(chrono::microseconds(activationDelayMicro))\n\n        // Wait while currently locked SingleContextMutex is unlocked\n```\n\nTo solve the above problem without sleep and 100% safe, Thread 1 must check after locking the mutex if current mutex changed or not. However, this logic already implemented in the `SharedContextMutex\u003c\u003e`. Only difference is that not the `State::mContextMutex` pointer is updated, but the mutex itself (`mRoot` pointer). Such update requires that the original mutex was a real mutex.\n\nThe fastest real mutex that is possible (assuming no thread contention) is `angle::FastMutex1` or `angle::Spinlock`. But my original plan was to use `SharedContextMutex\u003cangle::FastMutex1\u003e` anyway, so no point treating single Context differently.\n\nPossible scenario is to use `SharedContextMutex\u003cangle::FastMutex1\u003e` for single context and then switch to `SharedContextMutex\u003cstd::mutex\u003e` when there are multiple contexts. However, changing `Mutex` type is not supported. I may add this support, but it may run slower at the end.\n\nIMO I would use `SharedContextMutex\u003cangle::FastMutex1\u003e` regardless of the number of Contexts. I think in the real word there should not be too much thread contention with multiple Contexts where `angle::FastMutex1` will perform significantly worse than `std::mutex`.\n\n---\n\nAnyway, I still have some performance numbers:\n```\nAndroid S906B\nTime in ms for 1000\u0027000 `glGetError()` calls (average from 3x5 runs).\n\nNo Shared Context Mutex (mShared \u003d false)     9.973\nNo Shared Context Mutex (mShared \u003d true)     31.599\n\nSingleContextMutex (std::atomic_int)          9.684\nSingleContextMutex (angle::Spinlock)         13.933\nSharedContextMutex\u003cangle::FastMutex1\u003e        13.681\nSharedContextMutex\u003cstd::mutex\u003e               29.704\n```\n\nAs you can see, `SharedContextMutex\u003cangle::FastMutex1\u003e` works even faster than `SingleContextMutex` that uses `angle::Spinlock`. I can\u0027t explain this. I just experimented with code to make `SharedContextMutex\u003c\u003e` run as fast as possible on mobile.\n\nAlso note that original `SingleContextMutex` works slightly faster than the current code when `mShared \u003d false`. This was my goal. Unfortunately the price is not 100% safe transition to `SharedContextMutex\u003c\u003e`.",
      "parentUuid": "fff5f19d_47c20238",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37b84883_13d1b178",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T14:54:14Z",
      "side": 1,
      "message": "Thanks for the explanations. I understand the problem, but I also don\u0027t have a solution that wouldn\u0027t regress performance. I have a strong dislike for the sleep, simply because the longevity of the caches (CPU and stack) are not a function of time, but as you said we\u0027ve currently been merging contexts entirely unsafely and it hasn\u0027t practically caused a problem. I have a few questions about this though:\n\n\u003e I also did stress tests and there was no single case when mutex replacement failed. But test failed will less delay.\n\nIs that a test you wrote specifically for merging mutexes, or an existing test / app? Just for the sake of argument, if we completely ignore safety here, how much is the code simplified? Just the 100ms sleep, or anything else? (I\u0027m not asking to remove the safety, just want to make sure I understand how much complexity it\u0027s bringing with it)\n\n\u003e Anyway, I still have some performance numbers:\n\nJust to be super clear, are these with locked CPU clocks?\n\nAlso would be interesting to try spinlock with pause() correctly implemented to see how much it affects performance (I suspect it makes things worse, but is it significant?). Currently, pause() is added only for x86*:\n\n```\n// TODO(jplate) Add pause for ARM, http://anglebug.com:6067\n...\n#    define ANGLE_SMT_PAUSE() ...\n```\n\n---\n\nTL;DR, I think we\u0027ll just have to move forward with what you have already.",
      "parentUuid": "1617814d_c4e543f0",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a9d9564_391f6156",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-05T17:34:37Z",
      "side": 1,
      "message": "\u003e  However, changing Mutex type is not supported. I may add this support, but it may run slower at the end.\n\nAdded support. Tried many different implementations. All implementations were slower with `angle::FastMutex1`.\n```\nusing SharedContextMutex\u003cangle::FastMutex1\u003e\n\noriginal (no support):    13.746 - retested on the new base\nfastest with support:     14.216 (+3.91%)\nslowest with support:     15.96 (+16.66%)\n\nusing SharedContextMutex\u003cstd::mutex\u003e\noriginal (no support):    29.589 - retested on the new base\nfastest with support:     28.981 (-2.05%) - need investigate performance gain...\n```\n\nInteresting. New implementation that supports `Mutex` type change, works slower with `angle::FastMutex1`, but faster with `std::mutex`. For completeness, `SingleContextMutex` also works slower with new implementation.\n\n\u003e Is that a test you wrote specifically for merging mutexes, or an existing test / app?\n\nIt was a separate app plus additional ASSERT in the ANGLE. I do not remember the details. I just remember that without `sleep` ASSERT failed. If reduce sleep duration, ASSERT may also happen (I do not remember exact delay). I remember that 100us has additional safety margin.\n\n\u003e Just for the sake of argument, if we completely ignore safety here, how much is the code simplified? Just the 100ms sleep, or anything else?\n\nYes. Simplification will only remove this `activationDelayMicro` sleep.\nReplacement logic will be:\n```\nif (not SharedContextMutex Active)\n   mContextMutex \u003d mSharedContextMutex\n   waitWhileSingleContextMutexIsLocked()\n   Activeate SharedContextMutex \n```\n\nBut if be completely unsafe, then (can also remove `mIsSharedContextMutexActive`):\n```\n   mContextMutex \u003d mSharedContextMutex\n```\nThe above is almost like `mShared` now.\n\n\u003e Just to be super clear, are these with locked CPU clocks?\n\nYes, of course. I retry different configurations over time: cfg1, cfg2, ..., cfgN, ... cfg1, cfg2, ..., cfgN. This is to confirm that results are consistent between runs.\n\n\u003e Also would be interesting to try spinlock with pause() correctly implemented to see how much it affects performance (I suspect it makes things worse, but is it significant?). Currently, pause() is added only for x86*:\n\nIn my tests there is only single thread, so \"wait\" logic is not used.\nDifference between `Spinlock` and `FastMutex` is that first uses `std::atomic_bool`, while second uses `std::atomic_int`. Additionally, `FastMutex1::wait()` is not inline, that may also affect performance.",
      "parentUuid": "37b84883_13d1b178",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0543e644_d42e6df5",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-06-08T19:54:07Z",
      "side": 1,
      "message": "Given that this is potentially risky, can we make it so that we can detect the error case and ASSERT that it doesn\u0027t happen? This will give us a sense of how often it actually happens in testing and the wild (Chrome ships with ANGLE assertions enabled on some channels).",
      "parentUuid": "1a9d9564_391f6156",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa104c78_17646df4",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-08T20:02:01Z",
      "side": 1,
      "message": "\u003e Given that this is potentially risky, can we make it so that we can detect the error case and ASSERT that it doesn\u0027t happen?\n\nI\u0027m not sure it is possible. I we could we would not have such problem.\n\nI will try to write a white box test at least.",
      "parentUuid": "0543e644_d42e6df5",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a771cd3_a929e049",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-09T12:53:39Z",
      "side": 1,
      "message": "I will add ASSERT and test in the follow up CL.",
      "parentUuid": "aa104c78_17646df4",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfbf69b2_43668feb",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2023-06-12T18:14:29Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "8a771cd3_a929e049",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5bbf11cf_f1e24a44",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-13T14:50:39Z",
      "side": 1,
      "message": "Unfortunately, `kActivationDelayMicro \u003d 100` was too small. I guess that the previous stress test that I used was not as robust as the new one. Also I might have tested on different device.\n\nCurrently only S906B is the most unstable when it come to `kActivationDelayMicro`. Other Android devices (G991U, G99GB) and Window seems to require a lot less delay to pass a stress test.\n\nAt the end, I decided to use `2500` microseconds delay regardless of the device. I hope it would be enough for the real world applications and will not cause future stress test to fail often.\n\nBecause `2500` microseconds is relatively big value, constant switching between `SingleContextMutex` and `SharedContextMutex` may affect the performance. To solve this problem, I limited the frequency of such switching to maximum once per second.",
      "parentUuid": "cfbf69b2_43668feb",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64e4ad44_91202fd9",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-13T17:51:56Z",
      "side": 1,
      "message": "Based on this data you previously posted:\n\n```\nAndroid S906B\nTime in ms for 1000\u0027000 `glGetError()` calls (average from 3x5 runs).\n\nNo Shared Context Mutex (mShared \u003d false)     9.973\nNo Shared Context Mutex (mShared \u003d true)     31.599\n\nSingleContextMutex (std::atomic_int)          9.684\nSingleContextMutex (angle::Spinlock)         13.933\nSharedContextMutex\u003cangle::FastMutex1\u003e        13.681\nSharedContextMutex\u003cstd::mutex\u003e               29.704\n```\n\nI have an idea. How about we _unconditionally_ use `ShredContextMutex\u003cangle::SpinLock\u003e` even for when the context is not shared? According to the data, the overhead is 4us per call. Obviously that overhead is not great, but we can offset it with a follow up change:\n\nNormally the apps make a lot of state-setting calls in between calls that actually do anything. Looking at a handful of our traces, I see on average ~10 state setting calls for each draw call. We don\u0027t need a lock for those calls; they are just updating front-end state. We should be able to list those calls and have the entry points directly call into `context-\u003egetState()` without providing a context pointer. Then they could skip the lock, and be risk free (no risk that they may actually make the context do work).\n\nIn other words, the non-shared contexts would be using a real lock, same as shared contexts. Merges would be race free. And we greatly reduce the added overhead by removing the lock from most calls.\n\nWhat do you think?",
      "parentUuid": "5bbf11cf_f1e24a44",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df0c2c2c_baa5a453",
        "filename": "src/libANGLE/Context.h",
        "patchSetId": 18
      },
      "lineNbr": 671,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-13T18:04:58Z",
      "side": 1,
      "message": "I like the idea removing lock from simple state-setting calls (just need to be careful).\n\n\u003e I have an idea. How about we unconditionally use ShredContextMutex\u003cangle::SpinLock\u003e even for when the context is not shared? \n\nSo we use `angle::SpinLock` even for shared Contexts?\nDetails are important. They affect implementations and performance.\nBest performance is to statically use single `ShredContextMutex\u003cangle::SpinLock\u003e` type (no virtual methods).\n\n\u003e What do you think?\n\nI was thinking similar thing, except not removing mutex lock from state-setting calls.",
      "parentUuid": "64e4ad44_91202fd9",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "baaaafe5_24947132",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1545,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "I noticed a bunch of these `#if`s all around. So we try our best to contain these to avoid an `#if` mess.\n\nOne way we could do it for this (and like, the one in Image.cpp) is to have a header with a few helper functions, and 2 source files, one which implements it as a no-op/UNREACHABLE/etc, and another that implements it for real. Then in the build scripts you choose to either build one file or the other based on the gn flag. For example, see `system_utils.h` vs `system_utils_*.cpp`\n\nIf not, at least put the helpers in `SharedContextMutex.h/cpp` so there\u0027d be one `#if` encompassing all of them",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d2602c0_f6204415",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1545,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e I noticed a bunch of these #ifs all around. So we try our best to contain these to avoid an #if mess.\n\nI know. This is my best try to limit this to minimum, while keep code readable.\n\nIt may be harder to understand when code is teared up to a different pieces and files, however with less #ifs.\n\nWill try to think something...",
      "parentUuid": "baaaafe5_24947132",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7edfbe95_37cf0105",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1545,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T14:54:14Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "4d2602c0_f6204415",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a660659a_c1e6a43d",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1545,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-08T20:02:01Z",
      "side": 1,
      "message": "Replaced all `#if`s with `kIsSharedContextMutexEnabled`.",
      "parentUuid": "7edfbe95_37cf0105",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f21189f8_167610ac",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1760,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Suggest this instead:\n\n```\nContextMutex::AddRefLock lock(image-\u003egetSharedContextMutex())\n```\n\nAnd in the constructor do `if (mutex) lock(mutex)`",
      "range": {
        "startLine": 1756,
        "startChar": 0,
        "endLine": 1760,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "447e90c6_a567d9fe",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1760,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "Do not like this. May cause errors if there `nullptr` that we do not want.\nWill overload constructor instead.",
      "parentUuid": "f21189f8_167610ac",
      "range": {
        "startLine": 1756,
        "startChar": 0,
        "endLine": 1760,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2a267e1_105db16e",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 18
      },
      "lineNbr": 1760,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added `kContextMutexMayBeNull` argument for constructor overloading.",
      "parentUuid": "447e90c6_a567d9fe",
      "range": {
        "startLine": 1756,
        "startChar": 0,
        "endLine": 1760,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9728745_92c04060",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 119,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "nit: The way we tend to avoid the `#if` mess is to use helper functions that are entirely contained within `ASSERT`, so they get compiled out naturally without asserts. For example:\n\n```\nbool CheckSameThread(angle::ThreadId currentThread, const std::atomic\u003cangle::ThreadId\u003e \u0026ownerThread)\n{\n    return ownerThread.load(std::memory_order_relaxed) \u003d\u003d currentThread;\n}\n\nbool CheckSameThreadAndUpdate(angle::ThreadId currentThread, angle::ThreadId newThread, std::atomic\u003cangle::ThreadId\u003e *ownerThread)\n{\n    const bool sameThread \u003d CheckSameThread(currentThread, ownerThread);\n    ownerThread-\u003estore(newThread, std::memory_order_relaxed);\n}\n```\n\nThen you can just write this where needed, no `#if` necessary.\n\n```\nASSERT(!CheckSameThread(angle::GetCurrentThreadId(), mOwnerThreadId));\nASSERT(CheckSameThreadAndUpdate(angle::InvalidThreadId(), threadId, \u0026mOwnerThreadId);\nASSERT(CheckSameThreadAndUpdate(angle::GetCurrentThreadId(), angle::InvalidThreadId(), \u0026mOwnerThreadId);\n// etc\n```",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "303791b5_46cc5231",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 119,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "I know, but the proposed solution is less readable. Not checked if it is correct.\nBut I am not arguing, will rewrite as you do.",
      "parentUuid": "a9728745_92c04060",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad7994d2_e0dbb76e",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 119,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-01T18:33:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "303791b5_46cc5231",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "251dbf1e_c4271589",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 153,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Should these two be reordered? Otherwise the root may change in between",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 153,
        "endChar": 0
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ba96534_2f088e77",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 153,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "No.\n\n`mMutex` is not root (above if) and it is unlocked, because no point holding mutex that is not root.\n\nThen we calling recursively `doLock` with *currently unstable* root. If after locking root of locked root is root - then *root is stable*. It is impossible to change root of a mutex while it is locked.\n\n\u003e Otherwise the root may change in between\n\n`mRoot` of `root` may change even if not unlock `mMutex`. `mMutex` is a leaf of `root` now and does not participate in locking. So locking `mMutex` was a mistake.",
      "parentUuid": "251dbf1e_c4271589",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 153,
        "endChar": 0
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d6d27b1_4e6cdd83",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 153,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "6ba96534_2f088e77",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 153,
        "endChar": 0
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "705ca0c4_18c1f53b",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 176,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "If you remove the `#if` from the header, you can also make this initialization unconditional.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0633e18a_3b93aaac",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 176,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-01T18:33:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "705ca0c4_18c1f53b",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91af88f2_72746832",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 200,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "A high level description of what\u0027s going on here would be good. Something about successfully acquiring the roots of both this and the other share group under their own locks, meanwhile accounting for the fact that root may change.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc4b2015_d92174b8",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 200,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "Agree. It is hard to make description clear, but Ill try...",
      "parentUuid": "91af88f2_72746832",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af6fd5ba_45e09898",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 200,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added description. Hope it is clear...",
      "parentUuid": "bc4b2015_d92174b8",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23a829bf_1be1d041",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 233,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "A comment as to why the tree height (even though the tree is later flattened) is being tracked here would be useful. IIUC, the node with a higher rank has gone through fewer root changes and so is carrying a smaller `mOldRoots` (according to the comment on `mRank`)?",
      "range": {
        "startLine": 224,
        "startChar": 0,
        "endLine": 233,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5597b3b_28eb6009",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 233,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "I see tree and flattened tree as completely different trees that exist to solve different problems.\n\n\u003e IIUC, the node with a higher rank has gone through fewer root changes and so is carrying a smaller mOldRoots (according to the comment on mRank)?\n\nCorrectly: leaf nodes of the root node with a higher rank has gone through fewer root changes and so these nodes carrying a smaller mOldRoots.\n\nFor a root note, root change may happen only once, after that it is always a leaf node. `mRank` is only relevant for a root node.",
      "parentUuid": "23a829bf_1be1d041",
      "range": {
        "startLine": 224,
        "startChar": 0,
        "endLine": 233,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ece8a26_84b63e2f",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 233,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "See description for `mRank`.",
      "parentUuid": "d5597b3b_28eb6009",
      "range": {
        "startLine": 224,
        "startChar": 0,
        "endLine": 233,
        "endChar": 5
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9939681d_fab59d91",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 249,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Please comment that this is called with the mutex held.\n\nStill, is it possible for another SharedContextMutex to call `getRoot()` without holding the lock at this time? What happens if that other share group gets the old root?",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af74537b_e06ac697",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 249,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "This is a private method. I generally do not comment such thing in small classes.\n\n\u003e Still, is it possible for another SharedContextMutex to call getRoot() without holding the lock at this time?\n\nYes. This is the first that is called to lock the mutex: get root and lock it.\nThere is a comment in the `getRoot()` method.\n\n\u003e What happens if that other share group gets the old root?\n\nThere are 2 scenarios:\n1) SharedContextMutex is not locked\n\nWe may get old root, however it is still OK to lock the old root.\nSo first we must lock the returned root.\nThen check what is the root of that root? If it itself, than we have locked root -\u003e scenario 2.\n\n2) SharedContextMutex is locked.\n\nReturned mutex can\u0027t be old since `setNewRoot()` only called while mutex is locked.\nSo we may safely use `getRoot()` inside locks for comparisons. For example, to tell if other Context uses same root mutex or not (can be used in `notifyDeviceLost` to lock all Contexts).",
      "parentUuid": "9939681d_fab59d91",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "534762dc_cb924b94",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 249,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added comment.",
      "parentUuid": "af74537b_e06ac697",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f294d53_a3cc41a3",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 261,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Why not `oldRoot-\u003erelease()` here and avoid tracking old roots altogether?",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e586b38_7fb9a016",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 261,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "Same question as for why have `mOldRoots` and `mRank`.\n`mOldRoots` are here to fix a specific problem. I will add description in the comments to the `mOldRoots`.\nI will also try to describe overall data structure and high level design.",
      "parentUuid": "6f294d53_a3cc41a3",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fe662225_0968491e",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 261,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added description why need to track `mOldRoots`.",
      "parentUuid": "0e586b38_7fb9a016",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7889238_76f57896",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 266,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "ditto (comment that it\u0027s called with lock)",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b281261_f5b865e8",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 266,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b7889238_76f57896",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8ce99fd_dccae448",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 276,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "ditto",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3227163_2875d92f",
        "filename": "src/libANGLE/SharedContextMutex.cpp",
        "patchSetId": 18
      },
      "lineNbr": 276,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d8ce99fd_dccae448",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e13f33b9_cb19573c",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 22,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "We tend to avoid nested classes in most cases. Why not call it `ScopedContextMutex` and move it below this class?",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d645b21_f3053611",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 22,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "Because I personally like nesting) And code was written a long time ago...\n\n\u003e Why not call it ScopedContextMutex and move it below this class?\n\nBecause there will be another why: \"Why not use `std::lock_guard\u003c\u003e`?\"\n\nThis lock specifically adds references and used in specific places when required. Other places may use `std::lock_guard\u003c\u003e`, like `SCOPED_SHARE_CONTEXT_LOCK()` for example.\n\nSo the name should be at least: `ScopedContextMutexAddRefLock`.",
      "parentUuid": "e13f33b9_cb19573c",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b42bd95_16d5843f",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 22,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "`ScopedContextMutexAddRefLock` SGTM",
      "parentUuid": "5d645b21_f3053611",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "961269ca_3e6e7f55",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 22,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0b42bd95_16d5843f",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "295a5ab3_734f2265",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 40,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Please avoid default arguments, as well as bool arguments. I haven\u0027t looked for all the places this is called, but either have `release()` and `releaseAndUnlock()`, or have an `enum class` that names the two states being passed to `release()`.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25b7efbe_1276dc02",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 40,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "It is OK if private method will have `bool` argument?",
      "parentUuid": "295a5ab3_734f2265",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b853a3ab_e863a9b7",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 40,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "In this case (small class), that should be fine.",
      "parentUuid": "25b7efbe_1276dc02",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a84d7ac8_8e910db1",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 40,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added enum `UnlockBehaviour`.",
      "parentUuid": "b853a3ab_e863a9b7",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "029720db_cde34811",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 60,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "nit: suggest `getState(std::memory_order order)` to make it clear at call site what the memory order is (and also because on its own `acquireState` is just synonym with `getState`, `fetchState`, `retrieveState`, `loadState` etc; it\u0027s not clear that it\u0027s talking about `memory_order_acquire`)",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9896c316_b9607c54",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 60,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e it\u0027s not clear that it\u0027s talking about \n\nNot everything is clear from the first glance. It is just 2 different getters with encapsulated memory order. In this case we need to remember that one is relaxed and other is acquire.\n\nI do not want to add an argument. Rather rename to be more explicit.",
      "parentUuid": "029720db_cde34811",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "841e1d74_18a05dc1",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 60,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "That\u0027s fine too.",
      "parentUuid": "9896c316_b9607c54",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e6a3e07d_49c7ab36",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 60,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Decided to add the `std::memory_order order` argument.",
      "parentUuid": "841e1d74_18a05dc1",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91c160d4_58484d7f",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 81,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Not clear what this means, add/release must be synchronized... by a mutex? Which mutex? And what is \"single mutex\"?",
      "range": {
        "startLine": 81,
        "startChar": 7,
        "endLine": 81,
        "endChar": 96
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2789aa30_f07498fe",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 81,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e Not clear what this means, add/release must be synchronized... by a mutex? Which mutex?\n\nMaybe. Or using atomic, or anything else.\nSame as for Vulkan APIs, that require external synchronization.\nSimply, can\u0027t call `addRef/release()` at the same time - that is it.\n\nAgree that this may be unclear, but I want for implementation to decide what will be used for this synchronization. Currently, `ContextMutex` itself is used for synchronization (like in `AddRefLock` lock).\n\nI instead could write specifically: lock the mutex while calling its `addRef/release()`, but this may potentially (but unlikely) limit other valid uses. For example, we may create some global mutex to protect `addRef/release()` call for all Contex mutexes.\n\n\u003e And what is \"single mutex\"\n\nNot merged.\n\nFor example: we have MutexA and MutexB each may be synchronized by different mutex. In this implementation, mutexes themself are used to synchronize their `addRef/release()` calls.\nAfter the merge we will still have MutexA and MutexB, however now both must be synchronized as if they are a single mutex. Fortunately, after merging, they will act as a single mutex (but with different handles) and will satisfy synchronization requirement.",
      "parentUuid": "91c160d4_58484d7f",
      "range": {
        "startLine": 81,
        "startChar": 7,
        "endLine": 81,
        "endChar": 96
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c98ea89_33fb77e3",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 81,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "\u003e Simply, can\u0027t call addRef/release() at the same time - that is it.\n\nI guess the sentence is a bit out of context, I don\u0027t really understand what the point about `addRef()/release()` is above `Merge()`. Are you saying _after_ the merge they should be synchronized?\n\nDoes something like this explain it? \"addRef()/release() should be protected by an external mutex after merging two mutexes (just as is the case for unmerged mutexes)\"",
      "parentUuid": "2789aa30_f07498fe",
      "range": {
        "startLine": 81,
        "startChar": 7,
        "endLine": 81,
        "endChar": 96
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2909af5_eee800c0",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 81,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-02T18:32:55Z",
      "side": 1,
      "message": "\u003e Does something like this explain it? \"addRef()/release() should be protected by an external mutex after merging two mutexes (just as is the case for unmerged mutexes)\"\n\nYes. I already have more detailed explanation. I also want to avoid words like \"protected by an external mutex\". This may be anything, including SharedCpontexMutex itself.",
      "parentUuid": "5c98ea89_33fb77e3",
      "range": {
        "startLine": 81,
        "startChar": 7,
        "endLine": 81,
        "endChar": 96
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e5c2bd7_42c6dbb2",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 81,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Update the comment.",
      "parentUuid": "e2909af5_eee800c0",
      "range": {
        "startLine": 81,
        "startChar": 7,
        "endLine": 81,
        "endChar": 96
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "017bca3d_35ab9aef",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 108,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "nit: could use a better explanation, it\u0027s obviously an array of references, but why is it keeping references?",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca557765_8672dbda",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 108,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "It is not obvious that for each element was called `addRef`.\nI will try to add explanation why...",
      "parentUuid": "017bca3d_35ab9aef",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "577c5904_7232c5b7",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 108,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Added the explanation why need `mOldRoots`.",
      "parentUuid": "ca557765_8672dbda",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c420cb3_0e662abf",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 112,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "super nit: you can simplify by having this be unconditionally defined in the header, but unused elsewhere without asserts. (i.e. you can remove the `#if`)",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7877b9d4_eb7b522e",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 112,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "In theory I can, but it may affect the performance. I know, this sounds  unrealistic, but on Android I was getting different kinds of strange behaviors. For example if constructor is not inline (not this class, but older not virtual version), then lock/unlock worked slower!\n\nI will try to remove this `#if` and see if it affects the performance.",
      "parentUuid": "9c420cb3_0e662abf",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0146be0c_f5b1326b",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 112,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-01T18:33:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7877b9d4_eb7b522e",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "787cb45c_967d11d0",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 134,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "AFAICT, this should just be a few global functions? What\u0027s with the pure virtual class and inheritance?",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 134,
        "endChar": 2
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70bdf50e_3071edf6",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "I wanted make it simple to change `SharedContextMutexManager` `Mutex` type also at runtime. With this interface we just need to instantiate required `SharedContextMutexManager\u003cMutex\u003e` instance and use it in the code.\n\nWith the global functions we need to know how to cast from `ContextMutex` to `SharedContextMutex\u003cMutex\u003e` in each function. With compile time `Mutex` type this is not a problem, but may require `RendererVk` in a run-time case.",
      "parentUuid": "787cb45c_967d11d0",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 134,
        "endChar": 2
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5df69078_c605c92e",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 134,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T18:02:49Z",
      "side": 1,
      "message": "\u003e I wanted make it simple to change SharedContextMutexManager Mutex type also at runtime.\n\nDo you have a specific use case in mind? Unless you\u0027re planning on adding such a thing, it\u0027s ok to keep this a compile-time thing for now and save some complexity 😊",
      "parentUuid": "70bdf50e_3071edf6",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 134,
        "endChar": 2
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c90ce4c9_27c015b8",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 134,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-02T18:32:55Z",
      "side": 1,
      "message": "In the beginning there was FastMutex implementations, so I was planning changing mutex type. By default it could be FastMutex1 but change to other type if there some problems in specific apps. How end where to detect apps is a different question.\n\nOther case is for debugging/testing. So to test different mutex types without recompilation.\n\nI do not want to rewrite what is already implemented into global functions...",
      "parentUuid": "5df69078_c605c92e",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 134,
        "endChar": 2
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a60767b1_9cb52435",
        "filename": "src/libANGLE/SharedContextMutex.h",
        "patchSetId": 18
      },
      "lineNbr": 134,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T14:54:14Z",
      "side": 1,
      "message": "Acknowledged. I may follow up with a simplification after this change, which you can keep reverted downstream. I don\u0027t suspect it would cause too much merge conflict annoyance",
      "parentUuid": "c90ce4c9_27c015b8",
      "range": {
        "startLine": 116,
        "startChar": 0,
        "endLine": 134,
        "endChar": 2
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c542761b_68a6a184",
        "filename": "src/libANGLE/State.h",
        "patchSetId": 18
      },
      "lineNbr": 1083,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Naming nit:` mUsesSharedContextMutex`?",
      "range": {
        "startLine": 1083,
        "startChar": 20,
        "endLine": 1083,
        "endChar": 47
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be47916a_3339b03c",
        "filename": "src/libANGLE/State.h",
        "patchSetId": 18
      },
      "lineNbr": 1083,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "Uses is incorrect.\nIt is a 2 stage process: 1 - use; 2 - activate.\n\nAlready have:\n`isUsingSharedContextMutex()` and `isSharedContextMutexActive()`.\n\nTwo states needed for mutex replacement. Maybe would not be required if use `SpinLock` in the `SingleContextMutex`. But need to be careful...",
      "parentUuid": "c542761b_68a6a184",
      "range": {
        "startLine": 1083,
        "startChar": 20,
        "endLine": 1083,
        "endChar": 47
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a0876ec_7f0130b9",
        "filename": "src/libANGLE/State.h",
        "patchSetId": 18
      },
      "lineNbr": 1083,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T18:41:10Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "be47916a_3339b03c",
      "range": {
        "startLine": 1083,
        "startChar": 20,
        "endLine": 1083,
        "endChar": 47
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25c097c1_b3b634ab",
        "filename": "src/libANGLE/queryutils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 4443,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "I don\u0027t entirely like what I\u0027m about to say, but it\u0027s probably better to just lock this on the entry point. If any other case ends up using the context, it\u0027s going to be very easy to miss this lock.\n\nIf you _really_ want to limit it to BUFFER_AGE, I\u0027d make the decision that BUFFER_AGE is the only one that needs the context right in the entry point (like `QuerySurface()` in `egl_stubs.cpp`) and then lock for \"all cases that need the context (currently only buffer age)\" and then send a `nullptr` context to this function for the other cases. If anyone needs the context elsewhere, they\u0027ll be forced to update the entry point and naturally end up taking the lock.",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0cd3487_43bd6fa5",
        "filename": "src/libANGLE/queryutils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 4443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e I don\u0027t entirely like what I\u0027m about to say, but it\u0027s probably better to just lock this on the entry point. If any other case ends up using the context, it\u0027s going to be very easy to miss this lock.\n\nUnfortunately this is true for all other EGL APIs that do not use Context lock at all. So we need to lock Context unconditionally in all EGL APIs that have Context current then? What if some API does not use current Context now, bot will use it later?\n\n\u003e if you really want to limit it to BUFFER_AGE, I\u0027d make the decision that BUFFER_AGE is the only one that needs the context right in the entry point (like QuerySurface() in egl_stubs.cpp) and then lock for \"all cases that need the context (currently only buffer age)\" and then send a nullptr context to this function for the other cases. If anyone needs the context elsewhere, they\u0027ll be forced to update the entry point and naturally end up taking the lock.\n\nI want to limit locking as much as possible...\nWill try to do the suggested.",
      "parentUuid": "25c097c1_b3b634ab",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9e5f6a1_c205d8be",
        "filename": "src/libANGLE/queryutils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 4443,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "Moved lock to `GetContextMutex_QuerySurface` and pass not null context in `QuerySurface()` only if `attribute \u003d\u003d EGL_BUFFER_AGE_EXT`.",
      "parentUuid": "f0cd3487_43bd6fa5",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57aa0eda_0d8336b1",
        "filename": "src/libANGLE/validationEGL.h",
        "patchSetId": 18
      },
      "lineNbr": 170,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "Could we use some Scoped* something and let destructor deal with it?",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d681245_dea7af38",
        "filename": "src/libANGLE/validationEGL.h",
        "patchSetId": 18
      },
      "lineNbr": 170,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "I can try. I used `std::unique_lock` before and performance was slower. Maybe with custom `Scoped` class performance will be the same.",
      "parentUuid": "57aa0eda_0d8336b1",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3cd413de_c2b18063",
        "filename": "src/libANGLE/validationEGL.h",
        "patchSetId": 18
      },
      "lineNbr": 170,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-01T18:33:45Z",
      "side": 1,
      "message": "Added `ScopedOptionalContextMutexLock`. Performance is the same.",
      "parentUuid": "8d681245_dea7af38",
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2b3604a_52c93a01",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 218,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "These functions only have a few possibilities, I suggest putting the list of what function needs what call in the python script, generate that on the entry point as necessary and pass it `ANGLE_EGL_CONTEXT_LOCK`.\n\nIf it helps, I\u0027d honestly get rid of the `!defined(ANGLE_ENABLE_SHARED_CONTEXT_MUTEX)` path",
      "range": {
        "startLine": 218,
        "startChar": 48,
        "endLine": 218,
        "endChar": 68
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90fee2a9_8b32008b",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 218,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "\u003e These functions only have a few possibilities, I suggest putting the list of what function needs what call in the python script, generate that on the entry point as necessary and pass it ANGLE_EGL_CONTEXT_LOCK.\n\nI do not like this. If in the future we add another API that requires lock we may forget to add this function in that list. Currently there will be linking error.\n\n\u003e If it helps, I\u0027d honestly get rid of the !defined(ANGLE_ENABLE_SHARED_CONTEXT_MUTEX) path\n\nImpossible unless remove `ANGLE_FORCE_CONTEXT_CHECK_EVERY_CALL` and `ANGLE_ENABLE_SHARE_CONTEXT_LOCK` options.",
      "parentUuid": "e2b3604a_52c93a01",
      "range": {
        "startLine": 218,
        "startChar": 48,
        "endLine": 218,
        "endChar": 68
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4675bb76_31308f7b",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 218,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T18:41:10Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "90fee2a9_8b32008b",
      "range": {
        "startLine": 218,
        "startChar": 48,
        "endLine": 218,
        "endChar": 68
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2686868_72f7cfc4",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-28T20:17:48Z",
      "side": 1,
      "message": "nit: `Active` is an internal detail of how the share group mutex is managed. I think we can drop it from the function name.",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e78b2479_92b649ac",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-01T15:05:20Z",
      "side": 1,
      "message": "It is not internal details.\n\nPublic methods:\n`\nContext::getContextMutex()\nContext::ensureSharedMutexActive()\n`\n\nSo `Active` comes from public `ensureSharedMutexActive()`.\nTo drop `Active` need also rename `ensureSharedMutexActive()`.\n\nMay rename to `ensureUsingSharedMutex()` but inside this method will check for `Active`, so that `Active` state will be internal only.",
      "parentUuid": "d2686868_72f7cfc4",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f10a65e0_8cc25309",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-31T19:50:17Z",
      "side": 1,
      "message": "If rename to `TryGetSharedContextMutex` it is not clear that this method will also change the mutex type from `SingleContextMutex` to `SharedContextMutex\u003c\u003e`.\n\nInitially Context may have both mutexes, in which case `mSharedContextMutex` will be inactive. So:\n\n```\nTryGetContextMutex()       -\u003e mSingleContextMutex\nTryGetSharedContextMutex() -\u003e mSharedContextMutex\nTryGetContextMutex()       -\u003e mSharedContextMutex or mSingleContextMutex?\nTryGetSharedContextMutex() -\u003e mSharedContextMutex\n```\n\nHaving `Active` adds a hint, that `mSharedContextMutex` will be activated (if not already) and then returned.\n```\nTryGetContextMutex()             -\u003e mSingleContextMutex\nTryGetActiveSharedContextMutex() -\u003e mSharedContextMutex\nTryGetContextMutex()             -\u003e mSharedContextMutex\nTryGetActiveSharedContextMutex() -\u003e mSharedContextMutex\n```\n\nI do not know what is wrong with `Active` and why it should be internal state...",
      "parentUuid": "e78b2479_92b649ac",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c2d8085_be9cf940",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T14:54:14Z",
      "side": 1,
      "message": "\u003e Having Active adds a hint, that mSharedContextMutex will be activated (if not already) and then returned.\n\nAh got it, in that case I suggest calling it `TryGetAndActivate...` that makes it clear that you are not \"getting an active mutex\", but rather you are \"getting _and_ activating mutex\".",
      "parentUuid": "f10a65e0_8cc25309",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b87b2daf_2174db11",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-05T17:34:37Z",
      "side": 1,
      "message": "`TryGetAndActivate` will only activate if not active, so activate will be called only once.\n\n\u003e that makes it clear that you are not \"getting an active mutex\n\nBut your are indeed getting an active mutex)\n\nFirst time when it is not active - it is activated and then returned as active.\nOther times it is simply returned because it is already active.\n\n\u003e  but rather you are \"getting and activating mutex\"\n\nThis is not correct.\nActivate is one time operation.\n`TryGetAndActivateSharedContextMutex` will suggest that it is activated multiple times.\n\nThat is why  I have function `ensureSharedMutexActive()` and not `activateSharedMutex()`. So I operate with state `Active` not with action `Activate`.\n\nIf rename `TryGetActiveSharedContextMutex() -\u003e TryGetAndActivateSharedContextMutex()` then need also rename `ensureSharedMutexActive() -\u003e activateSharedMutex()`.\n\nBut I do not like `activateSharedMutex()` because activate may happen only once, so it will only perform its function only the first time, all other times it is just check that it is already active.",
      "parentUuid": "1c2d8085_be9cf940",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea9c9f65_326cd644",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-06-05T18:40:21Z",
      "side": 1,
      "message": "Ok, I\u0027m not going to push for the name, resolving the issue.\n\nI still think `GetAndActive` (while keeping `ensure...Activate`) is better because `GetActive` looks like a getter without any \"action\". The precision of `GetAndActivate` vs `GetAndActivateIfNotAlready` doesn\u0027t really matter.",
      "parentUuid": "b87b2daf_2174db11",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b0990ba_5e6c6e96",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 18
      },
      "lineNbr": 230,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-06-05T18:58:01Z",
      "side": 1,
      "message": "\u003e is better because GetActive looks like a getter without any \"action\".\n\nBecause most of the time there will be no action. And activation may happen in many places, including Context creation.\n\nI guess we focus on different things. It is subjective. For you it is important to have action in the name, but for me state is more important.\n\nFor me with  `TryGetAndActive...` it is not clear what happen if it is already `Active`. Also actions are reversed... More correct is `TryActivateAndGet..`. But in this case it is more unclear what happen if it is already active - try will fail?\n\nThis name is longer, but at least it is clear for me what will happen: `TryEnsureActiveAndGet...`",
      "parentUuid": "ea9c9f65_326cd644",
      "range": {
        "startLine": 230,
        "startChar": 38,
        "endLine": 230,
        "endChar": 44
      },
      "revId": "d2624ed4ab04105a5c8f4062bf28a3a7b7e23247",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}