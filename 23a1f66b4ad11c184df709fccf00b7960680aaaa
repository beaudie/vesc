{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a9a455f6_d53c2221",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-03T14:17:48Z",
      "side": 1,
      "message": "Looks correct, CC @geofflang in case I missed something",
      "revId": "23a1f66b4ad11c184df709fccf00b7960680aaaa",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2970356_7aa74d37",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-04-03T16:35:38Z",
      "side": 1,
      "message": "I thought the original intention is to partition the global lock into multiple lock domains, one of which is surface lock. Should we do the opposite: Keep the ANGLE_SCOPED_GLOBAL_SURFACE_LOCK and remove ANGLE_SCOPED_GLOBAL_LOCK here (and do similar fix for https://chromium-review.googlesource.com/c/angle/angle/+/4316610 as well which leads to this CL). What do you think? Otherwise, there will still potential lock contention that when someone doing a bit lengthy work while holding global lock, surface operation will still get blocked, and lock partition was intended to avoid that.",
      "revId": "23a1f66b4ad11c184df709fccf00b7960680aaaa",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "199a3cfa_df3b1626",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-04-03T16:36:18Z",
      "side": 1,
      "message": "Unresolve.",
      "parentUuid": "f2970356_7aa74d37",
      "revId": "23a1f66b4ad11c184df709fccf00b7960680aaaa",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65f2d852_39b0d461",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-03T17:49:23Z",
      "side": 1,
      "message": "\u003e What do you think? \n\nI\u0027m afraid that we can\u0027t use only `ANGLE_SCOPED_GLOBAL_SURFACE_LOCK()` in the current state. Need to investigate each function individually. Some functions may access Display state, or Share Context state, for example. So need to also keep `ANGLE_SCOPED_GLOBAL_LOCK()` in such cases. Then, possibly, try to remove dependence on the Global Lock for these operations. But I do not know if such thing should be done in the generated code.\n\n\u003e when someone doing a bit lengthy work while holding global lock\n\nMy solution was to avoid such situations by temporary unlocking global lock. Each such unlock case must be investigated if it is safe to do so, of course.",
      "parentUuid": "199a3cfa_df3b1626",
      "revId": "23a1f66b4ad11c184df709fccf00b7960680aaaa",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "980e5b91_87a48380",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-03T18:15:48Z",
      "side": 1,
      "message": "\u003e I thought the original intention is to partition the global lock into multiple lock domains, one of which is surface lock\n\nMy understanding is that `g_SurfaceMutex` was added to ensure that all functions that use `EGLSurface` were protected by this mutex. Concrete function is `SurfaceImpl::prepareSwap()`. In the original implementation, `g_Mutex` was released before `prepareSwap()`, while `g_SurfaceMutex` was still locked. I think that `g_SurfaceMutex` was introduced solely to protect `prepareSwap()` call. As a consequence, this caused  usage of `g_SurfaceMutex` in every other function that uses `EGLSurface`.\n\nI do not know why `g_SurfaceMutex` was necessary to protect `prepareSwap()`. Maybe just for safety. `prepareSwap()` is a pretty big method, that can recreate Swapchain, for example. If not just for safety, than removing `ANGLE_SCOPED_GLOBAL_SURFACE_LOCK()` in the recent CL was a mistake.\n\nMy next CL: `DRAFT: Try remove CUSTOM_EGL_ENTRY_POINTS.`\nmakes refactoring where `prepareSwap()` replaced with temp unlock of `g_Mutex`. But I think it is much safer to just unlock Vulkan ANI call.",
      "parentUuid": "65f2d852_39b0d461",
      "revId": "23a1f66b4ad11c184df709fccf00b7960680aaaa",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}