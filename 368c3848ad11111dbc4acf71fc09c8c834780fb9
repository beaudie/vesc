{
  "comments": [
    {
      "key": {
        "uuid": "b4a82cde_7cce8060",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 368,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "Why are you hard-coding the shader version here?",
      "range": {
        "startLine": 368,
        "startChar": 75,
        "endLine": 368,
        "endChar": 78
      },
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2a96623_50e29b48",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 368,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "That\u0027s the version in which this function was introduced. Hard coding looks like the common practice as seen in `tree_ops/ClampFragDepth.cpp`, `tree_ops/ClampPointSize.cpp`, `tree_ops/RemovePow.cpp` etc.\n\nWould you rather I pass in the current shader version to the traverser?",
      "parentUuid": "b4a82cde_7cce8060",
      "range": {
        "startLine": 368,
        "startChar": 75,
        "endLine": 368,
        "endChar": 78
      },
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "994eaf34_8304ddd4",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 368,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-19T16:01:47Z",
      "side": 1,
      "message": "Ah, ok.   When I was working on the dFdy() stuff, I came across tree_ops/RewriteTexelFetchOffset.cpp which passed the value around.\n\nShould there be checking that the shader that this work is being done for is at least 310 before going through all of these steps?   Or is that protected somewhere else beforehand?   Otherwise, CreateBuiltInFunctionCallNode() will return null and it\u0027ll segfault in the next call to queueReplacement().\n\nSomething like:\n\n    if (shaderVersion \u003c 300)\n        return;",
      "parentUuid": "d2a96623_50e29b48",
      "range": {
        "startLine": 368,
        "startChar": 75,
        "endLine": 368,
        "endChar": 78
      },
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60c09540_fe9396e2",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 384,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "Is this just for simplicity?   \n\nIn a CPU, a R/M/W will be slower than just a read, since (presumably) there will be a sync after the write to make sure it lands before any other work is done.   GPUs may behave differently though.",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd7e3163_fca7ca4d",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 384,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "Yes. I would have preferred the \"atomic read\" wouldn\u0027t need to write to memory, but I\u0027m not sure what\u0027s the best way to achieve that. In particular, I\u0027m afraid just reading the value may end up caching it. The answer to the coherent question below might answer this too.",
      "parentUuid": "60c09540_fe9396e2",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4375ff43_a22ff267",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 384,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-19T16:01:47Z",
      "side": 1,
      "message": "I don\u0027t know how GPUs work, but assuming they are anything like CPUs, a write to the value will invalidate the cache line containing the data which forces a read by the next time it\u0027s accessed by anyone.   Otherwise, if you really want to avoid reading the cached value, you\u0027d need to add a \u0027volatile\u0027 to ensure it\u0027s always re-read.   Volatile accesses are different than atomic accesses to data though.   \n\nIn the atomic access case, marking the data as coherent (which CPU caches typically are) will cause the cache invalidation to occur if the value changes.   This is why the writer requires a sync to be performed, so it flushes any pending memory writes before releasing locks to tell the memory controller to invalidate everyone else\u0027s caches.   If no one is writing the data though, it\u0027s perfectly safe for everyone to keep a locally cached copy and use that value.\n\nIt looks like the \u0027coherent\u0027 qualifier may do what you\u0027re looking for also, but I\u0027m still learning the memory models for this stuff.",
      "parentUuid": "cd7e3163_fca7ca4d",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36955e5b_253430bc",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 477,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "Since the data must be stored in a buffer object, is there a way to know which buffer is being used to store the data and mark that buffer as coherent so the rest of the code handles the necessary barriers?",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "65f3e378_2dc46a1b",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 477,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "See the other comment regarding host coherency (which I believe is what you are talking about here).\n\nI\u0027m convinced now, reading more, that the `coherent` qualifier is indeed needed here. It\u0027s still not clear to me if reading the variable without an `atomic*` function would be equivalent to `atomicCounter()`.",
      "parentUuid": "36955e5b_253430bc",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd37ad23_7f4cf05b",
        "filename": "src/compiler/translator/TranslatorVulkan.cpp",
        "patchSetId": 4
      },
      "lineNbr": 477,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-19T16:01:47Z",
      "side": 1,
      "message": "Yup, I was thinking along the lines of host coherency.",
      "parentUuid": "65f3e378_2dc46a1b",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d89f5cc_8b53a64c",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 210,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "This can be removed so only 1 function call is performed, since the result is checked later.",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7295ef5_9fc1449f",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 210,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2d89f5cc_8b53a64c",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6aa85118_973a5271",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 223,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "Assuming you can know this is for the buffer that\u0027s holding the atomic counters, can you set bufferHelper.mMemoryPropertyFlags to indicate the memory needs to be coherent?",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48f2bcb7_e7c68849",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 223,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "I believe there\u0027s a small confusion here. We don\u0027t need the buffer to be \"host\" coherent. The other comment about coherent was regarding the GLSL `coherent` qualifier, which I believe controls how the resource data is cached on the GPU.",
      "parentUuid": "6aa85118_973a5271",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d37cae3_45ed57fc",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1206,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-07-18T21:50:12Z",
      "side": 1,
      "message": "Ah, ok, you do know what the buffer is for here.   Maybe you can mark it coherent here instead.",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "281e0132_a8193ce5",
        "filename": "src/libANGLE/renderer/vulkan/ProgramVk.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1206,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-07-19T14:56:15Z",
      "side": 1,
      "message": "See other comments.",
      "parentUuid": "8d37cae3_45ed57fc",
      "revId": "368c3848ad11111dbc4acf71fc09c8c834780fb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}