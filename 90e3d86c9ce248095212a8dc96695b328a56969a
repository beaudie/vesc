{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "82aacd6e_61243aa7",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-23T20:50:02Z",
      "side": 0,
      "message": "How was this not a problem before? Should the restore function instead not attempt to restore this information when !separable?",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19cf6057_c28c05d0",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-23T23:41:06Z",
      "side": 0,
      "message": "\u003e How was this not a problem before?\n\nOnly PPOs use these values.\n\n\u003e Should the restore function instead not attempt to restore this information when !separable?\n\nI went with this approach to avoid any order of operations issues since mState.mSeparable is saved/restored in Program::serialize()/deserialize() vs. being used in ProgramExecutable::save()/load().   The current version of this CL loads mState.mSeparable after the call to mState.mExecutable-\u003eload(), since it was added to the end of the function.   I could rearrange things and move it to the top, but ordering requirements like that are fragile in the long term.\n\nAdditionally, this guarantees that the values are always valid in case we do end up needing to use them for monolithic programs in the future.",
      "parentUuid": "82aacd6e_61243aa7",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e0047bd_40fd9c55",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-24T03:33:26Z",
      "side": 0,
      "message": "My only concern is that we are storing unnecessary info for most programs and increasing the cache size unnecessarily. How much data is being written here?\n\nOut of the scope of this change, but eventually we could address the fragility by declaring the state in json and autogenerate the save/restore code. That would also let us make the pipeline cache keyed on the version of said json file instead of ANGLE commit hash so we don\u0027t discard the cache unnecessarily on ANGLE upgrades.",
      "parentUuid": "19cf6057_c28c05d0",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa93cad2_d27e301c",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-24T22:27:55Z",
      "side": 0,
      "message": "\u003e How much data is being written here?\n\nThat depends on how many varyings there are.\n\nI opened a bug to reduce the copies and added a TODO:\nanglebug.com/5793: Cleanup and unify ShaderState and ProgramExecutable varyings lists",
      "parentUuid": "0e0047bd_40fd9c55",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}