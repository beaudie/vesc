{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "82aacd6e_61243aa7",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-23T20:50:02Z",
      "side": 0,
      "message": "How was this not a problem before? Should the restore function instead not attempt to restore this information when !separable?",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19cf6057_c28c05d0",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-23T23:41:06Z",
      "side": 0,
      "message": "\u003e How was this not a problem before?\n\nOnly PPOs use these values.\n\n\u003e Should the restore function instead not attempt to restore this information when !separable?\n\nI went with this approach to avoid any order of operations issues since mState.mSeparable is saved/restored in Program::serialize()/deserialize() vs. being used in ProgramExecutable::save()/load().   The current version of this CL loads mState.mSeparable after the call to mState.mExecutable-\u003eload(), since it was added to the end of the function.   I could rearrange things and move it to the top, but ordering requirements like that are fragile in the long term.\n\nAdditionally, this guarantees that the values are always valid in case we do end up needing to use them for monolithic programs in the future.",
      "parentUuid": "82aacd6e_61243aa7",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e0047bd_40fd9c55",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-24T03:33:26Z",
      "side": 0,
      "message": "My only concern is that we are storing unnecessary info for most programs and increasing the cache size unnecessarily. How much data is being written here?\n\nOut of the scope of this change, but eventually we could address the fragility by declaring the state in json and autogenerate the save/restore code. That would also let us make the pipeline cache keyed on the version of said json file instead of ANGLE commit hash so we don\u0027t discard the cache unnecessarily on ANGLE upgrades.",
      "parentUuid": "19cf6057_c28c05d0",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa93cad2_d27e301c",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-24T22:27:55Z",
      "side": 0,
      "message": "\u003e How much data is being written here?\n\nThat depends on how many varyings there are.\n\nI opened a bug to reduce the copies and added a TODO:\nanglebug.com/5793: Cleanup and unify ShaderState and ProgramExecutable varyings lists",
      "parentUuid": "0e0047bd_40fd9c55",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a40854d7_e7c26820",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-26T01:53:19Z",
      "side": 0,
      "message": "\u003e How much data is being written here?\n\nTo clarify this further, I added some tracing to ProgramExecutable::save() to see how much space the varyings and version numbers are adding to the stream:\n\n    void ProgramExecutable::save(gl::BinaryOutputStream *stream) const\n    {\n    ...\n        size_t previousSize \u003d stream-\u003elength();\n        WARN() \u003c\u003c \"TIMTIM \u003e\u003e Starting stream-\u003elength() \u003d \" \u003c\u003c stream-\u003elength();\n        for (ShaderType shaderType : mLinkedGraphicsShaderStages)\n        {\n            stream-\u003ewriteInt(mLinkedOutputVaryings[shaderType].size());\n            WARN() \u003c\u003c \"TIMTIM \u003e\u003e \" \u003c\u003c shaderType \u003c\u003c \": Bytes added \u003d \" \u003c\u003c stream-\u003elength() - previousSize;\n            previousSize \u003d stream-\u003elength();\n\n            for (const sh::ShaderVariable \u0026shaderVariable : mLinkedOutputVaryings[shaderType])\n            {\n                WriteShaderVar(stream, shaderVariable);\n                WARN() \u003c\u003c \"TIMTIM \u003e\u003e \" \u003c\u003c shaderType \u003c\u003c \": Bytes added \u003d \" \u003c\u003c stream-\u003elength() - previousSize;\n                previousSize \u003d stream-\u003elength();\n            }\n\n            stream-\u003ewriteInt(mLinkedInputVaryings[shaderType].size());\n            WARN() \u003c\u003c \"TIMTIM \u003e\u003e \" \u003c\u003c shaderType \u003c\u003c \": Bytes added \u003d \" \u003c\u003c stream-\u003elength() - previousSize;\n            previousSize \u003d stream-\u003elength();\n\n            for (const sh::ShaderVariable \u0026shaderVariable : mLinkedInputVaryings[shaderType])\n            {\n                WriteShaderVar(stream, shaderVariable);\n                WARN() \u003c\u003c \"TIMTIM \u003e\u003e \" \u003c\u003c shaderType \u003c\u003c \": Bytes added \u003d \" \u003c\u003c stream-\u003elength() - previousSize;\n                previousSize \u003d stream-\u003elength();\n\n            }\n            stream-\u003ewriteInt(mLinkedShaderVersions[shaderType]);\n            WARN() \u003c\u003c \"TIMTIM \u003e\u003e \" \u003c\u003c shaderType \u003c\u003c \": Bytes added \u003d \" \u003c\u003c stream-\u003elength() - previousSize;\n            previousSize \u003d stream-\u003elength();\n        }\n        WARN() \u003c\u003c \"TIMTIM \u003e\u003e Final stream-\u003elength() \u003d \" \u003c\u003c stream-\u003elength();\n\nThe end2end test SimpleOperationTest::DrawQuadWithVertexUniform() uses a single varying between the VS and FS:\n\n    TEST_P(SimpleOperationTest, DrawQuadWithVertexUniform)\n    {\n        constexpr char kVS[] \u003d\n            \"attribute vec3 position;\\n\"\n            \"uniform vec4 color;\\n\"\n            \"varying vec4 vcolor;\\n\"\n            \"void main()\\n\"\n            \"{\\n\"\n            \"    gl_Position \u003d vec4(position, 1);\\n\"\n            \"    vcolor \u003d color;\\n\"\n            \"}\";\n        constexpr char kFS[] \u003d\n            \"varying mediump vec4 vcolor;\\n\"\n            \"void main()\\n\"\n            \"{\\n\"\n            \"    gl_FragColor \u003d vcolor;\\n\"\n            \"}\";\n\nThis gives the following:\n\n    [ RUN      ] SimpleOperationTest.DrawQuadWithVertexUniform/ES2_Vulkan\n    WARN: ProgramExecutable.cpp:594 (save): TIMTIM \u003e\u003e Starting stream-\u003elength() \u003d 602\n    WARN: ProgramExecutable.cpp:598 (save): TIMTIM \u003e\u003e GL_VERTEX_SHADER: Bytes added \u003d 8\n    WARN: ProgramExecutable.cpp:604 (save): TIMTIM \u003e\u003e GL_VERTEX_SHADER: Bytes added \u003d 146\n    WARN: ProgramExecutable.cpp:604 (save): TIMTIM \u003e\u003e GL_VERTEX_SHADER: Bytes added \u003d 154\n    WARN: ProgramExecutable.cpp:609 (save): TIMTIM \u003e\u003e GL_VERTEX_SHADER: Bytes added \u003d 8\n    WARN: ProgramExecutable.cpp:620 (save): TIMTIM \u003e\u003e GL_VERTEX_SHADER: Bytes added \u003d 4\n    WARN: ProgramExecutable.cpp:598 (save): TIMTIM \u003e\u003e GL_FRAGMENT_SHADER: Bytes added \u003d 8\n    WARN: ProgramExecutable.cpp:609 (save): TIMTIM \u003e\u003e GL_FRAGMENT_SHADER: Bytes added \u003d 8\n    WARN: ProgramExecutable.cpp:615 (save): TIMTIM \u003e\u003e GL_FRAGMENT_SHADER: Bytes added \u003d 146\n    WARN: ProgramExecutable.cpp:620 (save): TIMTIM \u003e\u003e GL_FRAGMENT_SHADER: Bytes added \u003d 4\n    WARN: ProgramExecutable.cpp:623 (save): TIMTIM \u003e\u003e Final stream-\u003elength() \u003d 1088\n    INFO: GL performance: HIGH: GPU stall due to ReadPixels\n    [       OK ] SimpleOperationTest.DrawQuadWithVertexUniform/ES2_Vulkan (560 ms)\n\n\nAdding 486 bytes for a simple program is a decent amount and could add up quickly.   The number of varyings affects how much data is added, but the varyings themselves also affect the data, since things like the length of their names is variable.   \n\nIs it worth the effort of rearranging things to only save the data for PPOs?",
      "parentUuid": "aa93cad2_d27e301c",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd0e460a_28cd1d4b",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-26T03:01:51Z",
      "side": 0,
      "message": "It does look significant to be honest. It shouldn\u0027t be too much work to restrict this to PPOs, right?",
      "parentUuid": "a40854d7_e7c26820",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7690b107_b52909c8",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1638,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-29T17:18:46Z",
      "side": 0,
      "message": "Done",
      "parentUuid": "bd0e460a_28cd1d4b",
      "revId": "90e3d86c9ce248095212a8dc96695b328a56969a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}