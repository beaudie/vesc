{
  "comments": [
    {
      "key": {
        "uuid": "77698514_6dcdb307",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-06-17T14:47:52Z",
      "side": 1,
      "message": "It\u0027s fine to no-op these for now but it might let us implement a ring buffer in GL in the future.\n\nSay the user creates a buffer with the DYNAMIC hint. If the user then maps the buffer for write, we must assume that the user can overwrite some bits but not others. If the user maps with INVALIDATE_RANGE then we can discard the whole region and allocate a new chunk from the dynamic buffer.\n\nThis is a performance optimization though so it\u0027s not high priority to fix immediately.\n\nCommented in issue 3213.",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 18,
        "endChar": 34
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2ecdc70_c2a5227e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-17T14:59:58Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "77698514_6dcdb307",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 18,
        "endChar": 34
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4c543f4c_fff9e7d9",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 161,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-17T18:12:00Z",
      "side": 1,
      "message": "Is mapImpl() necessary anymore?   It looks like you can just call directly to mapRangeImpl() from here without really losing any readability.",
      "range": {
        "startLine": 161,
        "startChar": 11,
        "endLine": 161,
        "endChar": 18
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "224677ba_2a0b9f79",
        "filename": "src/libANGLE/renderer/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 161,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-17T18:48:19Z",
      "side": 1,
      "message": "I thought so too at first, but we have a user outside this class (VertexArrayVk IIRC)",
      "parentUuid": "4c543f4c_fff9e7d9",
      "range": {
        "startLine": 161,
        "startChar": 11,
        "endLine": 161,
        "endChar": 18
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77558223_531e6700",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-06-17T14:47:52Z",
      "side": 1,
      "message": "this looks like it doesn\u0027t belong in submitcommands. I would rather see this inserted in the locations where buffers are adding barriers. How feasible is it to do that?",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9365b509_f6421ee4",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-17T14:59:58Z",
      "side": 1,
      "message": "It would be inefficient to do so. You wouldn\u0027t want to add such a barrier after every buffer write (which would effectively flush it from the GPU caches) because you may write to it later or need to read from it.\n\nThis makes sure there is only a single flush for all writes to host-visible-buffers. It\u0027s analogous to the memory barriers inserted in `visitAndExecute()`, which is also called from `submitCommands`.\n\nAn alternative could be to add a special node to execute this and insert it before calling `submitCommands`, though that would be the same thing with extra overhead.",
      "parentUuid": "77558223_531e6700",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "65f1c04a_3f8b5f57",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-06-17T18:59:36Z",
      "side": 1,
      "message": "OK, I get what you\u0027re saying. I suggest we ignore the unsynchronized bit for now and explicitly set the host visible barrier right before we map. We should be able to afford to add a barrier before map for now. Let\u0027s deal with the performance problems (if any) when we get to tackling ES 3.0 perf.",
      "parentUuid": "9365b509_f6421ee4",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d660728c_efacfdf5",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-06-17T19:06:01Z",
      "side": 1,
      "message": "(That\u0027s my feeling anyway - definitely feel free to disagree :)",
      "parentUuid": "65f1c04a_3f8b5f57",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de2ee3a6_b0fc94f0",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-06-17T19:31:14Z",
      "side": 1,
      "message": "Spoke offline. Adding a single global barrier before a submit is probably the optimal path. Although thinking about your proposal for a ContextVk node a second time I would mildly prefer if you added a the extra node before a flush. Just to keep the responsibilities of the graph simpler. Does that sound reasonable?",
      "parentUuid": "d660728c_efacfdf5",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1040ab43_32b3ae3d",
        "filename": "src/libANGLE/renderer/vulkan/CommandGraph.cpp",
        "patchSetId": 2
      },
      "lineNbr": 833,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-17T19:35:56Z",
      "side": 1,
      "message": "Will do!",
      "parentUuid": "de2ee3a6_b0fc94f0",
      "range": {
        "startLine": 833,
        "startChar": 8,
        "endLine": 833,
        "endChar": 38
      },
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8c391122_808df634",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1189,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-06-17T18:12:00Z",
      "side": 1,
      "message": "Maybe this is just reiterating Jamie\u0027s comment, but looking at the various bits and their meanings:\n\n\u003e VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit specifies that memory allocated with this type can be mapped for host access using vkMapMemory.\n\n- The memory can be mapped, but this doesn\u0027t necessarily mean that it is mapped so we may be adding unnecessary barriers to keep memory coherent that no one is looking at.   Are we doing too many barriers by only looking at VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT and not whether the memory is actually mapped also (assumign we know that)?\n\n\u003e VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit specifies that the host cache management commands vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges are not needed to flush host writes to the device or make device writes visible to the host, respectively.\n\n- Based on this code, this is how OpenGL expects to behave by default and the caller should use additional flags to override that behavior.   Should we set this flag by default or would that kill performance too much and the extra work to do it only when necessary is worth the effort?\n\n\u003e VK_MEMORY_PROPERTY_HOST_CACHED_BIT bit specifies that memory allocated with this type is cached on the host. Host memory accesses to uncached memory are slower than to cached memory, however uncached memory is always host coherent.\n\n- Presumably the Vulkan driver is doing the work to keep the uncached memory coherent, so there\u0027s no work needed for us.",
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a73a0fc_e2b8f670",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1189,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2019-06-17T18:48:19Z",
      "side": 1,
      "message": "\u003e Are we doing too many barriers by only looking at VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT and not whether the memory is actually mapped also (assumign we know that)?\n\nThe problem is exactly that we _don\u0027t_ know that. The memory map is most definitely not done in the same frame the buffer is written to in any real application. So for example, we have something like this:\n\n- Frame 1, write to buffer 1\n- Frame 2, write to buffer 2\n- Frame 3, Map buffer 1, write to buffer 3\n- Frame 4, Map buffer 2, write to buffer 1\n- Frame 5, Map buffer 3, write to buffer 2\n- ...\n\nIf we don\u0027t put the barrier for buffer 1 right at the end of frame 1, we would need to make a submit/finish in frame 3 to read it back, which is unacceptable.\n\n---\n\nRegarding coherent, it\u0027s very subtle, and I might be incorrect, but there are two operations to make device writes visible to host:\n\n- An availability operation is required to make device writes even accessible by the host (effectively, this means GPU cache flush to host-visible memory)\n- A visibility operation is required to make *available* memory visible to host (effectively, this means CPU cache invalidation so the most up-to-date data can be read).\n\n`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` ensures the second part is done automatically. Your quote says:\n\n\u003e not needed to ... make device writes **visible** to the host\n\nIt doesn\u0027t include availability. The spec has another part that\u0027s even clearer:\n\n\u003e vkInvalidateMappedMemoryRanges guarantees that device writes to the memory ranges described by pMemoryRanges, which have been made available to the host memory domain using the VK_ACCESS_HOST_WRITE_BIT and VK_ACCESS_HOST_READ_BIT access types, are made visible to the host.\n\nIt says vkInvalidate* makes writes that are already available visible. It also says that VK_ACCESS_HOST_* must be used (by a pipeline barrier) to make them available. `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` makes this function unnecessary (visibility operation) and says nothing about availability. The spec says:\n\n\u003e If the memory object does have the VK_MEMORY_PROPERTY_HOST_COHERENT_BIT property flag ...  writes made available to the host domain are automatically made visible to the host.\n\nSo writes that are made available are automatically visible. How are they made available? A pipeline barrier.\n\n---\n\nWe don\u0027t use `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`, and I haven\u0027t looked into it much. I\u0027m sure it\u0027s related to CPU caching though, which shouldn\u0027t affect GPU caches.",
      "parentUuid": "8c391122_808df634",
      "revId": "8455181fd688cade530f9ad6c418c233fdd291be",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}