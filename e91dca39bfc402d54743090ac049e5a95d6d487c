{
  "comments": [
    {
      "key": {
        "uuid": "e8f77460_e5a33984",
        "filename": "scripts/registry_xml.py",
        "patchSetId": 5
      },
      "lineNbr": 67,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-07-11T17:40:25Z",
      "side": 1,
      "message": "Will let Geoff do the main review. But would suggest you split this off into a separate change to refactor our some of the code generation boilerplate. Leaving UNIMPLEMENTED() where necessary.",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 67,
        "endChar": 44
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2838487_864a3824",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 321,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "I think this can be removed, see comments below.",
      "range": {
        "startLine": 317,
        "startChar": 0,
        "endLine": 321,
        "endChar": 2
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0421c208_a9052d7a",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 321,
      "author": {
        "id": 1335991
      },
      "writtenOn": "2019-07-17T00:04:21Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d2838487_864a3824",
      "range": {
        "startLine": 317,
        "startChar": 0,
        "endLine": 321,
        "endChar": 2
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c824f5a5_52e5900a",
        "filename": "src/libANGLE/Framebuffer.cpp",
        "patchSetId": 5
      },
      "lineNbr": 2330,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "I don\u0027t think this can ever be false, it can be changed to an assert instead.",
      "range": {
        "startLine": 2330,
        "startChar": 4,
        "endLine": 2330,
        "endChar": 44
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8264b507_f0861664",
        "filename": "src/libANGLE/Framebuffer.h",
        "patchSetId": 5
      },
      "lineNbr": 183,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "textureIndex should contain the level (below too)",
      "range": {
        "startLine": 183,
        "startChar": 34,
        "endLine": 183,
        "endChar": 45
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6342bb17_91b667e9",
        "filename": "src/libANGLE/Framebuffer.h",
        "patchSetId": 5
      },
      "lineNbr": 183,
      "author": {
        "id": 1335991
      },
      "writtenOn": "2019-07-17T00:04:21Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8264b507_f0861664",
      "range": {
        "startLine": 183,
        "startChar": 34,
        "endLine": 183,
        "endChar": 45
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb7a95a3_4c79c874",
        "filename": "src/libANGLE/FramebufferAttachment.cpp",
        "patchSetId": 5
      },
      "lineNbr": 30,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "0 is a valid sample count.  Maybe you want to use -1 to represent that the multisampled-render-to-texture is not being used.",
      "range": {
        "startLine": 30,
        "startChar": 68,
        "endLine": 30,
        "endChar": 69
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa260edf_83616b54",
        "filename": "src/libANGLE/FramebufferAttachment.h",
        "patchSetId": 5
      },
      "lineNbr": 121,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "Shouldn\u0027t need this, mipLevel() is the same.",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 121,
        "endChar": 75
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c65300a5_4ce0a900",
        "filename": "src/libANGLE/FramebufferAttachment.h",
        "patchSetId": 5
      },
      "lineNbr": 222,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "Instead of usage, could this be a sample count that TextureStorage11_2D::getRenderTarget uses to initialize the multisample storage?\n\nThis would mean we wouldn\u0027t need the Texture::setMultisampledTextureInfo function chain because all of the info would be in this call.",
      "range": {
        "startLine": 222,
        "startChar": 44,
        "endLine": 222,
        "endChar": 66
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fa7869e_e6191ac3",
        "filename": "src/libANGLE/FramebufferAttachment.h",
        "patchSetId": 5
      },
      "lineNbr": 222,
      "author": {
        "id": 1335991
      },
      "writtenOn": "2019-07-16T19:15:14Z",
      "side": 1,
      "message": "Hey Geoff, \n\nI was finally able to chat with Rafael today since he was off last week. I\u0027ve been having a hard time understanding this comment. \n\nI believe that RenderTargetUse will mostly be effective on subsequent calls such as copyTexImage2D or readPixels or drawArrays or clear. In which, some cases we will need the single sampled texture back (readPixels) in others we will need the multisampled texture back (drawArrays, clear). \n\nI originally had a version where I passed samples down to the textureStorage object and it would use that value. Rafael had a comment about that saying that, I\u0027ve added this sample number to quite a number of getRenderTarget/getAttachmentRenderTarget methods (TextureStorage11_xxx, TextureD3D_xxx, RenderbufferD3D, SurfaceD3D, basically any class that inherits from FramebufferAttachmentObjectImpl). He was worried that this sample number in so many different places may be a likely source of errors in the future. From what I can tell, getAttachmentRenderTarget is only called once outside the Framebuffer chain in EGLImageD3D::getRenderTarget. However since getAttachmentRenderTarget will pass through the samples to getRenderTarget at the TextureImpl and the TextureStorage level, anything now that directly calls TextureD3D/TextureStorage11 will also need to know what samples they are looking for. \nAlthough most calls go though the framebuffer chain, but there are still some that call into textured3d/texturestorage directly:\nContext11::intializeMultisampleTextureToBlack\nRenderer11::copyImage2D/Cube/3D/2DArray\n\nThe other thing we were discussing, is that would the samples indicate which texture is expected SS vs MS and then textureStorage still does the resolution or are we always going to be returning the multisampled one based on that sample count and then the caller will do the resolution outside? Either way it seems that the sample count itself isn\u0027t enough to determine the use, we will need logic somewhere in that path to determine what it will be used for and what number we need to pass through.",
      "parentUuid": "c65300a5_4ce0a900",
      "range": {
        "startLine": 222,
        "startChar": 44,
        "endLine": 222,
        "endChar": 66
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "194ceb70_1b0ba38d",
        "filename": "src/libANGLE/FramebufferAttachment.h",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "nit: compare against kDefaultRenderToTextureSamples",
      "range": {
        "startLine": 245,
        "startChar": 35,
        "endLine": 245,
        "endChar": 36
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9d388e9_2a2afe74",
        "filename": "src/libANGLE/FramebufferAttachment.h",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 1335991
      },
      "writtenOn": "2019-07-17T00:04:21Z",
      "side": 1,
      "message": "Hey Geoff, \n\nI realized in my investigation about passing samples around that this piece of code I added here has some implication that I overlooked.\n\nI had originally added this here because getCachedSamples (which internally calls getSamples()) below was setting a flag in the rasterizer state that allowed for the renderTarget to know that it was multisample and therefore to draw with antialiasing. \n bool multiSample \u003d (fbo-\u003egetCachedSamples(context) !\u003d 0);\n    if (multiSample !\u003d mCurRasterState.multiSample)\n    {\n        mInternalDirtyBits.set(DIRTY_BIT_RASTERIZER_STATE);\n        mCurRasterState.multiSample \u003d multiSample;\n    }\n\nHowever getSamples is called from many different places, some of which I believe we would want to return the MS samples and some of which I don\u0027t think we should.\n\nSingle sampled: \nFramebufferGL::blit() -- readAttachmentSamples \u003d colorReadAttachment-\u003egetSamples(), this readAttachmentSamples is later used to determine a split between blitColorBufferWithShader or blitFramebuffer.\n\nvalidationES ValidateBlitFramebufferParameters -- readColorBuffer-\u003egetSamples() \u003e 0 and readBuffer-\u003egetSamples \u003e 0 both instances are used to determine an error in validation. But because the samples that we are getting returned should not really be \u003e 0, the validation shouldn\u0027t fail. \n\nsimilar case in validationES2 ValidateBlitFramebufferANGLE\n\nValidationES ValidateFramebufferNotMultisampled\n\n\nMultisampled:\nqueryutils.cpp\n case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT:\n            if (attachmentObject-\u003etype() \u003d\u003d GL_TEXTURE)\n            {\n                *params \u003d attachmentObject-\u003egetSamples();\n            }\n            else\n\n\nFramebuffer11::getSamplePosition\n\nContextVK::GetCoverageSampleCount\n\nContextVK::syncState \nmGraphicsPipelineDesc-\u003eupdateRasterizationSamples(\u0026mGraphicsPipelineTransition,\n                                                         mDrawFramebuffer-\u003egetSamples());\n\nState::getIntegerv\n    Framebuffer *framebuffer \u003d mDrawFramebuffer;\n    if (framebuffer-\u003eisComplete(context))\n    {\n        GLint samples \u003d framebuffer-\u003egetSamples(context);\n\n\nvalidationES::ValidateGetMultisamplefvBase\n\n\nBasically I just wanted to highlight that there are places where we may want to expose the fact that the underlying texture is multisampled and sometimes we don\u0027t. Any suggestions on how we can do this cleanly?",
      "parentUuid": "194ceb70_1b0ba38d",
      "range": {
        "startLine": 245,
        "startChar": 35,
        "endLine": 245,
        "endChar": 36
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "640f343b_58e5fc32",
        "filename": "src/libANGLE/Observer.h",
        "patchSetId": 5
      },
      "lineNbr": 53,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "I think we could skip these notifications and just leave the multisampled version of the textures alive until they\u0027re needed for reading or another framebuffer for writing.",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 53,
        "endChar": 24
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f6755a7_6edc15e6",
        "filename": "src/libANGLE/renderer/FramebufferAttachmentObjectImpl.h",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-07-11T17:41:40Z",
      "side": 1,
      "message": "I might also split this into a refactoring-only CL if that aligns with Geoff\u0027s suggestions.",
      "range": {
        "startLine": 36,
        "startChar": 51,
        "endLine": 36,
        "endChar": 77
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "110da7b9_88f34b04",
        "filename": "src/libANGLE/renderer/TextureImpl.h",
        "patchSetId": 5
      },
      "lineNbr": 193,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-07-11T17:41:40Z",
      "side": 1,
      "message": "these can also go into refactoring CLs. again to simplify the review process and make the changes more atomic.",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 193,
        "endChar": 79
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a35bf81_ed5a29f3",
        "filename": "src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1201,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "Because this function is doing some complex caching and resolving, we may want to make sure all higher level caches are invalidated when we make new render targets or resolve.  I think we can do this by making TextureStorage inherit from angle::Subject and TextureD3D will observe the storage for SubjectMessage::SubjectChanged messages and forward them to it\u0027s own onStateChange function.\n\nThis should essentially tell all users of this TextureD3D/TextureStorage that it\u0027s internals have changed and they should invalidate any caches they have.\n\nI think this may eliminate any need for the frontend layer to tell the backend to resolve or release the MS storage.",
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdb4e8f1_a472d45c",
        "filename": "src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1211,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-07-10T15:33:41Z",
      "side": 1,
      "message": "This function can handle all the transitions between the MS and non-MS versions.  Something like:\n\n    bool needsMS \u003d samples !\u003d 0;\n    if (needsMS)\n    {\n        if (mMSTexInfo \u0026\u0026 mMSTexInfo matches level/samples)\n        {\n            return mMSTexInfo-\u003emsRenderTarget;\n        }\n        else\n        {\n            if (mMSTexInfo)\n            {\n                resolve mMSTexInfo;\n                delete mMSTexInfo;\n            }\n\n            create new mMSTexInfo;\n            copy data into mMSTexInfo;\n            return mMSTexInfo-\u003emsRenderTarget;\n        }\n    }\n    else\n    {\n        if (mMSTexInfo)\n        {\n            resolve mMSTexInfo;\n            delete mMSTexInfo;\n        }\n\n        old render target path;\n    }\n\nI think we have to update a few additional places in this class that would want the non-ms resource (such as getResource, getMippedResource, copyToStorage, getSRVForSampler) to have some small logic to check if the MS texture exists and resolve it.",
      "range": {
        "startLine": 1211,
        "startChar": 4,
        "endLine": 1211,
        "endChar": 66
      },
      "revId": "e91dca39bfc402d54743090ac049e5a95d6d487c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}