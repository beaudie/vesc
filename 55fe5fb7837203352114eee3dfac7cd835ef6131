{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0779e786_74a35635",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1528827
      },
      "writtenOn": "2022-03-16T14:20:32Z",
      "side": 1,
      "message": "Hi, I am not sure whether this is the correct approach for adding support to other platforms in `GetPlatformDisplay()`, so please let me know if I am on the right track here.",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "033bc216_f90d737d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-17T02:57:45Z",
      "side": 1,
      "message": "No idea, I\u0027ll let Jamie answer you.\n\nIt does look weird that all the platforms go through EGL_PLATFORM_ANGLE_ANGLE, but somehow Wayland is special.",
      "parentUuid": "0779e786_74a35635",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66ce2dfe_1ca0337b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1125810
      },
      "writtenOn": "2022-03-17T13:23:17Z",
      "side": 1,
      "message": "Mmm.\n\nThe first question is: why EGL_PLATFORM_ANGLE_ANGLE? I can see how that makes sense from a WebGL perspective, but otherwise ANGLE is not a platform. A wl_surface or an X11 Window or a HWND is not ANGLE\u0027s native window type - so why would you create an ANGLE platform to pass in those types? (I can guess at the history here and that it would still make a certain amount of sense to choose between underlying implementations, but glvnd/EGLDevice are a better fit for that if you ask me.)\n\nSecondly, on non-Windows/Android systems, there is no \u0027the display\u0027, so we need to pass in a native display pointer. There can be multiple Wayland servers or X servers on a single machine: if you\u0027re using completely separate instances for app isolation, or nested instances also for isolation, or for development, etc. Chromium itself contains a Wayland server ... so we need to pass in a pointer to the underlying display (again in friction with EGL_PLATFORM_ANGLE_ANGLE, given that the EGL platform interface was meant to disambiguate these types, not just keep them mashed up but with more verbosity for the user).\n\nEven if there was only one system-global display server, you still need to pass in a pointer to a display connection for correctness. Wayland has a strictly per-client ID space, so you cannot create a Wayland surface from one connection and pass it to another connection. X11 does not have this restriction as it has global IDs, but there are sequencing issues: if you call XCreateWindow on one connection and pass that Window ID to another connection, it might work. Or it might not, if you haven\u0027t done a blocking roundtrip to make sure the server has processed your window-create request, which is pretty pointless. (There are other sequencing issues even in the steady state, but you get the idea.)\n\nSo we\u0027re already at the point of a hard requirement for native display and window types being passed in through the platform interface - and a wl_display/wl_surface is _not_ ANGLE\u0027s \u0027native type\u0027.\n\nEven if you close your eyes and ignore this, there isn\u0027t even one window system. On a modern native Wayland system, you will have three window systems available to you. The Wayland server will be using EGL+GL(ES) to do its own internal composition, and it wants to use EGL_KHR_platform_gbm: its output isn\u0027t feeding itself, but its upstream display platform, which is DRM/KMS for the display controller. Wayland clients will of course be using EGL_KHR_platform_wayland to connect to the Wayland server. X11 clients will be using EGL_KHR_platform_x11 to connect to the Xwayland server, which will in turn be using EGL_KHR_platform_wayland to connect to the Wayland server. (For native X11-only systems, it\u0027s similar: the X server uses EGL_KHR_platform_gbm, and clients use EGL_KHR_platform_x11).\n\nSo yeah, that\u0027s what necessitates implementing the platforms: we _could_ group three window systems under EGL_PLATFORM_ANGLE_ANGLE and attempt to internally disambiguate, but ... why? The EGL platform extensions were literally created to make it unambiguous to begin with.\n\nThe other, larger, issue is about just using ANGLE for general-purpose systems. Every Wayland client out there today uses EGL_PLATFORM_WAYLAND_KHR. If you\u0027re deploying a general-purpose system with ANGLE as the EGL/GL(ES) implementation, it means every single client would have to be patched to use EGL_PLATFORM_ANGLE_ANGLE instead. That\u0027s not really a good idea (as above) and also probably infeasible.\n\nSo yeah, coming back to the first question - is there a reason to _not_ implement the actual platform extensions?",
      "parentUuid": "033bc216_f90d737d",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8f983b9_f6e1d8b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1125810
      },
      "writtenOn": "2022-03-17T13:47:15Z",
      "side": 1,
      "message": "Arguing with myself: the obvious counter would be that the EGL_ANGLE_platform_angle_* extensions let you specify details about the underlying implementation (e.g. \u0027I want ANGLE to use Vulkan\u0027 or \u0027I want ANGLE to use Metal\u0027). But these are orthogonal to \u0027I want ANGLE to use Wayland and I want to connect to this Wayland server\u0027.\n\nEGLDevice is in a similar boat: it\u0027s specified as an EGL platform, but \u0027I want to use my powerful discrete GPU\u0027 and \u0027I want to display on this Wayland server\u0027 should not be conflated and mutually exclusive.\n\nTo that end we\u0027d discussed a new extension which would make them orthogonal: https://github.com/KhronosGroup/EGL-Registry/pull/23\n\nSo platform would be reserved for window-system specification as intended, and device would be about how the rendering occurred. If we were able to push that forward (we haven\u0027t because we\u0027ve been working on a bunch of Mesa internals to make it usefully possible and multi-GPU works just about well enough that it hasn\u0027t been burningly critical), then ANGLE could do the same: enumerate devices for each of the underlying GPUs/APIs/whatever, apps who don\u0027t care would get the default, and apps who did care could still specify details about the rendering via device together with details about the winsys via platform.",
      "parentUuid": "66ce2dfe_1ca0337b",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ddf2272_6e13783a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2022-03-17T13:51:32Z",
      "side": 1,
      "message": "I don\u0027t think we need to dig too deeply into the pros/cons of platform_angle vs other platform exts. It\u0027s just kinda where we ended up without really researching the most idiomatic extensions. I like re-using existing extensions where possible.\n\nOne request would be to split up this CL into a refactoring CL and a functionality CL. There\u0027s quite a few large diffs that would be nice to hide in a simple prior CL.",
      "parentUuid": "e8f983b9_f6e1d8b1",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03f83708_ce60e450",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1125810
      },
      "writtenOn": "2022-03-17T13:52:53Z",
      "side": 1,
      "message": "Sounds like a good path forward. Thanks!",
      "parentUuid": "8ddf2272_6e13783a",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf5edc25_cda5fcfd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-17T14:21:54Z",
      "side": 1,
      "message": "Thanks for the explanations. SGTM",
      "parentUuid": "03f83708_ce60e450",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1013b1b_c39b1c49",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1528827
      },
      "writtenOn": "2022-03-17T14:26:01Z",
      "side": 1,
      "message": "I have split this CL in a refactoring CL and a functionality CL.",
      "parentUuid": "bf5edc25_cda5fcfd",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce447b9f_59d0a828",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1528827
      },
      "writtenOn": "2022-05-03T15:50:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1013b1b_c39b1c49",
      "revId": "55fe5fb7837203352114eee3dfac7cd835ef6131",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}