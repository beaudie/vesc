{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "36be9eed_52e132dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-11T21:12:15Z",
      "side": 1,
      "message": "PTAL",
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e14ca1ae_c0b898e1",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-02-11T21:19:08Z",
      "side": 1,
      "message": "why are you keeping the references? can\u0027t you just make a copy and treat it the same as BitSetT?",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8167129a_2d149a95",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-11T21:42:58Z",
      "side": 1,
      "message": "copy-paste from another comment -\n\nEverytime an iterator is created, it needs to be a fast operation without any copies involved so that usecases that only iterate without mutating should not take any perf hit [this is where we get the win by having the const reference]. Given that we want the fastest path possible for a fast bitset \"good\" usecases should not have to take the hit just so we can support functionality for mutating cases.",
      "parentUuid": "e14ca1ae_c0b898e1",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e68b0cf4_2158f902",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-02-11T21:51:10Z",
      "side": 1,
      "message": "I feel like a single copy is faster than two pointers and a copy. You already have mParentCopy and mIndex, why do you need \u0026mParent and mCurrentParent?",
      "parentUuid": "8167129a_2d149a95",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "313967e6_1044aa38",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-11T21:58:13Z",
      "side": 1,
      "message": "\u003e mParentCopy\n\nonly activated when a mutation is required. for usecases with just iteration it wont have valid values\n\n\u003e why do you need \u0026mParent\n\nconst reference for usecases that only iterate without mutation\n\n\u003e why do you need ... mCurrentParent\n\nthis is a pointer to which ever parent is the active one\n1. for non-mutating cases mCurrentParent points to mParent\n2. for mutating cases mCurrentParent points to mParentCopy",
      "parentUuid": "e68b0cf4_2158f902",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6758153_dab06b65",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-02-11T22:02:30Z",
      "side": 1,
      "message": "There would be 2 64-bit copies instead of a pointer copy, but instead every *iter wouldn\u0027t be a pointer dereference.\n\n\u003e 2. if we have a BitSetArray\u003c96\u003e and we are at bit 1, a usecase can call setLaterBit(90) in which case the current iterator is out of luck and cant satisfy the requirement. This was not the case with BitSetT::Iterator\n\nHow is setLaterBit(90) a problem? The iterator has a copy of the whole bitset.",
      "parentUuid": "313967e6_1044aa38",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac5b8c6a_f0d47897",
        "filename": "src/common/bitset_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 657,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2021-02-11T22:34:04Z",
      "side": 1,
      "message": "\u003e but instead every *iter wouldn\u0027t be a pointer dereference\n\nthis is Iterator::operator*() -\n\n template \u003cstd::size_t N\u003e\n std::size_t BitSetArray\u003cN\u003e::Iterator::operator*() const\n {\n     return (mIndex * priv::kDefaultBitSetSize) + *mCurrentIterator;\n }\n\nare you talking about \"*mCurrentIterator\"? because that code existed prior to this change\n\n\u003e How is setLaterBit(90) a problem? The iterator has a copy of the whole bitset.\n\ni thought you were talking about manipulating the existing iterator some way, might have misunderstood it. but yes, when we have a copy that usecase is not a problem",
      "parentUuid": "d6758153_dab06b65",
      "range": {
        "startLine": 655,
        "startChar": 0,
        "endLine": 657,
        "endChar": 42
      },
      "revId": "1b8e38f137c7a22afdcd45b22253896c18c86f1a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}