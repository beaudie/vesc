{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b8cfcb0e_e70c9e42",
        "filename": "src/libGLESv2/entry_points_egl_autogen.cpp",
        "patchSetId": 16
      },
      "lineNbr": 399,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-07T22:34:19Z",
      "side": 0,
      "message": "Does nothing need locking here until SwapBuffers?\n\nHow about this (see also comment in SwapBuffers):\n\n    EGL_SwapBuffers:\n        - Get global lock\n        - Do everything else here\n        - Call PrepareSwapBuffer:\n          * Takes surface lock first before unlocking the global lock (IMPORTANT so nothing else sneaks in the middle)\n\n        - Get global lock again\n        - Do everything else here *again* (because another thread may have done something in the middle, unless you can prove nothing can be changed)\n        - Call SwapBuffers again",
      "revId": "c2a296149357a359d801084f8b7a4b3531817821",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65faa653_27fd623d",
        "filename": "src/libGLESv2/entry_points_egl_autogen.cpp",
        "patchSetId": 16
      },
      "lineNbr": 399,
      "author": {
        "id": 1175714
      },
      "writtenOn": "2022-01-07T22:46:49Z",
      "side": 0,
      "message": "\u003e Takes surface lock first before unlocking the global lock (IMPORTANT so nothing else sneaks in the middle)\n\nI thought of that earlier but that still doesn\u0027t protect against a non-surface lock egl call doing something in the middle, and it also breaks locking order which might lead to deadlocks.",
      "parentUuid": "b8cfcb0e_e70c9e42",
      "revId": "c2a296149357a359d801084f8b7a4b3531817821",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dea89c5_bafe1932",
        "filename": "src/libGLESv2/entry_points_egl_autogen.cpp",
        "patchSetId": 16
      },
      "lineNbr": 399,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-01-08T02:31:04Z",
      "side": 0,
      "message": "The point is that non-surface lock egl calls don\u0027t touch the surface right? So that shouldn\u0027t matter, or rather if it matters they should take the surface lock too.\n\nI don\u0027t believe the above can deadlock. Any specific sequence you have in mind?\n\nAnd the most important point was to reacquire the global lock and do everything this function is currently doing again, as if these were really two separate egl calls (eglPrepareSwapBuffers followed by eglSwapBuffers). Because then we can reason about it the same way we reason about different egl calls getting interleaved.",
      "parentUuid": "65faa653_27fd623d",
      "revId": "c2a296149357a359d801084f8b7a4b3531817821",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53b8d770_27a1e90f",
        "filename": "src/libGLESv2/entry_points_egl_autogen.cpp",
        "patchSetId": 16
      },
      "lineNbr": 399,
      "author": {
        "id": 1175714
      },
      "writtenOn": "2022-01-10T15:53:05Z",
      "side": 0,
      "message": "I think I understand your point about doing more things twice in one hold of the global lock (such as ANGLE_EGL_VALIDATE), but the problem is the whole EGL_XXX entry point thing isn\u0027t standardized for this. What would your recommendation be on how to adjust the codegen?",
      "parentUuid": "7dea89c5_bafe1932",
      "revId": "c2a296149357a359d801084f8b7a4b3531817821",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}