{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a138af4d_c8032685",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 147,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-11-11T01:22:04Z",
      "side": 1,
      "message": "nit: you can init it directly.",
      "range": {
        "startLine": 147,
        "startChar": 9,
        "endLine": 147,
        "endChar": 20
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1dd1d69_2a244aa6",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 151,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-11-11T01:22:04Z",
      "side": 1,
      "message": "nit: this can go on one line.",
      "range": {
        "startLine": 150,
        "startChar": 0,
        "endLine": 151,
        "endChar": 22
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f99551c3_46f1b037",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-11-11T01:22:04Z",
      "side": 1,
      "message": "Ideally this should be happening in Context11 instead of in a global state header file. Did you already try out that approach?",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84aa3f0f_30242adc",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1452687
      },
      "writtenOn": "2020-11-19T17:20:53Z",
      "side": 1,
      "message": "This is just replacing the existing `GetShareGroupLock` function with a better named `GetContextLock`. For D3D11 builds, it will `define` to dirtying the state in addition to acquiring the lock.\n\nWe\u0027re taking advantage of the fact that gles functions already call into `GetShareGroupLock`. So we contain all of our changes there.\n\nI\u0027m not exactly sure what you\u0027re recommending?\nAre you recommending that `GetGlobalLastContext()`, `dirtyAllState()`, and `SetGlobalLastContext()` should all be contained within `Context11`?\n\nI implemented the design as outlined in the design doc.",
      "parentUuid": "f99551c3_46f1b037",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64721c4f_8d47e164",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-11-20T18:23:43Z",
      "side": 1,
      "message": "Hey Trevor,\n\nThe comparison with the prior context and dirtying the state if so is a concern that seems more particular to D3D. I don\u0027t recall the design doc. Sorry if I didn\u0027t point out this observation during the design phase.\n\nWhat happens if you move the prior context comparison into StateManager11::onMakeCurrent?",
      "parentUuid": "84aa3f0f_30242adc",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e84474f7_11d20b59",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-11-20T18:24:37Z",
      "side": 1,
      "message": "If you re-share the design doc with me I can surface this suggestion there. I lost the link.",
      "parentUuid": "64721c4f_8d47e164",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62cc6cf5_0c81022f",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1190898
      },
      "writtenOn": "2021-01-11T23:55:39Z",
      "side": 1,
      "message": "I was looking at this today Jamie and moving the check to the d3d11 backend will require d3d11 to take a dependency on libGLESv2 for the global state. Is that ok?",
      "parentUuid": "e84474f7_11d20b59",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6644f104_502e5d5a",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-12T15:37:34Z",
      "side": 1,
      "message": "I don\u0027t see why you need to do that Doug. The D3D11 back-end can determine the last context without needing global state. There\u0027s probably several ways. In onMakeCurrent you could cache the prior Context11 pointer or something if you want to do the check there.",
      "parentUuid": "62cc6cf5_0c81022f",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d28d250_59dfe95d",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1190898
      },
      "writtenOn": "2021-01-12T21:17:18Z",
      "side": 1,
      "message": "Err, you\u0027re right. Here\u0027s the problem I\u0027m currently facing, just speaking aloud essentially:\n\nWe can cache the last context in onMakeCurrent(), but it seems like syncState() can fire asynchronously/on a different context than is current, which messes with the object caches we have (mFrameBuffer11, et. al.). I think we need to store these on a per-context basis, which is the approach I\u0027m looking at now. I\u0027m not actually sure how this worked with the current patchset, I suspect it has something to do when when syncState fires in relation to when the dirty call is made.",
      "parentUuid": "6644f104_502e5d5a",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a9a483d_babe88a8",
        "filename": "src/libGLESv2/global_state.h",
        "patchSetId": 11
      },
      "lineNbr": 156,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-01-12T21:37:52Z",
      "side": 1,
      "message": "You will always get a Context11::onMakeCurrent call when you get a next context on a thread. So your question is  - given I get onMakeCurrent, how do *force* gl::Context (owner of Context11) to call syncState with the right dirty bits after an onMakeCurrent? Let me know if I have your question right. The syncState call won\u0027t happen until the next draw call.\n\nOK, so if I have that right, one solution: we can force all dirty bits on D3D11 *only* using our subject/object state notification system. See an example in Buffer.h:\n\n\u003e    angle::ObserverBinding mImplObserver;\n\nThis is the binding that passes the notification back up the chain from rx::BufferImpl to gl::Buffer. Then in Buffer.cpp we call:\n\n\u003e     mImplObserver.bind(mImpl);\n\nThis establishes the binding. Then in Buffer11.cpp we call:\n\n\u003e    onStateChange(angle::SubjectMessage::SubjectChanged);\n\nThis sends the notification. And in Buffer.cpp we receive the notification:\n\n\u003e void Buffer::onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMessage message)\n\nIn Context::onSubjectStateChange you\u0027d handle the matching ID for the Impl (Context11) and set all the right dirty bits. This would constrain this behaviour to D3D11.\n\nAn alternative solution: expose a flag in ContextImpl that says \"set all dirty bits on a new context\" and handle this in Context::makeCurrent instead of Context11/notifiers.",
      "parentUuid": "2d28d250_59dfe95d",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 5
      },
      "revId": "0fb2ee32a2486504df520b742802c673d19d14e9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}