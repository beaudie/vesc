{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e8edb7fe_e714b399",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2022-08-11T15:47:50Z",
      "side": 1,
      "message": "Still looks good to me.\n\nAdding Alexey too, he may be interested.",
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c4d0013_ea6dff90",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "Allocated 4 enums for you from 0x96BB through 0x96BE",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "881a87d5_e86d19ae",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:33:39Z",
      "side": 1,
      "message": "Ah you added more, scratch the above, and use these 6 enums instead: 0x96E0 through 0x96E5",
      "parentUuid": "8c4d0013_ea6dff90",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74897c6a_714af366",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "Thanks for allocating those.\n\nIn the future we will almost definitely need more for this extension. (I haven\u0027t accounted for a potential implementation that uses NV_texture_barrier yet.) Should we just reallocate when we need more?",
      "parentUuid": "881a87d5_e86d19ae",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5efb27c4_4216de61",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T02:47:30Z",
      "side": 1,
      "message": "We have 15 more enums allocated to ANGLE that are still unused. If you intend to use more, let me know in advance and we can request more enums from Khronos.",
      "parentUuid": "74897c6a_714af366",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71beb8dd_15f58001",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-12T20:13:27Z",
      "side": 1,
      "message": "I went ahead and wrote out the other two enums I foresee us needing. Which values should I assign to them?",
      "parentUuid": "5efb27c4_4216de61",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc240998_fc9d01d8",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 155,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-13T01:42:06Z",
      "side": 1,
      "message": "0x96E6 and 0x96E7 (we have this range up to ...F for now)",
      "parentUuid": "71beb8dd_15f58001",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 155,
        "endChar": 73
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a619a96a_c2afbc50",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 243,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "\u003e Memoryless pixel local storage planes may also be\n\u003e initialized with historic data rendered into other\n\u003e memoryless planes by the same application.\n\nThis pretty much sounds like \"undefined\"",
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3090bbec_763d08fc",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 243,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "Yeah I\u0027m on the fence for this one. Should we just spec it as ZERO or KEEP? The only wrinkle is that KEEP is technically not valid for memoryless planes, but if the implementation has a shader image it\u0027s obvious what it would mean in that case",
      "parentUuid": "a619a96a_c2afbc50",
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "091f3c0d_9e12c118",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 243,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T02:47:30Z",
      "side": 1,
      "message": "For memoryless, `KEEP` doesn\u0027t make sense, so it sounds like it should always be `ZERO`. On TBR this is free, but unfortunately not when backed with shader images.\n\nHow about this: call the values undefined here. Then in the WebGL version of this spec, say its `ZERO`. WebGL typically pays extra cost to avoid undefined values, and this would be one example of that.\n\nYou\u0027re probably familiar, but there is the robust resource init extension that basically makes all buffers and textures 0 initialized; this feels like a similar situation. (so when I say WebGL above, it really means robust resource init)",
      "parentUuid": "3090bbec_763d08fc",
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c183bbbf_a9b1ab95",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 316,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "It seems like the GL ext doesn\u0027t make this guarantee (because it doesn\u0027t have an \"endPLS\" call). It says:\n\n\u003e The contents of the pixel local storage persist until color data is flushed to the framebuffer\n\nwhich leaves it open when and where the render pass breaks. If you look at `RenderPassClosureReason` in the Vulkan backend, you\u0027ll see there are more reasons than listed here. For example:\n\n- Some cases with transform feedback restart\n- Timer queries\n- GenerateMipmap() and texture copy on the CPU due to restrictions, where the textures are not necessarily those that are used for PLS\n\nSome cases are not obvious, for example, we may break the render pass in `BufferVk::setDataImpl` if `stagedUpdate` is called; basically everywhere we have an `ANGLE_VK_PERF_WARNING` that warns about render pass break or GPU stall.\n\nI see two solutions:\n\n1. Meticulously exclude more things; for example transform feedback entirely, queries other than occlusion, basically at least every reason we may break the render pass for in Vulkan.\n2. Add an option where any of the operations that are still permitted could return an error if the render pass is broken.\n\nThe former is probably hard to make bullet-proof. The latter makes it harder for the devs, as some render pass breaks can happen only on some hardware. Maybe a mix of both? Try your best for 1, and leave 2 as backup?\n\nNote that for the Vulkan backend it\u0027s actually not an impossible problem, if the render pass breaks, use STORE_OP_STORE + LOAD_OP_LOAD to continue on to the next render pass. It works, but the lazily-allocated memory used for the memoryless attachments are now actually allocated.\n\nI\u0027m a little worried about what happens when you use the GL ext too (which doesn\u0027t let you for example implement 2 as there\u0027s no feedback IIUC)",
      "range": {
        "startLine": 316,
        "startChar": 14,
        "endLine": 316,
        "endChar": 45
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "065ecb3e_b973948f",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 316,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "Thanks for pointing out `RenderPassClosureReason` and `ANGLE_VK_PERF_WARNING`\n\nYeah, it seems challenging to make this bullet proof. What about #3 below?",
      "parentUuid": "c183bbbf_a9b1ab95",
      "range": {
        "startLine": 316,
        "startChar": 14,
        "endLine": 316,
        "endChar": 45
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fcf799e_6416a197",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 323,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "\"tiled memory\" is not formally defined, and isn\u0027t universal either. The GL ext calls this \"flushed to the framebuffer\", which is vague too, but at least less tied to TBR parlance.",
      "range": {
        "startLine": 322,
        "startChar": 65,
        "endLine": 323,
        "endChar": 26
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78a5cd8f_b8a2c48a",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 323,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "Changed the wording to match the GL ext",
      "parentUuid": "6fcf799e_6416a197",
      "range": {
        "startLine": 322,
        "startChar": 65,
        "endLine": 323,
        "endChar": 26
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1407be8_f47b93ce",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 331,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "Based on the long comment above, my suggestion is to ban these entirely. Ideally the render pass would have nothing but:\n\n- Bind program\n- Bind textures/buffers\n- Draws\n- Occlusion queries\n\nEvery data upload, copy, whatever should be done before the pass.",
      "range": {
        "startLine": 330,
        "startChar": 56,
        "endLine": 331,
        "endChar": 76
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06f305c0_cf837450",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 331,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "I like that. I also banned all the texture creation calls below. There\u0027s no reason the application can\u0027t create its textures before the PLS rendering pass, since it already can\u0027t access any rendering results anyway.\n\nIf you\u0027re making so many textures that you have to break them up in order to not run out of memory, you might as well break up your PLS rendering passes as well.\n\nIs this an option #3 to the possible solutions to preventing render pass splits? Make a small list of allowed functions while PLS is active, and ban everything else?",
      "parentUuid": "b1407be8_f47b93ce",
      "range": {
        "startLine": 330,
        "startChar": 56,
        "endLine": 331,
        "endChar": 76
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fae59b6e_faf72bc7",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 331,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:20:47Z",
      "side": 1,
      "message": "One more point for #3: if we miss one and have to add it later, it\u0027s backward compatible to just update the spec to allow more at any time.\n\nIf we instead go the route of banning specific commands, then it is not backward compatible to update the spec to ban more in the future.",
      "parentUuid": "06f305c0_cf837450",
      "range": {
        "startLine": 330,
        "startChar": 56,
        "endLine": 331,
        "endChar": 76
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "410b06b5_81e0f64a",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 331,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T02:47:30Z",
      "side": 1,
      "message": "\u003e Is this an option #3 to the possible solutions to preventing render pass splits? Make a small list of allowed functions while PLS is active, and ban everything else?\n\nYes actually. After all, that\u0027s how it is in Vulkan too, right? You have very specific commands that can be recorded inside a render pass.\n\nWith GL it\u0027s a little more complicated, because some commands translate in part to outside render pass commands and in part to inside render pass commands, like implicit barrier before RP + actual command inside RP. The issue with transform feedback that I mentioned is actually like that; restarting transform feedback in a render pass requires a barrier on the counter buffers if on top of VK_EXT_transform_feedback, so we have to break the render pass (although this particular case could be optimized in ANGLE, but it isn\u0027t right now). Another transform feedback issue is capture then use as VAO that needs render pass break.\n\nI think going with an allowlist instead of denylist is good. Just note that I actually missed all the state-setting functions (`glScissor`, `glEnable(WHATEVER)` etc), so the allowlist is not that short.\n\nThat said, state setting functions are also not entirely innocent. For example, dithering-done-in-hardware is a render pass flag on TBR hardware; a WIP Vulkan extension for dithering makes it such that a change in dither state would break the render pass. Another example is if the depth attachment is also bound as a texture, so a read-only feedback loop is established (spec is vague, and some benchmarks do this), then after a while it\u0027s unbound as a texture and depth write is enabled, at which point we have to break the render pass.\n\nAdmittedly situations such as this would be rare, but you might consider option 2 as a way of at least giving feedback to the application/developer that they hit a land mine.",
      "parentUuid": "fae59b6e_faf72bc7",
      "range": {
        "startLine": 330,
        "startChar": 56,
        "endLine": 331,
        "endChar": 76
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d066b4b2_ab5c2ebc",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-11T18:32:23Z",
      "side": 1,
      "message": "Can you make this guarantee when implemented on top of native GL extensions?",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e61c18e0_9f310d5e",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-11T19:18:04Z",
      "side": 1,
      "message": "Nope ðŸ˜¬\n\nThe best we can do is assume that must be what happens and make a conformance test that verifies it (which we have)\n\nThis obviously is not a real guarantee, but it\u0027s the best we can do if we want to expose this extension in WebGL\n\nThe alternative, which I would certainly be open to, is to only expose the coherent extension in WebGL",
      "parentUuid": "d066b4b2_ab5c2ebc",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20621521_5d8e1c69",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T02:47:30Z",
      "side": 1,
      "message": "I think you would have to make this ubiquitous, otherwise it\u0027d be either developers complaining that the ext they want is not usable, or users complaining that the WebGL content doesn\u0027t work on their platform. So let\u0027s try to get incoherent supported as best we can.\n\nI think we would actually need some guarantees from the vendors themselves here. @Ken, how would WebGL feel about this? Some optimal implementations (like on top of a GL extension) don\u0027t guarantee that garbage produced in this case is not your bank password, but in reality that\u0027s probably true. Would WebGL be content with a verbal confirmation from the vendors that undefined value here means racy, but derived only from the rendering results? Should we push for an update to the GL extensions themselves to provide this guarantee?",
      "parentUuid": "e61c18e0_9f310d5e",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a25d18e_d6c8dab0",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T02:53:37Z",
      "side": 1,
      "message": "In the worst case, we can have:\n\n- Non-coherent PLS produces undefined value, and\n- Non-coherent PLS produces incorrect values on WebGL\n\nThen the condition to use the GL extension or use the image-based emulation would have `\u0026\u0026 isWebGL()` somewhere. I.e. the GL platforms that can\u0027t support coherent would fall back to image-based instead of using the GL extension so would be less optimal, but \"safe\"",
      "parentUuid": "20621521_5d8e1c69",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3ffcddb_17780dcf",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-12T16:34:34Z",
      "side": 1,
      "message": "From the standpoint of WebGL\u0027s security, it\u0027s fine if the strongest guarantee that can be made about the undefined values is that they\u0027re racy, but that they don\u0027t come from other rendering contexts. In other words, we wouldn\u0027t be able to write a conformance test for them, but they wouldn\u0027t allow cross-domain information leakage.\n\nYes, it would be best to update the native GL/GLES extensions with a statement regarding this.\n\nI could imagine that memoryless PLS could really pick up semi-arbitrary GPU register content. Since Chrome and ANGLE virtualize GLES contexts, it\u0027s not clear to me we\u0027d actually be able to take advantage of a statement about PLS information being scoped to a specific rendering context.\n\nPerhaps we could suggest to the GL/GLES working group that a dependency be added from the pixel-local-storage and framebuffer-fetch extensions to the GL_KHR_robustness extension? If robust buffer access is enabled for a rendering context, there are stronger guarantees about the contents of tile memory? We don\u0027t want to tank performance.\n\nPlease offer more suggestions.",
      "parentUuid": "4a25d18e_d6c8dab0",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71ef1f46_f905a9d9",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-12T17:01:01Z",
      "side": 1,
      "message": "A bit more concretely - I think we could ship non-coherent PLS for WebGL with a verbal statement from GPU vendors about the behavior of the extension on their hardware, and also think we should follow up to codify behaviors in the extension specifications.",
      "parentUuid": "c3ffcddb_17780dcf",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00475da3_0d3f9ae4",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T17:14:34Z",
      "side": 1,
      "message": "Thanks, I\u0027ll follow up on that to see what we can do with the GL spec.\n\n\u003e I could imagine that memoryless PLS could really pick up semi-arbitrary GPU register content.\n\nIf you\u0027re talking about _clearing_ the memoryless plane (in accordance with robust `ANGLE_robust_resource_initialization`), that\u0027s mostly achievable (when backed by storage image, or in Vulkan), but we\u0027d have to get the vendors to agree on a \"LOAD_OP_CLEAR\" semantics in the GL spec.\n\nFor overlapping writes in non-coherent PLS, I don\u0027t actually imagine memoryless PLS picking up any data other than what\u0027s on the tile. If the tile is cleared on load, there should be no leakage. Again, needs the vendors to agree to do that.",
      "parentUuid": "71ef1f46_f905a9d9",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d567bc4_8b8963ef",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T18:11:35Z",
      "side": 1,
      "message": "Ah actually it seems like the authors of EXT_pixel_local_storage have thought about this. I found this issue on the spec:\n\n```\n     (14) What does \u0027undefined\u0027 mean for a pixel local storage variable\n          or a color value?\n\n        RESOLVED.\n\n        It simply means that the value has no well-defined meaning to an\n        application. It does _not_ mean that the value is random nor that it\n        could have been leaked from other contexts or processes.\n```\n\nBut that\u0027s probably not enough for WebGL, because all pages are rendered through the same context, but their contents still shouldn\u0027t leak. Right?",
      "parentUuid": "00475da3_0d3f9ae4",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aea696ce_3c5b75cd",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-12T18:27:22Z",
      "side": 1,
      "message": "Opened an issue with GL to get the above guarantee to include render passes, which I believe should resolve this for WebGL: https://gitlab.khronos.org/opengl/API/-/issues/168",
      "parentUuid": "0d567bc4_8b8963ef",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5707c28_6346afe6",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-12T19:53:05Z",
      "side": 1,
      "message": "Just to clarify: EXT_shader_pixel_local_storage and EXT_shader_framebuffer_fetch are both coherent, so this paragraph does not apply to them. As long as we clear to 0 at the beginning, the application can\u0027t hit these race conditions because barriers aren\u0027t required in coherent PLS.\n\n\u003e I could imagine that memoryless PLS could really pick up semi-arbitrary GPU register content.\n\n\u003e Perhaps we could suggest to the GL/GLES working group that a dependency be added from the pixel-local-storage and framebuffer-fetch extensions to the GL_KHR_robustness extension?\n\nSince these extensions are coherent, as long as *we* clear the tile during BeginPixelLocalStorageANGLE() I don\u0027t think the spec allows for the possibility of undefined values does it? (Except for the flush scenario in EXT_pls.)\n\n\u003e Ah actually it seems like the authors of EXT_pixel_local_storage have thought about this.\n\nThe note about undefined values in the EXT_pls spec is regarding what happens after operations that flush to the framebuffer, like glFinish(). Not race conditions. I hope we can work around those by making a very strict allowlist while PLS is active, and running that list past the authors of the extension to make 100% certain our allowlist can\u0027t ever cause a flush ðŸ¤ž (lofy, I know)\n\n\u003e Then the condition to use the GL extension or use the image-based emulation would have  \u0026\u0026 isWebGL()  somewhere.\n\nWhich GL extension were you referring to here? Image-based emulation itself is pretty racy unless we support ANGLE_pls_coherent and synchronize them.\n\nPotential implementations that note on race conditions applies to:\n* Shader images without synchronization\n* Subpass loads without rasterizer order guarantees\n* EXT_shader_framebuffer_fetch_noncoherent\n* NV_texture_barrier\n* We could make this extension work literally everywhere by having a final fallback that actually reads the framebuffer in PixelLocalStorageBarrierANGLE. We probably wouldn\u0027t want to do that though unless we added a rectangle argument to the barrier command.\n\nI think all the other implementations we\u0027ve talked about are automatically coherent.",
      "parentUuid": "aea696ce_3c5b75cd",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd7cc267_931a80cd",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-12T22:25:55Z",
      "side": 1,
      "message": "\u003e Since these extensions are coherent, as long as *we* clear the tile during BeginPixelLocalStorageANGLE() I don\u0027t think the spec allows for the possibility of undefined values does it? (Except for the flush scenario in EXT_pls.)\n\nHow would ANGLE clear the tile? Would it have to draw a quad in order to run a special shader clearing out the pixel local storage attachments?",
      "parentUuid": "a5707c28_6346afe6",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d31df83b_afac51b2",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-12T22:44:18Z",
      "side": 1,
      "message": "Exactly.\n\nIn modern APIS, ANGLE can just set up the render pass with a clear op.\n\nOtherwise it can generally glClear the backing texture.\n\nBut for EXT_shader_pixel_local_storage specifically, it isn\u0027t always easy. If the application specifies ZERO, ANGLE can call \"glClearColor(0); glClear()\". Otherwise, it will have to do what you suggested, which is issuing a fullscreen draw that draws the clear value into every pixel. This probably isn\u0027t as bad as it sounds, but still it\u0027s why the spec recommends using ZERO for your loadop.",
      "parentUuid": "dd7cc267_931a80cd",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42e2b82b_4b615ebe",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-12T23:52:01Z",
      "side": 1,
      "message": "\u003e Otherwise it can generally glClear the backing texture.\n\nOK. It wasn\u0027t clear to me that that would work. The situation I was thinking of is that you have valid contents in the framebuffer already, want to preserve and blend over them, are using a memoryless PLS attachment, and the only way to initialize the PLS contents would be to run a special render to zero out just the PLS planes and do nothing (KEEP semantics) to the other attachments. It\u0027s possible I\u0027m not understanding the API semantics.\n\nLet\u0027s focus on Shabi\u0027s concerns if they aren\u0027t addressed already.",
      "parentUuid": "d31df83b_afac51b2",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e6c8d22_a6f110d9",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-13T00:14:21Z",
      "side": 1,
      "message": "I see.\n\nBeginPixelLocalStorageANGLE only takes load ops for PLS planes, so any color attachments on the framebuffer are unaffected (KEEP semantics, since we\u0027re GL).\n\nEXT_shader_pixel_local_storage doesn\u0027t support rendering to color attachments while PLS is active anyway, so this scenario doesn\u0027t apply there, and all the other implementations can easily clear PLS attachments without affecting the rest of the framebuffer.",
      "parentUuid": "42e2b82b_4b615ebe",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21601b6d_7469c046",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-13T01:42:06Z",
      "side": 1,
      "message": "\u003e Which GL extension were you referring to here?\n\nGL_EXT_pixel_local_storage\n\n\u003e Potential implementations that note on race conditions applies to:\n\nRace conditions are ok, so \"Shader images without synchronization\" is not an issue. We want to avoid the \"undefined\" value per spec, or rather turn that into \"undefined, but not leaked from elsewhere\". Could you check again which of those options actually don\u0027t have a no-leak guarantee? I could potentially bring them all up with the GL workgroup and see if we can sort them out.\n\n\u003e We could make this extension work literally everywhere by having a final fallback that actually reads the framebuffer in PixelLocalStorageBarrierANGLE. We probably wouldn\u0027t want to do that though unless we added a rectangle argument to the barrier command.\n\nI didn\u0027t quite understand how that helps here. If you issue one self-overlapping draw call, there\u0027s nothing PLSBarrier can do about that.",
      "parentUuid": "1e6c8d22_a6f110d9",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb161ce7_4cb08820",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-13T04:40:26Z",
      "side": 1,
      "message": "\u003e GL_EXT_pixel_local_storage\n\nGot it, following.\n\nThat would be unfortunate to lose EXT_pls since it\u0027s our only route to fast, coherent support on a big chunk of devices worldwide. Hopefully we can work with the vendors and make it bulletproof.\n\n\u003e Could you check again which of those options actually don\u0027t have a no-leak guarantee? \n\nThe rest all have a no-leak guarantee as long as we clear things up front. EXT_pls is the only one with an iffy \"you might randomly lose your data\" clause.\n\n\u003e I didn\u0027t quite understand how that helps here. If you issue one self-overlapping draw call, there\u0027s nothing PLSBarrier can do about that.\n\nIt\u0027s probably worse than you\u0027re expecting:\n\n* PLS keeps two copies of the data\n* pixelLocalLoadANGLE() calls texelFetch() on the copy\n* pixelLocalStoreANGLE() renders to the original\n* PLSBarrier() calls CopyTexSubImage2D on every active PLS plane to update the copy texture\n\nMaybe helpful in some cases since, since that would be the app\u0027s only fallback anyway. Maybe just bad since it would only be a performance landmine. But it would get the extension up to 100% coverage.",
      "parentUuid": "21601b6d_7469c046",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7d8bc18_3c93cd2b",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 3
      },
      "lineNbr": 393,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-14T01:32:21Z",
      "side": 1,
      "message": "Yeesh, let\u0027s hope it doesn\u0027t come to that.",
      "parentUuid": "bb161ce7_4cb08820",
      "range": {
        "startLine": 392,
        "startChar": 27,
        "endLine": 393,
        "endChar": 11
      },
      "revId": "16922fc271c50a3b3db6c274b2d1f603421d234c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}