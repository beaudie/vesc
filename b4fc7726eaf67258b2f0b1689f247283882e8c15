{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b64a5ec5_e78a69f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "Indeed I was going to point this out. Are you saying _apps_ should use semaphores? Unfortunately we can\u0027t require apps to do something the spec doesn\u0027t require.\n\nOne possible solution is to submit command buffers from all priorities of the contexts in the share group, but there\u0027s another bug here:\n\nWhen the resource usage is intermixed between render passes, the ordering won\u0027t be right if the contexts are separately recording to primary command buffers:\n\n- Context 1 (low priority) copies to texture (created with glTexStorage, so ANGLE flushes the work)\n- Context 2 (high priority) blends to image A and breaks the render pass (e.g. by copy into temp texture) (should read context1\u0027s write as blend dst)\n- Context 1 reads back from the texture (should read context2\u0027s result)\n\nWe rely on the fact these are recorded in order in the primary command buffer. If context2\u0027s commands are written separately to another primary command buffer, there\u0027s no way to order the two CBs to get correct rendering.\n\nCould you please add a test based on this? Take a look at MultithreadingTest.cpp and how tests use `RunLockStepThreads` to make sure the threads do the tasks in the desired order.",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bc46895_8931692e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "Not apps. ANGLE should use VkSemaphore automatically between submissions of commands, that accesses same resource into different VkQueue(s).\nHow to implement this - is another question. This may be simple or may be not. I did not have time to investigate this problem.\n\nAbout Context 1/2 scenario and test.\nI think that the app must use either glFinish() or glFenceSync() to synchronize access to the texture from Context 1 (copy) to Context 2 (blend); and Context 2 (blend) to Context 1 (read). Or how else we can ensure (from GLES stand point) this synchronization?\nIn case of glFinish() - no need to do enything.\nIn case of glFenceSync() - need to insert VkSemaphore() in the glWaitSync().",
      "parentUuid": "b64a5ec5_e78a69f2",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7ba25b9_5c366fb4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "Take a look at `UnsynchronizedTextureReads*` tests for example, EGL allows multiple threads to read from the texture without synchronization, while internally ANGLE would have to sequence them correctly due to image layout transitions.",
      "parentUuid": "2bc46895_8931692e",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a998d897_196cb273",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:32:09Z",
      "side": 1,
      "message": "Thanks.",
      "parentUuid": "d7ba25b9_5c366fb4",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb21587c_8a00e030",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "I understand the problem, and sympathize with the desire to fix it. I don\u0027t believe this is the right approach though.\n\nIn a sense, what we have _now_ is a priority inheritance system, except we can also downgrade priority depending on who actually submits the commands.\n\nI think a better solution is an actual priority inheritance mechanism. It should actually be fairly trivial to do; when we flush a secondary CB, get the priority and record the max, then on submission use the max priority instead of current context\u0027s priority.\n\nThis would actually mean that if A (high prio) depends on B (low prio), we\u0027d automatically run B at high prio for the sake of A.\n\nAlternatively, if that\u0027s not what we want to support (or there\u0027s a risk of unrelated low prio work getting submitted at high prio), we can always enforce a submission when SCB-\u003ePCB flush is done with a different priority.\n\nWhat do you think?",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b29bd753_4bb1d465",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "This problem is not theoretical and causes artifacts in Samsung Notes app.\n\nI think I understand the \"priority inheritance system/mechanism\".\n\nI do not understand how \"enforce a submission when SCB-\u003ePCB flush\" will help?\nFor example:\n- Context A (prio1) records and flushes commands and wait semaphore from Acquire\n- Context B (prio2) flushes commands -\u003e enforced submission.\n- Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n- Context A (prio1) continues to render into the same framebuffer.\n- Context A (prio1) calls eglSwapBuffers()\n- Rest of Context A commands (without Acquire semaphore) in the \"prio1\" VkQueue.\n- Blinking/artifacts may appear on screen, because there is no synchronization between commands from \"prio2\" VkQueue and \"prio1\" VkQueue, also no dependency chain with Acquire semaphore and Present semaphore.\n\nThe above situation is implicit command shuffle of a single Context.\nANGLE must detect such cases and use VkSemaphore when commands of a Context switches VkQueue like that.\nProposed solution simply avoid this shuffling.\n\nHowever, VkSemaphore may still be required to synchronize resource between multiple Contexts (Shared or via EGLImage).\nWe may call this problem - explicit command shuffle.",
      "parentUuid": "bb21587c_8a00e030",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a140c70_afb6f81f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "\u003e * Context A (prio1) records and flushes commands and wait semaphore from Acquire\n\u003e * Context B (prio2) flushes commands -\u003e enforced submission.\n\u003e * Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n\nNo actually the point was to have commands of Context A be submitted to prio1 queue. That can be done by recording the \"current priority of the PCB\", and when a new SCB flush comes with a different priority, _first_ submit the old PCB to its respective queue, _then_ record SCB into a new PCB and update the current priority.\n\nWould that not solve the issue?\n\nWe don\u0027t need a semaphore by the way because all the queues are from the same family, and pipeline barriers are taking care of synchronization.",
      "parentUuid": "b29bd753_4bb1d465",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e5d6910_01eb884c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:32:09Z",
      "side": 1,
      "message": "\u003e No actually the point was to have commands of Context A be submitted to prio1 queue.\n\nSorry, I misunderstood that.\n\n\u003e Would that not solve the issue?\n\nI guess so. I need to check this.\n\n\u003e We don\u0027t need a semaphore by the way because all the queues are from the same family, and pipeline barriers are taking care of synchronization.\n\nCould you point in the Vulkan spec where such guarantee is made?\n\nFrom what I found:\n\u003e Semaphores can be used to control resource access across multiple queues.\n\nSo \"multiple queues\" not queue families.\n\n\u003e Layout transitions that are performed via image memory barriers execute in their entirety in submission order, relative to other image layout transitions submitted to the same queue, including those performed by render passes.\n\nKey parts are \"submission order\" and \"same queue\".",
      "parentUuid": "9a140c70_afb6f81f",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d69c9eca_e730f5bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:44:11Z",
      "side": 1,
      "message": "You may be right, let me dig deeper. I did in fact have this chaining of submissions with semaphores done in the past: https://chromium-review.googlesource.com/c/angle/angle/+/1276805 but that was (rightfully) removed as we didn\u0027t actually need that with single-queue submissions.\n\nChaining the submissions between queues with semaphores is not really hard with the above flush-on-priority-change method. The harder part is detecting when the chaining is necessary; we wouldn\u0027t really want to make A wait for B if not using the same resources, otherwise it\u0027s basically priority inversion all over the place 😄",
      "parentUuid": "5e5d6910_01eb884c",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "328d5556_99e28fb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:59:50Z",
      "side": 1,
      "message": "\u003e The harder part is detecting when the chaining is necessary.\n\nI was really hoping that GLES spec requires some sort of explicit synchronization... (Still need to look at the `UnsynchronizedTextureReads*`).\n\nMean while we can fix current problem by enforcing submit on flush when priority changes.",
      "parentUuid": "d69c9eca_e730f5bb",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50a05bb4_e776b8db",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-06T21:43:10Z",
      "side": 1,
      "message": "\u003e I was really hoping that GLES spec requires some sort of explicit synchronization\n\nIt\u0027s _generally_ like that, except for parallel reads 🙄\n\n\u003e Mean while we can fix current problem by enforcing submit on flush when priority changes.\n\nSounds good. We _currently_ have the problem of missing semaphores, which this change can exacerbate, but that can be fixed separately.",
      "parentUuid": "328d5556_99e28fb2",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e56710f_6b067dd1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T18:28:26Z",
      "side": 1,
      "message": "\u003e Sounds good. We currently have the problem of missing semaphores, which this change can exacerbate, but that can be fixed separately.\n\nUnfortunately it is hard to implement.\nEnforced submission may be on 2 levels: `RendererVk` or `CommandQueue`.\nIn the first case we need `QueueSerial` which we do not have.\nIn the second case - need to track forcefully submitted `VkCommandBuffer`s. Currently it can be only done in the `CommandBatch` that also relying on `QueueSerial`.\nSo need to made modifications in the `CommandQueue` to allow tracking such enforce submissions.\n\nBut is it really much different that having separate primary command buffers per priority?\nThe only difference - with separate buffers there will be no enforced submission.\nIn both cases - Semaphore synchronization is still required.\n\nI think @cclao@google.com should also comment on this matter.",
      "parentUuid": "50a05bb4_e776b8db",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33d8dc5d_0f24562d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-10T18:53:53Z",
      "side": 1,
      "message": "My proposal is to make primary command buffer per context, and ensure all contexts within same share group have the same priority (which means same VkQueue). Then you do not need semaphores to sync between VkQueues. And it also gives us other benefit, that you can directly encode outsideRenderPassCommands into primary command buffer without need of ANGLE\u0027s secondary command buffer, a potential CPU overhead save as well.\n\nAnd I believe you also want to make CommandQueue::mInflightCommands per VkQueue so that if one VkQueue has slow job, it will not stop it from progressing.\n\nThis will make vkQueue completely independent from each other. Am I miss anything here?",
      "parentUuid": "2e56710f_6b067dd1",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "846d2e2f_28b9ea47",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T19:22:37Z",
      "side": 1,
      "message": "These are the big changes.\n\nPer context command buffers adds complexity. Need add code to implicitly submit other command buffers in the share group. Can\u0027t directly record into primary if use asyncCommandQueue. Anyway, this may be separate change.\n\nMaking context in the same group have same priority - easy. Independent change from this CL. May be as temp solution (or not) until semaphores implemented.\n\nSeparate inflight queue is also separate optimization, and not related to the fix.\n\nOne place when semaphores still needed is via EGLImage. Other maybe when read from surface that was rendered by other context.",
      "parentUuid": "33d8dc5d_0f24562d",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1ad4561_6efb7c21",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-10T19:37:52Z",
      "side": 1,
      "message": "\u003e One place when semaphores still needed is via EGLImage. Other maybe when read from surface that was rendered by other context.\n\nread\u003c-\u003ewrite requires explicit sync, so it\u0027s probably easy. Simultaneous read is likely our worst case. I opened https://gitlab.khronos.org/opengl/API/-/issues/176 to make sure we are not trying so hard to support something that was an app mistake",
      "parentUuid": "846d2e2f_28b9ea47",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "349c3b1c_0313296c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-15T01:24:52Z",
      "side": 1,
      "message": "\u003e We *currently* have the problem of missing semaphores, which this change can exacerbate, but that can be fixed separately.\n\nPatchset is updated and passed all tests.\nI want to know what I need to do with these patch. Is it going to be submitted or I should abandon the CL?\n\n\u003e But is it really much different that having separate primary command buffers per priority?\nThe only difference - with separate buffers there will be no enforced submission.\nIn both cases - Semaphore synchronization is still required.\n\nI was thinking. Even with separate buffers we need to do enforced submissions once/if we add Semaphore tracking.\n\nI still do not understand from the GLES point of view what **\"command\"** *Context A* must execute so that results appear visible to the *Context B*. We need to at least flush commands to the primary command buffer when this **\"command\"** is executed by *Context A* so `CommandQueue` could submit commands/add semaphore. If there is no specific **\"command\"** - then *Context B* must flush and submit commands of *Context A*. But it may be **multiple** contexts such as *Context A* and we need to flush/submit all of them.\n\nIn any case. Enforced submission is necessary. Only question at what level it should be implemented:\n1. Contexts must flush commands to the `CommandQueue` in order for other Contexts to see results. `CommandQueue` will performs enforced submission - need to add such support into `CommandQueue`.\n2. Contexts will flush/submit commands of *other* Contexts that use same resources in order to see results (must be protected by Global mutex). - need to somehow track this *other* Contexts.",
      "parentUuid": "b1ad4561_6efb7c21",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec864478_54f9724a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-17T03:15:06Z",
      "side": 1,
      "message": "I don\u0027t remember if I ever pointed this out, but the spec has this:\n\n\u003e Rule 4 If the contents of an object T are changed in a context other than the current context, T must be attached or re-attached to at least one binding point in the current context, or at least one attachment point of a currently bound container object C, in order to guarantee that the new contents of T are visible in the current context.\n\n\u003e Note: “Attached or re-attached” means either attaching an object to a binding point it wasn’t already attached to, or attaching an object again to a binding point it was already attached to.\n\n\u003e Example: If a texture image is bound to multiple texture bind points and the texture is changed in another context, re-binding the texture at any one of the texture bind points is sufficient to cause the changes to be visible at all texture bind points.\n\nSo sync objects are needed, but _also_ a rebind is necessary. Right now we don\u0027t do anything on rebind, but if necessary it\u0027s something we could take advantage of.\n\nBy the way, there was a recent GL meeting and there was no conclusive answer to the issue of parallel reads (yet). I _think_ the answer is going to be that it\u0027s illegal, or I hope we can make that so. Our support for parallel unsynchronized reads is shaky at the moment, and outside of a single app, there are no known users. That leads me to the answer for:\n\n\u003e I want to know what I need to do with these patch. Is it going to be submitted or I should abandon the CL?\n\nDefinitely don\u0027t abandon. Didn\u0027t you say it fixes an issue with Samsung Notes? But it may need some time:\n\n- First, I\u0027d like to get https://gitlab.khronos.org/opengl/API/-/issues/176 resolved, and unfortunately GL workgroup meetings are once every 2 weeks so it\u0027ll be slow\n- Second, I want to have someone contact that developer of the affected app and get them to properly synchronize. We can\u0027t just break that app\n- Third, in the meantime, it\u0027d be good to have a solution for adding semaphores between submissions. Let\u0027s just assume sync objects are necessary, and use that to know when semaphores should be used. If we require timeline semaphores for that, I suspect it wouldn\u0027t be too hard.",
      "parentUuid": "349c3b1c_0313296c",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2daedcf1_1bedf1d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-17T13:07:07Z",
      "side": 1,
      "message": "\u003e Definitely don\u0027t abandon. Didn\u0027t you say it fixes an issue with Samsung Notes? But it may need some time:\n\nYes. Old version. Newer version seems work fine. Did non investigate in details how exactly working old and new versions. We applied this patch in our devices and I not heard about regressions.\n\n\u003e Second, I want to have someone contact that developer of the affected app and get them to properly synchronize. We can\u0027t just break that app\n\nThis app uses different priorities?\n\n\u003e If we require timeline semaphores for that, I suspect it wouldn\u0027t be too hard.\n\nTimeline semaphore is the Vulkan 1.2 or extension. What if the driver does not support this feature?\n\n\u003e Let\u0027s just assume sync objects are necessary, and use that to know when semaphores should be used. \n\nThe `SyncHelperNativeFence::serverWait` already uses semaphore, so it may work across different `VkQueue`s even if have separate command buffers per queue.",
      "parentUuid": "ec864478_54f9724a",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}