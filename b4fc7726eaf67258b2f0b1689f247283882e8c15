{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b64a5ec5_e78a69f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "Indeed I was going to point this out. Are you saying _apps_ should use semaphores? Unfortunately we can\u0027t require apps to do something the spec doesn\u0027t require.\n\nOne possible solution is to submit command buffers from all priorities of the contexts in the share group, but there\u0027s another bug here:\n\nWhen the resource usage is intermixed between render passes, the ordering won\u0027t be right if the contexts are separately recording to primary command buffers:\n\n- Context 1 (low priority) copies to texture (created with glTexStorage, so ANGLE flushes the work)\n- Context 2 (high priority) blends to image A and breaks the render pass (e.g. by copy into temp texture) (should read context1\u0027s write as blend dst)\n- Context 1 reads back from the texture (should read context2\u0027s result)\n\nWe rely on the fact these are recorded in order in the primary command buffer. If context2\u0027s commands are written separately to another primary command buffer, there\u0027s no way to order the two CBs to get correct rendering.\n\nCould you please add a test based on this? Take a look at MultithreadingTest.cpp and how tests use `RunLockStepThreads` to make sure the threads do the tasks in the desired order.",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bc46895_8931692e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "Not apps. ANGLE should use VkSemaphore automatically between submissions of commands, that accesses same resource into different VkQueue(s).\nHow to implement this - is another question. This may be simple or may be not. I did not have time to investigate this problem.\n\nAbout Context 1/2 scenario and test.\nI think that the app must use either glFinish() or glFenceSync() to synchronize access to the texture from Context 1 (copy) to Context 2 (blend); and Context 2 (blend) to Context 1 (read). Or how else we can ensure (from GLES stand point) this synchronization?\nIn case of glFinish() - no need to do enything.\nIn case of glFenceSync() - need to insert VkSemaphore() in the glWaitSync().",
      "parentUuid": "b64a5ec5_e78a69f2",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7ba25b9_5c366fb4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "Take a look at `UnsynchronizedTextureReads*` tests for example, EGL allows multiple threads to read from the texture without synchronization, while internally ANGLE would have to sequence them correctly due to image layout transitions.",
      "parentUuid": "2bc46895_8931692e",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a998d897_196cb273",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:32:09Z",
      "side": 1,
      "message": "Thanks.",
      "parentUuid": "d7ba25b9_5c366fb4",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb21587c_8a00e030",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "I understand the problem, and sympathize with the desire to fix it. I don\u0027t believe this is the right approach though.\n\nIn a sense, what we have _now_ is a priority inheritance system, except we can also downgrade priority depending on who actually submits the commands.\n\nI think a better solution is an actual priority inheritance mechanism. It should actually be fairly trivial to do; when we flush a secondary CB, get the priority and record the max, then on submission use the max priority instead of current context\u0027s priority.\n\nThis would actually mean that if A (high prio) depends on B (low prio), we\u0027d automatically run B at high prio for the sake of A.\n\nAlternatively, if that\u0027s not what we want to support (or there\u0027s a risk of unrelated low prio work getting submitted at high prio), we can always enforce a submission when SCB-\u003ePCB flush is done with a different priority.\n\nWhat do you think?",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b29bd753_4bb1d465",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "This problem is not theoretical and causes artifacts in Samsung Notes app.\n\nI think I understand the \"priority inheritance system/mechanism\".\n\nI do not understand how \"enforce a submission when SCB-\u003ePCB flush\" will help?\nFor example:\n- Context A (prio1) records and flushes commands and wait semaphore from Acquire\n- Context B (prio2) flushes commands -\u003e enforced submission.\n- Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n- Context A (prio1) continues to render into the same framebuffer.\n- Context A (prio1) calls eglSwapBuffers()\n- Rest of Context A commands (without Acquire semaphore) in the \"prio1\" VkQueue.\n- Blinking/artifacts may appear on screen, because there is no synchronization between commands from \"prio2\" VkQueue and \"prio1\" VkQueue, also no dependency chain with Acquire semaphore and Present semaphore.\n\nThe above situation is implicit command shuffle of a single Context.\nANGLE must detect such cases and use VkSemaphore when commands of a Context switches VkQueue like that.\nProposed solution simply avoid this shuffling.\n\nHowever, VkSemaphore may still be required to synchronize resource between multiple Contexts (Shared or via EGLImage).\nWe may call this problem - explicit command shuffle.",
      "parentUuid": "bb21587c_8a00e030",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a140c70_afb6f81f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "\u003e * Context A (prio1) records and flushes commands and wait semaphore from Acquire\n\u003e * Context B (prio2) flushes commands -\u003e enforced submission.\n\u003e * Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n\nNo actually the point was to have commands of Context A be submitted to prio1 queue. That can be done by recording the \"current priority of the PCB\", and when a new SCB flush comes with a different priority, _first_ submit the old PCB to its respective queue, _then_ record SCB into a new PCB and update the current priority.\n\nWould that not solve the issue?\n\nWe don\u0027t need a semaphore by the way because all the queues are from the same family, and pipeline barriers are taking care of synchronization.",
      "parentUuid": "b29bd753_4bb1d465",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e5d6910_01eb884c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:32:09Z",
      "side": 1,
      "message": "\u003e No actually the point was to have commands of Context A be submitted to prio1 queue.\n\nSorry, I misunderstood that.\n\n\u003e Would that not solve the issue?\n\nI guess so. I need to check this.\n\n\u003e We don\u0027t need a semaphore by the way because all the queues are from the same family, and pipeline barriers are taking care of synchronization.\n\nCould you point in the Vulkan spec where such guarantee is made?\n\nFrom what I found:\n\u003e Semaphores can be used to control resource access across multiple queues.\n\nSo \"multiple queues\" not queue families.\n\n\u003e Layout transitions that are performed via image memory barriers execute in their entirety in submission order, relative to other image layout transitions submitted to the same queue, including those performed by render passes.\n\nKey parts are \"submission order\" and \"same queue\".",
      "parentUuid": "9a140c70_afb6f81f",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d69c9eca_e730f5bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:44:11Z",
      "side": 1,
      "message": "You may be right, let me dig deeper. I did in fact have this chaining of submissions with semaphores done in the past: https://chromium-review.googlesource.com/c/angle/angle/+/1276805 but that was (rightfully) removed as we didn\u0027t actually need that with single-queue submissions.\n\nChaining the submissions between queues with semaphores is not really hard with the above flush-on-priority-change method. The harder part is detecting when the chaining is necessary; we wouldn\u0027t really want to make A wait for B if not using the same resources, otherwise it\u0027s basically priority inversion all over the place ðŸ˜„",
      "parentUuid": "5e5d6910_01eb884c",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "328d5556_99e28fb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T19:59:50Z",
      "side": 1,
      "message": "\u003e The harder part is detecting when the chaining is necessary.\n\nI was really hoping that GLES spec requires some sort of explicit synchronization... (Still need to look at the `UnsynchronizedTextureReads*`).\n\nMean while we can fix current problem by enforcing submit on flush when priority changes.",
      "parentUuid": "d69c9eca_e730f5bb",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50a05bb4_e776b8db",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-06T21:43:10Z",
      "side": 1,
      "message": "\u003e I was really hoping that GLES spec requires some sort of explicit synchronization\n\nIt\u0027s _generally_ like that, except for parallel reads ðŸ™„\n\n\u003e Mean while we can fix current problem by enforcing submit on flush when priority changes.\n\nSounds good. We _currently_ have the problem of missing semaphores, which this change can exacerbate, but that can be fixed separately.",
      "parentUuid": "328d5556_99e28fb2",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e56710f_6b067dd1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-10T18:28:26Z",
      "side": 1,
      "message": "\u003e Sounds good. We currently have the problem of missing semaphores, which this change can exacerbate, but that can be fixed separately.\n\nUnfortunately it is hard to implement.\nEnforced submission may be on 2 levels: `RendererVk` or `CommandQueue`.\nIn the first case we need `QueueSerial` which we do not have.\nIn the second case - need to track forcefully submitted `VkCommandBuffer`s. Currently it can be only done in the `CommandBatch` that also relying on `QueueSerial`.\nSo need to made modifications in the `CommandQueue` to allow tracking such enforce submissions.\n\nBut is it really much different that having separate primary command buffers per priority?\nThe only difference - with separate buffers there will be no enforced submission.\nIn both cases - Semaphore synchronization is still required.\n\nI think @cclao@google.com should also comment on this matter.",
      "parentUuid": "50a05bb4_e776b8db",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}