{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b64a5ec5_e78a69f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "Indeed I was going to point this out. Are you saying _apps_ should use semaphores? Unfortunately we can\u0027t require apps to do something the spec doesn\u0027t require.\n\nOne possible solution is to submit command buffers from all priorities of the contexts in the share group, but there\u0027s another bug here:\n\nWhen the resource usage is intermixed between render passes, the ordering won\u0027t be right if the contexts are separately recording to primary command buffers:\n\n- Context 1 (low priority) copies to texture (created with glTexStorage, so ANGLE flushes the work)\n- Context 2 (high priority) blends to image A and breaks the render pass (e.g. by copy into temp texture) (should read context1\u0027s write as blend dst)\n- Context 1 reads back from the texture (should read context2\u0027s result)\n\nWe rely on the fact these are recorded in order in the primary command buffer. If context2\u0027s commands are written separately to another primary command buffer, there\u0027s no way to order the two CBs to get correct rendering.\n\nCould you please add a test based on this? Take a look at MultithreadingTest.cpp and how tests use `RunLockStepThreads` to make sure the threads do the tasks in the desired order.",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bc46895_8931692e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "Not apps. ANGLE should use VkSemaphore automatically between submissions of commands, that accesses same resource into different VkQueue(s).\nHow to implement this - is another question. This may be simple or may be not. I did not have time to investigate this problem.\n\nAbout Context 1/2 scenario and test.\nI think that the app must use either glFinish() or glFenceSync() to synchronize access to the texture from Context 1 (copy) to Context 2 (blend); and Context 2 (blend) to Context 1 (read). Or how else we can ensure (from GLES stand point) this synchronization?\nIn case of glFinish() - no need to do enything.\nIn case of glFenceSync() - need to insert VkSemaphore() in the glWaitSync().",
      "parentUuid": "b64a5ec5_e78a69f2",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7ba25b9_5c366fb4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "Take a look at `UnsynchronizedTextureReads*` tests for example, EGL allows multiple threads to read from the texture without synchronization, while internally ANGLE would have to sequence them correctly due to image layout transitions.",
      "parentUuid": "2bc46895_8931692e",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb21587c_8a00e030",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T17:11:31Z",
      "side": 1,
      "message": "I understand the problem, and sympathize with the desire to fix it. I don\u0027t believe this is the right approach though.\n\nIn a sense, what we have _now_ is a priority inheritance system, except we can also downgrade priority depending on who actually submits the commands.\n\nI think a better solution is an actual priority inheritance mechanism. It should actually be fairly trivial to do; when we flush a secondary CB, get the priority and record the max, then on submission use the max priority instead of current context\u0027s priority.\n\nThis would actually mean that if A (high prio) depends on B (low prio), we\u0027d automatically run B at high prio for the sake of A.\n\nAlternatively, if that\u0027s not what we want to support (or there\u0027s a risk of unrelated low prio work getting submitted at high prio), we can always enforce a submission when SCB-\u003ePCB flush is done with a different priority.\n\nWhat do you think?",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b29bd753_4bb1d465",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-01-30T18:12:03Z",
      "side": 1,
      "message": "This problem is not theoretical and causes artifacts in Samsung Notes app.\n\nI think I understand the \"priority inheritance system/mechanism\".\n\nI do not understand how \"enforce a submission when SCB-\u003ePCB flush\" will help?\nFor example:\n- Context A (prio1) records and flushes commands and wait semaphore from Acquire\n- Context B (prio2) flushes commands -\u003e enforced submission.\n- Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n- Context A (prio1) continues to render into the same framebuffer.\n- Context A (prio1) calls eglSwapBuffers()\n- Rest of Context A commands (without Acquire semaphore) in the \"prio1\" VkQueue.\n- Blinking/artifacts may appear on screen, because there is no synchronization between commands from \"prio2\" VkQueue and \"prio1\" VkQueue, also no dependency chain with Acquire semaphore and Present semaphore.\n\nThe above situation is implicit command shuffle of a single Context.\nANGLE must detect such cases and use VkSemaphore when commands of a Context switches VkQueue like that.\nProposed solution simply avoid this shuffling.\n\nHowever, VkSemaphore may still be required to synchronize resource between multiple Contexts (Shared or via EGLImage).\nWe may call this problem - explicit command shuffle.",
      "parentUuid": "bb21587c_8a00e030",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a140c70_afb6f81f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-01-30T19:01:12Z",
      "side": 1,
      "message": "\u003e * Context A (prio1) records and flushes commands and wait semaphore from Acquire\n\u003e * Context B (prio2) flushes commands -\u003e enforced submission.\n\u003e * Commands of Context A and Acquire semaphore in the \"prio2\" VkQueue.\n\nNo actually the point was to have commands of Context A be submitted to prio1 queue. That can be done by recording the \"current priority of the PCB\", and when a new SCB flush comes with a different priority, _first_ submit the old PCB to its respective queue, _then_ record SCB into a new PCB and update the current priority.\n\nWould that not solve the issue?\n\nWe don\u0027t need a semaphore by the way because all the queues are from the same family, and pipeline barriers are taking care of synchronization.",
      "parentUuid": "b29bd753_4bb1d465",
      "revId": "b4fc7726eaf67258b2f0b1689f247283882e8c15",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}