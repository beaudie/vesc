{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e3bcdf86_b34f1c4d",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 6517,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-30T16:05:54Z",
      "side": 1,
      "message": "What happens today if that check is removed? Do applications actually render incorrectly? What I\u0027m wondering is if applications are missing this because \"it seems to work\", and drivers keep WaW optimal for applications that _do_ use it correctly. We\u0027d be taking a perf hit in that case.\n\nI mean, sure we may get syncval errors from those apps, but as long as it renders correctly, they would be getting lucky with ANGLE same way they get lucky with native drivers.\n\nEither way, for now I suggest putting back `kBufferMemoryBarrierBits` where it was, add an `enum class BufferUpdateWithMemoryBarrier { No, Yes }` kind of thing (in vk_cache_utils.h), and pass that here. ContextVk can keep that instead of the `GLbitfield`, we only ever check `(memoryBarrierBits \u0026 kBufferMemoryBarrierBits) \u003d\u003d 0` anyway (so all we need is a boolean).\n\nIt would also then be easier to later add a feature to do this or not and make this possibly a per-app workaround.",
      "revId": "918e3ee8384347e09e1ecd8d777fa2c42b2372df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "825402c0_cd06b3fc",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 6517,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-07-31T00:53:44Z",
      "side": 1,
      "message": "See https://chromium-review.googlesource.com/c/angle/angle/+/5434967?tab\u003dchecks\nQuite some tests are broken.\n\nRegarding passing `enum class BufferUpdateWithMemoryBarrier { No, Yes }`. I was try to avoid have to declare another enum for this. We already have GLbitfield and we can perfectly use it and easy to read and debug as well.",
      "parentUuid": "e3bcdf86_b34f1c4d",
      "revId": "918e3ee8384347e09e1ecd8d777fa2c42b2372df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0825d95_6e5a7c49",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 6517,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-31T13:21:55Z",
      "side": 1,
      "message": "I\u0027m just trying to stop more of GL leaking into namespace vk, but I guess this function is already pretty GL-centric.\n\nOk, looks like _apps_ are fine, and these are just test bugs. I\u0027ll see about fixing them and then we can clean this back up.",
      "parentUuid": "825402c0_cd06b3fc",
      "revId": "918e3ee8384347e09e1ecd8d777fa2c42b2372df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4d92ae1_29dbd913",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 18
      },
      "lineNbr": 6517,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-07-31T13:55:25Z",
      "side": 1,
      "message": "Looked into `KHR-GLES31.core.compute_shader.pipeline-gen-draw-commands`, the problem seems to be something different; it\u0027s not the same thing as the write-after-access issue we talked about in the other CL.\n\nIn that test, there\u0027s a dispatch, then `glMemoryBarrier(GL_COMMAND_BARRIER_BIT)`, then an indirect draw call. With the debug change, what happens is that this call doesn\u0027t generate a barrier:\n\n```\nangle::Result ContextVk::dispatchComputeIndirect(const gl::Context *context, GLintptr indirect)\n{\n    ...\n\n    // Process indirect buffer after command buffer has started.\n    mOutsideRenderPassCommands-\u003ebufferRead(this, VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n                                           vk::PipelineStage::DrawIndirect, \u0026buffer);\n```\n\nBasically, that depends on the first dispatch call to result in `bufferWrite` so that `bufferRead` generates a barrier. And the first dispatch call\u0027s `bufferWrite` shouldn\u0027t depend on a pre-existing memory barrier (like, it may be filling the buffer for the first time).\n\nLet\u0027s talk about this later today, it looks like there\u0027s a misunderstanding here.",
      "parentUuid": "a0825d95_6e5a7c49",
      "revId": "918e3ee8384347e09e1ecd8d777fa2c42b2372df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}