{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f123bc4a_3cc0471e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-04-20T17:16:51Z",
      "side": 1,
      "message": "LGTM",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6660cfbe_3325a80e",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2227,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-04-20T17:16:51Z",
      "side": 1,
      "message": "You can test swapSerial here and do the tail call only if it has not finished.",
      "range": {
        "startLine": 2227,
        "startChar": 8,
        "endLine": 2227,
        "endChar": 26
      },
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7caf8bdb_5bc8e9e8",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2227,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T15:20:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6660cfbe_3325a80e",
      "range": {
        "startLine": 2227,
        "startChar": 8,
        "endLine": 2227,
        "endChar": 26
      },
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5a07258_eba6e3b0",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-20T18:27:20Z",
      "side": 1,
      "message": "What if other context in a share group make access to the `context`. For example, will flush all of its commands?\n\nOnly problem I can think of is the concurrent calls to the `Context::handleError()`.",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "928d4ce4_224dfba1",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T15:20:01Z",
      "side": 1,
      "message": "Good point, I mistakenly thought the `(void)` stopping the error from bubbling up prevents that call, but now I see it\u0027s being done in `ANGLE_VK_TRY`.\n\nOther than that though, the `finishQueueSerial` function doesn\u0027t actually do anything with contexts, it waits for an-already-submitted serial to finish and is pretty much independent of contexts.\n\n`finishQueueSerial` gets a `vk::Context`, so I changed the call here to get the display instead of the context. That should hopefully make it clear that this function has nothing to do with ContextVk. It\u0027s also an improvement I think because if there\u0027s an error, it\u0027ll be counted as an EGL error (instead of GL) which is more appropriate for this function.\n\nThere\u0027s still a race though with `DisplayVk::mSavedError`, which shouldn\u0027t have been global like that. Let me see if I can just remove that somehow; otherwise it\u0027ll have to turn thread-local.",
      "parentUuid": "b5a07258_eba6e3b0",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58bd2cec_3fbdb257",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T15:37:57Z",
      "side": 1,
      "message": "\u003e There\u0027s still a race though with DisplayVk::mSavedError, which shouldn\u0027t have been global like that. Let me see if I can just remove that somehow; otherwise it\u0027ll have to turn thread-local.\n\nAlso:\n```\nDisplayVk::handleError() -\u003e RendererVk::notifyDeviceLost() -\u003e Display::notifyDeviceLost() -\u003e Context::markContextLost() -\u003e Context::setContextLost()\n```\n\nI think we need to handle errors similar to `ErrorProxyContext` here: https://chromium-review.googlesource.com/c/angle/angle/+/4386409\n\nTail call uses `ErrorProxyContext`. In case if there is an error after the tail call -\u003e lock necessary mutex and handles the error.\n\nHere I added `ContextType` for the purpose of unlock: https://chromium-review.googlesource.com/c/angle/angle/+/4374547\nBut we may use it for locking instead.\n\n- So we pass `ErrorProxyContext` to the lambda by value. \n- `ErrorProxyContext` remembers the original context and knows what mutex must be used to protect it.\n- We use `ErrorProxyContext` inside the tail call.\n- In `ErrorProxyContext` destructor, in case of any error we lock mutexes and handle errors using the original context.",
      "parentUuid": "928d4ce4_224dfba1",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd884386_11441211",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T18:47:52Z",
      "side": 1,
      "message": "Thanks, that\u0027s interesting.\n\nSince you mentioned issues with the \"current valid context\" TLS and the idea of always getting the \"current context\" and check for isContextLost() in the call itself, perhaps there is a way to make that solve this at the same time. That is, if mContextLost is atomic, Display::notifyDeviceLost() can continue to be done unlocked, and the context will pick it up on its next entry point (and do whatever processing it needs to do). This has the downside of an atomic read on every entry point, though I\u0027m speculating what the cost is.\n\nAnother approach could be for Display::notifyDeviceLost() to take the share group locks per https://chromium-review.googlesource.com/c/angle/angle/+/4374545 right away and handle the error. What do you think of that?",
      "parentUuid": "58bd2cec_3fbdb257",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9238a4e_34eba3d5",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T18:49:06Z",
      "side": 1,
      "message": "(Hmm.. the last idea could lead to lock recursion)",
      "parentUuid": "dd884386_11441211",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c23dc38_417ad36d",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T19:36:51Z",
      "side": 1,
      "message": "\u003e  That is, if mContextLost is atomic, Display::notifyDeviceLost() can continue to be done unlocked, and the context will pick it up on its next entry point (and do whatever processing it needs to do).\n\nThis will not prevent Context to become lost after checking the atomic.\n\nTo guarantee that Context is not lost while it holding the Share Context lock - we must only make it Lost inside that lock.\nOtherwise, if Context may be Lost during the call - mContextLost race is not a problem at all)\n\n\u003e Another approach could be for Display::notifyDeviceLost() to take the share group locks per https://chromium-review.googlesource.com/c/angle/angle/+/4374545 right away and handle the error. What do you think of that?\n\nI need to think about this.\n\nThere are 2 problems:\n1) Tail call may call `handleError()` without lock. No matter if `vk::Context` is `ContextVk` or `DisplayVk`.\n2) `Display::notifyDeviceLost()` access all contexts without locks.\n\nTo fix (1) may use `ErrorProxyContext` that will take necessary lock when calling `handleError()`. This is just so that `handleError()` called with the same mutex as it would without the tail call.\n\nFor problem (2).\n\nCalls to `Display::notifyDeviceLost()` must be protected by a Global Mutex, because it accesses `mState.contextSet`. So if some non Shared Context calls this, then there is a race (and it looks like it is called in some back-ends). It seems that with my SharedContextMutex CL, race will happen also for Shared Contexts...\nSo we need to detect when `Display::notifyDeviceLost()` is called with/without Global Lock and make Global Lock if needed (need to track `ThreadId` for that...). \n\nAlternatively, we can protect `mState.contextSet` by separate mutex, so that `Display::notifyDeviceLost()` does not require a GlobalLock. Can\u0027t say now what to do with `mDeviceLost`, because do not know how it is used and how it relates to the `mContextLost`.\n\nWhen using SharedContextMutex we need to pass `Context` inside `Display::notifyDeviceLost()` when applicable. Passing the `Context` will assume that it\u0027s mutex is locked. Then, we can compare what mutex each context is using and lock it if it is different.\n\n---\n\nAlso it is strange that `ContextVk::handleError()` does not make Lost all other Contexts, while `DisplayVk::handleError` does.\n`Context11::handleResult()` for example, calls `Display::notifyDeviceLost()`.",
      "parentUuid": "c9238a4e_34eba3d5",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96547394_7dfc253c",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-04-24T20:07:18Z",
      "side": 1,
      "message": "\u003e Also it is strange that ContextVk::handleError() does not make Lost all other Contexts, while DisplayVk::handleError does.\n\nContext loss should only make other contexts in the same share group lost. This is per KHR_robustness:\n\n\u003e 6. If a graphics reset occurs in a shared context, what happens in\n\u003e    shared contexts?\n\u003e\n\u003e    RESOLVED: A reset in one context will result in a reset in all other\n\u003e    contexts in its share group.\n\nDevice loss ends up losing all contexts because they are all backed by the same device.\n\n---\n\nI don\u0027t want to gloss over this of course (I\u0027ll create a tracking issue for this once discussions settle), but I kind of feel like it\u0027s a low priority problem. Device loss is already rare, and I suspect if a call on some context goes through after the device is lost, it\u0027ll just fail on the next call anyway (and just generate another loss). Don\u0027t you agree?",
      "parentUuid": "1c23dc38_417ad36d",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08e91755_990a93a9",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 2236,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-24T20:08:48Z",
      "side": 1,
      "message": "It is I who removed `mRenderer-\u003enotifyDeviceLost();` from `ContextVk::handleDeviceLost()`!\n\nhttps://chromium-review.googlesource.com/c/angle/angle/+/4334579/10/src/libANGLE/renderer/vulkan/ContextVk.cpp#b3757\n\nWill return it right away)",
      "parentUuid": "1c23dc38_417ad36d",
      "revId": "2c53b56d9c913da72009903c5d46417835ecfff3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}