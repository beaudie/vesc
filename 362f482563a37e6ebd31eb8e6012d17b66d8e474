{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8927c271_53cc6227",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-18T19:53:10Z",
      "side": 1,
      "message": "`render pass, context or ...`",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "751d15e6_facec964",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-18T20:22:47Z",
      "side": 1,
      "message": "In this particular case, it\u0027s acceptable for the contents to be leaked from a previous render pass in the same context though, right? Or do we want to be more restrictive?\n\nIn the strictest sense, \"KEEP\" might be leaked from a previous render pass in the same context.",
      "parentUuid": "8927c271_53cc6227",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c3230bb_ccea8ab6",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-19T01:47:16Z",
      "side": 1,
      "message": "\u003e In this particular case, it\u0027s acceptable for the contents to be leaked from a previous render pass in the same context though, right?\n\nNo? Wouldn\u0027t that mean one WebGL context\u0027s data would leak to another? Their rendering is interleaved on the same backend context, right?\n\nBut based on your KEEP comment, I think I understand what the concern is. We don\u0027t want to entirely ban leaks between render passes, just leaks between render passes of different framebuffers (or rather, their attachments). Assuming textures, renderbuffers and framebuffers are unique to each WebGL context, then leaks between render passes of the same WebGL context are fine (enforced with the wording that leaks between render passes with framebuffers that don\u0027t share any attachments is impossible).\n\nIf WebGL contexts can share textures, then that would be a mess!",
      "parentUuid": "751d15e6_facec964",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a8a3e47_c46c4922",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-19T08:43:39Z",
      "side": 1,
      "message": "I think we\u0027re on the same page, and I had a couple more thoughts --\n\n\u003e leaks between render passes with framebuffers that don\u0027t share any attachments is impossible\n\nMaybe I\u0027m getting too far out there, but does this matter? Maybe our implementation reuses the same internal scratch texture for memoryless pixel local storage on different framebuffers, but in the same context. Is that theoretically ok?\n\nIn the interest of keeping it simple, I\u0027m wondering if the wording \"not leaked from another context\" alone is enough, since that already covers render passes in another context?\n\nEither way, I\u0027m not too picky about the wording, and clearing is fine on a tiler. I\u0027m just seeing if we can avoid clearing a texture in the shader image implementation of memoryless pixel local storage. That would mean leaving the data from a previous pixel local storage render pass to that same plane, which may be understood as being leaked from another render pass.\n\n\u003e If WebGL contexts can share textures, then that would be a mess!\n\n ðŸ˜¬",
      "parentUuid": "2c3230bb_ccea8ab6",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a8e26c1_b65ec59f",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-19T15:45:24Z",
      "side": 1,
      "message": "\u003e In the interest of keeping it simple, I\u0027m wondering if the wording \"not leaked from another context\" alone is enough, since that already covers render passes in another context?\n\nSo when contexts are virtualized, Chrome thinks it has many contexts, but in reality there is one context running everything. There is no _other_ context, so we can only talk about render passes when dealing with leaks. That said:\n\n\u003e Maybe I\u0027m getting too far out there, but does this matter? Maybe our implementation reuses the same internal scratch texture for memoryless pixel local storage on different framebuffers, but in the same context. Is that theoretically ok?\n\nI think not, because one WebGL context\u0027s render results should not be visible to another WebGL context (again, remember that they are all running over the same _real_ GL context). I don\u0027t believe we can allow reuse of the scratch texture between framebuffers. In other words, anything necessary to support memoryless planes must be owned by the framebuffer.\n\n\u003e I\u0027m just seeing if we can avoid clearing a texture in the shader image implementation of memoryless pixel local storage.\n\nWe definitely can. As long as the shader image is owned by the framebuffer. Of course, it\u0027ll need to be cleared once because of robust-resource-init, but can be freely used by that framebuffer afterwards. Like I said, leaks between render passes of the same framebuffer are ok, because (I\u0027m presuming) WebGL resources aren\u0027t shared between pages.",
      "parentUuid": "9a8a3e47_c46c4922",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6c8e4c4_b212b1f3",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 250,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-19T20:27:44Z",
      "side": 1,
      "message": "\u003e there is one context running everything\n\nI see, yes. Virtual contexts make this need to be really locked down. Thanks for explaining that.\n\n\u003e We definitely can. As long as the shader image is owned by the framebuffer\n\nPerfect. We can plan on doing it that way.\n\n\u003e Like I said, leaks between render passes of the same framebuffer are ok\n\nMaybe we could just say: \"leaked from outside the current render pass\", with the understanding that the existing contents of framebuffer attachments coming in also count as part of the current render pass.\n\nDoes that work? It might also work to say \"Leaked from outside the current draw framebuffer\" if we like that better.",
      "parentUuid": "2a8e26c1_b65ec59f",
      "range": {
        "startLine": 250,
        "startChar": 65,
        "endLine": 250,
        "endChar": 66
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2edef90c_cfbf1686",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 646,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-08-18T19:53:10Z",
      "side": 1,
      "message": "nit: remove `and unmeaningful`. Just undefined is enough.",
      "range": {
        "startLine": 646,
        "startChar": 59,
        "endLine": 646,
        "endChar": 76
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "44483ca3_8e2fef0a",
        "filename": "extensions/ANGLE_shader_pixel_local_storage.txt",
        "patchSetId": 19
      },
      "lineNbr": 646,
      "author": {
        "id": 1543967
      },
      "writtenOn": "2022-08-18T20:22:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2edef90c_cfbf1686",
      "range": {
        "startLine": 646,
        "startChar": 59,
        "endLine": 646,
        "endChar": 76
      },
      "revId": "362f482563a37e6ebd31eb8e6012d17b66d8e474",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}