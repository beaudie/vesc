#!/usr/bin/python
#
# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_glenum_table.py:
#   Generates GLenum value to string table for ANGLE
#   NOTE: don't run this script directly. Run scripts/run_code_generation.py.

import sys
import os
from datetime import date
from collections import namedtuple

import registry_xml

template_gl_enums_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// gl_enums_autogen.h:
//   mapping of GLenum value to string.

#ifndef LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_
#define LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_

#include <string>
#include <vector>

namespace angle
{{

const char *getGLenumInString(unsigned int value);

std::vector<std::string> getGLbitmaskInString(unsigned int value);

}}

#endif  // LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_
"""

template_gl_enums_source = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// gl_enums_autogen.cpp:
//   mapping of GLenum value to string.

#include "libANGLE/gl_enums_autogen.h"

#include "common/debug.h"

namespace angle
{{

const char *getGLenumInString(unsigned int value) {{
    switch (value) {{
        {gl_enums_value_to_string_table}
        default: 
            return nullptr;
    }}
}}

std::vector<std::string> getGLbitmaskInString(unsigned int value) {{
    switch (value) {{
        {gl_bitmasks_value_to_string_table}
        default: 
            UNREACHABLE();
    }}

    return std::vector<std::string>();
}}

}}

"""

export_apis = ['gles2']
export_extensions = []

trivial_gl_enums = {
    'GL_FALSE', 'GL_TRUE', 'GL_ZERO', 'GL_ONE', 'GL_NONE', 'GL_NO_ERROR', 'GL_TIMEOUT_IGNORED'
}


def add_gl_enum_to_table(enum_name, enum_value, enum_table):
    if enum_name in trivial_gl_enums:
        return

    if enum_value not in enum_table:
        enum_table[enum_value] = enum_name
    else:
        # Some value may have more than one GLenum mapped to them, such as:
        #     GL_DRAW_FRAMEBUFFER_BINDING and GL_FRAMEBUFFER_BINDING
        #     GL_BLEND_EQUATION_RGB and GL_BLEND_EQUATION
        # it is safe to output either one of them, here just chose the shorter one for simplity
        if len(enum_name) < len(enum_table[enum_value]):
            enum_table[enum_value] = enum_name


def add_gl_bitmask_to_table(enum_name, enum_value, bitmask_table):
    if enum_value not in bitmask_table:
        bitmask_table[enum_value] = list()
    bitmask_table[enum_value].append(enum_name)


def dump_enum_table_to_string(table):
    table_in_tuples = sorted(table.iteritems(), key=lambda t: t[0])
    return "\n".join([
        'case {value}: return "{string}";'.format(
            value=hex(t[0]),
            string=t[1],
        ) for t in table_in_tuples
    ])


def dump_bitmask_table_to_string(table):
    table_in_tuples = sorted(table.iteritems(), key=lambda t: t[0])
    return "\n".join([
        "case {value}: return std::vector<std::string>{{ {strings} }};".format(
            value=hex(t[0]),
            strings=", ".join(['"%s"' % s for s in t[1]]),
        ) for t in table_in_tuples
    ])


def main(output_base_path):
    xml = registry_xml.RegistryXML('gl.xml', 'gl_angle_ext.xml')

    # build a map from GLenum name to its value
    all_gl_enums = dict()
    all_gl_bitmasks = dict()
    for enums_dom in xml.root.findall('enums'):
        if enums_dom.attrib.get('type') == 'bitmask':
            dst_mappings = all_gl_bitmasks
        else:
            dst_mappings = all_gl_enums

        for enum in enums_dom.findall('enum'):
            name = enum.attrib['name']
            value = int(enum.attrib['value'], base=16)
            dst_mappings[name] = value

    # find GLenums need to be exported according to apis and extensions
    non_bitmasks_table = dict()
    bitmasks_table = dict()
    for api in export_apis:
        xpath = ".//feature[@api='%s']//require//enum" % api
        for enum_tag in xml.root.findall(xpath):
            enum_name = enum_tag.attrib['name']
            if enum_name in all_gl_enums:
                add_gl_enum_to_table(enum_name, all_gl_enums[enum_name], non_bitmasks_table)
            else:
                add_gl_bitmask_to_table(enum_name, all_gl_bitmasks[enum_name], bitmasks_table)

    for extension in export_extensions:
        xpath = ".//extensions//extension[@name='%s']//require//enum" % extension
        for enum_tag in xml.root.findall(xpath):
            enum_name = enum_tag.attrib['name']
            if enum_name in all_gl_enums:
                add_gl_enum_to_table(enum_name, all_gl_enums[enum_name], non_bitmasks_table)
            else:
                add_gl_bitmask_to_table(enum_name, all_gl_bitmasks[enum_name], bitmasks_table)

    # dump GLenum table to cpp code
    non_bitmasks_table_dump = dump_enum_table_to_string(non_bitmasks_table)
    bitmasks_table_dump = dump_bitmask_table_to_string(bitmasks_table)

    header_content = template_gl_enums_header.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
    )
    header_output_path = registry_xml.script_relative(output_base_path + '.h')
    with open(header_output_path, 'w') as f:
        f.write(header_content)

    source_content = template_gl_enums_source.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
        gl_enums_value_to_string_table=non_bitmasks_table_dump,
        gl_bitmasks_value_to_string_table=bitmasks_table_dump,
    )

    source_output_path = registry_xml.script_relative(output_base_path + '.cpp')
    with open(source_output_path, 'w') as f:
        f.write(source_content)

    return 0


if __name__ == '__main__':
    inputs = [
        'gl.xml',
        'gl_angle_ext.xml',
    ]

    gl_enums_autogen_base_path = '../src/libANGLE/gl_enums_autogen'
    outputs = [
        gl_enums_autogen_base_path + '.h',
        gl_enums_autogen_base_path + '.cpp',
    ]

    if len(sys.argv) > 1:
        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print ','.join(outputs)
    else:
        sys.exit(main(gl_enums_autogen_base_path))
