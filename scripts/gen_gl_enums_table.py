#!/usr/bin/python
#
# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_glenum_table.py:
#   Generates GLenum value to string table for ANGLE
#   NOTE: don't run this script directly. Run scripts/run_code_generation.py.

import sys
import os
from datetime import date
from collections import namedtuple

import registry_xml

export_apis = ['gles2']
export_extensions = ['GL_AMD_depth_clamp_separate']

template_gl_enums_table = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// gl_enums_table_autogen.h:
//   ANGLE used GLenum value to string table.

#ifndef LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_
#define LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_

#include <string>
#include <vector>
#include <map>

namespace angle
{{

const std::map<const unsigned int, const std::vector<std::string>> GLenumValueToStringLookupTable = {{
{gl_enums_value_to_string_table}
}};

const std::map<const unsigned int, const std::vector<std::string>> GLbitmaskValueToStringLookupTable = {{
{gl_bitmasks_value_to_string_table}
}};

}}

#endif  // LIBANGLE_GL_ENUMS_TABLE_AUTOGEN_H_
"""

trivial_gl_enums = {'GL_FALSE', 'GL_TRUE', 'GL_ZERO', 'GL_ONE', 'GL_NONE', 'GL_NO_ERROR'}

GLenumInfo = namedtuple('GLenum_Description', ['name', 'value', 'vendor', 'is_bitmask'])


def script_relative(path):
    return os.path.join(os.path.dirname(sys.argv[0]), path)


def add_enum_to_table(enum, dst_table):
    if enum.name in trivial_gl_enums:
        return

    if enum.value not in dst_table:
        dst_table[enum.value] = set()
    dst_table[enum.value].add(enum.name)


def dump_table_to_string(table):
    table_in_tuples = sorted(table.iteritems(), key=lambda t: t[0])
    return ",\n".join([
        "{{ {value}, {{ {strings} }} }}".format(
            value=hex(t[0]),
            strings=", ".join(['"%s"' % s for s in t[1]]),
        ) for t in table_in_tuples
    ])


def main(output_rel_path):
    xml = registry_xml.RegistryXML('gl.xml', 'gl_angle_ext.xml')

    # build a map from GLenum name to its description
    all_enums = dict()
    for enums_group in xml.root.findall('enums'):
        vendor = enums_group.attrib.get('vendor')
        is_bitmask = enums_group.attrib.get('type') == 'bitmask'
        for enum in enums_group.findall('enum'):
            name = enum.attrib['name']
            value = int(enum.attrib['value'], base=16)
            all_enums[name] = GLenumInfo(name, value, vendor, is_bitmask)

    # find GLenums need to be exported according to apis and extensions
    non_bitmasks_table = dict()
    bitmasks_table = dict()
    for api in export_apis:
        xpath = ".//feature[@api='%s']//require//enum" % api
        for enum_tag in xml.root.findall(xpath):
            required_enum = all_enums[enum_tag.attrib['name']]
            if required_enum.is_bitmask:
                add_enum_to_table(required_enum, bitmasks_table)
            else:
                add_enum_to_table(required_enum, non_bitmasks_table)

    for extension in export_extensions:
        xpath = ".//extensions//extension[@name='%s']//require//enum" % extension
        for enum_tag in xml.root.findall(xpath):
            extension_enum = all_enums[enum_tag.attrib['name']]
            if extension_enum.is_bitmask:
                add_enum_to_table(extension_enum, bitmasks_table)
            else:
                add_enum_to_table(extension_enum, non_bitmasks_table)

    # dump GLenum table to cpp code
    non_bitmasks_table_dump = dump_table_to_string(non_bitmasks_table)
    bitmasks_table_dump = dump_table_to_string(bitmasks_table)

    content = template_gl_enums_table.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
        gl_enums_value_to_string_table=non_bitmasks_table_dump,
        gl_bitmasks_value_to_string_table=bitmasks_table_dump,
    )

    output_path = script_relative(output_rel_path)
    with open(output_path, 'w') as f:
        f.write(content)

    return 0


if __name__ == '__main__':
    inputs = [
        'gl.xml',
        'gl_angle_ext.xml',
    ]
    output = '../src/libANGLE/gl_enums_table_autogen.h'

    if len(sys.argv) > 1:
        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print output
    else:
        sys.exit(main(output))
