#!/usr/bin/python
#
# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_frame_capture_replay.py:
#   Generates GLenum value to string mapping for ANGLE
#   NOTE: don't run this script directly. Run scripts/run_code_generation.py.

import sys
import os
import json
from datetime import date

import registry_xml

template_frame_capture_replay_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// frame_capture_replay_autogen.h:
//   Replay GL calls being captured

#include "libANGLE/FrameCapture.h"

namespace angle
{{

void CallCaptureReplay(gl::Context *context, const angle::CallCapture &call);

}}

"""

template_frame_capture_replay_soureces = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// frame_capture_replay_autogen.cpp:
//   Replay GL calls being captured

#include "frame_capture_replay_autogen.h"

#include <export.h>
#include "angle_gl.h"

#include "anglebase/no_destructor.h"
#include "common/debug.h"
#include "libANGLE/frame_capture_utils_autogen.h"

using namespace gl;

namespace angle 
{{

template <typename T>
inline static T readParamCapture(const angle::ParamCapture &param)
{{
    T paramOut;
    angle::AccessParamValue(param.type, param.value, &paramOut);
    return paramOut;
}}

template <typename T>
static T readPointerParamCapture(const angle::ParamCapture &param)
{{
    if (!param.data.empty())
    {{
        ASSERT(param.data.size() == 1);
        return reinterpret_cast<T>(const_cast<uint8_t *>(param.data[0].data()));
    }}
    else
    {{
        T paramOut;
        angle::AccessParamValue(param.type, param.value, &paramOut);
        return paramOut;
    }}
}}

template <typename T>
static T readPointerPointerParamCapture(const angle::ParamCapture &param)
{{
    static angle::base::NoDestructor<std::vector<const uint8_t *>> pointersBuffer;
    if (!param.data.empty())
    {{
        pointersBuffer->clear();
        pointersBuffer->reserve(param.data.size());
        for(const auto &data : param.data) {{
            pointersBuffer->emplace_back(data.data());
        }}
        return reinterpret_cast<T>(const_cast<uint8_t **>(pointersBuffer->data()));
    }}
    else
    {{
        T paramOut;
        angle::AccessParamValue(param.type, param.value, &paramOut);
        return paramOut;
    }}
}}

void CallCaptureReplay(gl::Context *context, const angle::CallCapture &call) {{
    const std::vector<angle::ParamCapture> & paramCaptures = call.params.getParamCaptures();
    switch (call.entryPoint) {{
        {call_replay_cases}
        case gl::EntryPoint::Invalid:
            // Custom function is not handled here, let it pass through
            break;            
        default:
            UNREACHABLE();
    }}
}}

}}

"""

# TODO: determin enum type
template_param_access = """readParamCapture<{type}>(paramCaptures[{index}])"""

template_pointer_param_access = """readPointerParamCapture<{type}>(paramCaptures[{index}])"""

template_pointer_pointer_param_access = """readPointerPointerParamCapture<{type}>(paramCaptures[{index}])"""

template_gl_call_case = """case gl::EntryPoint::{entry_point}: 
    context->{context_call}({param_value_access});break;"""


def type_name_sep_index(param):
    space = param.rfind(" ")
    pointer = param.rfind("*")
    return max(space, pointer)


def just_the_type(param):
    if "*" in param:
        return param[:type_name_sep_index(param) + 1]
    return param[:type_name_sep_index(param)]


def just_the_name(param):
    return param[type_name_sep_index(param) + 1:]


def just_the_type_packed(param, entry):
    name = just_the_name(param)
    if entry.has_key(name):
        return entry[name]
    else:
        return just_the_type(param)


# Strip these suffixes from Context entry point names. NV is excluded (for now).
strip_suffixes = ["ANGLE", "EXT", "KHR", "OES", "CHROMIUM", "OVR"]


def strip_suffix(name):
    for suffix in strip_suffixes:
        if name.endswith(suffix):
            name = name[0:-len(suffix)]
    return name


def get_packed_enums(cmd_packed_gl_enums, cmd_name):
    # Always strip the suffix when querying packed enums.
    return cmd_packed_gl_enums.get(strip_suffix(cmd_name), {})


def get_command_name(command_node):
    return command_node.find('proto').find('name').text


def get_param_type_list(command_node, cmd_name, cmd_packed_gl_enums):
    param_type_list = list()
    for param_node in command_node.findall('param'):
        param_text = "".join(param_node.itertext())
        param_type = just_the_type_packed(param_text,
                                          get_packed_enums(cmd_packed_gl_enums, cmd_name))
        param_type_list.append(param_type)
    return param_type_list


def param_value_access(param_type_list):
    param_access_strs = list()
    for i, param_type in enumerate(param_type_list):
        param_template = template_param_access
        pointer_count = param_type.count('*')
        if pointer_count == 0:
            param_template = template_param_access
        elif pointer_count == 1:
            param_template = template_pointer_param_access
        elif pointer_count == 2:
            param_template = template_pointer_pointer_param_access
        else:
            assert False

        param_access_strs.append(param_template.format(index=i, type=param_type))
    return ",".join(param_access_strs)


def main(header_file_path, source_file_path):
    xml = registry_xml.RegistryXML('gl.xml', 'gl_angle_ext.xml')

    with open(registry_xml.script_relative('entry_point_packed_gl_enums.json')) as f:
        cmd_packed_gl_enums = json.loads(f.read())

    all_commands_names = set()

    # First run through the main GLES entry points.  Since ES2+ is the primary use
    # case, we go through those first and then add ES1-only APIs at the end.
    for major_version, minor_version in [[2, 0], [3, 0], [3, 1], [1, 0]]:
        # XXX: share code with generate_entry_points
        version = "{}_{}".format(major_version, minor_version)
        annotation = "GLES_{}".format(version)
        name_prefix = "GL_ES_VERSION_"

        is_gles1 = major_version == 1
        if is_gles1:
            name_prefix = "GL_VERSION_ES_CM_"

        comment = version.replace("_", ".")
        feature_name = "{}{}".format(name_prefix, version)

        xpath = ".//feature[@name='%s']//command" % feature_name
        all_commands_names.update([cmd.attrib['name'] for cmd in xml.root.findall(xpath)])

    entry_point_to_param_types_mapping = dict()
    for command_node in xml.root.findall('commands/command'):
        command_name = get_command_name(command_node)
        if command_name not in all_commands_names:
            continue

        entry_point_name = command_name[2:]  # strip the 'gl' prefix
        entry_point_to_param_types_mapping[entry_point_name] = get_param_type_list(
            command_node, command_name, cmd_packed_gl_enums)

    header_file_path = registry_xml.script_relative(header_file_path)
    header_content = template_frame_capture_replay_header.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
    )
    with open(header_file_path, 'w') as f:
        f.write(header_content)

    call_replay_cases = '\n'.join([
        template_gl_call_case.format(
            entry_point=entry_point_name,  # strip the 'gl' prefix
            param_value_access=param_value_access(cmd_param_types),
            context_call=entry_point_name[0].lower() + entry_point_name[1:],
        )
        for entry_point_name, cmd_param_types in sorted(entry_point_to_param_types_mapping.items())
    ])
    source_content = template_frame_capture_replay_soureces.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
        call_replay_cases=call_replay_cases,
    )
    source_output_path = registry_xml.script_relative(source_file_path)
    with open(source_file_path, 'w') as f:
        f.write(source_content)


if __name__ == '__main__':
    inputs = [
        'gl.xml',
        'gl_angle_ext.xml',
    ]

    frame_capture_replay_autogen_base_path = '../src/libANGLE/frame_capture_replay_autogen'
    outputs = [
        frame_capture_replay_autogen_base_path + '.h',
        frame_capture_replay_autogen_base_path + '.cpp',
    ]

    if len(sys.argv) > 1:
        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print ','.join(outputs)
    else:
        sys.exit(
            main(
                registry_xml.script_relative(outputs[0]),
                registry_xml.script_relative(outputs[1])))
