#!/usr/bin/python
#
# Copyright 2019 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# gen_frame_capture_replay.py:
#   Generates GLenum value to string mapping for ANGLE
#   NOTE: don't run this script directly. Run scripts/run_code_generation.py.

import sys
import os
from datetime import date

import registry_xml

template_frame_capture_replay_header = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// frame_capture_replay_autogen.h:
//   Replay GL calls being captured

#include "libANGLE/FrameCapture.h"

void CallCaptureReplay(gl::Context *context, const angle::CallCapture &call);

"""

template_frame_capture_replay_soureces = """// GENERATED FILE - DO NOT EDIT.
// Generated by {script_name} using data from {data_source_name}.
//
// Copyright {year} The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// frame_capture_replay_autogen.cpp:
//   Replay GL calls being captured

#include "frame_capture_replay_autogen.h"

#include "common/debug.h"

void CallCaptureReplay(gl::Context *context, const angle::CallCapture &call) {{
    switch (call.entryPoint) {{
        {call_replay_cases}
        default:
            UNREACHABLE();
    }}
}}

"""


def main(header_file_path, source_file_path):
    xml = registry_xml.RegistryXML('gl.xml', 'gl_angle_ext.xml')

    all_commands_names = set()
    for major_version, minor_version in [[2, 0], [3, 0], [3, 1], [1, 0]]:

        # XXX: share code with generate_entry_points
        version = "{}_{}".format(major_version, minor_version)
        annotation = "GLES_{}".format(version)
        name_prefix = "GL_ES_VERSION_"

        is_gles1 = major_version == 1
        if is_gles1:
            name_prefix = "GL_VERSION_ES_CM_"

        comment = version.replace("_", ".")
        feature_name = "{}{}".format(name_prefix, version)

        xpath = ".//feature[@name='%s']//command" % feature_name
        all_commands_names.update([cmd.attrib['name'] for cmd in xml.root.findall(xpath)])

    header_file_path = registry_xml.script_relative(header_file_path)
    header_content = template_frame_capture_replay_header.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
    )
    with open(header_file_path, 'w') as f:
        f.write(header_content)

    call_replay_cases = '\n'.join([
        "case gl::EntryPoint::{entry_point}: context->{context_call}(TODO(call.params)); return;"
        .format(
            entry_point=cmd_name[2:],  # strip the 'gl' prefix
            context_call=cmd_name[2].lower() +
            cmd_name[3:]  # strip the 'gl' prefix and lower first letter
        ) for cmd_name in all_commands_names
    ])
    source_content = template_frame_capture_replay_soureces.format(
        script_name=os.path.basename(sys.argv[0]),
        data_source_name="gl.xml and gl_angle_ext.xml",
        year=date.today().year,
        call_replay_cases=call_replay_cases,
    )
    source_output_path = registry_xml.script_relative(source_file_path)
    with open(source_file_path, 'w') as f:
        f.write(source_content)


if __name__ == '__main__':
    inputs = [
        'gl.xml',
        'gl_angle_ext.xml',
    ]

    frame_capture_replay_autogen_base_path = '../src/libANGLE/frame_capture_replay_autogen'
    outputs = [
        frame_capture_replay_autogen_base_path + '.h',
        frame_capture_replay_autogen_base_path + '.cpp',
    ]

    if len(sys.argv) > 1:
        if sys.argv[1] == 'inputs':
            print ','.join(inputs)
        elif sys.argv[1] == 'outputs':
            print ','.join(outputs)
    else:
        sys.exit(
            main(
                registry_xml.script_relative(outputs[0]),
                registry_xml.script_relative(outputs[1])))
