{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "45fe99cb_94ad68d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-08-30T15:51:40Z",
      "side": 1,
      "message": "I\u0027m not sure why this was \"WaitForScheduled\" vs just \"NoWait\".",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e6f55f7_e388966d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:23:02Z",
      "side": 1,
      "message": "lgtm\n\nThe only reason I can think of why this wouldn\u0027t work is IOSurface interactions - if for some reason Chrome or WebKit are relying on the command buffer reaching the GPU before handing an IOSurface to Core Animation. I\u0027d hope that the tests would cover this, but it might show up as flickering and the tests might not catch regressions. Anyway, let\u0027s proceed with this and test thorougly with Canary.\n",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8d7b5f1_2c7cb7fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:24:40Z",
      "side": 1,
      "message": "Also +ynovikov@ - did the gpu.fyi tryjobs test this ANGLE CL properly? I\u0027m not 100% sure what the current status is of running Chromium trybots against ANGLE CLs.\n",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9338081f_acc194a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2022-08-30T18:34:46Z",
      "side": 1,
      "message": "No, gpu_fyi_try_* bots can\u0027t test ANGLE CLs.\nWe have these trybots instead https://luci-milo.appspot.com/ui/p/chromium/g/tryserver.chromium.angle/builders\nhttps://luci-milo.appspot.com/p/chromium/builders/try/mac-angle-chromium-try should give a good coverage for this. Although, it doesn\u0027t run on M1.",
      "parentUuid": "b8d7b5f1_2c7cb7fd",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb7aba24_db2a5877",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:37:19Z",
      "side": 1,
      "message": "Thanks, sent to mac-angle-chromium-try.",
      "parentUuid": "9338081f_acc194a8",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eae68c95_8e7ec6f0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2022-08-30T18:39:07Z",
      "side": 1,
      "message": "It\u0027s on CQ, so no need to trigger it manually.",
      "parentUuid": "fb7aba24_db2a5877",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84ee721d_37b623a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002358
      },
      "writtenOn": "2022-08-30T21:49:35Z",
      "side": 1,
      "message": "-[MTLCommandBuffer waitUntilScheduled] has the same as glFlush with respect to IOSurfaces.\n\nAll work that has been waitUntilScheduled will be completed before an IOSurface is used by any subsequent commands.\n\nThose commands can be\n- sending the IOSurface to a CALayer for display\n- locking the IOSurface for CPU access (e.g, one copy canvas capture)\n\nSo this is likely to break those things. We\u0027d need to add a \"flush but for real\" command, and insert it in the appropriate places for this.",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07f4fc55_48f4bccc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-31T00:08:54Z",
      "side": 1,
      "message": "Thanks very much for your insight Chris. Roughly where in Chromium\u0027s code base would we need to change to \"flush but for real\"? We could specify a new ANGLE extension. Or, can you think of other ways we could heuristically bypass the current too-expensive flush primitive?",
      "parentUuid": "84ee721d_37b623a2",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9b24ccf2_cff751d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T01:44:37Z",
      "side": 1,
      "message": "I think Chromium\u0027s GL_COMMANDS_ISSUED_CHROMIUM queries could be appropriate places to insert [waitUntilScheduled]",
      "parentUuid": "07f4fc55_48f4bccc",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53f8ed8d_462876c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T02:11:23Z",
      "side": 1,
      "message": "GLImageBacking\u0027s GLTextureImageRepresentationBeginAccess/GLTextureImageRepresentationEndAccess could also be appropriate places to insert [waitUntilScheduled]\n\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/gl_image_backing.cc;drc\u003d5ffea9162c8890390f2565bf3db2bce0c31a3b40;l\u003d681\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/gl_image_backing.cc;drc\u003d5ffea9162c8890390f2565bf3db2bce0c31a3b40;l\u003d693",
      "parentUuid": "9b24ccf2_cff751d7",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dc5d98b_fd02de56",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1449558
      },
      "writtenOn": "2022-08-31T07:58:57Z",
      "side": 1,
      "message": "Is there a reason \"glFlush()\" cannot behave as \"flush but for real\"?\nI think in WebKit we flush for real.",
      "parentUuid": "53f8ed8d_462876c2",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b9f96d2_2d280ca0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T13:39:18Z",
      "side": 1,
      "message": "I think the main question is why Metal backend had to wait until the committed command buffer is scheduled during a glFlush() call. Is there any test case or Webkit\u0027s scenario that depends on this wait?\n\nPutting IOSurface\u0027s coherent accesses asides, afaik OpenGL doesn\u0027t have any expectations that glFlush() has to wait until the flushed commands are scheduled or not. The purpose of this function is just sending the queued up commands to the driver. And from this CL\u0027s discovery, removing the wait did improve the performance in some scenarios that uses a lot of \"glFlush\" such as Motionmark \"Leaves\" benchmark.",
      "parentUuid": "7dc5d98b_fd02de56",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96105d36_025ef574",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002358
      },
      "writtenOn": "2022-08-31T13:59:18Z",
      "side": 1,
      "message": "On macOS, glFlush does a lot more than the spec says that it should do. It is, in effect, a waitUntilScheduled.\n\n\u003e Roughly where in Chromium\u0027s code base would we need to change to \"flush but for real\"? We could specify a new ANGLE extension. \n\nThat\u0027s the scary thing. We\u0027ve always done more glFlushes than we need, and so we\u0027ve never needed to worry about making sure that we do the ones that we we need to do. That\u0027s a long winded way of saying \"I\u0027m not completely sure\". But I think we should fix this now.\n\n\u003e We could specify a new ANGLE extension.\n\nI think that\u0027s the way to go. We\u0027ve been doing excessive flushing for too long.\n\nFor ensuring correctness for compositing, I think we only need to add one call, and it should be before we make any calls to ScheduleOverlayPlanes.\n\nFor one copy canvas capture, we already do a wait (at least in this instance [0], we\u0027d want to double check the rest), so that might have us covered.\n\nThe one other thing to consider is multiple GPUs. I worked through an example of this in [1], and found that nothing short of waitUntilScheduled works to ensure cross-GPU synchronization of an IOSurface\u0027s contents. Maybe that can be implemented in the bowels of SharedImage(?).\n\n[0] https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/graphics/web_graphics_context_3d_video_frame_pool.cc;l\u003d181;drc\u003ddb6f1567b8caa6dacdd0d46b2a7ac60c5b5ddc82\n\n[1] https://github.com/ccameron-chromium/test-programs/blob/main/mtl-layer-share-drawable.mm",
      "parentUuid": "8b9f96d2_2d280ca0",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ebd6c98_b9977bb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-08-31T18:57:17Z",
      "side": 1,
      "message": "There are several places in the code related to IOSurfaces that do their own `waitUntiScheduled`.\n\nhttps://source.chromium.org/search?q\u003dwaitUntilScheduled\u0026sq\u003d\u0026ss\u003dchromium%2Fchromium%2Fsrc:third_party%2Fangle%2F\n\nAre you sure the one in ContextMTL::flush is needed? When I tried removing those other ones things broke but removing this one I saw nothing break. I get that could just be luck.\n\nDo you know of a test or webpage on a certain device I can run that will show the issue? Running with this change locally youtube and meet both seem to work. What else can I check?",
      "parentUuid": "96105d36_025ef574",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f16b7bb7_26d3b132",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1449558
      },
      "writtenOn": "2022-08-31T19:00:03Z",
      "side": 1,
      "message": "\u003e Is there any test case or Webkit\u0027s scenario that depends on this wait?\n\nAll rendering depends on this wait. The rendering is happening to IOSurface and then glFlushed.\nThen the rendering results is observed from the IOSurface, but without OpenGL.\n\nThis works with the native OpenGL driver, and I don\u0027t understand why would it not work in ANGLE implemented OpenGL driver.\n\nI think all EGL external surface access and other actions document the cases which \"cause flush\".\n\nIf I understand correctly, the purpose of those is to ensure that the external observability of the effects of the OpenGL rendering is deterministic.\nSo at least how I see them, these impose the semantics of glFlush relative to the primitives EGL on a particular platform offers.\n\nIn other words: if you bring in EGL primitives to modify external resources, you have to bring in the primitives to synchronise the resources. If we are talking about \"adding an extension to implement this primitive\", then would it not mean that all these 20 years of EGL that primitive was lacking? And since this does not sound plausible, it has to be interpreted as always being there, in form of glFlush.\n\n\u003e And from this CL\u0027s discovery, removing the wait did improve the performance in some scenarios that uses a lot of \"glFlush\" such as Motionmark \"Leaves\" benchmark.\n\nReplacing glFlush with no-op is obviously going to improve performance. This in itself does not provide a proof of anything. The root cause might be numerous things, such as Metal ANGLE not scheduling work to GPU as aggressively as OpenGL driver.",
      "parentUuid": "96105d36_025ef574",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ac6aece_6f672711",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-09-01T01:11:43Z",
      "side": 1,
      "message": "glFlush has never guaranteed these things AFAIK. Only glFinish (and or other sync primitives). 20 years of EGL says nothing about glFlush that I know of. Unless things have changed. It\u0027s certainly been a few years but last time I read the spec on various sychronizations, the relevant specs only said glFinish guarantees sync.\n\nFor example appendix D.3.1 of the OpenGL ES 3.0 spec says glFinish or glWaitSync are required to sychronize shared objects across contexts.\n\nThe EGL spec only mentions implicit flushes at a glance.",
      "parentUuid": "f16b7bb7_26d3b132",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22a31099_389fd78a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-09-01T01:36:45Z",
      "side": 1,
      "message": "FWIW, we also delay flush in the Vulkan backend, but we only do that when in the middle of a render pass (and defer it to when the render pass closes for other reasons).\n\nThis is mentioned in the GLES spec, in a footnote:\n\n\u003e Historically, use of Flush has had negative performance implications for some implementations, and subsequently it does not universally operate as described here. One exception to this is when  the default framebuffer is bound, and it is single-buffered; in this case, flush behaves as expected. Other references to the flush operation in the specification, such as that in section 4.1.2, will behave as expected. Waiting on a fence sync object with SYNC_FLUSH_COMMANDS_BIT is thus recommended as a way to perform a guaranteed flush.",
      "parentUuid": "9ac6aece_6f672711",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "102810f9_4717f238",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-09-01T02:07:47Z",
      "side": 1,
      "message": "\u003e glFlush has never guaranteed these things AFAIK. Only glFinish (and or other sync primitives)\n\nYeah, I agree glFlush was never mentioned to do any synchronization in the spec. Removing [waitUntilScheduled] is not the same as replacing glFlush with no-op. It still flushes the pending command buffer to commit it to the command queue. Only this time it won\u0027t wait until the command buffer is actually sent to the GPU.\n\nEven if you want IOSurface to see the prior GL commands, doing synchronization every time in glFlush is still a waste for other use cases that don\u0027t need it. And for IOSurface\u0027s coherent access, there are still sync primitives to be used such as EGLSync and GL_EXT_semaphore extension https://registry.khronos.org/OpenGL/extensions/EXT/EXT_external_objects.txt. The latter is specifically designed for external resources.\n\nOpenGL driver can make IOSurface see \"flush\"ed commands, however afaik, the driver knows a lot more information than ANGLE does. When \"IOSurfaceLock\" is called, it could just issue a \"waitUntilScheduled\" on flushed commands or use a sync primitive internally (fwiw, we only need to \"waitUntilScheduled\" on the last command buffer because the order of scheduling is guaranteed by Metal).\nANGLE cannot do the same because it doesn\u0027t know when IOSurface is locked, unless we could hook \"IOSurfaceLock\" function or related things.",
      "parentUuid": "9ac6aece_6f672711",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}