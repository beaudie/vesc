{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "45fe99cb_94ad68d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-08-30T15:51:40Z",
      "side": 1,
      "message": "I\u0027m not sure why this was \"WaitForScheduled\" vs just \"NoWait\".",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e6f55f7_e388966d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:23:02Z",
      "side": 1,
      "message": "lgtm\n\nThe only reason I can think of why this wouldn\u0027t work is IOSurface interactions - if for some reason Chrome or WebKit are relying on the command buffer reaching the GPU before handing an IOSurface to Core Animation. I\u0027d hope that the tests would cover this, but it might show up as flickering and the tests might not catch regressions. Anyway, let\u0027s proceed with this and test thorougly with Canary.\n",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8d7b5f1_2c7cb7fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:24:40Z",
      "side": 1,
      "message": "Also +ynovikov@ - did the gpu.fyi tryjobs test this ANGLE CL properly? I\u0027m not 100% sure what the current status is of running Chromium trybots against ANGLE CLs.\n",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9338081f_acc194a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2022-08-30T18:34:46Z",
      "side": 1,
      "message": "No, gpu_fyi_try_* bots can\u0027t test ANGLE CLs.\nWe have these trybots instead https://luci-milo.appspot.com/ui/p/chromium/g/tryserver.chromium.angle/builders\nhttps://luci-milo.appspot.com/p/chromium/builders/try/mac-angle-chromium-try should give a good coverage for this. Although, it doesn\u0027t run on M1.",
      "parentUuid": "b8d7b5f1_2c7cb7fd",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb7aba24_db2a5877",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-30T18:37:19Z",
      "side": 1,
      "message": "Thanks, sent to mac-angle-chromium-try.",
      "parentUuid": "9338081f_acc194a8",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eae68c95_8e7ec6f0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001921
      },
      "writtenOn": "2022-08-30T18:39:07Z",
      "side": 1,
      "message": "It\u0027s on CQ, so no need to trigger it manually.",
      "parentUuid": "fb7aba24_db2a5877",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84ee721d_37b623a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002358
      },
      "writtenOn": "2022-08-30T21:49:35Z",
      "side": 1,
      "message": "-[MTLCommandBuffer waitUntilScheduled] has the same as glFlush with respect to IOSurfaces.\n\nAll work that has been waitUntilScheduled will be completed before an IOSurface is used by any subsequent commands.\n\nThose commands can be\n- sending the IOSurface to a CALayer for display\n- locking the IOSurface for CPU access (e.g, one copy canvas capture)\n\nSo this is likely to break those things. We\u0027d need to add a \"flush but for real\" command, and insert it in the appropriate places for this.",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07f4fc55_48f4bccc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2022-08-31T00:08:54Z",
      "side": 1,
      "message": "Thanks very much for your insight Chris. Roughly where in Chromium\u0027s code base would we need to change to \"flush but for real\"? We could specify a new ANGLE extension. Or, can you think of other ways we could heuristically bypass the current too-expensive flush primitive?",
      "parentUuid": "84ee721d_37b623a2",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9b24ccf2_cff751d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T01:44:37Z",
      "side": 1,
      "message": "I think Chromium\u0027s GL_COMMANDS_ISSUED_CHROMIUM queries could be appropriate places to insert [waitUntilScheduled]",
      "parentUuid": "07f4fc55_48f4bccc",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53f8ed8d_462876c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T02:11:23Z",
      "side": 1,
      "message": "GLImageBacking\u0027s GLTextureImageRepresentationBeginAccess/GLTextureImageRepresentationEndAccess could also be appropriate places to insert [waitUntilScheduled]\n\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/gl_image_backing.cc;drc\u003d5ffea9162c8890390f2565bf3db2bce0c31a3b40;l\u003d681\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/gl_image_backing.cc;drc\u003d5ffea9162c8890390f2565bf3db2bce0c31a3b40;l\u003d693",
      "parentUuid": "9b24ccf2_cff751d7",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dc5d98b_fd02de56",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1449558
      },
      "writtenOn": "2022-08-31T07:58:57Z",
      "side": 1,
      "message": "Is there a reason \"glFlush()\" cannot behave as \"flush but for real\"?\nI think in WebKit we flush for real.",
      "parentUuid": "53f8ed8d_462876c2",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b9f96d2_2d280ca0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1543187
      },
      "writtenOn": "2022-08-31T13:39:18Z",
      "side": 1,
      "message": "I think the main question is why Metal backend had to wait until the committed command buffer is scheduled during a glFlush() call. Is there any test case or Webkit\u0027s scenario that depends on this wait?\n\nPutting IOSurface\u0027s coherent accesses asides, afaik OpenGL doesn\u0027t have any expectations that glFlush() has to wait until the flushed commands are scheduled or not. The purpose of this function is just sending the queued up commands to the driver. And from this CL\u0027s discovery, removing the wait did improve the performance in some scenarios that uses a lot of \"glFlush\" such as Motionmark \"Leaves\" benchmark.",
      "parentUuid": "7dc5d98b_fd02de56",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96105d36_025ef574",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002358
      },
      "writtenOn": "2022-08-31T13:59:18Z",
      "side": 1,
      "message": "On macOS, glFlush does a lot more than the spec says that it should do. It is, in effect, a waitUntilScheduled.\n\n\u003e Roughly where in Chromium\u0027s code base would we need to change to \"flush but for real\"? We could specify a new ANGLE extension. \n\nThat\u0027s the scary thing. We\u0027ve always done more glFlushes than we need, and so we\u0027ve never needed to worry about making sure that we do the ones that we we need to do. That\u0027s a long winded way of saying \"I\u0027m not completely sure\". But I think we should fix this now.\n\n\u003e We could specify a new ANGLE extension.\n\nI think that\u0027s the way to go. We\u0027ve been doing excessive flushing for too long.\n\nFor ensuring correctness for compositing, I think we only need to add one call, and it should be before we make any calls to ScheduleOverlayPlanes.\n\nFor one copy canvas capture, we already do a wait (at least in this instance [0], we\u0027d want to double check the rest), so that might have us covered.\n\nThe one other thing to consider is multiple GPUs. I worked through an example of this in [1], and found that nothing short of waitUntilScheduled works to ensure cross-GPU synchronization of an IOSurface\u0027s contents. Maybe that can be implemented in the bowels of SharedImage(?).\n\n[0] https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/graphics/web_graphics_context_3d_video_frame_pool.cc;l\u003d181;drc\u003ddb6f1567b8caa6dacdd0d46b2a7ac60c5b5ddc82\n\n[1] https://github.com/ccameron-chromium/test-programs/blob/main/mtl-layer-share-drawable.mm",
      "parentUuid": "8b9f96d2_2d280ca0",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ebd6c98_b9977bb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-08-31T18:57:17Z",
      "side": 1,
      "message": "There are several places in the code related to IOSurfaces that do their own `waitUntiScheduled`.\n\nhttps://source.chromium.org/search?q\u003dwaitUntilScheduled\u0026sq\u003d\u0026ss\u003dchromium%2Fchromium%2Fsrc:third_party%2Fangle%2F\n\nAre you sure the one in ContextMTL::flush is needed? When I tried removing those other ones things broke but removing this one I saw nothing break. I get that could just be luck.\n\nDo you know of a test or webpage on a certain device I can run that will show the issue? Running with this change locally youtube and meet both seem to work. What else can I check?",
      "parentUuid": "96105d36_025ef574",
      "revId": "58afdabc11fa7289aad5d7e3c87c16e303865701",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}