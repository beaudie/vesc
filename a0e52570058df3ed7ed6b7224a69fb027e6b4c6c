{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9fc6f2ee_aff9d499",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-14T02:00:19Z",
      "side": 1,
      "message": "LGTM",
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "919f81ce_b8eb2067",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-13T20:32:21Z",
      "side": 1,
      "message": "The real bug here is that CommandQueue::handleDeviceLost() should also take mQueueSubmitMutex to ensure no one is adding more work while we handle device lost. Caller has to ensure no one is adding or removing anything from the FixedQueue while calling clear. So I don\u0027t think the clear implementation itself has a bug here.",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fad00b7e_06525d20",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-13T20:49:11Z",
      "side": 1,
      "message": "Locking aside, the old code would still only iterate over half the items",
      "parentUuid": "919f81ce_b8eb2067",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef0b7c7a_c9e4ac05",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-13T21:08:05Z",
      "side": 1,
      "message": "I see, that makes sense. Yes, this change (or while(!empty()), my preference is !empty()) plus taking the mQueueSubmitMutex in handleDeviceLost is good.",
      "parentUuid": "fad00b7e_06525d20",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2160accc_ac1ae14f",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-14T12:30:16Z",
      "side": 1,
      "message": "\u003e I see, that makes sense. Yes, this change (or while(!empty()), my preference is !empty()) plus taking the mQueueSubmitMutex in handleDeviceLost is good.\n\nWhat is a point in `mQueueSubmitMutex`?\nLets assume we added a mutex lock and performing pop while not empty. Other thread at the same time trying to push, so blocking on the `mQueueSubmitMutex`. After `handleDeviceLost` unblock the mutex, all these thread will rush and add items into the `mInFlightCommands`. So at the end, no much difference - `mInFlightCommands` will not be empty. Maybe we need to reject new submissions once device is lost?\n\nOr I missing something?",
      "parentUuid": "ef0b7c7a_c9e4ac05",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fcb2c370_42733100",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-14T17:17:01Z",
      "side": 1,
      "message": "I think we should grab mQueueSubmitMutex, just in case there are other thread in the middle of calling vkQueueSubmit. That way we will wait for that call to finish and then clean up everything.\n\nBut lets leave that alone for now and just land this CL. I will fix that in my CL. (otherwise it might trigger merge conflict). I initially missed the bug in clear().",
      "parentUuid": "2160accc_ac1ae14f",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "675eb6ce_97f75182",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-02-14T17:18:06Z",
      "side": 1,
      "message": "BTW, thanks for catching the bug and fixing it!",
      "parentUuid": "fcb2c370_42733100",
      "range": {
        "startLine": 231,
        "startChar": 30,
        "endLine": 231,
        "endChar": 39
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ef43ae5_d682287c",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 234,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-13T20:33:05Z",
      "side": 1,
      "message": "How about `while (!empty()) pop();`?",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 234,
        "endChar": 5
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6dd5fed_682020ad",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 234,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-14T12:30:16Z",
      "side": 1,
      "message": "I was afraid of infinite loop if other thread keeps adding items. This is a outside problem, that should be solved by a mutex or other means. If solve \"pushing during clear\" problem - there is no difference. So I prefer avoid possible infinite loop and clear only items what was in the queue the moment it was called.",
      "parentUuid": "1ef43ae5_d682287c",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 234,
        "endChar": 5
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79b6ddd8_d0948fa8",
        "filename": "src/common/FixedQueue.h",
        "patchSetId": 1
      },
      "lineNbr": 234,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-02-14T17:07:12Z",
      "side": 1,
      "message": ":shrug: no real difference in safety IMO. If unsafe threaded access is done here, you could just as easily pop() non-existing items because another thread did a pop.",
      "parentUuid": "f6dd5fed_682020ad",
      "range": {
        "startLine": 229,
        "startChar": 0,
        "endLine": 234,
        "endChar": 5
      },
      "revId": "a0e52570058df3ed7ed6b7224a69fb027e6b4c6c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}