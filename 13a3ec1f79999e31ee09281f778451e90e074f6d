{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c98351b1_73d2c7d3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Please also note that need also protect: `mSyncPools` and `mSyncHandleAllocator` in case of `EGL_Terminate()`.\n\nAdditionally:\n- `mSyncMap` is accessed from: `EGL_LabelObjectKHR()` (in case of `ObjectType::Sync`). \n- `mSyncPools` and `mSyncHandleAllocator` are accessed from: `EGL_CreateSync()`, `EGL_DestroySync()`, `EGL_Terminate()`, `EGL_ReleaseThread()`, and `ThreadCleanupCallback()`.\n\nAbove means, that need to use `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK()` in the following functions: `EGL_LabelObjectKHR()`, `EGL_Terminate()` (already covered), `EGL_ReleaseThread()`, and `ThreadCleanupCallback()`.",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53e20606_ff8e4998",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "\u003e Please also note that need also protect: mSyncPools and mSyncHandleAllocator in case of EGL_Terminate()\n\nFor `mSyncPools`, `EGL_Terminate()` should not access it if there is any context that is still current on any thread:  `Display::Terminate()` returns early before calling `mSyncPools.clear()`: https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Display.cpp;l\u003d1247;drc\u003da0586d6e54d4738ebfae34dd5ae6391548196dbf. So I think if `mSyncPools` is still being used by any thread, it means there is still a current context on that thread, and `EGL_Terminate()` should return early before touching `mSyncPools`. But I agree that it is safe to protect `mSyncPools` in case the code changes in the future.\n\nFor `mSyncHandleAllocator`, would mind pointing me on where it is getting accessed in `EGL_Terminate()` code path?\n\n\u003e Above means, that need to use ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK() in the following functions: EGL_LabelObjectKHR(), EGL_Terminate() (already covered), EGL_ReleaseThread(), and ThreadCleanupCallback().\n\nThank you for pointing out the `EGL_LabelObjectKHR()`! For `EGL_ReleaseThread()`, and `ThreadCleanupCallBack()`, is it because they call `Display::makeCurrent()`, which can call to `Display::terminate()`?",
      "parentUuid": "c98351b1_73d2c7d3",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b19558c_b2c4f703",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "\u003e For `mSyncPools`, `EGL_Terminate()` should not access it if there is any context that is still current on any thread: `Display::Terminate()` returns early before calling `mSyncPools.clear()`: \n\nIn order to call `eglDestroySync()` context do not need to be current.\n\nSo we can create situation where no contexts are current, but  still have `EGLSync` objects. One thread will call `eglTerminate()`, while other will destroy`EGLSync` objects by calling `eglDestroySync()`:\n\n- Thread 1:\n```\nEGL_Terminate() -\u003e\n      Terminate() -\u003e\n          Display::terminate() -\u003e\n              mSyncMap\n              Display::destroyInvalidEglObjects() -\u003e\n                  Display::destroySyncImpl() -\u003e\n                      mSyncHandleAllocator\n                      mSyncPools\n              mSyncPools\n```\n\n- Thread 2:\n```\nEGL_DestroySync() -\u003e\n      DestroySync() -\u003e\n          Display::destroySync() -\u003e\n              mSyncMap (passing pointer)\n              Display::destroySyncImpl() -\u003e\n                  mSyncHandleAllocator\n                  mSyncPools\n                  mSyncMap\n```\n\nAnother scenario, is to call `eglCreateSync()` while display is terminating.\n\nBut now I think, that we also need to protect `Display::mInitialized`, because it is used in `ValidateDisplay()`. So need to also use `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK` for `eglInitialize()` so there is no race conditions if some thread calls EGL sync APIs (incorrectly), while other initializes the display.\n\nUnfortunately, access to members need to be protected even if API is used incorrectly (unlike in Vulkan).\n\n\u003e For `mSyncHandleAllocator`, would mind pointing me on where it is getting accessed in `EGL_Terminate()` code path?\n\nFrom `Display::destroyInvalidEglObjects()`. See the below answer.\n\n\u003e For `EGL_ReleaseThread()`, and `ThreadCleanupCallBack()`, is it because they call `Display::makeCurrent()`, which can call to `Display::terminate()`?\n\nNot only. There are 2 code paths (that I found):\n\n1. Path calling `Display::releaseThread()`:\n```\nEGL_ReleaseThread() | ThreadCleanupCallback() -\u003e \n      ReleaseThread() -\u003e \n          Display::releaseThread() -\u003e\n              Display::destroyInvalidEglObjects()\n```\n\n2. Path calling `Display::makeCurrent()`:\n```\nEGL_ReleaseThread() | ThreadCleanupCallback() -\u003e\n      ReleaseThread() -\u003e\n          Display::makeCurrent() -\u003e\n              Display::terminate() -\u003e\n                  mSyncMap\n                  Display::destroyInvalidEglObjects()\n                  mSyncPools\n```\n\nBoth access `mSyncPools` and `mSyncHandleAllocator` from `Display::destroyInvalidEglObjects()` -\u003e `Display::destroySyncImpl()`.",
      "parentUuid": "53e20606_ff8e4998",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f16e8ae_4360c3e8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "Thank you so much for the detailed explanations. I didn\u0027t notice it is allowed to call `eglCreateSync()` without a current context. I have updated the CL description. And I have added the `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK` to the `EGL_Initialize()`.",
      "parentUuid": "7b19558c_b2c4f703",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30992e66_f846f53f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T13:27:21Z",
      "side": 1,
      "message": "My pleasure.",
      "parentUuid": "6f16e8ae_4360c3e8",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31352038_2e57b46a",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Please consider passing `std::unique_lock\u003cangle::SimpleMutex\u003e \u0026\u0026contextsLock` into the `releaseContextImpl()` along with `contexts`, like so:\n```\nreleaseContextImpl(context, \u0026mState.contextMap,\n                   std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex))\n```\nIn case of `mInvalidContextMap` just call:\n```\nreleaseContextImpl(context, \u0026mInvalidContextMap, {})\n```",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "22ffc8ed_31ed1f86",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "31352038_2e57b46a",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79cb8f52_4aa6a0e3",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Sorry, but I expected that you keep the local `lock` object. And better to name parameter `contextsLock`, so it is clear what lock is protecting. In the current code the entire function is protected by the mutex and `, std::move(lock)` does nothing.\n\nSuggest:\n```\nError Display::releaseContext(gl::Context *context, Thread *thread)\n{\n    return releaseContextImpl(context, \u0026mState.contextMap,\n               std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex));\n}\n\nError Display::releaseContextImpl(gl::Context *context,\n    ContextMap *contexts, std::unique_lock\u003cangle::SimpleMutex\u003e \u0026\u0026contextsLock)\n{\n    // ...\n    {\n        std::unique_lock\u003cangle::SimpleMutex\u003e lock \u003d std::move(contextsLock);\n        // ...\n    }\n    // ...\n}\n```\n\nRegarding creating local `lock` object and then `std::move()` to the `releaseContextImpl()`, I think it is unnecessary. IMO, passing temporary object is a bit cleaner.",
      "parentUuid": "22ffc8ed_31ed1f86",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b35389d1_86ef655e",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "When calling below function:\n\n```\nreturn releaseContextImpl(context, \u0026mState.contextMap, std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex));\n```\n\nMy understanding is the `std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex)` is constructed before calling the function. This means before entering the function `releaseContextImpl()`, the `mState.ContextMapMutex` is locked. Is that not the case?",
      "parentUuid": "79cb8f52_4aa6a0e3",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb01215e_49de4965",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T13:27:21Z",
      "side": 1,
      "message": "\u003e Is that not the case?\n\nYes, your are right, thank you.\n\nSorry, I did not think of this. I wanted to pass a mutex pointer, but since `mInvalidContextMap` does not require locking, we would have `nullptr`, that I avoided by passing the lock, but created a problem, when mutex is locked a little earlier, than needed.\n\nHowever in this particular method, `contexts` is used almost right away, so having a lock early is not a big problem. Lock will still be unlocked, when done with `contexts` - rest of the function will be without the lock.\n\nIn patchset 17, lock was held for the entire method, for example.\n\nRegardless of the above, now I think that it is better to pass the mutex pointer and handle `nullptr` case inside the function. Like this:\n```\nError Display::releaseContextImpl(gl::Context *context, ContextMap *contexts,\n                                  angle::SimpleMutex *contextsMutex)\n{\n    // ...\n    {\n        auto lock \u003d (contextsMutex !\u003d nullptr)\n            ? std::unique_lock\u003cangle::SimpleMutex\u003e(*contextsMutex)\n            : std::unique_lock\u003cangle::SimpleMutex\u003e();\n        ASSERT(contexts-\u003efind(context-\u003eid().value) !\u003d contexts-\u003eend());\n        contexts-\u003eerase(context-\u003eid().value);\n    }\n    // ...\n}\n```\n\nI\u0027m sorry for the confusion...\n\n---\n\nRegarding naming parameter `contextMapLock`. It is still better to call it `contextsLock` (just example, now need to use `contextsMutex`), because it will match `contexts` parameter name. When you call `releaseContextImpl(context, \u0026mInvalidContextMap, {}` you pass empty lock, because in that case you need a lock for the `mInvalidContextMap`, but since it is not requiring lock (yet?) - using empty lock. The `releaseContextImpl()` is universal, and should not be tied to the `State::contextMap` or `State::contextMapMutex`.",
      "parentUuid": "b35389d1_86ef655e",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be4afb2d_8eedf2fd",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-11-01T14:07:14Z",
      "side": 1,
      "message": "My suggestion would be to split `releaseContextImpl` into two parts: one that requires locking (accessing `contexts` and returning `context` that it erased) and one that doesn\u0027t (further calls on `context`). This way we should be able to simplify locking down to the regular local scope locks. The simpler we can keep multi-threading code the less confusion and hence cost it will cause in future.",
      "parentUuid": "eb01215e_49de4965",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d633a0d_a95928b4",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T15:38:05Z",
      "side": 1,
      "message": "If I understand the above suggestion correctly, then this might be one way to do this:\n\n```\nError Display::releaseContext(gl::Context *context, Thread *thread)\n{\n    return releaseContextImpl(eraseContextImpl(\n        context, \u0026mState.contextMap,\n        std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex)));\n}\n\nstd::unique_ptr\u003cgl::Context\u003e eraseContextImpl(\n    gl::Context *context,\n    ContextMap *contexts,\n    std::unique_lock\u003cangle::SimpleMutex\u003e contextsLock)\n{\n    ASSERT(!context-\u003eisReferenced());\n\n    // Use scoped_ptr to make sure the context is always freed.\n    std::unique_ptr\u003cgl::Context\u003e unique_context(context);\n    ASSERT(contexts-\u003efind(context-\u003eid().value) !\u003d contexts-\u003eend());\n    contexts-\u003eerase(context-\u003eid().value);\n\n    return unique_context;\n}\n\nError Display::releaseContextImpl(std::unique_ptr\u003cgl::Context\u003e context)\n{\n    ASSERT(context);\n\n    // ...\n```",
      "parentUuid": "be4afb2d_8eedf2fd",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4b6f8e7_49325d85",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-11-01T15:50:11Z",
      "side": 1,
      "message": "Unless I\u0027m missing something, we shouldn\u0027t need to pass the lock to `eraseContextImpl`, just lock as usual:\n\n```\nstd::unique_ptr\u003cgl::Context\u003e context;\n{\n   std::unique_lock\u003cangle::SimpleMutex\u003e lock(mState.contextMapMutex);\n   context \u003d eraseContextImpl(...);\n}\nreleaseContextImpl(context);\n\n```\n\nThe other caller that doesn\u0027t need `contextMapMutex` can just call `releaseContextImpl(eraseContextImpl())`",
      "parentUuid": "8d633a0d_a95928b4",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "486468aa_9691daac",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T16:09:35Z",
      "side": 1,
      "message": "\u003e Unless I\u0027m missing something, we shouldn\u0027t need to pass the lock to `eraseContextImpl`, just lock as usual\n\nI see 2 sources of errors in the above code:\n1. Added after splitting: caller may call `eraseContextImpl()` but not the `releaseContextImpl()`\n2. Added after using external lock: caller may call `eraseContextImpl(context, \u0026mState.contextMap)` without the external lock.\n\nWith single function one source of error: is forget to pass mutex or lock. But this is harder to miss, than requiring to have external lock.\n\nRegardless, I think we need to rename `eraseContextImpl()` into `eraseContextImplLocked()` or just `eraseContextLocked()`. But... It must be locked only in case of using `\u0026mState.contextMap`.\n\nSo it is looks like we can\u0027t add `Locked` suffix here...\n\nWhat is the difference of locking local scope to call `eraseContextImpl()` vs the same thing (but using mutex from passed argument) to lock `contexts-\u003eerase(context-\u003eid().value);`?\nMy understanding of split is to have a function that is entirely locked. Passing lock inside will almost guarantee that (removes source of error).\nI\u0027m confused...\n\nOne nit: can use `std::lock_guard\u003c\u003e` in the above case.",
      "parentUuid": "f4b6f8e7_49325d85",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49487f41_f0f008ec",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-11-01T16:32:58Z",
      "side": 1,
      "message": "Passing locks around is more difficult to follow than having a local scope guard that is very common in the codebase and unambiguous.\n\nPassing a pointer to the mutex which can sometimes be null makes it harder to understand that function in isolation (because now we have to know all the callers).\n\nTechnically we _could_ force the caller to remember about locking by adding synthetic lock args all over the place, but that would be a LOT of noise and limited benefit as many other multi-threaded mistakes can still be made. Doing it in only one place but not in the rest of the codebase results in inconsistency, which increases the overall complexity. Hence my preference is to stick to the basic, commonly used patterns, despite their limitations, unless we are motivated enough to develop an improved pattern and refactor the entire codebase to use it.",
      "parentUuid": "486468aa_9691daac",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8dbbc1ac_cb999801",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T17:01:23Z",
      "side": 1,
      "message": "Thank you for you time and attempts to answer my questions.\n\n\u003e Passing locks around is more difficult to follow than having a local scope guard that is very common in the codebase and unambiguous.\n\nI see. I will remember this.\n\n\u003e Passing a pointer to the mutex which can sometimes be null makes it harder to understand that function in isolation (because now we have to know all the callers).\n\nThis I do not follow.\n\nWhen reading `eraseContextImpl(ContextMap *contexts, Mutex *contextsMutex)` all I see is that `contexts` requires protection by the corresponding mutex somewhere in the function. One question remain if it may be null. This may be added in the comments, that null can be passed if `contexts` does not require protection.\n\n\u003e Technically we could force the caller to remember about locking by adding synthetic lock args all over the place, but that would be a LOT of noise and limited benefit as many other multi-threaded mistakes can still be made. Doing it in only one place but not in the rest of the codebase results in inconsistency, which increases the overall complexity. \n\nUnderstand and agree.\n\n\u003e Hence my preference is to stick to the basic, commonly used patterns, despite their limitations, unless we are motivated enough to develop an improved pattern and refactor the entire codebase to use it.\n\nI understand desire sticking to the pattern, but pattern is not a silver bullet.\nSometimes trying to stick to the pattern makes the original logic more convoluted and therefore more error prone (one example is splitting startThreadLocked in my CLs, especially for the delegate classes).\n\nI agree that trying to enforce patterns is simple, but afraid that even if follow patterns we are not eliminating possibility of bugs, unfortunately. In other words, if you see code that follows all the patterns, you do not get a false sense of a robust and safe code just from this.\n\nAnyway, I will try to suggest/write code that tries to stick to basics/patterns as much as possible, unless it does not make the original code a lot more convoluted.",
      "parentUuid": "49487f41_f0f008ec",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c07a14f_fc91ce50",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2024-11-01T18:56:40Z",
      "side": 1,
      "message": "Thank you Igor\n\n\u003e When reading eraseContextImpl(ContextMap *contexts, Mutex *contextsMutex) all I see is that contexts requires protection by the corresponding mutex somewhere in the function. One question remain if it may be null.\n\nSo if I imagine seeing this function the first time, without having the additional context such as this CL:\n* first I would be confused why the mutex is being passed as an argument (have a look at `git grep \u0027Mutex \\*\u0027`, this is an uncommon pattern and generally used for completely different use cases)\n* when I read the corresponding bit of code I would see the nullptr check and now would be wondering in which cases it is nullptr, so I would have to look at the callers to actually understand what this function does\n* note that if I\u0027m looking at this code in future I likely need to fully understand what is going on because I\u0027m probably chasing a multi-threading bug and those tend to require a lot of elimination of unknowns\n\nThe refactored version with the code requiring locking being its own section (or function in this case) makes it easier: I can now understand the function in isolation, and the function itself doesn\u0027t have anything about locks - meaning I can entirely ignore the implementation if I\u0027m looking into a deadlock, for example.\n\n\u003e This may be added in the comments, that null can be passed if contexts does not require protection.\n\nIt might be a personal preference but I\u0027m not a big believer in relying on people reading comments, especially as the distance between the comment and the changed code increases (note how during a code review \"remote\" comments wouldn\u0027t be visible and hence the reviewer is likely to be unaware of their existence). The only kind of comments that I semi-trust are those that are right next to the problematic spot. So for instance in this case, if we\u0027re adding a nullptr check in the middle of a function that\u0027s where I would add the comment explaining when the mutex can actually be nullptr. That both reduces the likelihood of future breakage and helps anyone reading the code like I described above - but again, in this case the separation between locked and unlocked code seems clear enough that having them in two separate blocks seems like the most logical option.\n\n\u003e Sometimes trying to stick to the pattern makes the original logic more convoluted and therefore more error prone (one example is splitting startThreadLocked in my CLs, especially for the delegate classes)\n\nI totally agree that there are cases like that, but in this specific case I think the separation is quite clean and in my opinion simplifies the code. It is a case-by-case scenario otherwise, yeah. Your CL is a more complex scenario with multiple implementations intertwined which inherently increases the overall complexity; I agree we can\u0027t blindly apply those rules of thumb everywhere!",
      "parentUuid": "8dbbc1ac_cb999801",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "674839d4_2a062473",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T19:54:30Z",
      "side": 1,
      "message": "I appreciate a very detailed explanation.\n\nI hope I understand you.\n\nI agree that passing mutex pointer into a big function where only small part requires locking makes debugging harder, since you will need to look inside that big function each time. This is similar thing, as passing pointer to `rx::Renderer` when all you need is `VkDevice` (or it is used in a single part, that can be split into multiple functions). Or passing non const pointer/reference, when const reference is enough. It is about limiting scope for debugging.\n\n\n\u003e but in this specific case I think the separation is quite clean and in my opinion simplifies the code. \n\nNow I agree.",
      "parentUuid": "6c07a14f_fc91ce50",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9bccce9_b83d1dbe",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-11-01T20:04:29Z",
      "side": 1,
      "message": "Hi! This conversation may be a little spiraling out of control 🤓\n\nA small disagreement I\u0027m sure, maybe let\u0027s move on with our lives 😊 The code as it is... it\u0027s probably just fine. The split has its merits, the existing encapsulation too. How about we let Yuxin land her optimization change and if anyone feels strongly about the design of the code, we could follow up with another change and see how that looks like?",
      "parentUuid": "6c07a14f_fc91ce50",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ae13593_5de34755",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: clang format glitch.\n\nTry this: replace `\";\"` with `\"; \"` or `\"\\n\"` with `\" \\n\"`, save and run `git cl format` again.",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26543b24_6905ee07",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Can you help checking if the format issue is fixed in latest patch? Thank you.",
      "parentUuid": "0ae13593_5de34755",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a7fa691_5a849f7d",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Everything seems fine. Thanks.",
      "parentUuid": "26543b24_6905ee07",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3954497d_ac95fb30",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 146,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Consider passing as pointer to match general ANGLE code style. This way at the call site it will be clear that it is out/in-out parameter.",
      "range": {
        "startLine": 146,
        "startChar": 76,
        "endLine": 146,
        "endChar": 77
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f58813f6_56c96ad3",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 146,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3954497d_ac95fb30",
      "range": {
        "startLine": 146,
        "startChar": 76,
        "endLine": 146,
        "endChar": 77
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48bfc411_03126865",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 235,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: I\u0027m not sure if compiler will remove this assignment, but IMO no need to reset pointer in a performance critical code.",
      "range": {
        "startLine": 235,
        "startChar": 4,
        "endLine": 235,
        "endChar": 21
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa92d58e_6668d82c",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 235,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "48bfc411_03126865",
      "range": {
        "startLine": 235,
        "startChar": 4,
        "endLine": 235,
        "endChar": 21
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e69225a_ed344876",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 238,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Duplicate code. Please move it after the `#endif`.",
      "range": {
        "startLine": 237,
        "startChar": 0,
        "endLine": 238,
        "endChar": 68
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6dc35ba1_83293ccf",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 238,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9e69225a_ed344876",
      "range": {
        "startLine": 237,
        "startChar": 0,
        "endLine": 238,
        "endChar": 68
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2d405a8_3b32122a",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 279,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Please use `*` similar to `AllocateGlobalMutexImpl()`.",
      "range": {
        "startLine": 279,
        "startChar": 64,
        "endLine": 279,
        "endChar": 65
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03a890e3_cd201265",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 279,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d2d405a8_3b32122a",
      "range": {
        "startLine": 279,
        "startChar": 64,
        "endLine": 279,
        "endChar": 65
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b53abe0c_56b13cc8",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Consider moving `ScopedGlobalMutexLock` template into the `priv` namespace.",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d09cf05f_ff4fa9e1",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T01:03:51Z",
      "side": 1,
      "message": "I ended up having to move code in anonymous namespace https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/GlobalMutex.cpp;l\u003d114;drc\u003d25ce3dfec69bccb212dba1f0a2510b38952377a9 in `egl::priv` namespace, too. Is there any issue with this move?",
      "parentUuid": "b53abe0c_56b13cc8",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af055dc9_1164ab10",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Sorry for misunderstanding. My intention was to only hide `ScopedGlobalMutexLock\u003c\u003e` template from public use. Moving also `ScopedGlobalEGLMutexLock` and `ScopedGlobalEGLSyncObjectMutexLock` into `egl::priv` contradicts my intention.\n\n\u003e in `egl::priv` namespace, too. Is there any issue with this move?\n\nThis way functions from anonymous namespace can be called from other files. I think it is still better to keep the anonymous namespace - so just extend the `priv` namespace to include the anonymous namespace and the `ScopedGlobalMutexLock\u003c\u003e` implementation.\n\nAlso please check for unnecessary `priv::` usage after extending the `priv` namespace. While you removed some, there are plenty left.\n\nOur you can just add another `priv` namespace scope just for the `ScopedGlobalMutexLock\u003c\u003e` to reduce the code diff. It is up to you.",
      "parentUuid": "d09cf05f_ff4fa9e1",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17919c40_d913ce92",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "\u003e This way functions from anonymous namespace can be called from other files.\n\nThat\u0027s a very good point.\n\n\u003e Also please check for unnecessary priv:: usage after extending the priv namespace. While you removed some, there are plenty left.\n\nThank you very much for catching them.",
      "parentUuid": "af055dc9_1164ab10",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}