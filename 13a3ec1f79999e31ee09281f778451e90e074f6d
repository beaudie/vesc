{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c98351b1_73d2c7d3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Please also note that need also protect: `mSyncPools` and `mSyncHandleAllocator` in case of `EGL_Terminate()`.\n\nAdditionally:\n- `mSyncMap` is accessed from: `EGL_LabelObjectKHR()` (in case of `ObjectType::Sync`). \n- `mSyncPools` and `mSyncHandleAllocator` are accessed from: `EGL_CreateSync()`, `EGL_DestroySync()`, `EGL_Terminate()`, `EGL_ReleaseThread()`, and `ThreadCleanupCallback()`.\n\nAbove means, that need to use `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK()` in the following functions: `EGL_LabelObjectKHR()`, `EGL_Terminate()` (already covered), `EGL_ReleaseThread()`, and `ThreadCleanupCallback()`.",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53e20606_ff8e4998",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "\u003e Please also note that need also protect: mSyncPools and mSyncHandleAllocator in case of EGL_Terminate()\n\nFor `mSyncPools`, `EGL_Terminate()` should not access it if there is any context that is still current on any thread:  `Display::Terminate()` returns early before calling `mSyncPools.clear()`: https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/Display.cpp;l\u003d1247;drc\u003da0586d6e54d4738ebfae34dd5ae6391548196dbf. So I think if `mSyncPools` is still being used by any thread, it means there is still a current context on that thread, and `EGL_Terminate()` should return early before touching `mSyncPools`. But I agree that it is safe to protect `mSyncPools` in case the code changes in the future.\n\nFor `mSyncHandleAllocator`, would mind pointing me on where it is getting accessed in `EGL_Terminate()` code path?\n\n\u003e Above means, that need to use ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK() in the following functions: EGL_LabelObjectKHR(), EGL_Terminate() (already covered), EGL_ReleaseThread(), and ThreadCleanupCallback().\n\nThank you for pointing out the `EGL_LabelObjectKHR()`! For `EGL_ReleaseThread()`, and `ThreadCleanupCallBack()`, is it because they call `Display::makeCurrent()`, which can call to `Display::terminate()`?",
      "parentUuid": "c98351b1_73d2c7d3",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b19558c_b2c4f703",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "\u003e For `mSyncPools`, `EGL_Terminate()` should not access it if there is any context that is still current on any thread: `Display::Terminate()` returns early before calling `mSyncPools.clear()`: \n\nIn order to call `eglDestroySync()` context do not need to be current.\n\nSo we can create situation where no contexts are current, but  still have `EGLSync` objects. One thread will call `eglTerminate()`, while other will destroy`EGLSync` objects by calling `eglDestroySync()`:\n\n- Thread 1:\n```\nEGL_Terminate() -\u003e\n      Terminate() -\u003e\n          Display::terminate() -\u003e\n              mSyncMap\n              Display::destroyInvalidEglObjects() -\u003e\n                  Display::destroySyncImpl() -\u003e\n                      mSyncHandleAllocator\n                      mSyncPools\n              mSyncPools\n```\n\n- Thread 2:\n```\nEGL_DestroySync() -\u003e\n      DestroySync() -\u003e\n          Display::destroySync() -\u003e\n              mSyncMap (passing pointer)\n              Display::destroySyncImpl() -\u003e\n                  mSyncHandleAllocator\n                  mSyncPools\n                  mSyncMap\n```\n\nAnother scenario, is to call `eglCreateSync()` while display is terminating.\n\nBut now I think, that we also need to protect `Display::mInitialized`, because it is used in `ValidateDisplay()`. So need to also use `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK` for `eglInitialize()` so there is no race conditions if some thread calls EGL sync APIs (incorrectly), while other initializes the display.\n\nUnfortunately, access to members need to be protected even if API is used incorrectly (unlike in Vulkan).\n\n\u003e For `mSyncHandleAllocator`, would mind pointing me on where it is getting accessed in `EGL_Terminate()` code path?\n\nFrom `Display::destroyInvalidEglObjects()`. See the below answer.\n\n\u003e For `EGL_ReleaseThread()`, and `ThreadCleanupCallBack()`, is it because they call `Display::makeCurrent()`, which can call to `Display::terminate()`?\n\nNot only. There are 2 code paths (that I found):\n\n1. Path calling `Display::releaseThread()`:\n```\nEGL_ReleaseThread() | ThreadCleanupCallback() -\u003e \n      ReleaseThread() -\u003e \n          Display::releaseThread() -\u003e\n              Display::destroyInvalidEglObjects()\n```\n\n2. Path calling `Display::makeCurrent()`:\n```\nEGL_ReleaseThread() | ThreadCleanupCallback() -\u003e\n      ReleaseThread() -\u003e\n          Display::makeCurrent() -\u003e\n              Display::terminate() -\u003e\n                  mSyncMap\n                  Display::destroyInvalidEglObjects()\n                  mSyncPools\n```\n\nBoth access `mSyncPools` and `mSyncHandleAllocator` from `Display::destroyInvalidEglObjects()` -\u003e `Display::destroySyncImpl()`.",
      "parentUuid": "53e20606_ff8e4998",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f16e8ae_4360c3e8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "Thank you so much for the detailed explanations. I didn\u0027t notice it is allowed to call `eglCreateSync()` without a current context. I have updated the CL description. And I have added the `ANGLE_SCOPED_GLOBAL_EGL_AND_EGL_SYNC_LOCK` to the `EGL_Initialize()`.",
      "parentUuid": "7b19558c_b2c4f703",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30992e66_f846f53f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 16
      },
      "lineNbr": 26,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T13:27:21Z",
      "side": 1,
      "message": "My pleasure.",
      "parentUuid": "6f16e8ae_4360c3e8",
      "range": {
        "startLine": 26,
        "startChar": 50,
        "endLine": 26,
        "endChar": 58
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31352038_2e57b46a",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Please consider passing `std::unique_lock\u003cangle::SimpleMutex\u003e \u0026\u0026contextsLock` into the `releaseContextImpl()` along with `contexts`, like so:\n```\nreleaseContextImpl(context, \u0026mState.contextMap,\n                   std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex))\n```\nIn case of `mInvalidContextMap` just call:\n```\nreleaseContextImpl(context, \u0026mInvalidContextMap, {})\n```",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "22ffc8ed_31ed1f86",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "31352038_2e57b46a",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79cb8f52_4aa6a0e3",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Sorry, but I expected that you keep the local `lock` object. And better to name parameter `contextsLock`, so it is clear what lock is protecting. In the current code the entire function is protected by the mutex and `, std::move(lock)` does nothing.\n\nSuggest:\n```\nError Display::releaseContext(gl::Context *context, Thread *thread)\n{\n    return releaseContextImpl(context, \u0026mState.contextMap,\n               std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex));\n}\n\nError Display::releaseContextImpl(gl::Context *context,\n    ContextMap *contexts, std::unique_lock\u003cangle::SimpleMutex\u003e \u0026\u0026contextsLock)\n{\n    // ...\n    {\n        std::unique_lock\u003cangle::SimpleMutex\u003e lock \u003d std::move(contextsLock);\n        // ...\n    }\n    // ...\n}\n```\n\nRegarding creating local `lock` object and then `std::move()` to the `releaseContextImpl()`, I think it is unnecessary. IMO, passing temporary object is a bit cleaner.",
      "parentUuid": "22ffc8ed_31ed1f86",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b35389d1_86ef655e",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "When calling below function:\n\n```\nreturn releaseContextImpl(context, \u0026mState.contextMap, std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex));\n```\n\nMy understanding is the `std::unique_lock\u003cangle::SimpleMutex\u003e(mState.contextMapMutex)` is constructed before calling the function. This means before entering the function `releaseContextImpl()`, the `mState.ContextMapMutex` is locked. Is that not the case?",
      "parentUuid": "79cb8f52_4aa6a0e3",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb01215e_49de4965",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 16
      },
      "lineNbr": 1869,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-11-01T13:27:21Z",
      "side": 1,
      "message": "\u003e Is that not the case?\n\nYes, your are right, thank you.\n\nSorry, I did not think of this. I wanted to pass a mutex pointer, but since `mInvalidContextMap` does not require locking, we would have `nullptr`, that I avoided by passing the lock, but created a problem, when mutex is locked a little earlier, than needed.\n\nHowever in this particular method, `contexts` is used almost right away, so having a lock early is not a big problem. Lock will still be unlocked, when done with `contexts` - rest of the function will be without the lock.\n\nIn patchset 17, lock was held for the entire method, for example.\n\nRegardless of the above, now I think that it is better to pass the mutex pointer and handle `nullptr` case inside the function. Like this:\n```\nError Display::releaseContextImpl(gl::Context *context, ContextMap *contexts,\n                                  angle::SimpleMutex *contextsMutex)\n{\n    // ...\n    {\n        auto lock \u003d (contextsMutex !\u003d nullptr)\n            ? std::unique_lock\u003cangle::SimpleMutex\u003e(*contextsMutex)\n            : std::unique_lock\u003cangle::SimpleMutex\u003e();\n        ASSERT(contexts-\u003efind(context-\u003eid().value) !\u003d contexts-\u003eend());\n        contexts-\u003eerase(context-\u003eid().value);\n    }\n    // ...\n}\n```\n\nI\u0027m sorry for the confusion...\n\n---\n\nRegarding naming parameter `contextMapLock`. It is still better to call it `contextsLock` (just example, now need to use `contextsMutex`), because it will match `contexts` parameter name. When you call `releaseContextImpl(context, \u0026mInvalidContextMap, {}` you pass empty lock, because in that case you need a lock for the `mInvalidContextMap`, but since it is not requiring lock (yet?) - using empty lock. The `releaseContextImpl()` is universal, and should not be tied to the `State::contextMap` or `State::contextMapMutex`.",
      "parentUuid": "b35389d1_86ef655e",
      "range": {
        "startLine": 1869,
        "startChar": 8,
        "endLine": 1869,
        "endChar": 73
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ae13593_5de34755",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: clang format glitch.\n\nTry this: replace `\";\"` with `\"; \"` or `\"\\n\"` with `\" \\n\"`, save and run `git cl format` again.",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26543b24_6905ee07",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Can you help checking if the format issue is fixed in latest patch? Thank you.",
      "parentUuid": "0ae13593_5de34755",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a7fa691_5a849f7d",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 123,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Everything seems fine. Thanks.",
      "parentUuid": "26543b24_6905ee07",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 123,
        "endChar": 47
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3954497d_ac95fb30",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 146,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Consider passing as pointer to match general ANGLE code style. This way at the call site it will be clear that it is out/in-out parameter.",
      "range": {
        "startLine": 146,
        "startChar": 76,
        "endLine": 146,
        "endChar": 77
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f58813f6_56c96ad3",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 146,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3954497d_ac95fb30",
      "range": {
        "startLine": 146,
        "startChar": 76,
        "endLine": 146,
        "endChar": 77
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48bfc411_03126865",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 235,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: I\u0027m not sure if compiler will remove this assignment, but IMO no need to reset pointer in a performance critical code.",
      "range": {
        "startLine": 235,
        "startChar": 4,
        "endLine": 235,
        "endChar": 21
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa92d58e_6668d82c",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 235,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "48bfc411_03126865",
      "range": {
        "startLine": 235,
        "startChar": 4,
        "endLine": 235,
        "endChar": 21
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e69225a_ed344876",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 238,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "Duplicate code. Please move it after the `#endif`.",
      "range": {
        "startLine": 237,
        "startChar": 0,
        "endLine": 238,
        "endChar": 68
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6dc35ba1_83293ccf",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 238,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9e69225a_ed344876",
      "range": {
        "startLine": 237,
        "startChar": 0,
        "endLine": 238,
        "endChar": 68
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2d405a8_3b32122a",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 279,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Please use `*` similar to `AllocateGlobalMutexImpl()`.",
      "range": {
        "startLine": 279,
        "startChar": 64,
        "endLine": 279,
        "endChar": 65
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03a890e3_cd201265",
        "filename": "src/libANGLE/GlobalMutex.cpp",
        "patchSetId": 16
      },
      "lineNbr": 279,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T00:42:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d2d405a8_3b32122a",
      "range": {
        "startLine": 279,
        "startChar": 64,
        "endLine": 279,
        "endChar": 65
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b53abe0c_56b13cc8",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-30T15:58:41Z",
      "side": 1,
      "message": "nit: Consider moving `ScopedGlobalMutexLock` template into the `priv` namespace.",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d09cf05f_ff4fa9e1",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-10-31T01:03:51Z",
      "side": 1,
      "message": "I ended up having to move code in anonymous namespace https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/GlobalMutex.cpp;l\u003d114;drc\u003d25ce3dfec69bccb212dba1f0a2510b38952377a9 in `egl::priv` namespace, too. Is there any issue with this move?",
      "parentUuid": "b53abe0c_56b13cc8",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af055dc9_1164ab10",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2024-10-31T12:23:17Z",
      "side": 1,
      "message": "Sorry for misunderstanding. My intention was to only hide `ScopedGlobalMutexLock\u003c\u003e` template from public use. Moving also `ScopedGlobalEGLMutexLock` and `ScopedGlobalEGLSyncObjectMutexLock` into `egl::priv` contradicts my intention.\n\n\u003e in `egl::priv` namespace, too. Is there any issue with this move?\n\nThis way functions from anonymous namespace can be called from other files. I think it is still better to keep the anonymous namespace - so just extend the `priv` namespace to include the anonymous namespace and the `ScopedGlobalMutexLock\u003c\u003e` implementation.\n\nAlso please check for unnecessary `priv::` usage after extending the `priv` namespace. While you removed some, there are plenty left.\n\nOur you can just add another `priv` namespace scope just for the `ScopedGlobalMutexLock\u003c\u003e` to reduce the code diff. It is up to you.",
      "parentUuid": "d09cf05f_ff4fa9e1",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17919c40_d913ce92",
        "filename": "src/libANGLE/GlobalMutex.h",
        "patchSetId": 16
      },
      "lineNbr": 29,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2024-11-01T06:20:48Z",
      "side": 1,
      "message": "\u003e This way functions from anonymous namespace can be called from other files.\n\nThat\u0027s a very good point.\n\n\u003e Also please check for unnecessary priv:: usage after extending the priv namespace. While you removed some, there are plenty left.\n\nThank you very much for catching them.",
      "parentUuid": "af055dc9_1164ab10",
      "range": {
        "startLine": 29,
        "startChar": 20,
        "endLine": 29,
        "endChar": 42
      },
      "revId": "13a3ec1f79999e31ee09281f778451e90e074f6d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}