{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2291fded_2b76d0e5",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-01-12T19:17:49Z",
      "side": 1,
      "message": "I am thinking the easier way might just do it in ImageHelper class. You basically add a new method (lets say ImageHelper::isUpdatingEntireContent()), and then  TextureVk::flushImageStagedUpdates(), you do this:\n\nif(mImage-\u003eisUpdatingEntireContent(){\n releaseImage();\n initImage();\n}\n\nThat way you do not need do any of extra state tracking to figure out if this is full texture update or not. You should be able to figure out from inspecting all the staged updates and make that decision, I think.",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86440037_140739de",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1446209
      },
      "writtenOn": "2022-01-13T05:56:19Z",
      "side": 1,
      "message": "But for texture update with unpackbuffer,current angle will not go to TextureVk::flushImageStagedUpdates,see TextureVk::copyBufferDataToImage,and MH31 is full of this case.",
      "parentUuid": "2291fded_2b76d0e5",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e173ba9d_8a9f83a1",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1446209
      },
      "writtenOn": "2022-01-13T08:00:15Z",
      "side": 1,
      "message": "Adding single level condition(mImage-\u003eisSingleLevelUpdate() is due to:\nglTexSubImage2D(level\u003d0)-\u003evkCmdCopyBufferToImage(image1,miplevel\u003d0)\nglTexSubImage2D(level\u003d1)-\u003evkCmdCopyBufferToImage(image2,miplevel\u003d1)\nglDraw()\nThis will cause level 0 update missing.Therefore,shouldn\u0027t create new image if not single level update.\n\nExcept for single-mip and full texture update,adding \u0027usedInRunningCommands and mImage-\u003egetCurrentImageLayout() \u003d\u003d vk::ImageLayout::FragmentShaderReadOnly\u0027 condition to recreate image only when old image is being read by fragment shader to save image recreation operation.\neg:\nglTexStorage2D()-\u003ecreate image1\nglTexSubImage2D(level\u003d0)-\u003evkCmdCopyBufferToImage(image1,miplevel\u003d0)\nglTexSubImage2D(level\u003d0)-\u003evkCmdCopyBufferToImage(image1,miplevel\u003d0),\nno need to recreate image every time,since there\u0027re no FRAGMENT_SHADER_BIT -\u003e TRANSFER_BIT barrier.\nglDraw()\nSubmitQueue\nglSubTexImage2D(image2)-\u003erecreate image to do buffercopy on this new image\nglDraw()\nSubmitQueue",
      "parentUuid": "86440037_140739de",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cbeafb5_186b8b88",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-01-13T21:52:47Z",
      "side": 1,
      "message": "Thanks Cheryl for explantation. I am still worried that the tracking of \"eligibility\" for ghosting here is too fragile here. For example, mSingleLevelUpdate is set to true when ImageHelper is constructed and later on it may set to false from TextureVk::setSubImageImpl() if level is not 0. This means if no one calls glTexSubImage on level other than 0, it will always think it is single level update. Now consider this example, \nTexStorage2D(numLevels\u003d2);\nrender to level 1\ntexture sample from fragment shader from level 1\nTexSubImage2D on level 0;\n\nYou will still think this is single level update, because \"if (index.getLevelIndex() !\u003d 0)\" is false. And you will end up ghosting VkImage, now you lost level 1 content.\n\nSimilar situation with write to level 1 with compute shader, or glCopyImageSubImage2D etc. You can try to write a test to verify my theory.\n\nIf you verified there is a hole here and want to fix this, I think we will need a bitfield in ImageHelper object to track whether VkImage object\u0027s given level has the most recent data or not, including the already encoded VkCmd* calls. And then every place we could imageWrite, or render to, or CopyBufferToImage, or CopyImageToImage, we set the level bit. Every time we stage a full update to a level, or texture gets redefined, we remove the bit. Then you can use that bitfield to tell if this is a single level update or not.",
      "parentUuid": "e173ba9d_8a9f83a1",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08698099_ccb11af1",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1446209
      },
      "writtenOn": "2022-01-17T07:59:13Z",
      "side": 1,
      "message": "Thanks Charlie for your comment,you\u0027re right,when using glCopyImageSubImage2D to write to level 1 then using glTexSubImage2D to full update level 0,level 1 content will be lost.I updated 3 test cases to verify what you mentioned in above comment.\nVery simplistically, I used a bool value mSingleLevelUpdate to indicate if texture update is single level update or not,in TextureVk::copyTextureSubData and TextureVk::setSubImageImpl,I will check and update this value.\nIn another two cases,\u0027!mState.hasBeenBoundAsAttachment() \u0026\u0026 mImage-\u003egetCurrentImageLayout() \u003d\u003d vk::ImageLayout::FragmentShaderReadOnly\u0027 will exclude them and ensure no image recreation.",
      "parentUuid": "7cbeafb5_186b8b88",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "175d0ab6_fb31487b",
        "filename": "src/libANGLE/renderer/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 2390,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-01-20T18:32:39Z",
      "side": 1,
      "message": "I think the above concern are addressed with you new patch. Thanks for that. I think the remaining concern really is how this tracking is implemented. My preference is that we should do a more general per level data valid tracking, that is more systematic and not just for this optimization. Then you do not have to limit this optimization to only for a single level update. But that is not correctness issue, more of cleanness. So I am giving +1 here and let you address other folks\u0027 concerns.",
      "parentUuid": "08698099_ccb11af1",
      "range": {
        "startLine": 2387,
        "startChar": 9,
        "endLine": 2390,
        "endChar": 85
      },
      "revId": "2e49233b3affeb4f1f438d536bf735087ea05a70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}