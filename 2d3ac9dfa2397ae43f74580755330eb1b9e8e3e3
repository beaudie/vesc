{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4e1eb6eb_d1f1d2e8",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 13
      },
      "lineNbr": 1108,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "There are a lot of these manual trackings, and it\u0027s easy to miss them. How about adding `ContextVk` to the constructor of `CommandBufferAccess`, and let it automatically call this function (or a more generic version that takes the list of images) on destructor? Then you don\u0027t have to ever call this manually for outside RP commands.",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "069d5d90_15723682",
        "filename": "src/libANGLE/renderer/vulkan/FramebufferVk.cpp",
        "patchSetId": 13
      },
      "lineNbr": 1108,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:06:05Z",
      "side": 1,
      "message": "There are two reasons here:\n1) Have access automatically call it won\u0027t work here because there are quite some places we end up calling getOutsideRenderPassCommands() and then call into util function and that util function calls getOutsideRenderPassCommands again. You then run into situation that you try to wait for a event that has not been set. ImageHelper::flushSTagedUpdatesImpl also has similar situations as well. If you want to go down this roite, you basically have to ensure we call getOutsideRenderPassCommands onky once and deconstructor only triggers *after* enture operation is done. That is hardly the case for utility functions.\n2) For performance reason we do prefer manual inserting the tracking so that we have the full control of how fine grain event tracking should we use. We want one event track the entire big operation. For example we want one event for flushStagedUpdates of all levels instead of one per level.\n\nThe other thing is that it is totally okay to miss them. If you want to track one operation with event but forgot to add it, the only downside should be you end up using pipelineBarrier instead of event. That is in next CL.",
      "parentUuid": "4e1eb6eb_d1f1d2e8",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8d31bf0_ba72a6b3",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 13
      },
      "lineNbr": 1817,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "Doesn\u0027t setting an event here cause the same problem? That is, the image\u0027s event is the one for render pass, but then gets overridden to the outside RP\u0027s event?",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "066818af_c07c78bd",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 13
      },
      "lineNbr": 1817,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:57:57Z",
      "side": 1,
      "message": "Right, this probably was added accidentally (this was removed in next CL). Removed.",
      "parentUuid": "f8d31bf0_ba72a6b3",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1982f377_bcf16430",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.cpp",
        "patchSetId": 13
      },
      "lineNbr": 37,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "nit: Not setting `VK_EVENT_CREATE_DEVICE_ONLY_BIT`? I know it\u0027s coming from sync2, but is it incompatible with 1.0 events?",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c727359_38d5f0d3",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.cpp",
        "patchSetId": 13
      },
      "lineNbr": 37,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:06:05Z",
      "side": 1,
      "message": "It should use device only. I was using device only initially but some how missed that during the evolution process. I intended to use device only here. Will fix it soon.",
      "parentUuid": "1982f377_bcf16430",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4be475ad_1f415c3c",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.cpp",
        "patchSetId": 13
      },
      "lineNbr": 37,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T22:50:04Z",
      "side": 1,
      "message": "https://chromium-review.googlesource.com/c/angle/angle/+/5499379",
      "parentUuid": "1c727359_38d5f0d3",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb9572f1_3b4b7c23",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 58,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "WrappedObject is supposed to be a wrapper for basic Vulkan types. You probably don\u0027t want that here. When ref counted event is passed where a wrapped object is needed (like garbage lists?), couldn\u0027t you take out the `Event` and pass that instead?",
      "range": {
        "startLine": 58,
        "startChar": 37,
        "endLine": 58,
        "endChar": 50
      },
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ebd6335e_6db203ac",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 58,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:06:05Z",
      "side": 1,
      "message": "Its mostly for garbage list, but it also provides the convenience that wrappedObject comes with it. For garbage list, you can not just pass `Event`. Garbage needs to take the `RefCountedEvent` and decrement the refcount instead of destroy event. I am trying to conceptually treating the RefCountedEvent a vulkan object here. Someday maybe we can have a VKEvent3 that does not require us to do refcounting and that will all handled in the driver.",
      "parentUuid": "cb9572f1_3b4b7c23",
      "range": {
        "startLine": 58,
        "startChar": 37,
        "endLine": 58,
        "endChar": 50
      },
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8d4a39a_b04ac04c",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 58,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T19:45:20Z",
      "side": 1,
      "message": "Related thread: https://chromium-review.googlesource.com/c/angle/angle/+/5490203/comment/9f85379e_e0946d5d/\n\nWhy not have the refcount release done _before_ adding to garbage list? You can avoid adding multiple copies of the same event to garbage list (only to find out the event doesn\u0027t end up getting deleted). You can also avoid making the atomic decrement `acq_rel`. At that point, you don\u0027t really need this to be a `WrappedObject` either. It looks to me like the convenience of using this class comes at perf cost and code complications that\u0027s probably not worth it.",
      "parentUuid": "ebd6335e_6db203ac",
      "range": {
        "startLine": 58,
        "startChar": 37,
        "endLine": 58,
        "endChar": 50
      },
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c2a7e41_45dab3d4",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 58,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T22:50:04Z",
      "side": 1,
      "message": "Right, the alternative way is you only add to garbage list when last refCount goes away. But this means we have to check against mUse before release refcount. Since events are created and destroyed rather frequently (because it has to track every GPU usage), the concern here is that we may end up have excessive check against mUse. The current design is try to mitigate check of mUse by having GPU hold one reference to RefCountEvent. That reference count only gets decremented when GPU\u0027s reference is completed. And that tracking is associated with command buffer instead of image, which means all event garbage are collected per command buffer and mUse check is only once per command buffer instead of once per image use. (i.e, try to achieve the batch the GPU completion check for all events used by one submission, sort of similar to ContextVk::mCurrentGarbage). So this is done this way for the performance reason. Now the question is check against mUse or atomic decrement of the RefCountEvent which is more expensive? I think mUse should be more expensive. Sometimes mUse could have more than one entry. And mUse check also involves atomic operations. Also note that we might able to get rid of (or at least reduce) the atomic decrement acq_rel once we have the event recylcer in place so that events can recycle per context or share group which does not need the lock or atomic. \n\nI can add more comment here.",
      "parentUuid": "d8d4a39a_b04ac04c",
      "range": {
        "startLine": 58,
        "startChar": 37,
        "endLine": 58,
        "endChar": 50
      },
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6b80c57_aaf7cc06",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 58,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-05-02T16:39:41Z",
      "side": 1,
      "message": "Comment added in vk_ref_counted_event.h in class RefCountedEventGarbageObjects",
      "parentUuid": "8c2a7e41_45dab3d4",
      "range": {
        "startLine": 58,
        "startChar": 37,
        "endLine": 58,
        "endChar": 50
      },
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "320909a1_75539fb4",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "```suggestion\n    // Release one reference count to the underline Event object and destroy if this is the\n```",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19e9d6d4_1593b641",
        "filename": "src/libANGLE/renderer/vulkan/vk_ref_counted_event.h",
        "patchSetId": 13
      },
      "lineNbr": 104,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:57:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "320909a1_75539fb4",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f85379e_e0946d5d",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 13
      },
      "lineNbr": 704,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2024-04-29T16:04:45Z",
      "side": 1,
      "message": "Shouldn\u0027t need this, because all access is under the sharegroup lock, no? Even for EGL images we \"merge\" our share groups so that shouldn\u0027t be a problem (we should rework that by the way, but EGL images will eventually have to be under _some_ lock in the end).",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "366163f2_1e53497b",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 13
      },
      "lineNbr": 704,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2024-04-29T17:06:05Z",
      "side": 1,
      "message": "The problem is garbage clean up in separate thread and will decrement the refcount.",
      "parentUuid": "9f85379e_e0946d5d",
      "revId": "2d3ac9dfa2397ae43f74580755330eb1b9e8e3e3",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}