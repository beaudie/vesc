{
  "comments": [
    {
      "key": {
        "uuid": "54fc5e7a_a224f319",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-06T02:00:49Z",
      "side": 1,
      "message": "nit: date \u0026 top level comment",
      "range": {
        "startLine": 2,
        "startChar": 13,
        "endLine": 2,
        "endChar": 18
      },
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b6c6865_3255c838",
        "filename": "src/libANGLE/ProgramExecutable.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "54fc5e7a_a224f319",
      "range": {
        "startLine": 2,
        "startChar": 13,
        "endLine": 2,
        "endChar": 18
      },
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35b346c4_f52ecb52",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-06T02:46:40Z",
      "side": 1,
      "message": "I imagine eventually you would want a ProgramExecutableState as well, which is what\u0027s shared with the backend (and has all the data), with ProgramExecutable getting lists of things to link (from Program or PPO) and populate it.\n\nThen a lot of current \"program-\u003egetState()\"s become \"programExecutable-\u003egetState()\" and otherwise be used exactly the same way.",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "adc5047e_c955d291",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "I was thinking more that ProgramExecutable is the state of the executable, and just contains the members in it directly.   Otherwise, I\u0027m not sure what would be in ProgramExecutable vs ProgramExecutableState - it seems like everything would just be in ProgramExecutableState without any need for ProgramExecutable other than to implement shared functions.\n\nWith Jamie\u0027s request to have ProgramExecutable be a peer of ProgramState, rather than a member of it, the backend requires its own reference to the ProgramExecutable just like the ProgramState:\n\nclass ProgramImpl : angle::NonCopyable\n{\n...\n  protected:\n    const gl::ProgramState \u0026mState;\n    const gl::ProgramExecutable \u0026mProgramExecutable;\n};\n\nThis is because the backend doesn\u0027t have access to the corresponding frontend Program to get the ProgramExecutable from (it was getting it through the mState before), so it needs the reference to it just like the ProgramState.\n\nWith both your\u0027s and Jamie\u0027s suggestion it would change from:\nmState.getProgramExecutable().mLinkedShaderStages\nto:\nmProgramExecutable.getState().mLinkedShaderStages\n\nPersonally, I\u0027d prefer to avoid the extra ProgramExecutableState abstraction, since I think the \"executable\" part already implies it\u0027s mutable:\nmProgramExecutable.mLinkedShaderStages",
      "parentUuid": "35b346c4_f52ecb52",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6f92385_1574db38",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-09T14:09:35Z",
      "side": 1,
      "message": "I think Shabi\u0027s thinking of the back-end using inheritance to add the additional state. The decision is if you want something like Program + ProgramState -\u003e ProgramImpl -\u003e ProgramVk - Executable + ExecutableState -\u003e ExecutableImpl -\u003e ExecutableVk or if we just want Executable + ExecutableVk.",
      "parentUuid": "adc5047e_c955d291",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75561506_19a81ccf",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-10T21:20:45Z",
      "side": 1,
      "message": "I\u0027m confused (and don\u0027t understand the +/-/-\u003e description).\n\nWhen ProgramState \"shares\" data with the backed, it\u0027s via the backend calling ProgramState methods to return the desired data.   The only relation from ProgramState to ProgramVk (ProgramImpl) is that ProgramVk contains a reference to the corresponding ProgramState in the frontend; it doesn\u0027t inherit anything from ProgramState.   My expectation is that ProgramExecutable would be behave and be treated the same as a ProgramState, since it\u0027s the same data that just happens to be filled out different whether it\u0027s a Program vs a ProgramPipeline.\n\nThe backend ProgramExecutableVk will be the same idea.   It\u0027s the same data that\u0027s currently in ProgramVk that just happens to be filled out differently whether it\u0027s a ProgramVk or a ProgramPipelineVk.   They will both have a new \u0027ProgramExecutableVk mExecutable\u0027 member that contains the necessary data structures and shared function calls.",
      "parentUuid": "d6f92385_1574db38",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6381642f_c2f5ae1b",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-10T21:39:32Z",
      "side": 1,
      "message": "Option 1:\n\nwhat you have now\n\nOption 2:\n\n namespace gl\n {\n class ExecutableState {\n   // front-end executable state.\n };\n\n class Executable {\n private:\n   rx::ExecutableImpl *mImplementation;\n   ExecutableState mState;\n }\n }\n\n namespace rx\n {\n class ExecutableImpl {\n    ExecutableImpl(const ExecutableState \u0026state) : mState(state) {}\n  protected:\n    const ExecutableState \u0026mState;\n    // probably not much else.\n };\n }\n\n namespace rx\n {\n class ExecutableVk : public ExecutableImpl {\n private:\n   // special Vulkan state.\n }\n }\n\nI\u0027m personally OK with what you have now. Just trying to explain what Shabi means.",
      "parentUuid": "75561506_19a81ccf",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20926ce3_3062eebc",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-11T00:46:19Z",
      "side": 1,
      "message": "Ah, ok; follow the same Program/ProgramImpl(ProgramState)/ProgramVk approach with Executable/ExecutableImpl(ExecutableState)/ExecutableVk.\n\nI don\u0027t think there will be anything in Executable that we wouldn\u0027t want to share with the backend, so if the intent is that *only* things in ExecutableState are shared, then everything would end up in ExecutableState and Executable would just be an empty class to hold ExecutableState.\n\nMy understanding is also that the only way for ProgramVk to access ExecutableVk members/functions would be via ProgramVk::mState, since there wouldn\u0027t be any ExecutableVk members in the backend directly.   For example, we would have to get the vulkan pipeline layout by going through the ProgramState:\nvk::GetImpl(programVk-\u003emState-\u003egetExecutable())-\u003emPipelineLayout\n\nInstead, I was expecting for ProgramVk/ProgramPipelineVk to have their own ExecutableVk members which contains the shared members/functions:\nprogramVk-\u003egetExecutable().mPipelineLayout\n\nI think since Executable is already inside ProgramState and ProgramVk/ProgramPipelineVk are already essentially their own \"state\"s (there is no ProgramStateVk), having the standalone Executable (instantiated by ProgramState) and ExecutableVk (instantiated by ProgramVk/ProgramPipelineVk) makes sense for now.\n\nThis is certainly something that\u0027s worth revisiting once things become concrete with more substantial content for each though.   I\u0027ll add this as an alternative to the design doc so it\u0027s not lost, if everyone is ok with moving forward with this simplified version for now.",
      "parentUuid": "6381642f_c2f5ae1b",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20d8f14e_6958c575",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-11T08:01:47Z",
      "side": 1,
      "message": "\u003e I don\u0027t think there will be anything in Executable that we wouldn\u0027t want to share with the backend\n\nMaybe not data, but there is functionality we wouldn\u0027t want to share with the backend. I imagine Executable would at some point assume responsibility for (parts of) the linking process (to populate its (or its State\u0027s) data). Then the Executable/ExecutableState split makes sure the backend cannot call those functions.\n\nI\u0027m ok with this too and we can move on. It\u0027s always possible to refactor later.",
      "parentUuid": "20926ce3_3062eebc",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e46bc87a_3dacde24",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-06T01:16:52Z",
      "side": 1,
      "message": "This is an example of a member that behaves the same for Programs or ProgramPipelines, so all accesses/modifications of it are done through ProgramExecutable.",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34b088b5_d1e6c5ca",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e46bc87a_3dacde24",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bd7eac1e_52ab925d",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-06T01:16:52Z",
      "side": 1,
      "message": "This is an example of a member that\u0027s accessed the same way throughout, but the data itself is populated differently based on Programs vs ProgramPipelines.\n\nThis CL only supports Programs and Program::updateLinkedShaderStages() already exists, so there isn\u0027t much that\u0027s exciting to see there yet, but ProgramPipeline::updateLinkedShaderStages() would eventually exist as well.   If you\u0027re interested what that would look like, see ProgramPipeline::useProgramStages() (line 129) in the \"Support Program Pipeline Objects\" CL:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/1934432/55/src/libANGLE/ProgramPipeline.cpp\n\nThere, whenever glUseProgramStages() is called a linked Program is added to the ProgramPipeline, so the current state of the linked program stages is updated for the ProgramPipeline.   Once this CL is merged into there, this ProgramExecutable::mLinkedShaderStages would actually hold the updated value to be queried by the rest of ANGLE.",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d18cf1c_092fb741",
        "filename": "src/libANGLE/ProgramExecutable.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "bd7eac1e_52ab925d",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a39893b9_0f742b16",
        "filename": "src/libANGLE/State.h",
        "patchSetId": 3
      },
      "lineNbr": 308,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-06T02:46:40Z",
      "side": 1,
      "message": "At some point in the future, it would be nice to have this cached and calculated on program / program pipeline binding change. Then the cost of accessing the ProgramExecutable would be the same as the cost of accessing the Program has been so far.\n\nDefinitely a separate CL though.",
      "range": {
        "startLine": 301,
        "startChar": 0,
        "endLine": 308,
        "endChar": 9
      },
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cc66acdd_cd46bed3",
        "filename": "src/libANGLE/queryutils.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1197,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-06T02:00:49Z",
      "side": 1,
      "message": "nit: how about program-\u003egetExecutable().get...",
      "range": {
        "startLine": 1196,
        "startChar": 30,
        "endLine": 1197,
        "endChar": 66
      },
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e33deed5_0d0d5990",
        "filename": "src/libANGLE/queryutils.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1197,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cc66acdd_cd46bed3",
      "range": {
        "startLine": 1196,
        "startChar": 30,
        "endLine": 1197,
        "endChar": 66
      },
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27f0f91f_cc092bc6",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2274,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-06T01:16:52Z",
      "side": 1,
      "message": "Here\u0027s a good example of ContextVk not needing to know whether a Program or PPO is currently being worked on, just whether it\u0027s a Compute executable or not.   The gl::State handles returning the correct ProgramExecutable, which then knows how to correctly respond to isCompute().",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07b6789a_9cf1ffc9",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2274,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-08T01:08:26Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "27f0f91f_cc092bc6",
      "revId": "02c3e54f98d4a23442565507bc26b560a8be9d00",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}