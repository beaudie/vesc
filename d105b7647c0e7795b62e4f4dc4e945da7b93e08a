{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8c7474bd_ab541d14",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-20T22:24:49Z",
      "side": 1,
      "message": "Sorry about the delay, busy day",
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e7a10c9_86837690",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1151,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-20T22:24:49Z",
      "side": 1,
      "message": "I\u0027m still struggling to understand why contexts with `context-\u003egetRefCount() \u003d\u003d 0` are being moved into `mInvalidContextSet` here. Why do we need to postpone `releaseContextImpl` until `destroyInvalidEglObjects()` is invoked?\n\nLet\u0027s say we added a context to `mInvalidContextSet` and then run into the `!mState.contextSet.empty()` case below. `destroyInvalidEglObjects` is not going to be invoked during this call as we\u0027ll return on line 1160. However, when *any* thread calls `eglReleaseThread`, we\u0027ll call `destroyInvalidEglObjects()` unconditionally regardless of how many other active threads there may be. Why do we choose to call `releaseContextImpl` during eglReleaseThread on some random thread instead of doing it here right away? Was that done this way because eglReleaseThread was guarded by the global lock and this code wasn\u0027t?.. which is no longer the case?",
      "range": {
        "startLine": 1151,
        "startChar": 7,
        "endLine": 1151,
        "endChar": 43
      },
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a747169_c619251d",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1151,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-20T23:48:46Z",
      "side": 1,
      "message": "\u003e when *any* thread calls  eglReleaseThread , we\u0027ll call  destroyInvalidEglObjects()  unconditionally regardless of how many other active threads there may be\n\nANGLE\u0027s implementation of `eglReleaseThread` is doing things that isn\u0027t listed in the spec. The only reason `eglReleaseThread` calls `destroyInvalidEglObjects` is to specifically address the \"Android CTS WrapperTest.testThreadCleanup\" test case, in other words it was a workaround designed to get past CTS issue.\n\nI have not yet verified this but with ToT ANGLE along with this change, we should be able to remove the workaround in `releaseThread` and be more aligned with the spec and still pass the \"Android CTS WrapperTest.testThreadCleanup\" test\n\n\u003e Why do we choose to call  releaseContextImpl  during eglReleaseThread on some random thread instead of doing it here right away?\n\nwith the removal of the workaround in `releaseThread` and enabling the \"aggressive\" cleanup i mentioned in the other comment we will end up with the thread being destroyed cleaning up its own resources.\n\nAs for why we have a dedicated method `destroyInvalidEglObjects` to cleanup invalid resources - its just a helper to be called from multiple places (earlier it was `releasThread` and `terminate` but now it will be `terminate` and `threadCleanup`)",
      "parentUuid": "8e7a10c9_86837690",
      "range": {
        "startLine": 1151,
        "startChar": 7,
        "endLine": 1151,
        "endChar": 43
      },
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63c1a2ba_fd4b6107",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1151,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-21T16:39:26Z",
      "side": 1,
      "message": "Thanks for bearing with me, Mohan, and I apologize about all the back and forth but I\u0027m still confused. Let me take a little step back and try to explain my current state of confusion:\n\nI am trying to make sense of the eglTerminate spec to better understand where we\u0027re trying to get with this cl. \n\nOne thing that I still don\u0027t understand is what is supposed to happen to unreleased contexts when eglTerminate is called but then the display is brought back to life with eglInitialize again.\n\nThis part of the spec suggests that contexts are no longer valid immediately after the call:\n\n```\nTermination marks all EGL-specific resources, such as contexts and surfaces, associated with the specified display for deletion. Handles to all such resources are invalid as soon as eglTerminate returns, but the dpy handle itself remains valid. Passing such handles to any other EGL command will generate EGL_BAD_SURFACE or EGL_BAD_CONTEXT errors. Applications should not try to perform useful work with such resources following eglTerminate; only eglMakeCurrent or eglReleaseThread should be called, to complete deletion of these resources.\n```\n\nIt doesn\u0027t seem to state explicitly that those contexts remain invalid after eglInitialize is called again, but presumably that\u0027s the case. If so, then shouldn\u0027t *all* contexts be moved to some kind of \"invalid\" set regardless of whether or not ref count reached zero? My understanding is that if the display is initialized again, those objects are not supposed to become valid again.\n\nMy understanding of this following part of the spec is that these contexts may still be used by some threads and that\u0027s okay but rendering behavior is undefined as long as the app doesn\u0027t crash:\n\n```\nUse of bound contexts and surfaces (that is, continuing to issue commands to a bound client API context) will not result in interruption or termination of applications, but rendering results are undefined, and client APIs may generate errors\n```\n\nI had a look at \"Android CTS WrapperTest.testThreadCleanup\" and I don\u0027t understand why that test is problematic. It seems to do a proper cleanup on each thread. In that case, we should be able to release thread-specific resources in `eglReleaseThread`.. do you know what was the root cause there?\n\nI am still missing something in the logic behind the entire move-to-`mInvalid*Set`-then-destroy-in-`eglReleaseThread` approach. `eglReleaseThread` does not check for any ref counts so it will just destroy objects unconditionally. Why is the destroy operation postponed until `eglReleaseThread` then? If there is a good reason why it is postponed, what makes us believe that this reason is no longer there when `eglReleaseThread` gets called? There are potentially still other outstanding threads and current contexts.. so what is special about `eglReleaseThread` being called by some thread?..\n\nAm I making sense at all? :)",
      "parentUuid": "9a747169_c619251d",
      "range": {
        "startLine": 1151,
        "startChar": 7,
        "endLine": 1151,
        "endChar": 43
      },
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b00bb2f_855f7494",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1151,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-08-15T16:45:08Z",
      "side": 1,
      "message": "apologies for the delay, i was out sick for a couple of weeks\n\n\u003e This part of the spec suggests that contexts are no longer valid immediately after the call\n\nthat is the correct interpretation\n\n\u003e then shouldn\u0027t *all* contexts be moved to some kind of \"invalid\" set regardless of whether or not ref count reached zero?\n\nthat was my intent when working on angleproject:6798 but it turned out to be more troublesome in that the other thread with the context still active expected display state\u0027s context set to contain that context in some methods and would otherwise crash\n\n\u003e My understanding is that if the display is initialized again, those objects are not supposed to become valid again\n\ngiven angle returns pointers as EGL objects, irrespective of which set we put the invalid context in we will never return the same pointer/address before free\u0027ing the context object. The only incorrect thing with ToT is if app called a get attrib on a context after calling terminate we would still treat it as a valid context instead of returning EGL_BAD_CONTEXT.\n\n\u003e these contexts may still be used by some threads and that\u0027s okay but rendering behavior is undefined as long as the app doesn\u0027t crash\n\nnew commands cannot be submitted since per spec the context is invalid (so we need to fail validation) but already submitted commands prior to `eglTerminate` must complete correctly without issues\n\n\u003e I don\u0027t understand why that test is problematic. It seems to do a proper cleanup on each thread. In that case, we should be able to release thread-specific resources in  eglReleaseThread .. do you know what was the root cause there?\n\n`eglTerminate` + `eglReleaseThread` combo will do the correct cleanup with ANGLE after bug 6798 was fixed, wasnt the case before since the surface would never be cleaned up since it is still actively being used when `eglTerminate` gets called\n\n\u003e eglReleaseThread  does not check for any ref counts so it will just destroy objects unconditionally.\n\ncorrect\n\n\u003e Why is the destroy operation postponed until  eglReleaseThread then?\n\nunless we want to perform a `glFinish` on all active threads (which is not possible since we do not know the state of each active thread) it would be incorrect to assume the objects can be destroyed. This is why only objects that are confirmed to be inactive are moved to invalid set and the clean up of remaining objects happens during thread destruction since we are guaranteed that those objects are no longer in use and is safe to delete\n\n\u003e so what is special about  eglReleaseThread  being called by some thread?\n\nthere is nothing special about `eglReleaseThread` ANGLE makes it special by treating it as a boundary condition to try and free resources (which is what i meant when i said angle is doing more than what spec allows for in `eglReleaseThread`). Ideally we can land my change and return back `eglReleaseThread` to its non-special state\n\ni hope this provided some clarity",
      "parentUuid": "63c1a2ba_fd4b6107",
      "range": {
        "startLine": 1151,
        "startChar": 7,
        "endLine": 1151,
        "endChar": 43
      },
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95e0935d_cd537b93",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 12
      },
      "lineNbr": 1219,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-20T11:49:33Z",
      "side": 1,
      "message": "we can be a bit more aggressive and do this as well -\n```\n if (!noActiveThreads)\n {\n     destroyInvalidEglObjects();\n }\n```",
      "revId": "d105b7647c0e7795b62e4f4dc4e945da7b93e08a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}