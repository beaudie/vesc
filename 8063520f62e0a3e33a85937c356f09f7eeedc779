{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "36972b57_54448425",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-15T22:32:32Z",
      "side": 1,
      "message": "PTAL",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2475f6a5_529b6d6d",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-06-15T23:25:30Z",
      "side": 1,
      "message": "Re-using the hack works practically, but I\u0027m not sure if ANGLE folks want a deeper fix to update `mDesiredSwapchainPresentMode` and recreate the swapchain accordingly based on what the app requests.\n\nThe reason it works practically is because of the comment above. Currently we have two call sequences:\n1. app requests autorefresh before angle recreates swapchain for shared present\n2. app toggles autorefresh after angle recreates the swapchain\n\nFor (1), `mAutoRefreshEnabled` makes angle to create with `VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR`.\n\nFor (2), angle doesn\u0027t recreate the swapchain, but that\u0027s fine since the platform would still passthrough the app\u0027s request into the Surface to toggle it, and that behavior is still transparent to both angle and the Vulkan implementation.\n\nConsidering the cost/overhead of swapchain recreation, I\u0027m not a big fan for the deeper fix. Up to our angle folks ; )",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "812fd6af_88d32491",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-06-16T02:13:26Z",
      "side": 1,
      "message": "This seems very fragile, what if another window system implements this? (Usually that ends up being Wayland ðŸ˜„)\n\nI\u0027m assuming this toggling doesn\u0027t actually happen often, so if we could recreate the swapchain with the right mode, we\u0027ll have a much cleaner state (instead of saying the mode is demand refresh, but there\u0027s this bool that says actually it\u0027s not).\n\nHow about letting the toggle cause a swapchain recreation, and in `GetDesiredPresentMode` we choose whether to use auto or demand refresh by querying the front-end? Then we also don\u0027t need to cache `mAutoRefreshEnabled` in the backend.\n\nWould that work?",
      "parentUuid": "2475f6a5_529b6d6d",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b8d883f_dce52ddd",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-06-16T06:52:32Z",
      "side": 1,
      "message": "That makes sense to me. A more robust fix is prefered.\n\n\u003e How about letting the toggle cause a swapchain recreation, and in  GetDesiredPresentMode  we choose whether to use auto or demand refresh by querying the front-end? Then we also don\u0027t need to cache  mAutoRefreshEnabled  in the backend.\n\nThat should work.",
      "parentUuid": "812fd6af_88d32491",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e82a5bd_043931c8",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-16T21:43:00Z",
      "side": 1,
      "message": "\u003e Would that work?\n\u003e That should work.\n\n1 small wrinkle, the spec does not require a context to be current when eglSurfaceAttrib is called",
      "parentUuid": "1b8d883f_dce52ddd",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2092093_fdf8cb9b",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-06-17T19:34:51Z",
      "side": 1,
      "message": "Do we need the context? We already handle switch from and to single buffer mode with this method. Just need to change `mDesiredSwapchainPresentMode` to `vk::PresentMode::SharedContinuousRefreshKHR` and make sure `GetDesiredPresentMode()` handle both `vk::PresentMode::SharedDemandRefreshKHR` and `vk::PresentMode::SharedContinuousRefreshKHR` correctly.",
      "parentUuid": "7e82a5bd_043931c8",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4365b53e_d5712713",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-17T20:26:14Z",
      "side": 1,
      "message": "when are we actually going to recreate the swapchain then?",
      "parentUuid": "b2092093_fdf8cb9b",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62b9fac5_b32249b8",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-17T23:41:49Z",
      "side": 1,
      "message": "note that having cotinuous refresh mode supported will mean we no longer have to call vulkan present (via swapImpl) in glFlush",
      "parentUuid": "4365b53e_d5712713",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69fc4f6d_1b922290",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-06-18T00:11:15Z",
      "side": 1,
      "message": "I thought mode change triggers the swap: https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/src/libANGLE/renderer/vulkan/SurfaceVk.cpp;l\u003d1677",
      "parentUuid": "62b9fac5_b32249b8",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd39d689_a116244a",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-18T00:30:16Z",
      "side": 1,
      "message": "\u003e I thought mode change triggers the swap\n\nthis assumes app keeps calling swap. check for the following sequence -\n\n1. switch to single buffer mode\n2. call swap\n3. some time later, enable auto refresh\n4. flush (no more swaps from app)\n\nat this point we are relying on behavior introduced by method \"WindowSurfaceVk::onSharedPresentContextFlush\", which forces a swap inside a flush. (to truly support auto refresh we need to update this method to take into account auto refresh mode as well)",
      "parentUuid": "69fc4f6d_1b922290",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa425d64_a13c2016",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1509302
      },
      "writtenOn": "2022-06-18T00:41:54Z",
      "side": 1,
      "message": "You are right that app no longer needs to call swap, however, implementation still has to make that call because of Android WSI specialty to queueBuffer/dequeueBuffer. demand v.s. auto would hint the platform presentation engine to choose to do IPC binder call for them or short-cut within the app side.\n\nThe overhead of this is trivial when in auto refresh mode.\n\nHere\u0027s also some docs for the mesa egl implementation: https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/third_party/mesa/include/GL/internal/dri_interface.h;l\u003d2108",
      "parentUuid": "cd39d689_a116244a",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4959e59e_012874cf",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1363,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-06-18T00:51:28Z",
      "side": 1,
      "message": "\u003e implementation still has to make that call because of Android WSI specialty to queueBuffer/dequeueBuffer\n\ni am a little confused, the spec states -\n If attribute is EGL_ANDROID_front_buffer_auto_refresh, then value specifies\n whether to enable or disable auto-refresh in the Android compositor when\n doing front-buffer rendering.\n \nIIUC, whenever it is time to update the display (say near vsync boundary) if SF knows that an app\u0027s window is in auto-refresh mode the spec states that SF must pull in latest content from app.\n\nAlso, in single buffer mode queueBuffer / dequeueBuffer is not that meaningful since swapchain image count will be 1",
      "parentUuid": "aa425d64_a13c2016",
      "revId": "8063520f62e0a3e33a85937c356f09f7eeedc779",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}