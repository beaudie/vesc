{
  "comments": [
    {
      "key": {
        "uuid": "cebd444b_2491a645",
        "filename": "src/libANGLE/renderer/gl/FramebufferGL.cpp",
        "patchSetId": 11
      },
      "lineNbr": 280,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "I had to double-check, but have confirmed that this constructor does value-initialization of the array - important to never expose uninitialized data.",
      "range": {
        "startLine": 280,
        "startChar": 20,
        "endLine": 280,
        "endChar": 27
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6594dcc_edc14c14",
        "filename": "src/libANGLE/renderer/gl/FramebufferGL.cpp",
        "patchSetId": 11
      },
      "lineNbr": 313,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "This memcpy is a little problematic. If the user used the GL_PACK_ROW_LENGTH / GL_PACK_SKIP_ROWS / GL_PACK_SKIP_PIXELS parameters to read back a sub-rectangle of the framebuffer, they would expect the data that wasn\u0027t read back to be untouched.\n\nThe way this workaround is currently structured, it will overwrite all of the data before the first pixel read back from the driver, and can also overwrite other data at the beginning and end of rows in the middle of the image.\n\nThe safest way to express this workaround would be to first read back into a temporary buffer, and then copy from that temporary buffer into the user\u0027s buffer, row by row, not touching any pixels the user didn\u0027t intend to touch.\n\nOne way to structure this would be to write a class like \"ScopedExtTextureNorm16ReadbackWorkaround\" and pass in its constructor all of the information needed in this function. So at call sites below like readPixelsRowByRow and readPixelsAllAtOnce:\n\n  ScopedExtTextureNorm16ReadbackWorkaround workaround(context, area, originalReadFormat, ...);\n  GLubyte* readBackPixels \u003d workaround.pixels();  // This would return either an internally-allocated temporary buffer, or the user\u0027s original pixels, depending on whether the workaround is actually needed\n  // Rest of body of readPixelsRowByRow or readPixelsAllAtOnce\n  return workaround.maybeDoWorkaround(); // either does the workaround, or skips it and returns angle::Result::Continue\n\nThen the destructor of the class would clean up the temporary buffer, if necessary (or just use unique_ptr in the class like you currently do and it\u0027ll happen automatically).\n\nThese are just a couple of ideas for structuring the workaround. Let\u0027s discuss more offline if you like. I think it\u0027s important to get these cases right and expand out the tests because we don\u0027t want to have to revisit this code later.",
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67890eb7_83a4ee16",
        "filename": "src/libANGLE/renderer/gl/formatutilsgl.cpp",
        "patchSetId": 11
      },
      "lineNbr": 665,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "Is it verified anywhere that the GL_IMPLEMENTATION_COLOR_READ_FORMAT advertised by the driver will be GL_RG for these RG16 textures, and GL_RED for these R16 textures? This isn\u0027t guaranteed by the specification. Probably the worst thing that would happen if the driver doesn\u0027t support it is that a GL error will be generated by ReadPixels, which will probably be surfaced up to the application, but it would be ideal if it were caught during ANGLE\u0027s validation of the ReadPixels call.",
      "range": {
        "startLine": 665,
        "startChar": 9,
        "endLine": 665,
        "endChar": 29
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a6d374d_93d4dbd5",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 11
      },
      "lineNbr": 4166,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "It would be better encapsulated if this test issued the glPixelStorei calls rather than the caller. What about refactoring it to do that?",
      "range": {
        "startLine": 4166,
        "startChar": 54,
        "endLine": 4166,
        "endChar": 65
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04de92e2_1b4a5435",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 11
      },
      "lineNbr": 4170,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "typo: components",
      "range": {
        "startLine": 4170,
        "startChar": 27,
        "endLine": 4170,
        "endChar": 37
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3abde4c8_f41c598e",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 11
      },
      "lineNbr": 4205,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "This test should verify that data outside the read-back pixel rectangle is untouched. This is important to confirm the behavior of ReadPixels with sub-rectangles as described above.",
      "range": {
        "startLine": 4205,
        "startChar": 16,
        "endLine": 4205,
        "endChar": 25
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afaafc10_3dbbfade",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 11
      },
      "lineNbr": 4213,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "testNorm16Render doesn\u0027t seem to be called any more. It used to be called by the TextureNorm16Test but isn\u0027t called by any of the newly refactored tests.",
      "range": {
        "startLine": 4213,
        "startChar": 9,
        "endLine": 4213,
        "endChar": 25
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30b13f81_fec4d673",
        "filename": "src/tests/gl_tests/TextureTest.cpp",
        "patchSetId": 11
      },
      "lineNbr": 4324,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2019-12-14T00:39:43Z",
      "side": 1,
      "message": "Can this just use ANGLE_SKIP_TEST_IF for this situation? Here and below.",
      "range": {
        "startLine": 4324,
        "startChar": 9,
        "endLine": 4324,
        "endChar": 33
      },
      "revId": "3c4b95607c46ebbda6dd58ba72501481c7fe524f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}