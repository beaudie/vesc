{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1fe88ddf_9b9d91e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-02-27T19:34:50Z",
      "side": 1,
      "message": "**Alternative fix**: https://chromium-review.googlesource.com/c/angle/angle/+/4296014",
      "revId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "34783991_438164e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-03-07T18:46:57Z",
      "side": 1,
      "message": "Is the bug you try to fix hitting any real usage?\n\nMy understanding is that EGLImage currently also have another bug (https://issuetracker.google.com/169868803). There are effort to make all contexts references EGLImage to be shared but then reverted, then individual locks added, but not sure if this is completely fixed. If not, we have a bigger problem to deal with as well.\n\nThe way I am thinking is to let EGLImage have multiple ImageHelper objects, one per shared group. They will share the same VkDeviceMemory. Then We will sync the layout at higher level code, where egl API is called. This way, the vulkan backend is thread safe, EGLImage will behave just like normal texture. You do not have bugs like this. I believe one context write and another context read case there is a clear egl API boundary you have to call. I am not 100% sure on two contexts both read EGLImage case, is it required to have egl API call. As long as there is egl API call requirment, we can do necessary sync at that egl call stack. Just want to throw this idea here, if this bug is not blocking us form shipping, we could wait a bit until we resolve this ImageHelper for EGLImage thread safety issue.",
      "revId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b8d8b9b_3754ae38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-03-07T19:01:57Z",
      "side": 1,
      "message": "This is the old fix version. New version: https://chromium-review.googlesource.com/c/angle/angle/+/4296014\n\n\u003e Is the bug you try to fix hitting any real usage?\n\nYes. Very long time ago there was crash in some app. My colleague fixed by simply finalizing layout. This fix was enough. I do not remember what app it was. We simply fix bugs without much bureaucracy.\n\nThen I ported his fix to a new ANGLE version and also added finalize for render buffer.\n\nNow prepared this CL. During this process I found that simply finalizing may corrupt RenderPass state if texture that finalizes not the one that used in the RenderPass.\n\n\u003e My understanding is that EGLImage currently also have another bug (https://issuetracker.google.com/169868803). There are effort to make all contexts references EGLImage to be shared but then reverted, then individual locks added, but not sure if this is completely fixed. If not, we have a bigger problem to deal with as well.\n\nYes. I already mentioned that I have solution with mutexes. Just do not have time to prepare CL for review...\nThis CL not only to fix EGLImage problem but also decouple independent share groups with separate mutex.\n\n\u003e The way I am thinking is to let EGLImage have multiple ImageHelper objects, one per shared group. They will share the same VkDeviceMemory. Then We will sync the layout at higher level code, where egl API is called. This way, the vulkan backend is thread safe, EGLImage will behave just like normal texture. You do not have bugs like this. I believe one context write and another context read case there is a clear egl API boundary you have to call. I am not 100% sure on two contexts both read EGLImage case, is it required to have egl API call. As long as there is egl API call requirment, we can do necessary sync at that egl call stack. Just want to throw this idea here, if this bug is not blocking us form shipping, we could wait a bit until we resolve this ImageHelper for EGLImage thread safety issue.\n\nSounds complicated. I do no know how to implement this or what other problems may appear. Maybe try solution with mutexes first and then optimize if needed?",
      "parentUuid": "34783991_438164e7",
      "revId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9065699_121a5fc4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-03-10T14:38:28Z",
      "side": 1,
      "message": "\u003e The way I am thinking is to let EGLImage have multiple ImageHelper objects, one per shared group. They will share the same VkDeviceMemory. Then We will sync the layout at higher level code, where egl API is called. This way, the vulkan backend is thread safe, EGLImage will behave just like normal texture.\n\nI guess a similar but less complicated approach could be to have ImageHelper be what it is, but have a SharedImageHelper class that just references the ImageHelper, then store instances of SharedImageHelper in the RP so the texture/renderbuffer can verify if it\u0027s _their_ reference to the image. You wouldn\u0027t need to sync the layout/etc between the copies (which will no longer exist)",
      "parentUuid": "2b8d8b9b_3754ae38",
      "revId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["has:approval_code-owners"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "Submit requirement for the \u0027Verified\u0027 label"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:false"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:true"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:false"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:true"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "af1ca4da0316ada41a04e372b34b7e2d897affef",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}