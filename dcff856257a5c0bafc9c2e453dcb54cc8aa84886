{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "be34530a_a2b14e63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-09-28T06:23:16Z",
      "side": 1,
      "message": "Kyle, Quyen, looking forward any feedback you have.",
      "revId": "dcff856257a5c0bafc9c2e453dcb54cc8aa84886",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3eda9a69_a65f828c",
        "filename": "src/libANGLE/renderer/metal/BufferMtl.mm",
        "patchSetId": 13
      },
      "lineNbr": 449,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-09-28T22:40:11Z",
      "side": 1,
      "message": "I\u0027m not sure I understand the rationale for all the cases in this switch statement. Can you help me understand this?\n\n\nMy understanding of the Metal buffer options comes from here, in the section \"Buffer Storage Mode (macOS)\":\n\nhttps://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/ResourceOptions.html\n\nAnd my understanding of the GL buffer usage options comes from here:\n\nhttps://docs.gl/gl3/glBufferData#description\n\n\nGiven the above docs, I would expect the GL usage to Metal storage mode mapping to be something like:\n\n- *Copy -\u003e \"Private\" or \"Managed\", since Copy seems to imply primarily GPU-side reads/writes\n- *Read -\u003e \"Shared\", since Read seems to suggest optimizing for CPU-side reads\n- \"StaticDraw\" -\u003e \"Private\" or \"Managed\", since the data is rarely written by the application, but frequently used by the GPU\n- \"DynamicDraw\" -\u003e \"Managed\", since the data is sometimes written by the application, and used frequently by the GPU\n- \"StreamDraw\" -\u003e \"Shared\", since the data is written frequently by the application, and used a few times by the GPU\n\n\nAs for the switch statement:\n\n- The *Read cases I agree with, because the CPU side is expected to read from the buffers. Shared mode makes the most sense there.\n\n- The StaticCopy I\u0027m unsure about. It sounds like that\u0027s expected to be read/written entirely GPU side.\n\n- A puzzler for me here is StaticDraw. To me, that means \"the application writes this data very rarely (or even once), and it is frequently used for draw commands by the GPU\". I would not expect \"Shared\" for that. To me, given the option of Shared or Managed, I\u0027d expect the latter.\n\nSo for me, it seems like maybe the \"StaticDraw\" case perhaps should have been \"StreamDraw\" instead?\n\nWhat am I missing here?",
      "revId": "dcff856257a5c0bafc9c2e453dcb54cc8aa84886",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5f7c672_8493b107",
        "filename": "src/libANGLE/renderer/metal/BufferMtl.mm",
        "patchSetId": 13
      },
      "lineNbr": 449,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-10-05T18:28:06Z",
      "side": 1,
      "message": "Thanks for looking at the CL! It\u0027s super appreciated!\n\nFirst off, advice, never reference GL docs for GLES. It will only lead to being mis-lead ðŸ˜¢ so https://docs.gl/es3/glBufferData not https://docs.gl/gl3/glBufferData\n\nAlso, at least in our/my experience, anything other than the spec itself is often wrong. I\u0027ve run into this multiple times. This includes the khronos ref pages at https://registry.khronos.org/OpenGL-Refpages/es3.0/  most likely because either they were wrong to begin with or someone copied and pasted from GL to GLES either not knowing they are different or missing some points when editing.\n\nIn this case docs.gl looks mostly correct?  The actual spec says\n\nSTREAM_DRAW The data store contents will be specified once by the application,\nand used at most a few times as the source for GL drawing and image specification commands.\n\nSTREAM_READ The data store contents will be specified once by reading data from\nthe GL, and queried at most a few times by the application.\n\nSTREAM_COPY The data store contents will be specified once by reading data from\nthe GL, and used at most a few times as the source for GL drawing and image\nspecification commands.\n\nSTATIC_DRAW The data store contents will be specified once by the application,\nand used many times as the source for GL drawing and image specification\ncommands.\n\nSTATIC_READ The data store contents will be specified once by reading data from\nthe GL, and queried many times by the application.\n\nSTATIC_COPY The data store contents will be specified once by reading data from\nthe GL, and used many times as the source for GL drawing and image specification commands.\n\nDYNAMIC_DRAW The data store contents will be respecified repeatedly by the application, and used many times as the source for GL drawing and image\nspecification commands.\n\nDYNAMIC_READ The data store contents will be respecified repeatedly by reading\ndata from the GL, and queried many times by the application.\n\nDYNAMIC_COPY The data store contents will be respecified repeatedly by reading\ndata from the GL, and used many times as the source for GL drawing and\nimage specification commands.\n\nSo,\n\n```\n            | often   | often   |\n            | updated | queried |\n            | by app  | by app  |\n------------+---------+---------+\nSTREAM_DRAW |         |         |\nSTREAM_READ |         |         |\nSTREAM_COPY |         |         |\nSTATIC_DRAW |         |         |\nSTATIC_READ |         |    X    |\nSTATIC_COPY |         |         |\nDYNAMIC_DRAW|    X    |         |\nDYNAMIC_READ|         |    X    |\nDYNAMIC_COPY|         |         |\n------------+---------+---------+\n```\n\n\"reading data from the GL\" \u003d GPU Blit? So those should be private/managed. Queried often by the app \u003d \"glMap\" so should be shared?. It\u0027s not entirely clear if updated often by the app should be shared or managed/private since it might be faster to blit changes in and not break render passes.\n\nThe switch is just kind of mindlessly copied from the previous code, tho maybe I got it backward ðŸ˜…. Paying attention now thanks to your comment.\n\nIt\u0027s possible the team did some tests and found users were doing something that suggested picking one or the other lead to faster perf over all? Not sure. I\u0027ll ask.\n\nNote: I did some tests with private and found no perf difference across Intel/AMD/M1 but I\u0027m not sure my tests exercised the case where private is a win. Do you know of one or have a small metal sample that shows where private wins?\n\nWith private we\u0027d have to blit any changes by the app to the buffer via a staging buffer. And, if the app maps the texture we\u0027d have to provide a temp. With managed we just have to sync.",
      "parentUuid": "3eda9a69_a65f828c",
      "revId": "dcff856257a5c0bafc9c2e453dcb54cc8aa84886",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dc6f299_0b25ebd8",
        "filename": "src/libANGLE/renderer/metal/BufferMtl.mm",
        "patchSetId": 13
      },
      "lineNbr": 449,
      "author": {
        "id": 1115588
      },
      "writtenOn": "2022-10-11T16:53:07Z",
      "side": 1,
      "message": "Let me add, rather than talking abstractly, small, easily timed benchmarks can help us verify which path is fastest on which architecture. As it is, I don\u0027t have any tests. Maybe you can offer some, ideally angle_perftests.\n\nIt seems like we\u0027d need to make each of the 9 cases listed above, as in, STATIC_DRAW, a test that makes a bunch of buffers, never changes them, draws with them. Then with that test, test Shared, Managed, Private, for different sized buffers and see if one is a win\n\nSimilarly for STATIC_READ, write a test that \"queries often\" and check the various modes for various sized buffers.\n\netc... for each different behavior.",
      "parentUuid": "e5f7c672_8493b107",
      "revId": "dcff856257a5c0bafc9c2e453dcb54cc8aa84886",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}