{
  "comments": [
    {
      "key": {
        "uuid": "483f4af1_d0b607dc",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 456,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-06T19:38:18Z",
      "side": 1,
      "message": "this is wrong, I think. what happens if the type and format of the vertex attribute changes? We would need to re-stream. If this wasn\u0027t failing the bots, can you add a test that draws with a vertex attribute twice, with the same buffer, but with different type, and doesn\u0027t draw correctly?",
      "range": {
        "startLine": 456,
        "startChar": 3,
        "endLine": 456,
        "endChar": 68
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9b23db8_3ccbfcfd",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 456,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-07-07T05:59:45Z",
      "side": 1,
      "message": "I don\u0027t think it is wrong. I have added the tests in VertexAttributeTest.cpp as you required in the new patch: \n- UsingDifferentFormatAndSameBuffer tests if the update is success when only vertex format is changed.\n- NegativeUsingDifferentFormatAndSameBuffer draws twice with the same buffer and same data, but different format. \n\nThe reasons are as follows:\n\nIf the format changes but the buffer doesn\u0027t, mAttributeNeedsStreaming[attribIndex] remains to be the same value as it was in the last draw:\n- if buffer is both nullptr, mAttributeNeedsStreaming[attribIndex] is true in streamAttributes(), so the attribute will be streamed as it was in the last draw.\n- if buffer is both the same one, mAttributeNeedsStreaming[attribIndex] is false in streamAttribtues(), so the attribute won\u0027t be streamed as it was in the last draw.\n\nNote that even the format, binding and the attribPointer are ALL not changed (this leads to an early-return in the original code), we still needs to stream it to copy the data in client memory to mStreamingArrayBuffer as it did in the last draw.\n\nThat\u0027s exactly why mAttributeNeedsStreaming won\u0027t be cleared when the draw is completed.",
      "parentUuid": "483f4af1_d0b607dc",
      "range": {
        "startLine": 456,
        "startChar": 3,
        "endLine": 456,
        "endChar": 68
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d21eb44a_58526b7a",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 542,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-06T19:38:18Z",
      "side": 1,
      "message": "could this also trigger a re-stream?",
      "range": {
        "startLine": 542,
        "startChar": 20,
        "endLine": 542,
        "endChar": 38
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3905a6a3_1ba95025",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 542,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-07-07T05:59:45Z",
      "side": 1,
      "message": "I don\u0027t think the update in a format should trigger a re-stream. The reasons are as follows:\n- Only attribute enabled/disabled and buffer changes will trigger an update of mAttributesNeedStreaming, which is used in streamAttributes().\n- Only default VAO can use client memory pointer, but Vertex Attrib Binding APIs cannot be used on the default VAO, so it is impossible to call VertexAttribFormat alone on the default VAO using a client memory pointer.",
      "parentUuid": "d21eb44a_58526b7a",
      "range": {
        "startLine": 542,
        "startChar": 20,
        "endLine": 542,
        "endChar": 38
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2fae4cc3_3a28834b",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 602,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-06T19:38:18Z",
      "side": 1,
      "message": "would this possibly trigger a need for a re-stream?",
      "range": {
        "startLine": 601,
        "startChar": 0,
        "endLine": 602,
        "endChar": 26
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1681e515_9618dea3",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 602,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-07-07T05:59:45Z",
      "side": 1,
      "message": "It isn\u0027t allowed to use a zero buffer in BindVertexBuffer, bindVertexBuffer only accept buffer objects, so it won\u0027t trigger a re-stream.",
      "parentUuid": "2fae4cc3_3a28834b",
      "range": {
        "startLine": 601,
        "startChar": 0,
        "endLine": 602,
        "endChar": 26
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "206743ff_1d4a6a4a",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 677,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-07-06T19:38:18Z",
      "side": 1,
      "message": "I don\u0027t think we should have these ifs here. Either make them ASSERT, or we should fix it that dirty bits can\u0027t be set if we can\u0027t support them. In what case could we reach this code and supportsVertexAttribBinding be false?",
      "range": {
        "startLine": 677,
        "startChar": 11,
        "endLine": 677,
        "endChar": 45
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8903e88_cb698226",
        "filename": "src/libANGLE/renderer/gl/VertexArrayGL.cpp",
        "patchSetId": 34
      },
      "lineNbr": 677,
      "author": {
        "id": 1161747
      },
      "writtenOn": "2017-07-07T05:59:45Z",
      "side": 1,
      "message": "This is caused by the design of dirty bits in VertexArray.cpp: each dirty bit represents a dirty state not a GL call.\n\nAccording to SPEC, VertexAttribPointer can update 4 parts of a vertex attribute:\nformat, binding, attribBinding and attribPointer\nSo all these 4 dirty bits are set when VertexAttribPointer are called. That\u0027s why we reach here on the platforms that don\u0027t support Vertex Attrib Binding.\n\nOn platforms with Vertex Attrib Binding, I plan to use this API to replace VertexAttribPointer so that we can update format and binding separately, and even save the update to the format when only binding should be updated. \n\nVertexAttribDivisor is the same story: it can update 2 parts of a vertex attribute:\nattribBinding and bindingDivisor,\nSo both 2 dirty bits are set when VertexAttribDivisor are called.\nAs attribBinding cannot be updated in ES3.0, we are actually using VertexBindingDivisor to implement VertexAttribDivisor.\n\nIf you prefer a single bit to represent VertexAttribPointer, then we should add a dirty bit for VertexAttribDivisor too.",
      "parentUuid": "206743ff_1d4a6a4a",
      "range": {
        "startLine": 677,
        "startChar": 11,
        "endLine": 677,
        "endChar": 45
      },
      "revId": "8aa0add222b4ff50d565e58c4769f5ab98ebcf02",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}