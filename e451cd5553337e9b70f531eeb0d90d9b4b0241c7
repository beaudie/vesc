{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c69f5e90_c15e8735",
        "filename": "/COMMIT_MSG",
        "patchSetId": 23
      },
      "lineNbr": 14,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "persistent typo:\n\n\"has been used\" like \"has gone there\"\n\"is be**ing** used\" like \"is go**ing** there\"",
      "range": {
        "startLine": 14,
        "startChar": 58,
        "endLine": 14,
        "endChar": 62
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2007c48f_55a7471f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 23
      },
      "lineNbr": 17,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2022-11-28T23:01:41Z",
      "side": 1,
      "message": "Would you mind elaborating why we need to reserve a range of serials for `outsideRenderPassCommands`? It is not clear to me why we can\u0027t generate a new queueSerial for `outsideRenderPassCommand` when we need to. Is it because we have to make sure the queueSerials used in `outsideRenderPassCommands` have to be smaller than the `RenderPassCommands`?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dd9927a_fec1b3c0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 23
      },
      "lineNbr": 17,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T23:49:50Z",
      "side": 1,
      "message": "All queueSerial send to CommandQueue must maintain order (i.e, monotonically incrementing). This is similar to wall clock time, that future time must be bigger than current time. For ANGLE, we have two command buffers, one is outsideRPCommands and another is RPCommands. OutsideRP always get submitted before RPCommands. Once we create a RPCommands, we generate a serial number for RPCommands, lets say RPCommands get serial number 12, and outsideRPCommands gets serial number 11. Now if you submit outsideRPCommands *without* submit RPCommands, what will be the new outsideRPCommands\u0027s serial be? It must be \u003c12, but there is no number left since it just used 11. The only choice now is to endRP and submit RP as well. EndRP has performance cost since GPU will have to flush out tile memory etc. In order to avoid this situation, when we generate a serial for RPCommand, we reserve a range of serials for outsideRPCommands. Lets say RPCommdns get 28 and outsideRPCommands have 11, and we have 12,13,...,27 reserved but unused. Now if you have to submit outsideRPCommands, you can submit 11, get 12, and submit 12, get 13,..., while we still keep all submission serial monotonically incrementing and outsideRPCommdns use smaller serial than corresponding RPCommands. If you keep subitting outsideRPCommands, and uses up all reserved serial, then you will have to endRP and submit RPCommands as well. But that is expected to be very rare, close to impossible in real usage case.\n(Feel free to ping me off line if you need more explanation).",
      "parentUuid": "2007c48f_55a7471f",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7a40bda_6a00191e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 23
      },
      "lineNbr": 17,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6dd9927a_fec1b3c0",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2eb41312_67cbcdce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 23
      },
      "lineNbr": 17,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2022-11-30T18:22:50Z",
      "side": 1,
      "message": "Thank you Charlie, this great explanation.",
      "parentUuid": "6dd9927a_fec1b3c0",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2031310_b71d201f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 23
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:23:50Z",
      "side": 1,
      "message": "Generally speaking, how do you deal with context changes resulting in different serials?\n\nTake this test for example:\n\n- Make context 1 current on thread 1 -\u003e gets queue index 0\n- Make context 2 current on thread 2 -\u003e gets queue index 1\n- On thread 2:\n  * Make a small submission \u003c- Queue index 0 now has last submitted serial 0\n- On thread 1:\n  * Wait for thread 2\n  * Make numerous submissions \u003c- Queue index 1 now has last submitted serial N\n  * Write to buffer B \u003c- Buffer B gets serial N+1\n- Make context 1 and 2 uncurrent\n- Make context 2 current on any thread -\u003e gets queue index 0\n- Make context 1 current on another thread -\u003e gets queue index 1\n- Map buffer B on context 1\n\nIIUC, once context 1 is made current again and gets queue index 1, it thinks that its last submitted serial is 0, while buffer B thinks its last used in submission N+1. Then the \"map\" operation is not going to wait for anything.\n\nDid I misunderstand something?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "309a2efe_5b17f11c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 23
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "makeCurrent will sync the lastSubmittedQueueSerial back. See ContextVk::allocateQueueSerialIndex() implementation. So it will have the same view regarding to lastSubmittedQueueSerial.\n\nNote that in this case, after write to bufferB, bufferB\u0027s mReadWriteUse will have QueueSerial\u003d{1, N+1}. Then when ctx1 gets index1, it calls map(). It sees mReadWriteUse and will wait for this QueueSerial{1,N+1} to finish, regarless which ctx submitted it.\n\nAs to who did queueSubmit the bufferWrite to vulkan, when ctx2 becomes uncurrent it will flush out all commands.",
      "parentUuid": "a2031310_b71d201f",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2eb0f8d_0ea81348",
        "filename": "src/libANGLE/renderer/serial_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 174,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Please also outline here what ANGLE does if that does happen.\n\nCould we instead use an `angle::FastVector` so this can be a smaller number like 16, but also allow infinite growth?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "332a0cd8_dc8eec5a",
        "filename": "src/libANGLE/renderer/serial_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 174,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Use FastVector requires us to protected the access with a lock, since FastVector may reallocate the storage. We can design a way to avoid mutex lock by keeping the previous storage (i.e., sort of stash away the old storage while keep allocating bigger storage). But I want to reserve that until we find a reasonable real world usage case that we have to support. I don\u0027t believe any real usage will ever have 256 threads and each thread has an active context (IMHO, this number likely can be much smaller, but I just a bit safe here).\n\nWill update the comment in next update with \"...not a reasonable usage case, and context creation will fail if exceeds).",
      "parentUuid": "b2eb0f8d_0ea81348",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a954ca8d_5ec0eb01",
        "filename": "src/libANGLE/renderer/serial_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 174,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-29T16:13:50Z",
      "side": 1,
      "message": "As long as context creation fails with a clear message (please add an ERR() log if not already), we can defer that to after your work is finished.\n\nThat said, the solution is quite simple IMO. You can create a `SafeFastVector` that:\n\n- For index\u003cN, uses an embedded std::array\n- For index\u003e\u003dN, uses a std::vector at index-N, and all access to the vector is protected by a mutex.\n\nSo for the normal case of context count \u003c N, there\u0027s no mutex used, at the same time we are not bound by any artificial limits (and the size() would also be smaller in the normal case)",
      "parentUuid": "332a0cd8_dc8eec5a",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a27f174_d0604d12",
        "filename": "src/libANGLE/renderer/serial_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 174,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Lets defer support of more than 256 current context in single process to future, when you actually can find a valid reason for it. For one thing, SafeFastVector will eat an if statement for every check.\n\nErr() added.",
      "parentUuid": "a954ca8d_5ec0eb01",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "12aaad03_23e34b48",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 78,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2022-11-28T19:39:43Z",
      "side": 1,
      "message": "should we rename `mLastCompletedSerials` to `lastCompletedSerials`? since `prefix m` is usually used for class members.",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bcb3462d_b64e1bc9",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 78,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Good catch, yuxin!",
      "parentUuid": "12aaad03_23e34b48",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b562b6a7_b99216b6",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1040,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "I suggest not trying to optimize for the crazy case of hundreds of threads, and avoid templatizing this. That would also help with removing the `kMaxQueueSerialIndexCount` limit.\n\nIn the `retireFinishedCommands` function, just have an `angle::FastVector` where you append the finished serials, and then iterate that. No need for a bitset.",
      "range": {
        "startLine": 1035,
        "startChar": 0,
        "endLine": 1040,
        "endChar": 37
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efc87e6a_6ac1356c",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1040,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "This is not try to optimize \"crazy case of hundreds of threads\", but try to optimize the less than 64 threads case (for example, 2 or 3 contexts which is very reasonable usage case).",
      "parentUuid": "b562b6a7_b99216b6",
      "range": {
        "startLine": 1035,
        "startChar": 0,
        "endLine": 1040,
        "endChar": 37
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d3f680a_d56183b6",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1040,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-28T18:53:47Z",
      "side": 1,
      "message": "By optimization, I meant the attempt to use a bitset array. My point exactly is that since the normal case has 2 or 3 contexts, you could just use an array (FastVector) of them instead of a bitset to track things. Then you won\u0027t need this sort of strange templating. That also reduces one variation to test for (like, right now the else case is untested)",
      "parentUuid": "efc87e6a_6ac1356c",
      "range": {
        "startLine": 1035,
        "startChar": 0,
        "endLine": 1040,
        "endChar": 37
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dff165a8_e1c68651",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1040,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T21:20:29Z",
      "side": 1,
      "message": "For this one, fastVector probably should perform as good as bitmask. The main reason I used bitmask here is for symetrical with getBatchCountUpToSerials. In that function, if you look, I am trying to avoid a nested for loop. I I am using the bitmask to bail out early when I have found a command that satisfies all serials in the mUse. What I am thinking in the follow up CL is to pass that bitmask directly to here. But anway, I can switch to festvector here and revsit it in follow up CL if necessary.",
      "parentUuid": "3d3f680a_d56183b6",
      "range": {
        "startLine": 1035,
        "startChar": 0,
        "endLine": 1040,
        "endChar": 37
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91a586ea_b92b8969",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1040,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dff165a8_e1c68651",
      "range": {
        "startLine": 1035,
        "startChar": 0,
        "endLine": 1040,
        "endChar": 37
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8e38af8_d8d1dd43",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1176,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "!",
      "range": {
        "startLine": 1176,
        "startChar": 33,
        "endLine": 1176,
        "endChar": 57
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "126ded07_31c0ad04",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1176,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c8e38af8_d8d1dd43",
      "range": {
        "startLine": 1176,
        "startChar": 33,
        "endLine": 1176,
        "endChar": 57
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e37f864c_c58e8b69",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1394,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Is it no longer possible to have a submission with out a fence?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1d084d3_1e87910e",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1394,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "This is oneOff submission code path. Without a fence, it makes mInFlightCommands related code more complicated. I am actually not sure if this is required or not, but I am not seeing any reason to not consistently have a fence.\n\nMy guess is that \"no fence\" was necessary because of previously the normal submission has to do deferred queueSerial generation. With this new queueSerial tracking, oneoff submission is almost identical to normal submission (except it gets its own queueIndex). The oneOff submisison code path will be further simplified in the follow up CL, see https://chromium-review.googlesource.com/c/angle/angle/+/4053261",
      "parentUuid": "e37f864c_c58e8b69",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64f39348_4778c17a",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1394,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-29T16:13:50Z",
      "side": 1,
      "message": "Thanks, a comment would be helpful.",
      "parentUuid": "c1d084d3_1e87910e",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5dcfb545_5b62b0f6",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1394,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "64f39348_4778c17a",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "012a1660_0ab5e21c",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1511,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Similarly, I\u0027d say don\u0027t templatize this. Just use an `angle::FastVector` instead of the bitset, it\u0027s gonna have like 2 values in it anyway. I realize bitset would be faster if there are a hundred threads, but that also never happens.\n\nYou could always microoptimize by using a bitset for the first 64 indices and a vector for the rest, but honestly given that that path would never get exercised, I wouldn\u0027t even bother.",
      "range": {
        "startLine": 1503,
        "startChar": 0,
        "endLine": 1511,
        "endChar": 30
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56982550_3bfc9a51",
        "filename": "src/libANGLE/renderer/vulkan/CommandProcessor.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1511,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "This will be more costly without using bitset though. With bitset, I can quickly early out when all indices have been identified. Otherwise, I will have to loop through FastVector to find the same answer. \n\nAlso, angle::BitSetArray should have been unit tested to work exactly like angle::BitSet64, so this actually is safer doing it this way.",
      "parentUuid": "012a1660_0ab5e21c",
      "range": {
        "startLine": 1503,
        "startChar": 0,
        "endLine": 1511,
        "endChar": 30
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4348c29b_31552697",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5458,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Can\u0027t this be an ASSERT?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c142cab_f3b8c25a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5458,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "On context destrouction, you will hit assertion if you turn it into assertion. We might able to turn it into assertion this in future if we are willing to dig more into the call sequence during context destruction.",
      "parentUuid": "4348c29b_31552697",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff1e672a_483778ab",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5458,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-29T16:13:50Z",
      "side": 1,
      "message": "Sounds like a bug. The context being destroyed is becoming momentarily current on destruction, if the index is not invalid, it could mean that the queue serial index was never given back.\n\nLooking at `Display::makeCurrent`, it could also be that a context that\u0027s current is being set to current again, and that\u0027s causing this. If so, you should be able to reproduce the assert with a test that calls `eglMakeCurrent` twice with the same parameters (or at least the same context). If that\u0027s the case, this might be enough to fix it:\n\n```\n     if (context !\u003d nullptr)\n     {\n-        ANGLE_TRY(context-\u003emakeCurrent(this, drawSurface, readSurface));\n         if (contextChanged)\n         {\n+            ANGLE_TRY(context-\u003emakeCurrent(this, drawSurface, readSurface));\n             context-\u003eaddRef();\n         }\n     }\n```",
      "parentUuid": "6c142cab_f3b8c25a",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20a963d5_116e8da0",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5458,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Lets deal with that in follow up CL. I am more than happy to turn it into assert, but we do not need to deal with everything in this CL.",
      "parentUuid": "ff1e672a_483778ab",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59be84d3_2bc86a3d",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5506,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Can\u0027t this be an ASSERT?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca5dd9e3_670eb602",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5506,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Same as the other comment. Something to do with context init/destroy.",
      "parentUuid": "59be84d3_2bc86a3d",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96798574_97bf0fc7",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5506,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-29T16:13:50Z",
      "side": 1,
      "message": "It could be because `Context::onDestroy` is calling `unMakeCurrent` unconditionally but the context may not be current. Could probably be fixed by tracking whether context is current and avoiding the call when unnecessary. (Similar to `mHasBeenCurrent`)",
      "parentUuid": "ca5dd9e3_670eb602",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66fe5df3_ab932f00",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 5506,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Same as the other comment. Lets defer this to follow up CL.",
      "parentUuid": "96798574_97bf0fc7",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c4a02d1_acfea822",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7023,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "It\u0027s starting to get a little confusion, why are there two render pass serials?",
      "range": {
        "startLine": 7022,
        "startChar": 72,
        "endLine": 7023,
        "endChar": 29
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73b42b7d_08c7bb5f",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7023,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:18:17Z",
      "side": 1,
      "message": "confusing*\n\nNever mind, just saw the next CL",
      "parentUuid": "1c4a02d1_acfea822",
      "range": {
        "startLine": 7022,
        "startChar": 72,
        "endLine": 7023,
        "endChar": 29
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd505484_28811255",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7109,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "`flushOutsideRenderPassCommands` _does_ call `generateOutsideRenderPassCommandsQueueSerial`. Can this be removed?",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df8e4949_562d5866",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7109,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T02:02:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dd505484_28811255",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89043b80_77ad81bd",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7158,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "outsideR",
      "range": {
        "startLine": 7158,
        "startChar": 23,
        "endLine": 7158,
        "endChar": 28
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ff2fd25_c1aae84e",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7158,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "89043b80_77ad81bd",
      "range": {
        "startLine": 7158,
        "startChar": 23,
        "endLine": 7158,
        "endChar": 28
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06b73004_c6e3079e",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7391,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Shouldn\u0027t this be done after the `flushOutsideRPCommands` call below? Otherwise this is going to be an infinite recursion.\n\nPlease add a basic test to make sure this path is at least minimally tested. See how the `SubmittingOutsideCommandBufferDoesNotCollectRenderPassGarbage` counter test works by uploading until a number of submissions are done. You could do something similar to make sure render pass break happens correctly.",
      "range": {
        "startLine": 7384,
        "startChar": 0,
        "endLine": 7391,
        "endChar": 5
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f09eb9d6_008359d3",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7391,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Either way should work, I think. The reason I did it here is because flushCommandsAndEndRenderPass also calls flushOutsideRPCommands. Since this is a more heavy handed code path, so might just do it early and take early out.\n\nRegarding test, right, I will add a test. The way I have tested so far is essentially reduce kMaxReservedOutsideQueueSerials to 1 and there are a few tests failed, including SubmittingOutsideCommandBufferDoesNotCollectRenderPassGarbage, because it is rely on the implementation detail how we do the flush/submit. Yes, it is my plan to expand the test to cover this.",
      "parentUuid": "06b73004_c6e3079e",
      "range": {
        "startLine": 7384,
        "startChar": 0,
        "endLine": 7391,
        "endChar": 5
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b21e177_49392e74",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7391,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-29T16:13:50Z",
      "side": 1,
      "message": "\u003e Either way should work, I think. The reason I did it here is because flushCommandsAndEndRenderPass also calls flushOutsideRPCommands.\n\nThat\u0027s exactly the problem, `flushCommandsAndEndRenderPass` calls `flushOutsideRPCommands`, which is this function itself, hence infinite recursion (unless somehow mOutsideRenderPassSerialFactory.empty() is stopping it?)",
      "parentUuid": "f09eb9d6_008359d3",
      "range": {
        "startLine": 7384,
        "startChar": 0,
        "endLine": 7391,
        "endChar": 5
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7ce9a9c_79aa8f55",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 7391,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T02:02:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1b21e177_49392e74",
      "range": {
        "startLine": 7384,
        "startChar": 0,
        "endLine": 7391,
        "endChar": 5
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f086020_0769658f",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1567,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "nit: OutsideRenderPass (otherwise it\u0027s reading \"outside queue\")",
      "range": {
        "startLine": 1567,
        "startChar": 40,
        "endLine": 1567,
        "endChar": 47
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "276b4d67_f1ca8228",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1567,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5f086020_0769658f",
      "range": {
        "startLine": 1567,
        "startChar": 40,
        "endLine": 1567,
        "endChar": 47
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33e86423_c73fe60f",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1631,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Please move any of these that is only called by ContextVk in ContextVk.cpp.",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a561799_b64233e9",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1631,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33e86423_c73fe60f",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b475f15_8a4b3fb6",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1634,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "nit: I\u0027d call this `mCurrentQueueIndex` or `mCurrentQueueSerialIndex` to be clear it\u0027s the queue index, not the serial index.",
      "range": {
        "startLine": 1634,
        "startChar": 51,
        "endLine": 1634,
        "endChar": 70
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28615b30_955d7579",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1634,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "mCurrentQueueSerialIndex sounds fine to me.",
      "parentUuid": "5b475f15_8a4b3fb6",
      "range": {
        "startLine": 1634,
        "startChar": 51,
        "endLine": 1634,
        "endChar": 70
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e6ebd8f_11f40a59",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 23
      },
      "lineNbr": 1634,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "28615b30_955d7579",
      "range": {
        "startLine": 1634,
        "startChar": 51,
        "endLine": 1634,
        "endChar": 70
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b7bae50_4139518c",
        "filename": "src/libANGLE/renderer/vulkan/ResourceVk.h",
        "patchSetId": 23
      },
      "lineNbr": 23,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Could you please create a (parameterized) test that exercises N threads each doing their own work? And another where the N threads are in a share group, and they all use the same texture.\n\nJust to make sure the rare paths are also exercised in tests (otherwise someone\u0027s bound to regress them)",
      "range": {
        "startLine": 23,
        "startChar": 13,
        "endLine": 23,
        "endChar": 33
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd3cd1fd_97c127fe",
        "filename": "src/libANGLE/renderer/vulkan/ResourceVk.h",
        "patchSetId": 23
      },
      "lineNbr": 161,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "nit: this function could probably use a better name now (in a follow up)",
      "range": {
        "startLine": 161,
        "startChar": 9,
        "endLine": 161,
        "endChar": 23
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fa3b57a_8f6f6bff",
        "filename": "src/libANGLE/renderer/vulkan/ResourceVk.h",
        "patchSetId": 23
      },
      "lineNbr": 161,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Totally agree. That is also in my plan of follow up CLs.",
      "parentUuid": "fd3cd1fd_97c127fe",
      "range": {
        "startLine": 161,
        "startChar": 9,
        "endLine": 161,
        "endChar": 23
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4dcf6a1_83825a20",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 192,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Please adjust the comment above. The second paragraph says all contexts are flushed, not just the one that used the sync object, but this change is actually making the optimization mentioned there a reality.",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b386559_e89b9283",
        "filename": "src/libANGLE/renderer/vulkan/SyncVk.cpp",
        "patchSetId": 23
      },
      "lineNbr": 192,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d4dcf6a1_83825a20",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b38ce32_2def84d2",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1500,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "Maybe worth mentioning that this can cause unnecessary outside RP command flushes (because a resource may think it\u0027s accessed by an outside RP command buffer based on the serial, but it\u0027s not actually).\n\nIn the very least, that could lead to less memory barrier aggregation.",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73e15d8c_846dce0a",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 23
      },
      "lineNbr": 1500,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Some test will be break if you do that.",
      "parentUuid": "3b38ce32_2def84d2",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfdca976_95dfc667",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 198,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "nit: `set()` is clearer",
      "range": {
        "startLine": 198,
        "startChar": 30,
        "endLine": 198,
        "endChar": 34
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f46908e4_e724969f",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 198,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bfdca976_95dfc667",
      "range": {
        "startLine": 198,
        "startChar": 30,
        "endLine": 198,
        "endChar": 34
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68b47a40_1ccfecd2",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 207,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "How will the caller handle this?",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 207,
        "endChar": 9
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df065a4b_8fe5750b",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 207,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Context creation will fail. See the other comment about max allowed current context being 256.",
      "parentUuid": "68b47a40_1ccfecd2",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 207,
        "endChar": 9
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2e53e28_80cc408b",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 207,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "ERR() has been added.",
      "parentUuid": "df065a4b_8fe5750b",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 207,
        "endChar": 9
      },
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "264fd3d3_be1440d8",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 231,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-11-24T19:11:53Z",
      "side": 1,
      "message": "You could use a pair of bitset (for smaller indices) and a free list so you\u0027re not limited to `kMaxQueueSerialIndexCount`.",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2269902_80fc2e0c",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-28T18:47:52Z",
      "side": 1,
      "message": "Same as the other comment.",
      "parentUuid": "264fd3d3_be1440d8",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d396e34_259dc58a",
        "filename": "src/libANGLE/renderer/vulkan/vk_utils.h",
        "patchSetId": 23
      },
      "lineNbr": 231,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2022-11-30T01:21:27Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c2269902_80fc2e0c",
      "revId": "e451cd5553337e9b70f531eeb0d90d9b4b0241c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}