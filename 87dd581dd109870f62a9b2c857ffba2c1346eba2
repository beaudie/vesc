{
  "comments": [
    {
      "key": {
        "uuid": "a2b937da_7902c7ef",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1001641
      },
      "writtenOn": "2015-02-26T14:06:46Z",
      "side": 1,
      "message": "Are you sure that it absolutely never returns true, even in a subset of cases? This seems really odd.",
      "range": {
        "startLine": 9,
        "startChar": 62,
        "endLine": 9,
        "endChar": 67
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2108f97_e6d720f8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1121008
      },
      "writtenOn": "2015-02-26T14:31:04Z",
      "side": 1,
      "message": "I haven\u0027t tested it for all possible NANs, I tested it for all values generated by dEQP tests and it was always returning false.\n\nmediump and lowp isnan tests were passing earlier as well. But when I looked at the test source, I found that for mediump and lowp, it just check if isnan returns true or false, it doesn\u0027t check exact value i.e. true for NANs and false for valid numbers. I also tried modifying test source so that it checks exact output values for lowp/mediump tests and then all the tests were failing because isnan was returning false for all the tests.\n\nI mainly verified this by inspecting individual bits in input and output values pointers for each test.",
      "parentUuid": "a2b937da_7902c7ef",
      "range": {
        "startLine": 9,
        "startChar": 62,
        "endLine": 9,
        "endChar": 67
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42c87b75_d60f2459",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 392,
      "author": {
        "id": 1001641
      },
      "writtenOn": "2015-02-26T14:06:46Z",
      "side": 1,
      "message": "This is unnecessary, the other masking commands to get the exponent and mantissa also filter out the sign bit.",
      "range": {
        "startLine": 391,
        "startChar": 9,
        "endLine": 392,
        "endChar": 42
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2108f97_c6d4a4f6",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 392,
      "author": {
        "id": 1121008
      },
      "writtenOn": "2015-02-26T14:31:04Z",
      "side": 1,
      "message": "Ok will do this in next patch set.",
      "parentUuid": "42c87b75_d60f2459",
      "range": {
        "startLine": 391,
        "startChar": 9,
        "endLine": 392,
        "endChar": 42
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42c87b75_5635d4ff",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 394,
      "author": {
        "id": 1001641
      },
      "writtenOn": "2015-02-26T14:06:46Z",
      "side": 1,
      "message": "Code formatting nit: remember spaces around operators! Could also consider just writing this out as a hexadecimal number.",
      "range": {
        "startLine": 394,
        "startChar": 24,
        "endLine": 394,
        "endChar": 40
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22ee27c7_b0343654",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 394,
      "author": {
        "id": 1121008
      },
      "writtenOn": "2015-02-26T14:31:04Z",
      "side": 1,
      "message": "Ok, will add necessary spaces. \nI personally found it readable than hex number but let me know if think having hex numbers is better and I will do that.",
      "parentUuid": "42c87b75_5635d4ff",
      "range": {
        "startLine": 394,
        "startChar": 24,
        "endLine": 394,
        "endChar": 40
      },
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a22bf7c1_29210d19",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 405,
      "author": {
        "id": 1001641
      },
      "writtenOn": "2015-02-26T14:06:46Z",
      "side": 1,
      "message": "I think that this kind of implementation fails if isnan(float) and isnan(vec2) are used in the same shader - the webgl_isnan helper function would be defined twice.\n\nIt would be better to have each webgl_isnan_emu implementation to be a single function in the final generated code, though I think it\u0027s okay if you use a C++ macro to reduce code duplication. You should also try to use the component-wise operators and built-ins to process the whole vector at once to get decent performance.",
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2108f97_460274ef",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 405,
      "author": {
        "id": 1121008
      },
      "writtenOn": "2015-02-26T14:31:04Z",
      "side": 1,
      "message": "Thanks for catching this, I did not think about having two variants used in same function. Will modify code accordingly.\nI am still grasping comment about using component-wise operators and built-ins so will comment on this later.",
      "parentUuid": "a22bf7c1_29210d19",
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42c87b75_16319ce6",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 405,
      "author": {
        "id": 1001641
      },
      "writtenOn": "2015-02-26T14:52:30Z",
      "side": 1,
      "message": "To clarify using component-wise operators, you can do things like this:\n\nuint4 a, mask;\nuint4 masked \u003d a \u0026 mask; // the \u0026 operation is done for each component individually, so this masks all 4 components simultaneously.\n\nI think pretty much all operators are component-wise in HLSL. In GLSL some of the component-wise operations are available as corresponding functions, like equal();",
      "parentUuid": "e2108f97_460274ef",
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22738725_48029f88",
        "filename": "src/compiler/translator/BuiltInFunctionEmulatorHLSL.cpp",
        "patchSetId": 1
      },
      "lineNbr": 405,
      "author": {
        "id": 1121008
      },
      "writtenOn": "2015-02-27T05:58:11Z",
      "side": 1,
      "message": "Thanks for the clarification olli, I have uploaded updated patch set.",
      "parentUuid": "42c87b75_16319ce6",
      "revId": "87dd581dd109870f62a9b2c857ffba2c1346eba2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}