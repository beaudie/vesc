{
  "comments": [
    {
      "key": {
        "uuid": "91880b96_0a1233fd",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1135559
      },
      "writtenOn": "2019-11-27T05:05:07Z",
      "side": 1,
      "message": "Hi, Geoff@,\nFor zeroTextures, the most simple (but tricky) way is to create zero video texture before texture 2D and Cube Map to prevent the destroy. Since video texture doesn\u0027t have initial texture concept, it is Ok for zero video texture be unbound by texture 2D (Pls correct me if I\u0027m wrong)\nWDYT?",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7c2b6f2_36d915f8",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-11-27T16:40:39Z",
      "side": 1,
      "message": "I\u0027m sorry but I don\u0027t understand the issue, why would creating this destroy another texture?  The order that these objects are created should not matter.",
      "parentUuid": "91880b96_0a1233fd",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f540f2cf_ce55d271",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1135559
      },
      "writtenOn": "2019-11-28T00:39:57Z",
      "side": 1,
      "message": "Sry.Let me provide more background about this special texture type.\n\nGL_TEXTURE_VIDEO_IMAGE_WEBGL is not a texture target that exists in OpenGLES/OpenGL. It will be mapped to GL_TEXTURE_2D, GL_TEXTURE_EXTERNAL_OES or GL_TEXTURE_RECTANGLE on different OS. \n\nWhen we create a zeroTexature for VideoImage(VIDEO_IMAGE_WEBGL), it will invoke createTexture, which will invoke glBindTexture function and been bound as its native type. \n\nPer my understanding, all zero texatures are bound to 0 texture unit with different texture type previously. But when we add VideoImage and create its zeroTexture after 2D zeroTexature creation, a native glBindTexture call with its real native texture type(e.g. TEXTURE_2D, TEXTURE_EXTERNAL_OES or TEXTURE_RECTANGLE) will unbound previous texture object. For example it looks like the following operation on gl renderer:\n//Create GL_TEXTURE_2D zeroTexture\nglActiveTexture(GL_TEXTURE0);\nglGenTexture(1, \u0026zero2DTexture);\nglBindTexture(TEXTURE_2D, zero2DTexture);\n\n//Create GL_TEXTURE_VIDEO_IMAGE_WEBGL zeroTexture but mapping to GL_TEXTURE_2D in native.\nglActiveTexture(GL_TEXTURE0);\nglGenTexture(1, \u0026zeroVideoTexture);\nglBindTexture(TEXTURE_2D, zeroVideoTexture).\n\nAs you can see, it will unbound previous zero2DTexture.\n\nIn most cases, it won\u0027t trigger issue. But in OpenGLES 1.x, it GL_TEXTURE_2D, quote from OpenGLES spec:\n    // [OpenGL ES 2.0.24] section 3.7 page 83:\n    // In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have two-dimensional\n    // and cube map texture state vectors respectively associated with them.\n    // In order that access to these initial textures not be lost, they are treated as texture\n    // objects all of whose names are 0.\nthis will trigger a issue because the \"initial texture\" has been unbound. And this issue has been caught by angle GLES1 conformance tests(e.g. PointSprite, TexCombine).\nSo, I think we should create zeroTexture for VideoImage before we create zeroTexture for 2D.\n\nWDYT?",
      "parentUuid": "f7c2b6f2_36d915f8",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "135ac3cc_7965603e",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-11-28T15:43:18Z",
      "side": 1,
      "message": "Ok, I understand but this is not an issue.  A texture will only be deleted when another is bound IF the texture has already been deleted with glDeleteTextures.  We don\u0027t call glDeleteTextures until Texture::~Texture is called which will not happen until the context is destroyed.  You are safe here.\n\nYou can think of textures as ref-counted objects.  glGenTextures adds a ref and glDeleteTextures removes one.  While a texture is bound, a ref is also added. It is not possible to remove the last reference until glDeleteTextures is called.  You also cannot delete the zero texture.",
      "parentUuid": "f540f2cf_ce55d271",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c0da7d5_fd6e23dc",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1135559
      },
      "writtenOn": "2019-11-29T02:12:37Z",
      "side": 1,
      "message": "Geoff@ : First, thanks for your replying. This comments is a bit long so apologize and thanks for your time first.\n\nYes, I understand this. And you\u0027re right about we cannot delete a zeroTexture object. And I suddenly realized the root cause about this issue maybe the state manager doesn\u0027t know the native texture has been unbound. So maybe I can notify state manager about this to avoid such issue. \n\nBut I still want to explain more about this with the failure reason of PointSprite case in GLES1 to show why bind-unbind issue breaks the case.\nTo brief describe it:\ntexture 1 means zeroTexture object of 2D.\ntexture 2 means zeroTexture object of VideoImage.\n\n// ANGLE status after context initialization\nNative:   TEXTURE2D \u003c- bound with texture 2 and texture 1 has been unbound.\n\n\n// 1st round : PointSpirte call glTexImage2D\n----------------------------------\nANGLE:\n      mActiveTextureUnit \u003d 0;\n      check mTextures[2D][0] \u003d\u003d texture 1; // it is true.\n      Skip call native bindTexture so that texture 2 keep binding on texture unit 0 TEXTURE_2D.\n      do setImage \u003c- texture 2, the videoImage zeroTexture accept all the values.\n----------------------------------------------------------------\n// 1st round: PointSprite call glDrawArrays\n--------------------------------------------------------\nANGLE:\n       Update and prepare resources for draw.\n       active texture unit 0-6.\n       mActiveTextureUnit \u003d 6; \u003c- with TEXTURE_CUBE zero texture bound.\n       check mTextures table and the table says texture 1 is bound on texture unit 0 TEXTURE_2D.\n       so skip call native binding for texture 1.\n       texture unit 0 \u003c- Actually, in native, bound with texture 2, the videoImage zero texture\n       sampling 0 and draw.\n\n----------------------------------------------------------------\n// 2nd round: PointSprite call glTexImage2D\n----------------------------------------------------------------\nANGLE:\n       mActiveTextureUnit \u003d 6;\n       check mTextures[2D][6] and it is not equal to texture 1.\n       invoke glBindTexture(TEXTURE_2D, texture 1) in native.\n       do setImage \u003c- texture 1, the 2D zeroTexture accept all the values.\n-------------------------------------------------------------------\n// 2nd round PointSprite call glDrawArrays\n--------------------------------------------------------------------\n       Update and prepare resources for draw.\n       active texture unit 0-6.\n       mActiveTextureUnit \u003d 6; \u003c- with TEXTURE_CUBE zero texture bound.\n       check mTextures table and the table says texture 1 is bound on texture unit 0 TEXTURE_2D.\n       so skip call native binding for texture 1.\n       texture unit 0 \u003c- Actually, in native, still bound with texture 2, the videoImage zero texture\n       sampling 0 and draw. \u003c- in this round, texture 2 doesn\u0027t have correct value, so fail the case\n\n\nIt is a bit complicated so I want to describe more about why it works previously and why D3D backend doesn\u0027t hit this.\n\nWithout VideoImage zero texture creation, texture 1 will always bound on texture unit 0 in native. In the second round run of PointSprite. texture unit 6 will be actived and texture 1 will be bound to accept values. Then running pipeline, on texture unit 0, it is still texture 1 that been bound on it (With VideoImage zero texture, texture unit 0 has been replaced to texture 2 actually).\nSo, we can still get correct values.\nThe corresponding brief explain:\ntexture 1 means zeroTexture object of 2D.\ntexture 2 means zeroTexture object of VideoImage.\n\n// ANGLE status after context initialization\nNative:   TEXTURE2D \u003c- bound with texture 1\n\n// 1st round : PointSpirte call glTexImage2D\n----------------------------------\nANGLE:\n      mActiveTextureUnit \u003d 0;\n      check mTextures[2D][0] \u003d\u003d texture 1; // it is true.\n      Skip call native bindTexture so that texture 1 keep binding on texture unit 0 TEXTURE_2D.\n      do setImage \u003c- texture 1, the 2D zeroTexture accept all the values.\n----------------------------------------------------------------\n// 1st round: PointSprite call glDrawArrays\n--------------------------------------------------------\nANGLE:\n       Update and prepare resources for draw.\n       active texture unit 0-6.\n       mActiveTextureUnit \u003d 6; \u003c- with TEXTURE_CUBE zero texture bound.\n       check mTextures table and the table says texture 1 is bound on texture unit 0 TEXTURE_2D.\n       so skip call native binding for texture 1.\n       texture unit 0 \u003c- Actually, in native, bound with texture 1, the 2D zero texture\n       sampling 0 and draw.\n\n----------------------------------------------------------------\n// 2nd round: PointSprite call glTexImage2D\n----------------------------------------------------------------\nANGLE:\n       mActiveTextureUnit \u003d 6;\n       check mTextures[2D][6] and it is not equal to texture 1.\n       invoke glBindTexture(TEXTURE_2D, texture 1) in native.\n       do setImage \u003c- texture 1, the 2D zeroTexture accept all the values.\n-------------------------------------------------------------------\n// 2nd round PointSprite call glDrawArrays\n--------------------------------------------------------------------\n       Update and prepare resources for draw.\n       active texture unit 0-6.\n       mActiveTextureUnit \u003d 6; \u003c- with TEXTURE_CUBE zero texture bound.\n       check mTextures table and the table says texture 1 is bound on texture unit 0 TEXTURE_2D.\n       so skip call native binding for texture 1.\n       texture unit 0 \u003c- in native, still bound with texture 1, the 2D zero texture\n       sampling 0 and draw. \u003c- in this round, texture 1 still have correct value, so pass the case\n\n\n\nOn D3D backends, ANGLE just return a texture object and no bound happens. So it won\u0027t hit this bound-unbound issue.\n\nThis is a bit long and thanks for your time. Hope it can make things clear. And I\u0027ll upload the patch to let state manager knows what happens exactly in native when binding VideoImage.",
      "parentUuid": "135ac3cc_7965603e",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e7c1a58_a0ea642f",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2019-12-02T16:02:52Z",
      "side": 1,
      "message": "Ok, I think I understand the problem.  StateManagerGL should be tracking the state of the native GL driver and not know about the emulated video textures. I suggested the fix.",
      "parentUuid": "6c0da7d5_fd6e23dc",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d6e38fe_fbaebcbc",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1135559
      },
      "writtenOn": "2019-12-03T04:11:41Z",
      "side": 1,
      "message": "Thanks for your time on this and suggestions!",
      "parentUuid": "2e7c1a58_a0ea642f",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91003b97_eed79b9a",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 26
      },
      "lineNbr": 397,
      "author": {
        "id": 1135559
      },
      "writtenOn": "2019-12-18T01:37:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8d6e38fe_fbaebcbc",
      "revId": "e53e0f2f3449786e488a1cf30e15404a7a3b5275",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}