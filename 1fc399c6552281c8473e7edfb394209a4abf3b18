{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "29778205_1c0a9b88",
        "filename": "src/libANGLE/renderer/metal/BufferMtl.mm",
        "patchSetId": 2
      },
      "lineNbr": 524,
      "author": {
        "id": 1449558
      },
      "writtenOn": "2023-05-02T18:36:54Z",
      "side": 0,
      "message": "Are we still able to somehow limit the amount of memory used by series of updates?\n\nPreviously it seemed we were?\n\nSo if I have 100mb buffer and make updates in a draw loop, looping 100 times, do we still limit the memory somehow?",
      "revId": "1fc399c6552281c8473e7edfb394209a4abf3b18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d89fd784_8fc834d5",
        "filename": "src/libANGLE/renderer/metal/BufferMtl.mm",
        "patchSetId": 2
      },
      "lineNbr": 524,
      "author": {
        "id": 1105344
      },
      "writtenOn": "2023-05-06T09:34:14Z",
      "side": 0,
      "message": "To try to limit the amount of memory consumed by shadow buffers I\u0027ve also added a heuristic which triggers GC based on the amount of memory allocated. This seems to have a positive effect on some workloads, including a Figma test case.\n\nIt doesn\u0027t however put a hard cap on the amount of memory. I don\u0027t know how to do this in the current code structure. Do you have any suggestions on how to? Maybe flush the current command buffer (though probably can\u0027t do this at this point in the code) and wait for its completion, so all shadow buffers become unused, and then force a GC which reclaims buffers even if they\u0027ve been recently referenced?",
      "parentUuid": "29778205_1c0a9b88",
      "revId": "1fc399c6552281c8473e7edfb394209a4abf3b18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}