{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5bb34caa_3e5ee5c6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-03T03:40:07Z",
      "side": 1,
      "message": "Why is this?   It doesn\u0027t look like you\u0027re adding any new release() calls, so why wasn\u0027t the size check good enough in the first place?\n\nI\u0027m mostly wondering if this is working around a bug or fixing one that was always there to begin with in the DynamicBuffer design.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 5
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "db59fe5c_4581350f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-03T21:55:21Z",
      "side": 1,
      "message": "\u003e why wasn\u0027t the size check good enough in the first place?\n\nNot sure what size check you are referring to. The one I can think of doesn\u0027t make sense.\n\n---\n\nThe DynamicBuffer class originally did this:\n\n- Allocate buffer\n * Suballocate from it many times\n- Release buffer and allocate a new one, loop\n\nAn optimization which significantly reduced the number of allocations with default uniforms, driver uniforms etc, made it work like this:\n\n- Allocate buffer, or take from free list\n * Suballocate from it many times\n- Add the buffer to in flight list and allocate a new one, move \"finished\" buffers to free list, loop\n\nThere was no trimming in place in the design of DynamicBuffer.\n\nCharlie made a good optimization in the past that made textures free their staging memory:\n\n    ImageHelper::flushStagedUpdates()\n    {\n        ...\n\n        // If no updates left, release the staging buffers to save memory.\n        if (mSubresourceUpdates.empty())\n        {\n            mStagingBuffer.releaseInFlightBuffers(contextVk);\n            mStagingBuffer.release(contextVk-\u003egetRenderer());\n        }\n\n        ...\n    }\n\nA similar thing was never done for ContextVk\u0027s staging buffer, so it\u0027s free list just grew (until stabilized).\n\nWith this change, Charlie\u0027s optimization above is most likely obsolete too (this change takes care of that), but I haven\u0027t verified it.",
      "parentUuid": "5bb34caa_3e5ee5c6",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 5
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0ec9f2d_eaf4a122",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-04T03:54:04Z",
      "side": 1,
      "message": "Hm, I don\u0027t think I\u0027ve dug into the details of DynamicBuffer enough to provide many meaningful comments.   I\u0027m thinking that my understanding of what\u0027s actually being released is a bit confused.\n\nFor my own sake, just a couple more questions:\n\n1.) The size check I was referring to is in DynamicBuffer::allocateWithAlignment() (see the ref).   It looks like we should be releasing the buffer once all of the sub-allocations have been exhausted.   Why doesn\u0027t that free the memory?\n\n2.) Looking at ImageHelper::flushStagedUpdates(), ContextVk::flushImpl() does something similar for ContextVk::mStagingBuffer, which is how your changes to releaseInFlightBuffersToResourceUseList() get called:\n\n    angle::Result ContextVk::flushImpl(const vk::Semaphore *signalSemaphore)\n    {\n    ...\n        // We must add the per context dynamic buffers into mResourceUseList before submission so that\n        // they get retained properly until GPU completes. We do not add current buffer into\n        // mResourceUseList since they never get reused or freed until context gets destroyed, at which\n        // time we always wait for GPU to finish before destroying the dynamic buffers.\n        for (DriverUniformsDescriptorSet \u0026driverUniform : mDriverUniforms)\n        {\n            driverUniform.dynamicBuffer.releaseInFlightBuffersToResourceUseList(this);\n        }\n        mDefaultUniformStorage.releaseInFlightBuffersToResourceUseList(this);\n        mStagingBuffer.releaseInFlightBuffersToResourceUseList(this);\n\nWhy don\u0027t we issue a mStagingBuffer.release() there also, so it matches ImageHelper::flushStagedUpdates()?   Is the issue that\u0027s too large of a hammer since we actually want to keep at least 1 buffer to prevent a re-allocation later?",
      "parentUuid": "db59fe5c_4581350f",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 5
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f35734fe_fae84cd0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-03T03:40:07Z",
      "side": 1,
      "message": "nit: the life of the application",
      "range": {
        "startLine": 12,
        "startChar": 18,
        "endLine": 12,
        "endChar": 33
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f2dc9cc_6678b7fc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-03T21:55:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f35734fe_fae84cd0",
      "range": {
        "startLine": 12,
        "startChar": 18,
        "endLine": 12,
        "endChar": 33
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "821534a1_3096f661",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-02T21:12:24Z",
      "side": 1,
      "message": "I monitored T-Rex, Manhattan 3.0 and Manhattan 3.1 with this. There are no sources of continuous allocation with or without this change. If this change introduces a handful of sporadic allocations, it\u0027s not discernible.",
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0fe3415_5855e8f3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2021-03-03T03:45:43Z",
      "side": 1,
      "message": "CC\u0027ing Charlie since he\u0027s also done some work in this area.",
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c7ac0dd_e464a984",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-03-03T18:16:19Z",
      "side": 1,
      "message": "Nice work! I do have concern on context staging buffer (see bellow). All other dynamic buffer usage looks good to me.",
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1d54568_fe1f8fe6",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 725,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-03-02T21:45:41Z",
      "side": 1,
      "message": "ShouldReleaseDynamicBuffer ?",
      "range": {
        "startLine": 725,
        "startChar": 5,
        "endLine": 725,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e97e185c_83becf1c",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 725,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-03T21:58:13Z",
      "side": 1,
      "message": "It\u0027s deciding whether to retain or release a buffer that has been freed up. That name is misleading, as it sounds like it plans to release the entire DynamicBuffer.\n\nAny other suggestions?",
      "parentUuid": "f1d54568_fe1f8fe6",
      "range": {
        "startLine": 725,
        "startChar": 5,
        "endLine": 725,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff76a48f_3942e6b1",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-03-02T21:45:41Z",
      "side": 1,
      "message": "I\u0027d just call these ReleaseBuffers/ReuseBuffers/LimitedReuseBuffers",
      "range": {
        "startLine": 68,
        "startChar": 4,
        "endLine": 68,
        "endChar": 22
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "852b0cfe_b230b9db",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-03T21:58:13Z",
      "side": 1,
      "message": "Renamed them to be less like \"Do this\" and more like \"I\u0027m used for this\" (see also next change).",
      "parentUuid": "ff76a48f_3942e6b1",
      "range": {
        "startLine": 68,
        "startChar": 4,
        "endLine": 68,
        "endChar": 22
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fdbdc34_afbcf10b",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-03-02T21:45:41Z",
      "side": 1,
      "message": "I\u0027m curious what led you to this design, or if it\u0027s proactive? Would anything change in Manhattan if we took it out? I\u0027d lean to simplifying if so, although not a big deal.",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02913f0d_3cb70ee1",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-02T22:08:14Z",
      "side": 1,
      "message": "I originally didn\u0027t have this, but it did lead to noticeable allocations both in T-Rex and Manhattan. Noticeable as in one allocation every other frame during some periods.\n\nIt kinda makes sense for the only place it\u0027s used (ContextVk\u0027s texture upload staging buffer shared by all immutable textures), because you know it will be used again in the future (texture streaming), but you also don\u0027t want to have it hold on to too much memory.",
      "parentUuid": "9fdbdc34_afbcf10b",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d0c1380_18b4a393",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-03-03T18:16:19Z",
      "side": 1,
      "message": "For per context staging buffer, I think you should just let context manage it how it want to free the buffer. So I am also incline to not having LimitedReuseFreeBuffers, but let context staging buffer adopt ReuseFreeBuffers. It does set the limit of how much it hold on to it and we can tune that to strike balance between perf and memory. A hard limit of kLimitedFreeListMaxSize for all dynamic buffer doesn\u0027t seem offer enough flexibility here. My original thinking for context staging buffer is to free based on idle time, i.e., if app is not actively rendering for a while, or have switched to background, lets delete all buffers in free list, otherwise just keep them in free list up to the max count. Anyway, my main point is context staging buffer should be managed explicitly.",
      "parentUuid": "02913f0d_3cb70ee1",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87ff7020_bcbbe29d",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-03-03T20:43:19Z",
      "side": 1,
      "message": "\u003e It does set the limit of how much it hold on to\n\nWhere is this happening Charlie?\n\n\u003e A hard limit of kLimitedFreeListMaxSize for all dynamic buffer doesn\u0027t seem offer enough flexibility here.\n\nTo be clear, this hard limit is only for the single user of LimitedReuseFreeBuffers (i.e. the context\u0027s staging buffer). I agree the limit of 1 likely needs more tuning though, and I\u0027m hoping to leave that for another time / another person. I was thinking a limit in bytes may be more appropriate for example, but I don\u0027t particularly plan to go too deep on the tuning.\n\n\u003e if app is not actively rendering for a while, or have switched to background, lets delete all buffers in free list\n\nThat\u0027s not going to cut it. What Manhattan does (and most apps likely) is to upload a lot of data to textures at load time, then render for a long time. You don\u0027t want to hold on to all that staging buffer memory after the initial upload. In Manhattan, that\u0027s over 1GB of memory sitting idle while the benchmark runs.\n\nIf I did this change in a way that had the Context decide what to do with the free list, it would look practically the same (where the context would ask DynamicBuffer to trim its free list every frame). This at least only does it when the buffer is used.",
      "parentUuid": "9d0c1380_18b4a393",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "171a1230_4e581509",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.h",
        "patchSetId": 2
      },
      "lineNbr": 74,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-03-03T21:09:49Z",
      "side": 1,
      "message": "Did you run gfxbench to ensure no perf regressions? I know last time when I worked on that area perf is very sensitive to memory size. There are other ways we can accommodate the specific situations you mentioned above (like free memory above the threshold if not used in past N frames etc).",
      "parentUuid": "87ff7020_bcbbe29d",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 74,
        "endChar": 28
      },
      "revId": "ee4d6b70468991741e934220bb6109047ff3e8ee",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}