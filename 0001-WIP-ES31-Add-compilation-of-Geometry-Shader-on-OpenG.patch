From df51f6a7d1947fc9b30e5cb5d29c1976d3a82bc5 Mon Sep 17 00:00:00 2001
From: Shao <jiawei.shao@intel.com>
Date: Fri, 21 Apr 2017 15:36:54 +0800
Subject: [PATCH] [WIP]ES31: Add compilation of Geometry Shader on OpenGL

This patch intends to implement the compilation of Geometry Shader
based on OpenGL ES3.1 extension EXT_geometry_shader on OpenGL back
ends.

1. Add support to the new shader type GL_GEOMETRY_SHADER_EXT.
2. Implement compilation of Geometry Shader in ANGLE compiler:
(1) Add extension "EXT_GEOMETRY_SHADER" support
(2) Add all built-in constants, variables and functions of Geometry
    Shader
(3) Add input and output primitive declaration in layout qualifiers
(4) Add array as the input of Geometry Shader
(5) Allow unsized arrays as input
(6) Split the original 'varying' to 'inVarying' and 'outVarying' to
    store the input and output variables of a Geometry Shader.
(7) Allow the interface block 'gl_in' as an input varying
3. Add support to the compilation of Geometry Shader on OpenGL
back-ends.
4. Add unit tests to cover the above new features.

Support of EXT_shader_io_blocks isn't included in this patch.

BUG=angleproject:1941
TEST=angle_unittests, angle_end2end_tests

Change-Id: I834b175a17caa3e4b12053b09fa5b0639adfb8cf
---
 include/GLSLANG/ShaderLang.h                       |   41 +-
 samples/shader_translator/shader_translator.cpp    |   17 +-
 src/compiler/translator/BaseTypes.h                |   69 +-
 src/compiler/translator/Compiler.cpp               |   73 +-
 src/compiler/translator/Compiler.h                 |   28 +-
 src/compiler/translator/Initialize.cpp             |   72 +-
 src/compiler/translator/IntermNode.h               |    2 +
 src/compiler/translator/Operator.cpp               |    6 +
 src/compiler/translator/Operator.h                 |    6 +-
 src/compiler/translator/OutputGLSLBase.cpp         |   20 +-
 src/compiler/translator/ParseContext.cpp           |  442 ++++++-
 src/compiler/translator/ParseContext.h             |   28 +
 src/compiler/translator/QualifierTypes.cpp         |   46 +
 src/compiler/translator/ShaderLang.cpp             |  127 +-
 src/compiler/translator/TranslatorESSL.cpp         |   76 ++
 src/compiler/translator/TranslatorGLSL.cpp         |   82 ++
 src/compiler/translator/Types.h                    |    6 +
 src/compiler/translator/VariableInfo.cpp           |  177 ++-
 src/compiler/translator/VariableInfo.h             |   15 +-
 src/compiler/translator/glslang.y                  |   22 +-
 src/compiler/translator/glslang_tab.cpp            |  569 ++++-----
 src/compiler/translator/util.cpp                   |    2 +
 src/libANGLE/Caps.cpp                              |   18 +-
 src/libANGLE/Caps.h                                |   15 +
 src/libANGLE/Compiler.cpp                          |   28 +-
 src/libANGLE/Compiler.h                            |    1 +
 src/libANGLE/ResourceManager.cpp                   |    3 +-
 src/libANGLE/Shader.cpp                            |   33 +-
 src/libANGLE/Shader.h                              |   12 +-
 src/libANGLE/renderer/gl/renderergl_utils.cpp      |   27 +
 src/libANGLE/validationES2.cpp                     |    9 +
 src/tests/angle_end2end_tests.gypi                 |    1 +
 src/tests/angle_unittests.gypi                     |    1 +
 src/tests/compiler_tests/CollectVariables_test.cpp |    2 +-
 src/tests/compiler_tests/GeometryShader_test.cpp   | 1299 ++++++++++++++++++++
 src/tests/compiler_tests/ShaderValidation_test.cpp |  275 +++++
 src/tests/gl_tests/GeometryShaderTest.cpp          |   50 +
 37 files changed, 3331 insertions(+), 369 deletions(-)
 create mode 100644 src/tests/compiler_tests/GeometryShader_test.cpp
 create mode 100644 src/tests/gl_tests/GeometryShaderTest.cpp

diff --git a/include/GLSLANG/ShaderLang.h b/include/GLSLANG/ShaderLang.h
index b9ce4e916..174a65a31 100644
--- a/include/GLSLANG/ShaderLang.h
+++ b/include/GLSLANG/ShaderLang.h
@@ -19,7 +19,6 @@
 // This is the platform independent interface between an OGL driver
 // and the shading language compiler.
 //
-
 // Note: make sure to increment ANGLE_SH_VERSION when changing ShaderVars.h
 #include "ShaderVars.h"
 
@@ -269,6 +268,7 @@ struct ShBuiltInResources
     int ARM_shader_framebuffer_fetch;
     int OVR_multiview;
     int EXT_YUV_target;
+    int EXT_geometry_shader;
 
     // Set to 1 to enable replacing GL_EXT_draw_buffers #extension directives
     // with GL_NV_draw_buffers in ESSL output. This flag can be used to emulate
@@ -383,6 +383,38 @@ struct ShBuiltInResources
 
     // maximum number of uniform block bindings
     int MaxUniformBufferBindings;
+
+    // EXT_geometry_shader constants;
+
+    // maximum number of input components in a geometry shader
+    int MaxGeometryInputComponents;
+
+    // maximum number of output components in a geometry shader
+    int MaxGeometryOutputComponents;
+
+    // maximum number of image uniforms in a geometry shader
+    int MaxGeometryImageUniforms;
+
+    // maximum number of texture image units in a geometry shader
+    int MaxGeometryTextureImageUnits;
+
+    // maximum number of max_vertices in a geometry shader
+    int MaxGeometryOutputVertices;
+
+    // maximum number of total output components in a geometry shader
+    int MaxGeometryTotalOutputComponents;
+
+    // maximum number of uniform components in a geometry shader
+    int MaxGeometryUniformComponents;
+
+    // maximum number of atomic counters in a geometry shader
+    int MaxGeometryAtomicCounters;
+
+    // maximum number of atomic counter buffers in a geometry shader
+    int MaxGeometryAtomicCounterBuffers;
+
+    // maximum number of invocations in a geometry shader
+    int MaxGeometryInvocations;
 };
 
 //
@@ -507,6 +539,13 @@ const std::vector<sh::InterfaceBlock> *GetInterfaceBlocks(const ShHandle handle)
 sh::WorkGroupSize GetComputeShaderLocalGroupSize(const ShHandle handle);
 int GetVertexShaderNumViews(const ShHandle handle);
 
+const std::vector<sh::Varying> *GetInputVaryings(const ShHandle handle);
+const std::vector<sh::Varying> *GetOutputVaryings(const ShHandle handle);
+GLenum GetGeometryShaderInputPrimitives(const ShHandle handle);
+GLenum GetGeometryShaderOutputPrimitives(const ShHandle handle);
+int GetGeometryShaderMaxVertices(const ShHandle handle);
+int GetGeometryShaderInvocations(const ShHandle handle);
+
 // Returns true if the passed in variables pack in maxVectors followingthe packing rules from the
 // GLSL 1.017 spec, Appendix A, section 7.
 // Returns false otherwise. Also look at the SH_ENFORCE_PACKING_RESTRICTIONS
diff --git a/samples/shader_translator/shader_translator.cpp b/samples/shader_translator/shader_translator.cpp
index f073372d1..003d7a775 100644
--- a/samples/shader_translator/shader_translator.cpp
+++ b/samples/shader_translator/shader_translator.cpp
@@ -74,6 +74,7 @@ int main(int argc, char *argv[])
     ShHandle vertexCompiler = 0;
     ShHandle fragmentCompiler = 0;
     ShHandle computeCompiler  = 0;
+    ShHandle geometryCompiler       = 0;
     ShShaderSpec spec = SH_GLES2_SPEC;
     ShShaderOutput output = SH_ESSL_OUTPUT;
 
@@ -262,7 +263,14 @@ int main(int argc, char *argv[])
                   }
                   compiler = computeCompiler;
                   break;
-
+              case GL_GEOMETRY_SHADER_EXT:
+                  if (geometryCompiler == 0)
+                  {
+                      geometryCompiler =
+                          sh::ConstructCompiler(GL_GEOMETRY_SHADER_EXT, spec, output, &resources);
+                  }
+                  compiler = geometryCompiler;
+                  break;
               default: break;
             }
             if (compiler)
@@ -301,7 +309,8 @@ int main(int argc, char *argv[])
         }
     }
 
-    if ((vertexCompiler == 0) && (fragmentCompiler == 0) && (computeCompiler == 0))
+    if ((vertexCompiler == 0) && (fragmentCompiler == 0) && (computeCompiler == 0) &&
+        (geometryCompiler == 0))
         failCode = EFailUsage;
     if (failCode == EFailUsage)
         usage();
@@ -312,6 +321,8 @@ int main(int argc, char *argv[])
         sh::Destruct(fragmentCompiler);
     if (computeCompiler)
         sh::Destruct(computeCompiler);
+    if (geometryCompiler)
+        sh::Destruct(geometryCompiler);
 
     sh::Finalize();
 
@@ -382,6 +393,8 @@ sh::GLenum FindShaderType(const char *fileName)
             return GL_VERTEX_SHADER;
         if (strncmp(ext, ".comp", 5) == 0)
             return GL_COMPUTE_SHADER;
+        if (strncmp(ext, ".geom", 5) == 0)
+            return GL_GEOMETRY_SHADER_EXT;
     }
 
     return GL_FRAGMENT_SHADER;
diff --git a/src/compiler/translator/BaseTypes.h b/src/compiler/translator/BaseTypes.h
index e1deb4fb6..c0f1e71b6 100644
--- a/src/compiler/translator/BaseTypes.h
+++ b/src/compiler/translator/BaseTypes.h
@@ -571,6 +571,15 @@ enum TQualifier
     EvqRestrict,
     EvqVolatile,
 
+    // GLSL ES 3.1 extension EXT_geometry_shader qualifiers
+    EvqGeometryIn,
+    EvqGeometryOut,
+    EvqGLPerVertex,
+    EvqPrimitiveIDIn,
+    EvqPrimitiveID,
+    EvqInvocationID,
+    EvqLayer,
+
     // end of list
     EvqLast
 };
@@ -621,6 +630,18 @@ enum TYuvCscStandardEXT
     EycsItu709
 };
 
+enum TLayoutGeometryShaderEXT
+{
+    EgsUndefined,
+    EgsPoints,
+    EgsLines,
+    EgsLinesAdjacency,
+    EgsTriangles,
+    EgsTrianglesAdjacency,
+    EgsLineStrip,
+    EgsTriangleStrip
+};
+
 struct TLayoutQualifier
 {
     int location;
@@ -643,6 +664,11 @@ struct TLayoutQualifier
     // EXT_YUV_target yuv layout qualifier.
     bool yuv;
 
+    // EXT_geometry_shader layout qualifiers.
+    TLayoutGeometryShaderEXT primitiveType;
+    int invocations;
+    int maxVertices;
+
     static TLayoutQualifier create()
     {
         TLayoutQualifier layoutQualifier;
@@ -659,6 +685,11 @@ struct TLayoutQualifier
         layoutQualifier.yuv      = false;
 
         layoutQualifier.imageInternalFormat = EiifUnspecified;
+
+        layoutQualifier.primitiveType = EgsUndefined;
+        layoutQualifier.invocations   = 0;
+        layoutQualifier.maxVertices   = -1;
+
         return layoutQualifier;
     }
 
@@ -666,13 +697,16 @@ struct TLayoutQualifier
     {
         return location == -1 && binding == -1 && offset == -1 && numViews == -1 && yuv == false &&
                matrixPacking == EmpUnspecified && blockStorage == EbsUnspecified &&
-               !localSize.isAnyValueSet() && imageInternalFormat == EiifUnspecified;
+               !localSize.isAnyValueSet() && imageInternalFormat == EiifUnspecified &&
+               primitiveType == EgsUndefined && invocations == 0 && maxVertices == -1;
     }
 
     bool isCombinationValid() const
     {
         bool workSizeSpecified = localSize.isAnyValueSet();
         bool numViewsSet       = (numViews != -1);
+        bool geometryShaderSpecified =
+            (primitiveType != EgsUndefined) || (invocations != 0) || (maxVertices != -1);
         bool otherLayoutQualifiersSpecified =
             (location != -1 || binding != -1 || matrixPacking != EmpUnspecified ||
              blockStorage != EbsUnspecified || imageInternalFormat != EiifUnspecified);
@@ -680,7 +714,7 @@ struct TLayoutQualifier
         // we can have either the work group size specified, or number of views,
         // or yuv layout qualifier, or the other layout qualifiers.
         return (workSizeSpecified ? 1 : 0) + (numViewsSet ? 1 : 0) + (yuv ? 1 : 0) +
-                   (otherLayoutQualifiersSpecified ? 1 : 0) <=
+                   (otherLayoutQualifiersSpecified ? 1 : 0) + (geometryShaderSpecified ? 1 : 0) <=
                1;
     }
 
@@ -795,6 +829,13 @@ inline const char *getQualifierString(TQualifier q)
     case EvqLocalInvocationIndex:   return "LocalInvocationIndex";
     case EvqReadOnly:               return "readonly";
     case EvqWriteOnly:              return "writeonly";
+    case EvqGeometryIn:             return "in";
+    case EvqGeometryOut:            return "out";
+    case EvqInvocationID:           return "InvocationID";
+    case EvqPrimitiveIDIn:          return "PrimitiveIDIn";
+    case EvqPrimitiveID:            return "PrimitiveID";
+    case EvqLayer:                  return "Layer";
+    case EvqGLPerVertex:            return "gl_in";
     default: UNREACHABLE();         return "unknown qualifier";
     }
     // clang-format on
@@ -897,6 +938,30 @@ inline const char *getYuvCscStandardEXTString(TYuvCscStandardEXT ycsq)
     }
 }
 
+inline const char *getGeometryShaderPrimitiveTypeString(TLayoutGeometryShaderEXT primitiveType)
+{
+    switch (primitiveType)
+    {
+        case EgsPoints:
+            return "points";
+        case EgsLines:
+            return "lines";
+        case EgsTriangles:
+            return "triangles";
+        case EgsLinesAdjacency:
+            return "lines_adjacency";
+        case EgsTrianglesAdjacency:
+            return "triangles_adjacency";
+        case EgsLineStrip:
+            return "line_strip";
+        case EgsTriangleStrip:
+            return "triangle_strip";
+        default:
+            UNREACHABLE();
+            return "unknown geometry shader primitive type";
+    }
+}
+
 }  // namespace sh
 
 #endif  // COMPILER_TRANSLATOR_BASETYPES_H_
diff --git a/src/compiler/translator/Compiler.cpp b/src/compiler/translator/Compiler.cpp
index 46da8069b..785617e12 100644
--- a/src/compiler/translator/Compiler.cpp
+++ b/src/compiler/translator/Compiler.cpp
@@ -221,7 +221,12 @@ TCompiler::TCompiler(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output)
       mDiagnostics(infoSink.info),
       mSourcePath(nullptr),
       mComputeShaderLocalSizeDeclared(false),
-      mTemporaryIndex(0)
+      mTemporaryIndex(0),
+      mGeometryInputArraySize(0),
+      mGeometryMaxVertices(-1),
+      mGeometryInvocations(0),
+      mGeometryPrimitiveIn(EgsUndefined),
+      mGeometryPrimitiveOut(EgsUndefined)
 {
     mComputeShaderLocalSize.fill(1);
 }
@@ -242,8 +247,12 @@ bool TCompiler::shouldRunLoopAndIndexingValidation(ShCompileOptions compileOptio
 bool TCompiler::Init(const ShBuiltInResources &resources)
 {
     shaderVersion     = 100;
-    maxUniformVectors = (shaderType == GL_VERTEX_SHADER) ? resources.MaxVertexUniformVectors
-                                                         : resources.MaxFragmentUniformVectors;
+    maxUniformVectors = (shaderType == GL_VERTEX_SHADER)
+                            ? resources.MaxVertexUniformVectors
+                            : (shaderType == GL_FRAGMENT_SHADER)
+                                  ? resources.MaxFragmentUniformVectors
+                                  : (resources.MaxGeometryUniformComponents / 4);
+
     maxExpressionComplexity = resources.MaxExpressionComplexity;
     maxCallStackDepth       = resources.MaxCallStackDepth;
     maxFunctionParameters   = resources.MaxFunctionParameters;
@@ -338,6 +347,15 @@ TIntermBlock *TCompiler::compileTreeImpl(const char *const shaderStrings[],
             success = false;
         }
 
+        if (success && shaderType == GL_GEOMETRY_SHADER_EXT)
+        {
+            mGeometryPrimitiveIn    = parseContext.getGeometryInputPrimitive();
+            mGeometryPrimitiveOut   = parseContext.getGeometryOutputPrimitive();
+            mGeometryMaxVertices    = parseContext.getGeometryMaxVertices();
+            mGeometryInvocations    = parseContext.getGeometryInvocations();
+            mGeometryInputArraySize = parseContext.getGeometryInputArraySize();
+        }
+
         // Disallow expressions deemed too complex.
         if (success && (compileOptions & SH_LIMIT_EXPRESSION_COMPLEXITY))
             success = limitExpressionComplexity(root);
@@ -585,6 +603,10 @@ bool TCompiler::InitBuiltInSymbolTable(const ShBuiltInResources &resources)
             symbolTable.setDefaultPrecision(integer, EbpHigh);
             symbolTable.setDefaultPrecision(floatingPoint, EbpHigh);
             break;
+        case GL_GEOMETRY_SHADER_EXT:
+            symbolTable.setDefaultPrecision(integer, EbpHigh);
+            symbolTable.setDefaultPrecision(floatingPoint, EbpHigh);
+            break;
         default:
             assert(false && "Language not supported");
     }
@@ -649,6 +671,7 @@ void TCompiler::setResourceString()
         << ":NV_shader_framebuffer_fetch:" << compileResources.NV_shader_framebuffer_fetch
         << ":ARM_shader_framebuffer_fetch:" << compileResources.ARM_shader_framebuffer_fetch
         << ":EXT_YUV_target:" << compileResources.EXT_YUV_target
+        << ":EXT_geometry_shader:" << compileResources.EXT_geometry_shader
         << ":MaxVertexOutputVectors:" << compileResources.MaxVertexOutputVectors
         << ":MaxFragmentInputVectors:" << compileResources.MaxFragmentInputVectors
         << ":MinProgramTexelOffset:" << compileResources.MinProgramTexelOffset
@@ -679,7 +702,16 @@ void TCompiler::setResourceString()
         << ":MaxVertexAtomicCounterBuffers:" << compileResources.MaxVertexAtomicCounterBuffers
         << ":MaxFragmentAtomicCounterBuffers:" << compileResources.MaxFragmentAtomicCounterBuffers
         << ":MaxCombinedAtomicCounterBuffers:" << compileResources.MaxCombinedAtomicCounterBuffers
-        << ":MaxAtomicCounterBufferSize:" << compileResources.MaxAtomicCounterBufferSize;
+        << ":MaxAtomicCounterBufferSize:" << compileResources.MaxAtomicCounterBufferSize
+        << ":MaxGeometryInputComponents:" << compileResources.MaxGeometryInputComponents
+        << ":MaxGeometryOutputComponents:" << compileResources.MaxGeometryOutputComponents
+        << ":MaxGeometryImageUniforms:" << compileResources.MaxGeometryImageUniforms
+        << ":MaxGeometryTextureImageUnits:" << compileResources.MaxGeometryTextureImageUnits
+        << ":MaxGeometryOutputVertices:" << compileResources.MaxGeometryOutputVertices
+        << ":MaxGeometryTotalOutputComponents:" << compileResources.MaxGeometryTotalOutputComponents
+        << ":MaxGeometryUniformComponents:" << compileResources.MaxGeometryUniformComponents
+        << ":MaxGeometryAtomicCounters:" << compileResources.MaxGeometryAtomicCounters
+        << ":MaxGeometryAtomicCounterBuffers:" << compileResources.MaxGeometryAtomicCounterBuffers;
     // clang-format on
 
     builtInResourcesString = strstream.str();
@@ -697,7 +729,8 @@ void TCompiler::clearResults()
     outputVariables.clear();
     uniforms.clear();
     expandedUniforms.clear();
-    varyings.clear();
+    inVaryings.clear();
+    outVaryings.clear();
     interfaceBlocks.clear();
     variablesCollected = false;
 
@@ -906,9 +939,9 @@ void TCompiler::collectVariables(TIntermNode *root)
 {
     if (!variablesCollected)
     {
-        sh::CollectVariables collect(&attributes, &outputVariables, &uniforms, &varyings,
-                                     &interfaceBlocks, hashFunction, symbolTable,
-                                     extensionBehavior);
+        sh::CollectVariables collect(&attributes, &outputVariables, &uniforms, &inVaryings,
+                                     &outVaryings, &interfaceBlocks, hashFunction, shaderType,
+                                     symbolTable, extensionBehavior);
         root->traverse(&collect);
 
         // This is for enforcePackingRestriction().
@@ -961,9 +994,9 @@ void TCompiler::useAllMembersInUnusedStandardAndSharedBlocks(TIntermBlock *root)
 void TCompiler::initializeOutputVariables(TIntermBlock *root)
 {
     InitVariableList list;
-    if (shaderType == GL_VERTEX_SHADER)
+    if (shaderType == GL_VERTEX_SHADER || shaderType == GL_GEOMETRY_SHADER_EXT)
     {
-        for (auto var : varyings)
+        for (auto var : outVaryings)
         {
             list.push_back(var);
         }
@@ -1022,11 +1055,25 @@ void TCompiler::writePragma(ShCompileOptions compileOptions)
 bool TCompiler::isVaryingDefined(const char *varyingName)
 {
     ASSERT(variablesCollected);
-    for (size_t ii = 0; ii < varyings.size(); ++ii)
+
+    if (shaderType == GL_VERTEX_SHADER || shaderType == GL_GEOMETRY_SHADER_EXT)
     {
-        if (varyings[ii].name == varyingName)
+        for (size_t ii = 0; ii < outVaryings.size(); ++ii)
         {
-            return true;
+            if (outVaryings[ii].name == varyingName)
+            {
+                return true;
+            }
+        }
+    }
+    if (shaderType == GL_FRAGMENT_SHADER || shaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        for (size_t ii = 0; ii < inVaryings.size(); ++ii)
+        {
+            if (inVaryings[ii].name == varyingName)
+            {
+                return true;
+            }
         }
     }
 
diff --git a/src/compiler/translator/Compiler.h b/src/compiler/translator/Compiler.h
index e66f51a03..b154f2984 100644
--- a/src/compiler/translator/Compiler.h
+++ b/src/compiler/translator/Compiler.h
@@ -110,8 +110,9 @@ class TCompiler : public TShHandleBase
     const std::vector<sh::Attribute> &getAttributes() const { return attributes; }
     const std::vector<sh::OutputVariable> &getOutputVariables() const { return outputVariables; }
     const std::vector<sh::Uniform> &getUniforms() const { return uniforms; }
-    const std::vector<sh::Varying> &getVaryings() const { return varyings; }
     const std::vector<sh::InterfaceBlock> &getInterfaceBlocks() const { return interfaceBlocks; }
+    const std::vector<sh::Varying> &getInputVaryings() const { return inVaryings; }
+    const std::vector<sh::Varying> &getOutputVaryings() const { return outVaryings; }
 
     ShHashFunction64 getHashFunction() const { return hashFunction; }
     NameMap &getNameMap() { return nameMap; }
@@ -125,8 +126,20 @@ class TCompiler : public TShHandleBase
     // Get the resources set by InitBuiltInSymbolTable
     const ShBuiltInResources &getResources() const;
 
-  protected:
+    int getGeometryShaderMaxVertices() const { return mGeometryMaxVertices; }
+    int getGeometryShaderInvocations() const { return mGeometryInvocations; }
+    TLayoutGeometryShaderEXT getGeometryShaderInputPrimitives() const
+    {
+        return mGeometryPrimitiveIn;
+    }
+    TLayoutGeometryShaderEXT getGeometryShaderOutputPrimitives() const
+    {
+        return mGeometryPrimitiveOut;
+    }
+
     sh::GLenum getShaderType() const { return shaderType; }
+
+  protected:
     // Initialize symbol-table with built-in symbols.
     bool InitBuiltInSymbolTable(const ShBuiltInResources &resources);
     // Compute the string representation of the built-in resources
@@ -179,8 +192,10 @@ class TCompiler : public TShHandleBase
     std::vector<sh::OutputVariable> outputVariables;
     std::vector<sh::Uniform> uniforms;
     std::vector<sh::ShaderVariable> expandedUniforms;
-    std::vector<sh::Varying> varyings;
+
     std::vector<sh::InterfaceBlock> interfaceBlocks;
+    std::vector<sh::Varying> inVaryings;
+    std::vector<sh::Varying> outVaryings;
 
   private:
     // Creates the function call DAG for further analysis, returning false if there is a recursion
@@ -249,6 +264,13 @@ class TCompiler : public TShHandleBase
     // GL_OVR_multiview num_views.
     int mNumViews;
 
+    // geometry shader parameters
+    int mGeometryInputArraySize;
+    int mGeometryMaxVertices;
+    int mGeometryInvocations;
+    TLayoutGeometryShaderEXT mGeometryPrimitiveIn;
+    TLayoutGeometryShaderEXT mGeometryPrimitiveOut;
+
     // name hashing.
     ShHashFunction64 hashFunction;
     NameMap nameMap;
diff --git a/src/compiler/translator/Initialize.cpp b/src/compiler/translator/Initialize.cpp
index 718968ff1..73a678e7f 100644
--- a/src/compiler/translator/Initialize.cpp
+++ b/src/compiler/translator/Initialize.cpp
@@ -676,6 +676,14 @@ void InsertBuiltInFunctions(sh::GLenum type,
                                                       voidType, "groupMemoryBarrier");
     }
 
+    if (type == GL_GEOMETRY_SHADER_EXT)
+    {
+        symbolTable.insertBuiltInFunctionNoParameters(ESSL3_1_BUILTINS, EOpEmitVertex, voidType,
+                                                      "EmitVertex");
+        symbolTable.insertBuiltInFunctionNoParameters(ESSL3_1_BUILTINS, EOpEndPrimitive, voidType,
+                                                      "EndPrimitive");
+    }
+
     //
     // Depth range in window coordinates
     //
@@ -927,7 +935,65 @@ void IdentifyBuiltIns(sh::GLenum type,
                               TType(EbtUInt, EbpUndefined, EvqLocalInvocationIndex, 1)));
         }
         break;
-
+        case GL_GEOMETRY_SHADER_EXT:
+        {
+            constexpr char *extension = "GL_EXT_geometry_shader";
+            TFieldList *fields        = NewPoolTFieldList();
+            TSourceLoc zeroSourceLoc  = {0, 0, 0, 0};
+            TField *glPositionField   = new TField(new TType(EbtFloat, EbpHigh, EvqPosition, 4),
+                                                 NewPoolTString("gl_Position"), zeroSourceLoc);
+            fields->push_back(glPositionField);
+            const auto *interfaceName = NewPoolTString("gl_in");
+            TInterfaceBlock *block = new TInterfaceBlock(interfaceName, fields, interfaceName, -1,
+                                                         TLayoutQualifier::create());
+            TType glInType(block, EvqGLPerVertex, TLayoutQualifier::create(), 0);
+            symbolTable.insert(ESSL3_1_BUILTINS, extension, new TVariable(interfaceName, glInType));
+
+            symbolTable.insert(COMMON_BUILTINS, extension,
+                               new TVariable(NewPoolTString("gl_Position"),
+                                             TType(EbtFloat, EbpHigh, EvqPosition, 4)));
+            symbolTable.insert(ESSL3_1_BUILTINS, extension,
+                               new TVariable(NewPoolTString("gl_PrimitiveIDIn"),
+                                             TType(EbtUInt, EbpUndefined, EvqPrimitiveIDIn, 1)));
+            symbolTable.insert(ESSL3_1_BUILTINS, extension,
+                               new TVariable(NewPoolTString("gl_PrimitiveID"),
+                                             TType(EbtUInt, EbpUndefined, EvqPrimitiveID, 1)));
+            symbolTable.insert(ESSL3_1_BUILTINS, extension,
+                               new TVariable(NewPoolTString("gl_InvocationID"),
+                                             TType(EbtUInt, EbpUndefined, EvqInvocationID, 1)));
+            symbolTable.insert(ESSL3_1_BUILTINS, extension,
+                               new TVariable(NewPoolTString("gl_Layer"),
+                                             TType(EbtUInt, EbpUndefined, EvqLayer, 1)));
+
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryInputComponents",
+                                          resources.MaxGeometryInputComponents);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryOutputComponents",
+                                          resources.MaxGeometryOutputComponents);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryImageUniforms",
+                                          resources.MaxGeometryImageUniforms);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryTextureImageUnits",
+                                          resources.MaxGeometryTextureImageUnits);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryOutputVertices",
+                                          resources.MaxGeometryOutputVertices);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryTotalOutputComponents",
+                                          resources.MaxGeometryTotalOutputComponents);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryUniformComponents",
+                                          resources.MaxGeometryUniformComponents);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryAtomicCounters",
+                                          resources.MaxGeometryAtomicCounters);
+            symbolTable.insertConstIntExt(ESSL3_1_BUILTINS, extension,
+                                          "gl_MaxGeometryAtomicCounterBuffers",
+                                          resources.MaxGeometryAtomicCounterBuffers);
+            break;
+        }
         default:
             assert(false && "Language not supported");
     }
@@ -968,6 +1034,10 @@ void InitExtensionBehavior(const ShBuiltInResources &resources, TExtensionBehavi
     {
         extBehavior["GL_EXT_YUV_target"] = EBhUndefined;
     }
+    if (resources.EXT_geometry_shader)
+    {
+        extBehavior["GL_EXT_geometry_shader"] = EBhUndefined;
+    }
 }
 
 void ResetExtensionBehavior(TExtensionBehavior &extBehavior)
diff --git a/src/compiler/translator/IntermNode.h b/src/compiler/translator/IntermNode.h
index 204802297..710d4fec4 100644
--- a/src/compiler/translator/IntermNode.h
+++ b/src/compiler/translator/IntermNode.h
@@ -180,6 +180,8 @@ class TIntermTyped : public TIntermNode
 
     bool isConstructorWithOnlyConstantUnionParameters();
 
+    bool isUnsizedArray() const { return mType.isUnsizedArray(); }
+
     static TIntermTyped *CreateIndexNode(int index);
     static TIntermTyped *CreateZero(const TType &type);
     static TIntermTyped *CreateBool(bool value);
diff --git a/src/compiler/translator/Operator.cpp b/src/compiler/translator/Operator.cpp
index 185898083..72a7b44c7 100644
--- a/src/compiler/translator/Operator.cpp
+++ b/src/compiler/translator/Operator.cpp
@@ -341,6 +341,12 @@ const char *GetOperatorString(TOperator op)
             return "memoryBarrierShared";
         case EOpGroupMemoryBarrier:
             return "groupMemoryBarrier";
+
+        case EOpEmitVertex:
+            return "EmitVertex";
+        case EOpEndPrimitive:
+            return "EndPrimitive";
+
         default:
             break;
     }
diff --git a/src/compiler/translator/Operator.h b/src/compiler/translator/Operator.h
index 5f028b974..e537fc11e 100644
--- a/src/compiler/translator/Operator.h
+++ b/src/compiler/translator/Operator.h
@@ -237,7 +237,11 @@ enum TOperator
     EOpMemoryBarrierBuffer,
     EOpMemoryBarrierImage,
     EOpMemoryBarrierShared,
-    EOpGroupMemoryBarrier
+    EOpGroupMemoryBarrier,
+
+    //  Geometry only
+    EOpEmitVertex,
+    EOpEndPrimitive
 };
 
 // Returns the string corresponding to the operator in GLSL
diff --git a/src/compiler/translator/OutputGLSLBase.cpp b/src/compiler/translator/OutputGLSLBase.cpp
index 94849ec95..d3d2f86c0 100644
--- a/src/compiler/translator/OutputGLSLBase.cpp
+++ b/src/compiler/translator/OutputGLSLBase.cpp
@@ -469,8 +469,17 @@ void TOutputGLSLBase::visitSymbol(TIntermSymbol *node)
     TInfoSinkBase &out = objSink();
     out << hashVariableName(node->getName());
 
-    if (mDeclaringVariables && node->getType().isArray())
-        out << arrayBrackets(node->getType());
+    if (mDeclaringVariables)
+    {
+        if (node->getQualifier() == EvqGeometryIn)
+        {
+            out << "[]";
+        }
+        else if (node->getType().isArray())
+        {
+            out << arrayBrackets(node->getType());
+        }
+    }
 }
 
 void TOutputGLSLBase::visitConstantUnion(TIntermConstantUnion *node)
@@ -616,7 +625,8 @@ bool TOutputGLSLBase::visitBinary(Visit visit, TIntermBinary *node)
                 const TField *field               = interfaceBlock->fields()[index->getIConst(0)];
 
                 TString fieldName = field->name();
-                ASSERT(!mSymbolTable.findBuiltIn(interfaceBlock->name(), mShaderVersion));
+                ASSERT(!mSymbolTable.findBuiltIn(interfaceBlock->name(), mShaderVersion) ||
+                       interfaceBlock->name() == "gl_in");
                 fieldName = hashName(TName(fieldName));
 
                 out << fieldName;
@@ -793,6 +803,8 @@ bool TOutputGLSLBase::visitUnary(Visit visit, TIntermUnary *node)
         case EOpBitCount:
         case EOpFindLSB:
         case EOpFindMSB:
+        case EOpEmitVertex:
+        case EOpEndPrimitive:
             writeBuiltInFunctionTriplet(visit, node->getOp(), node->getUseEmulatedFunction());
             return true;
         default:
@@ -1005,6 +1017,8 @@ bool TOutputGLSLBase::visitAggregate(Visit visit, TIntermAggregate *node)
         case EOpMemoryBarrierImage:
         case EOpMemoryBarrierShared:
         case EOpGroupMemoryBarrier:
+        case EOpEmitVertex:
+        case EOpEndPrimitive:
             writeBuiltInFunctionTriplet(visit, node->getOp(), node->getUseEmulatedFunction());
             break;
         default:
diff --git a/src/compiler/translator/ParseContext.cpp b/src/compiler/translator/ParseContext.cpp
index f3bd17997..bfcbc3ebd 100644
--- a/src/compiler/translator/ParseContext.cpp
+++ b/src/compiler/translator/ParseContext.cpp
@@ -148,7 +148,14 @@ TParseContext::TParseContext(TSymbolTable &symt,
       mMaxUniformLocations(resources.MaxUniformLocations),
       mMaxUniformBufferBindings(resources.MaxUniformBufferBindings),
       mMaxAtomicCounterBindings(resources.MaxAtomicCounterBindings),
-      mDeclaringFunction(false)
+      mDeclaringFunction(false),
+      mMaxGeometryInvocations(resources.MaxGeometryInvocations),
+      mMaxGeometryMaxVertices(resources.MaxGeometryOutputVertices),
+      mGeometryPrimitiveIn(EgsUndefined),
+      mGeometryPrimitiveOut(EgsUndefined),
+      mGeometryInputArraySize(-1),
+      mGeometryInvocations(0),
+      mGeometryMaxVertices(-1)
 {
     mComputeShaderLocalSize.fill(-1);
 }
@@ -462,6 +469,18 @@ bool TParseContext::checkCanBeLValue(const TSourceLoc &line, const char *op, TIn
         case EvqComputeIn:
             message = "can't modify work group size variable";
             break;
+        case EvqGeometryIn:
+            message = "can't modify an input";
+            break;
+        case EvqPrimitiveIDIn:
+            message = "can't modify gl_PrimitiveIDIn";
+            break;
+        case EvqInvocationID:
+            message = "can't modify gl_InvocationID";
+            break;
+        case EvqGLPerVertex:
+            message = "can't modify any member in gl_in";
+            break;
         default:
             //
             // Type that can't be written to?
@@ -1131,7 +1150,8 @@ void TParseContext::declarationQualifierErrorCheck(const sh::TQualifier qualifie
         error(location, "storage qualifier supported in GLSL ES 3.00 and above only", "in");
     }
 
-    bool canHaveLocation = qualifier == EvqVertexIn || qualifier == EvqFragmentOut;
+    bool canHaveLocation = qualifier == EvqVertexIn || qualifier == EvqFragmentOut ||
+                           qualifier == EvqGeometryIn || qualifier == EvqGeometryOut;
     if (mShaderVersion >= 310 && qualifier == EvqUniform)
     {
         canHaveLocation = true;
@@ -2058,6 +2078,13 @@ TIntermDeclaration *TParseContext::parseSingleDeclaration(
     declarationQualifierErrorCheck(publicType.qualifier, publicType.layoutQualifier,
                                    identifierOrTypeLocation);
 
+    if (type.getQualifier() == EvqGeometryIn)
+    {
+        error(identifierOrTypeLocation,
+              "Geometry shader input varying variable must be declared as an array",
+              identifier.c_str());
+    }
+
     bool emptyDeclaration = (identifier == "");
     mDeferredNonEmptyDeclarationErrorCheck = emptyDeclaration;
 
@@ -2127,15 +2154,61 @@ TIntermDeclaration *TParseContext::parseSingleArrayDeclaration(TPublicType &publ
 
     TType arrayType(publicType);
 
-    unsigned int size = checkIsValidArraySize(identifierLocation, indexExpression);
-    // Make the type an array even if size check failed.
-    // This ensures useless error messages regarding the variable's non-arrayness won't follow.
-    arrayType.setArraySize(size);
-
-    if (IsAtomicCounter(publicType.getBasicType()))
+    if (indexExpression == nullptr)
     {
-        checkAtomicCounterOffsetIsNotOverlapped(publicType, kAtomicCounterArrayStride * size, false,
-                                                identifierLocation, arrayType);
+        if (publicType.qualifier != EvqGeometryIn)
+        {
+            error(indexLocation, "Invalid unsized array declaration", "");
+            arrayType.setArrayUnsized();
+        }
+        if (mGeometryInputArraySize != -1)
+        {
+            arrayType.setArraySize(static_cast<GLuint>(mGeometryInputArraySize));
+        }
+        else
+        {
+            arrayType.setArrayUnsized();
+        }
+    }
+    else
+    {
+        unsigned int size = 0;
+        if (publicType.qualifier == EvqGeometryIn)
+        {
+            TIntermConstantUnion *constant = indexExpression->getAsConstantUnion();
+            int signedSize                 = constant->getIConst(0);
+            if (mGeometryInputArraySize == -1)
+            {
+                mGeometryInputArraySize = signedSize;
+                size                    = static_cast<GLuint>(signedSize);
+            }
+            else if (mGeometryInputArraySize != signedSize)
+            {
+                error(identifierLocation,
+                      "input array sizes doesn't match eariler input primitive or input array size "
+                      "declarations.",
+                      "");
+                size = 1u;
+            }
+            else
+            {
+                size = static_cast<GLuint>(signedSize);
+            }
+        }
+        else
+        {
+            size = checkIsValidArraySize(identifierLocation, indexExpression);
+        }
+
+        // Make the type an array even if size check failed.
+        // This ensures useless error messages regarding the variable's non-arrayness won't follow.
+        arrayType.setArraySize(size);
+
+        if (IsAtomicCounter(publicType.getBasicType()))
+        {
+            checkAtomicCounterOffsetIsNotOverlapped(publicType, kAtomicCounterArrayStride * size,
+                                                    false, identifierLocation, arrayType);
+        }
     }
 
     TVariable *variable = nullptr;
@@ -2446,6 +2519,185 @@ void TParseContext::setAtomicCounterBindingDefaultOffset(const TPublicType &publ
     mAtomicCounterBindingStates[layoutQualifier.binding].setDefaultOffset(layoutQualifier.offset);
 }
 
+static int GetGeometryShaderInputArraySize(TLayoutGeometryShaderEXT primitiveType)
+{
+    switch (primitiveType)
+    {
+        case EgsPoints:
+            return 1;
+        case EgsLines:
+            return 2;
+        case EgsTriangles:
+            return 3;
+        case EgsLinesAdjacency:
+            return 4;
+        case EgsTrianglesAdjacency:
+            return 6;
+        default:
+            return -1;
+    }
+}
+
+bool TParseContext::CheckPrimitiveTypeMatchesTypeQualifier(const TTypeQualifier &typeQualifier)
+{
+    switch (typeQualifier.layoutQualifier.primitiveType)
+    {
+        case EgsLines:
+        case EgsLinesAdjacency:
+        case EgsTriangles:
+        case EgsTrianglesAdjacency:
+            return typeQualifier.qualifier == EvqGeometryIn;
+
+        case EgsLineStrip:
+        case EgsTriangleStrip:
+            return typeQualifier.qualifier == EvqGeometryOut;
+
+        default:
+            return true;
+    }
+}
+
+bool TParseContext::parseGeometryShaderInputLayouts(const TTypeQualifier &typeQualifier)
+{
+    ASSERT(typeQualifier.qualifier == EvqGeometryIn);
+
+    const TLayoutQualifier &layoutQualifier = typeQualifier.layoutQualifier;
+
+    // Set Geometry Shader input primitive
+    if (layoutQualifier.primitiveType != EgsUndefined)
+    {
+        if (mGeometryPrimitiveIn == EgsUndefined)
+        {
+            mGeometryPrimitiveIn = layoutQualifier.primitiveType;
+        }
+        else if (mGeometryPrimitiveIn != layoutQualifier.primitiveType)
+        {
+            error(typeQualifier.line,
+                  "primitive doesn't match earlier in type layout primitive declaration", "layout");
+            return false;
+        }
+
+        // Set Geometry Shader input array size
+        if (mGeometryInputArraySize == -1)
+        {
+            mGeometryInputArraySize =
+                GetGeometryShaderInputArraySize(layoutQualifier.primitiveType);
+
+            TVariable *glIn =
+                static_cast<TVariable *>(symbolTable.findBuiltIn("gl_in", mShaderVersion));
+            ASSERT(glIn->getType().getInterfaceBlock());
+            glIn->getType().setArraySize(mGeometryInputArraySize);
+            glIn->getType().getInterfaceBlock()->setArraySize(mGeometryInputArraySize);
+        }
+        else if (mGeometryInputArraySize !=
+                 GetGeometryShaderInputArraySize(layoutQualifier.primitiveType))
+        {
+            error(typeQualifier.line,
+                  "it is not allowed to set geometry shader input layout primitive type for "
+                  "different "
+                  "value than was previously set (directly or indirectly by input array size)",
+                  "layout");
+            return false;
+        }
+    }
+
+    // Set invocations if exists
+    if (layoutQualifier.invocations > 0)
+    {
+        if (mGeometryInvocations == 0)
+        {
+            mGeometryInvocations = layoutQualifier.invocations;
+        }
+        else if (mGeometryInvocations != layoutQualifier.invocations)
+        {
+            error(typeQualifier.line, "invocations contradicts to the earlier declaration",
+                  "layout");
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool TParseContext::parseGeometryShaderOutputLayouts(const TTypeQualifier &typeQualifier)
+{
+    ASSERT(typeQualifier.qualifier == EvqGeometryOut);
+
+    const TLayoutQualifier &layoutQualifier = typeQualifier.layoutQualifier;
+
+    // Set output primitive type
+    if (layoutQualifier.primitiveType != EgsUndefined)
+    {
+        if (mGeometryPrimitiveOut == EgsUndefined)
+        {
+            mGeometryPrimitiveOut = layoutQualifier.primitiveType;
+        }
+        else if (mGeometryPrimitiveOut != layoutQualifier.primitiveType)
+        {
+            error(typeQualifier.line,
+                  "primitive doesn't match earlier out type layout primitive declaration",
+                  "layout");
+            return false;
+        }
+    }
+
+    // Set max_vertices if exists
+    if (layoutQualifier.maxVertices > 0)
+    {
+        if (mGeometryMaxVertices == -1)
+        {
+            mGeometryMaxVertices = layoutQualifier.maxVertices;
+        }
+        else if (mGeometryMaxVertices != layoutQualifier.maxVertices)
+        {
+            error(typeQualifier.line, "max_vertices contradicts to the earlier declaration",
+                  "layout");
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool TParseContext::parseGeometryShaderLayouts(const TTypeQualifier &typeQualifier)
+{
+    ASSERT(typeQualifier.qualifier == EvqGeometryIn || typeQualifier.qualifier == EvqGeometryOut);
+
+    if (!CheckPrimitiveTypeMatchesTypeQualifier(typeQualifier))
+    {
+        error(typeQualifier.line, "invalid layout", "layout");
+        return false;
+    }
+
+    const TLayoutQualifier &layoutQualifier = typeQualifier.layoutQualifier;
+    if (layoutQualifier.invocations > 0 && typeQualifier.qualifier != EvqGeometryIn)
+    {
+        error(typeQualifier.line,
+              "invocations can only be declared in in layout in a geometry"
+              "shader",
+              "layout");
+        return false;
+    }
+
+    if (layoutQualifier.maxVertices != -1 && typeQualifier.qualifier != EvqGeometryOut)
+    {
+        error(typeQualifier.line,
+              "max_vertices can only be declared in out layout in a geometry"
+              "shader",
+              "layout");
+        return false;
+    }
+
+    if (typeQualifier.qualifier == EvqGeometryIn)
+    {
+        return parseGeometryShaderInputLayouts(typeQualifier);
+    }
+    else
+    {
+        return parseGeometryShaderOutputLayouts(typeQualifier);
+    }
+}
+
 void TParseContext::parseGlobalLayoutQualifier(const TTypeQualifierBuilder &typeQualifierBuilder)
 {
     TTypeQualifier typeQualifier = typeQualifierBuilder.getVariableTypeQualifier(mDiagnostics);
@@ -2477,6 +2729,27 @@ void TParseContext::parseGlobalLayoutQualifier(const TTypeQualifierBuilder &type
 
     checkOffsetIsNotSpecified(typeQualifier.line, layoutQualifier.offset);
 
+    if (mShaderVersion < 310)
+    {
+        switch (typeQualifier.qualifier)
+        {
+            case EvqComputeIn:
+            case EvqGeometryIn:
+            {
+                error(typeQualifier.line, "in type qualifier supported in GLSL ES 3.10 only",
+                      "layout");
+                return;
+            }
+            case EvqGeometryOut:
+            {
+                error(typeQualifier.line, "out type qualifier supported in GLSL ES 3.10 only",
+                      "layout");
+                return;
+            }
+            default:
+                break;
+        }
+    }
     if (typeQualifier.qualifier == EvqComputeIn)
     {
         if (mComputeShaderLocalSizeDeclared &&
@@ -2487,12 +2760,6 @@ void TParseContext::parseGlobalLayoutQualifier(const TTypeQualifierBuilder &type
             return;
         }
 
-        if (mShaderVersion < 310)
-        {
-            error(typeQualifier.line, "in type qualifier supported in GLSL ES 3.10 only", "layout");
-            return;
-        }
-
         if (!layoutQualifier.localSize.isAnyValueSet())
         {
             error(typeQualifier.line, "No local work group size specified", "layout");
@@ -2553,6 +2820,13 @@ void TParseContext::parseGlobalLayoutQualifier(const TTypeQualifierBuilder &type
 
         mNumViews = layoutQualifier.numViews;
     }
+    else if (typeQualifier.qualifier == EvqGeometryIn || typeQualifier.qualifier == EvqGeometryOut)
+    {
+        if (!parseGeometryShaderLayouts(typeQualifier))
+        {
+            return;
+        }
+    }
     else
     {
         if (!checkWorkGroupSizeIsNotSpecified(typeQualifier.line, layoutQualifier))
@@ -3169,9 +3443,39 @@ TIntermTyped *TParseContext::addIndexExpression(TIntermTyped *baseExpression,
     {
         if (baseExpression->isInterfaceBlock())
         {
-            error(location,
-                  "array indexes for interface blocks arrays must be constant integral expressions",
-                  "[");
+            switch (baseExpression->getQualifier())
+            {
+                case EvqGLPerVertex:
+                {
+                    if (mShaderType != GL_GEOMETRY_SHADER_EXT)
+                    {
+                        error(location,
+                              "gl_PerVertex is only available with GL_EXT_geometry_shader", "[");
+                    }
+                    else if (mGeometryInputArraySize == -1)
+                    {
+                        error(location, "Missing array size declaration", "[");
+                    }
+                    break;
+                }
+                case EvqUniform:
+                {
+                    error(location,
+                          "Array indexes for uniform interface block arrays must be constant "
+                          "integral "
+                          "expressions",
+                          "[");
+                    break;
+                }
+                default:
+                {
+                    error(location,
+                          "Invalid interface block array type"
+                          "expressions",
+                          "[");
+                    break;
+                }
+            }
         }
         else if (baseExpression->getQualifier() == EvqFragmentOut)
         {
@@ -3272,7 +3576,7 @@ int TParseContext::checkIndexOutOfRange(bool outOfRangeIndexIsError,
         reasonStream << reason << " '" << index << "'";
         std::string token = reasonStream.str();
         outOfRangeError(outOfRangeIndexIsError, location, reason, "[]");
-        if (index < 0)
+        if (index < 0 || arraySize == 0)
         {
             return 0;
         }
@@ -3501,7 +3805,48 @@ TLayoutQualifier TParseContext::parseLayoutQualifier(const TString &qualifierTyp
         checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
         qualifier.imageInternalFormat = EiifR32UI;
     }
-
+    else if (qualifierType == "points" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsPoints;
+    }
+    else if (qualifierType == "lines" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsLines;
+    }
+    else if (qualifierType == "lines_adjacency" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsLinesAdjacency;
+    }
+    else if (qualifierType == "triangles" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsTriangles;
+    }
+    else if (qualifierType == "triangles_adjacency" &&
+             isExtensionEnabled("GL_EXT_geometry_shader") && mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsTrianglesAdjacency;
+    }
+    else if (qualifierType == "line_strip" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsLineStrip;
+    }
+    else if (qualifierType == "triangle_strip" && isExtensionEnabled("GL_EXT_geometry_shader") &&
+             mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        checkLayoutQualifierSupported(qualifierTypeLine, qualifierType, 310);
+        qualifier.primitiveType = EgsTriangleStrip;
+    }
     else
     {
         error(qualifierTypeLine, "invalid layout qualifier", qualifierType.c_str());
@@ -3543,6 +3888,50 @@ void TParseContext::parseNumViews(int intValue,
     *numViews = intValue;
 }
 
+void TParseContext::parseNumInvocations(int intValue,
+                                        const TSourceLoc &intValueLine,
+                                        const std::string &intValueString,
+                                        int *numInvocations)
+{
+    if (intValue < 0)
+    {
+        error(intValueLine, "out of range: invocations must be non-negative",
+              intValueString.c_str());
+    }
+    else if (intValue > mMaxGeometryInvocations)
+    {
+        error(intValueLine,
+              "out of range: invocations must be smaller than MAX_GEOMETRY_SHADER_INVOCATIONS_EXT",
+              intValueString.c_str());
+    }
+    else
+    {
+        *numInvocations = intValue;
+    }
+}
+
+void TParseContext::parseMaxVertices(int intValue,
+                                     const TSourceLoc &intValueLine,
+                                     const std::string &intValueString,
+                                     int *maxVertices)
+{
+    if (intValue < 0)
+    {
+        error(intValueLine, "out of range: max_vertices must be non-negative",
+              intValueString.c_str());
+    }
+    else if (intValue > mMaxGeometryMaxVertices)
+    {
+        error(intValueLine,
+              "out of range: max_vertices must be smaller than gl_MaxGeometryOutputVertices",
+              intValueString.c_str());
+    }
+    else
+    {
+        *maxVertices = intValue;
+    }
+}
+
 TLayoutQualifier TParseContext::parseLayoutQualifier(const TString &qualifierType,
                                                      const TSourceLoc &qualifierTypeLine,
                                                      int intValue,
@@ -3612,6 +4001,17 @@ TLayoutQualifier TParseContext::parseLayoutQualifier(const TString &qualifierTyp
     {
         parseNumViews(intValue, intValueLine, intValueString, &qualifier.numViews);
     }
+    else if (mShaderType == GL_GEOMETRY_SHADER_EXT)
+    {
+        if (qualifierType == "invocations")
+        {
+            parseNumInvocations(intValue, intValueLine, intValueString, &qualifier.invocations);
+        }
+        else if (qualifierType == "max_vertices")
+        {
+            parseMaxVertices(intValue, intValueLine, intValueString, &qualifier.maxVertices);
+        }
+    }
     else
     {
         error(qualifierTypeLine, "invalid layout qualifier", qualifierType.c_str());
diff --git a/src/compiler/translator/ParseContext.h b/src/compiler/translator/ParseContext.h
index 626f335e8..9b614880e 100644
--- a/src/compiler/translator/ParseContext.h
+++ b/src/compiler/translator/ParseContext.h
@@ -298,6 +298,14 @@ class TParseContext : angle::NonCopyable
                        const TSourceLoc &intValueLine,
                        const std::string &intValueString,
                        int *numViews);
+    void parseNumInvocations(int intValue,
+                             const TSourceLoc &intValueLine,
+                             const std::string &intValueString,
+                             int *numInvocations);
+    void parseMaxVertices(int intValue,
+                          const TSourceLoc &intValueLine,
+                          const std::string &intValueString,
+                          int *maxVertices);
     TLayoutQualifier parseLayoutQualifier(const TString &qualifierType,
                                           const TSourceLoc &qualifierTypeLine);
     TLayoutQualifier parseLayoutQualifier(const TString &qualifierType,
@@ -359,6 +367,12 @@ class TParseContext : angle::NonCopyable
                                       TIntermTyped *falseExpression,
                                       const TSourceLoc &line);
 
+    int getGeometryInputArraySize() const { return mGeometryInputArraySize; }
+    int getGeometryMaxVertices() const { return mGeometryMaxVertices; }
+    int getGeometryInvocations() const { return mGeometryInvocations; }
+    TLayoutGeometryShaderEXT getGeometryInputPrimitive() const { return mGeometryPrimitiveIn; }
+    TLayoutGeometryShaderEXT getGeometryOutputPrimitive() const { return mGeometryPrimitiveOut; }
+
     // TODO(jmadill): make these private
     TIntermediate intermediate;  // to build a parse tree
     TSymbolTable &symbolTable;   // symbol table that goes with the language currently being parsed
@@ -465,6 +479,11 @@ class TParseContext : angle::NonCopyable
     // followed by a declarator.
     bool mDeferredNonEmptyDeclarationErrorCheck;
 
+    bool CheckPrimitiveTypeMatchesTypeQualifier(const TTypeQualifier &typeQualifier);
+    bool parseGeometryShaderLayouts(const TTypeQualifier &typeQualifier);
+    bool parseGeometryShaderInputLayouts(const TTypeQualifier &typeQualifier);
+    bool parseGeometryShaderOutputLayouts(const TTypeQualifier &typeQualifier);
+
     sh::GLenum mShaderType;    // vertex or fragment language (future: pack or unpack)
     ShShaderSpec mShaderSpec;  // The language specification compiler conforms to - GLES2 or WebGL.
     ShCompileOptions mCompileOptions;  // Options passed to TCompiler
@@ -513,6 +532,15 @@ class TParseContext : angle::NonCopyable
 
     // Track the state of each atomic counter binding.
     std::map<int, AtomicCounterBindingState> mAtomicCounterBindingStates;
+
+    // keep track of geometry shader global parameters declared in layout.
+    int mMaxGeometryInvocations;
+    int mMaxGeometryMaxVertices;
+    TLayoutGeometryShaderEXT mGeometryPrimitiveIn;
+    TLayoutGeometryShaderEXT mGeometryPrimitiveOut;
+    int mGeometryInputArraySize;
+    int mGeometryInvocations;
+    int mGeometryMaxVertices;
 };
 
 int PaParseStrings(size_t count,
diff --git a/src/compiler/translator/QualifierTypes.cpp b/src/compiler/translator/QualifierTypes.cpp
index 4d7b206c3..a85117eb7 100644
--- a/src/compiler/translator/QualifierTypes.cpp
+++ b/src/compiler/translator/QualifierTypes.cpp
@@ -308,11 +308,15 @@ bool JoinVariableStorageQualifier(TQualifier *joinedQualifier, TQualifier storag
                     *joinedQualifier = EvqCentroid;
                     break;
                 case EvqVertexOut:
+                case EvqGeometryOut:
                     *joinedQualifier = EvqSmoothOut;
                     break;
                 case EvqFragmentIn:
                     *joinedQualifier = EvqSmoothIn;
                     break;
+                case EvqGeometryIn:
+                    *joinedQualifier = EvqGeometryIn;
+                    break;
                 default:
                     return false;
             }
@@ -326,11 +330,15 @@ bool JoinVariableStorageQualifier(TQualifier *joinedQualifier, TQualifier storag
                     *joinedQualifier = EvqFlat;
                     break;
                 case EvqVertexOut:
+                case EvqGeometryOut:
                     *joinedQualifier = EvqFlatOut;
                     break;
                 case EvqFragmentIn:
                     *joinedQualifier = EvqFlatIn;
                     break;
+                case EvqGeometryIn:
+                    *joinedQualifier = EvqGeometryIn;
+                    break;
                 default:
                     return false;
             }
@@ -341,11 +349,15 @@ bool JoinVariableStorageQualifier(TQualifier *joinedQualifier, TQualifier storag
             switch (storageQualifier)
             {
                 case EvqVertexOut:
+                case EvqGeometryOut:
                     *joinedQualifier = EvqCentroidOut;
                     break;
                 case EvqFragmentIn:
                     *joinedQualifier = EvqCentroidIn;
                     break;
+                case EvqGeometryIn:
+                    *joinedQualifier = EvqGeometryIn;
+                    break;
                 default:
                     return false;
             }
@@ -606,6 +618,40 @@ TLayoutQualifier JoinLayoutQualifiers(TLayoutQualifier leftQualifier,
         joinedQualifier.imageInternalFormat = rightQualifier.imageInternalFormat;
     }
 
+    if (rightQualifier.primitiveType != EgsUndefined)
+    {
+        if (joinedQualifier.primitiveType != EgsUndefined &&
+            joinedQualifier.primitiveType != rightQualifier.primitiveType)
+        {
+            diagnostics->error(rightQualifierLocation,
+                               "Cannot have multiple different primitive specifiers",
+                               getGeometryShaderPrimitiveTypeString(rightQualifier.primitiveType));
+        }
+        joinedQualifier.primitiveType = rightQualifier.primitiveType;
+    }
+
+    if (rightQualifier.invocations != 0)
+    {
+        if (joinedQualifier.invocations != 0 &&
+            joinedQualifier.invocations != rightQualifier.invocations)
+        {
+            diagnostics->error(rightQualifierLocation, "Cannot have multiple different invocations",
+                               "invocations");
+        }
+        joinedQualifier.invocations = rightQualifier.invocations;
+    }
+
+    if (rightQualifier.maxVertices != -1)
+    {
+        if (joinedQualifier.maxVertices != -1 &&
+            joinedQualifier.maxVertices != rightQualifier.maxVertices)
+        {
+            diagnostics->error(rightQualifierLocation,
+                               "Cannot have multiple different max_vertices", "max_vertices");
+        }
+        joinedQualifier.maxVertices = rightQualifier.maxVertices;
+    }
+
     return joinedQualifier;
 }
 
diff --git a/src/compiler/translator/ShaderLang.cpp b/src/compiler/translator/ShaderLang.cpp
index adeebf33a..3c06ec72a 100644
--- a/src/compiler/translator/ShaderLang.cpp
+++ b/src/compiler/translator/ShaderLang.cpp
@@ -11,6 +11,7 @@
 
 #include "GLSLANG/ShaderLang.h"
 
+#include "compiler/translator/BaseTypes.h"
 #include "compiler/translator/Compiler.h"
 #include "compiler/translator/InitializeDll.h"
 #include "compiler/translator/length_limits.h"
@@ -43,12 +44,6 @@ const std::vector<Uniform> *GetVariableList(const TCompiler *compiler)
 }
 
 template <>
-const std::vector<Varying> *GetVariableList(const TCompiler *compiler)
-{
-    return &compiler->getVaryings();
-}
-
-template <>
 const std::vector<Attribute> *GetVariableList(const TCompiler *compiler)
 {
     return &compiler->getAttributes();
@@ -164,6 +159,7 @@ void InitBuiltInResources(ShBuiltInResources *resources)
     resources->ARM_shader_framebuffer_fetch    = 0;
     resources->OVR_multiview                   = 0;
     resources->EXT_YUV_target                  = 0;
+    resources->EXT_geometry_shader             = 0;
 
     resources->NV_draw_buffers = 0;
 
@@ -224,6 +220,17 @@ void InitBuiltInResources(ShBuiltInResources *resources)
     resources->MaxAtomicCounterBufferSize      = 32;
 
     resources->MaxUniformBufferBindings = 32;
+
+    resources->MaxGeometryInputComponents       = 64;
+    resources->MaxGeometryOutputComponents      = 64;
+    resources->MaxGeometryImageUniforms         = 0;
+    resources->MaxGeometryTextureImageUnits     = 16;
+    resources->MaxGeometryOutputVertices        = 256;
+    resources->MaxGeometryTotalOutputComponents = 1024;
+    resources->MaxGeometryUniformComponents     = 1024;
+    resources->MaxGeometryAtomicCounters        = 0;
+    resources->MaxGeometryAtomicCounterBuffers  = 0;
+    resources->MaxGeometryInvocations           = 32;
 }
 
 //
@@ -349,11 +356,6 @@ const std::vector<Uniform> *GetUniforms(const ShHandle handle)
     return GetShaderVariables<Uniform>(handle);
 }
 
-const std::vector<Varying> *GetVaryings(const ShHandle handle)
-{
-    return GetShaderVariables<Varying>(handle);
-}
-
 const std::vector<Attribute> *GetAttributes(const ShHandle handle)
 {
     return GetShaderVariables<Attribute>(handle);
@@ -390,6 +392,109 @@ int GetVertexShaderNumViews(const ShHandle handle)
     return compiler->getNumViews();
 }
 
+const std::vector<sh::Varying> *GetVaryings(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    switch (compiler->getShaderType())
+    {
+        case GL_VERTEX_SHADER:
+            return &compiler->getOutputVaryings();
+        case GL_FRAGMENT_SHADER:
+            return &compiler->getInputVaryings();
+        default:
+            UNREACHABLE();
+            return &compiler->getOutputVaryings();
+    }
+}
+
+const std::vector<sh::Varying> *GetInputVaryings(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    return &compiler->getInputVaryings();
+}
+
+const std::vector<sh::Varying> *GetOutputVaryings(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    return &compiler->getOutputVaryings();
+}
+
+GLenum GetGeometryShaderInputPrimitives(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    switch (compiler->getGeometryShaderInputPrimitives())
+    {
+        case TLayoutGeometryShaderEXT::EgsPoints:
+            return GL_POINTS;
+        case TLayoutGeometryShaderEXT::EgsLines:
+            return GL_LINES;
+        case TLayoutGeometryShaderEXT::EgsLinesAdjacency:
+            return GL_LINES_ADJACENCY_EXT;
+        case TLayoutGeometryShaderEXT::EgsTriangles:
+            return GL_TRIANGLES;
+        case TLayoutGeometryShaderEXT::EgsTrianglesAdjacency:
+            return GL_TRIANGLES_ADJACENCY_EXT;
+        default:
+            return GL_INVALID_VALUE;
+    }
+}
+
+GLenum GetGeometryShaderOutputPrimitives(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    switch (compiler->getGeometryShaderOutputPrimitives())
+    {
+        case TLayoutGeometryShaderEXT::EgsPoints:
+            return GL_POINTS;
+        case TLayoutGeometryShaderEXT::EgsLineStrip:
+            return GL_LINE_STRIP;
+        case TLayoutGeometryShaderEXT::EgsTriangleStrip:
+            return GL_TRIANGLE_STRIP;
+        default:
+            return GL_INVALID_VALUE;
+    }
+}
+
+int GetGeometryShaderInvocations(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    return compiler->getGeometryShaderInvocations();
+}
+
+int GetGeometryShaderMaxVertices(const ShHandle handle)
+{
+    ASSERT(handle);
+    TShHandleBase *base = static_cast<TShHandleBase *>(handle);
+    TCompiler *compiler = base->getAsCompiler();
+    ASSERT(compiler);
+
+    return compiler->getGeometryShaderMaxVertices();
+}
+
 bool CheckVariablesWithinPackingLimits(int maxVectors, const std::vector<ShaderVariable> &variables)
 {
     VariablePacker packer;
diff --git a/src/compiler/translator/TranslatorESSL.cpp b/src/compiler/translator/TranslatorESSL.cpp
index ddb8c4c25..98fc6908e 100644
--- a/src/compiler/translator/TranslatorESSL.cpp
+++ b/src/compiler/translator/TranslatorESSL.cpp
@@ -95,6 +95,82 @@ void TranslatorESSL::translate(TIntermBlock *root, ShCompileOptions compileOptio
              << ", local_size_z=" << localSize[2] << ") in;\n";
     }
 
+    if (getShaderType() == GL_GEOMETRY_SHADER_EXT)
+    {
+        sh::TLayoutGeometryShaderEXT inputPrimitive = getGeometryShaderInputPrimitives();
+        int invocations                             = getGeometryShaderInvocations();
+
+        if (inputPrimitive != EgsUndefined || invocations > 0)
+        {
+            sink << "layout (";
+
+            switch (inputPrimitive)
+            {
+                case EgsPoints:
+                    sink << "points";
+                    break;
+                case EgsLines:
+                    sink << "lines";
+                    break;
+                case EgsLinesAdjacency:
+                    sink << "lines_adjacency";
+                    break;
+                case EgsTriangles:
+                    sink << "triangles";
+                    break;
+                case EgsTrianglesAdjacency:
+                    sink << "triangles_adjacency";
+                    break;
+                default:
+                    break;
+            }
+
+            if (invocations)
+            {
+                if (inputPrimitive != EgsUndefined)
+                {
+                    sink << ", ";
+                }
+
+                sink << "invocations = " << invocations;
+            }
+            sink << ") in;\n";
+        }
+
+        sh::TLayoutGeometryShaderEXT outputPrimitive = getGeometryShaderOutputPrimitives();
+        int maxVertices                              = getGeometryShaderMaxVertices();
+
+        if (outputPrimitive != EgsUndefined || maxVertices != -1)
+        {
+            sink << "layout (";
+
+            switch (outputPrimitive)
+            {
+                case EgsPoints:
+                    sink << "points";
+                    break;
+                case EgsLineStrip:
+                    sink << "line_strip";
+                    break;
+                case EgsTriangleStrip:
+                    sink << "triangle_strip";
+                    break;
+                default:
+                    break;
+            }
+
+            if (maxVertices != -1)
+            {
+                if (outputPrimitive != EgsUndefined)
+                {
+                    sink << ", ";
+                }
+                sink << "max_vertices = " << maxVertices;
+            }
+            sink << ") out;\n";
+        }
+    }
+
     // Write translated shader.
     TOutputESSL outputESSL(sink, getArrayIndexClampingStrategy(), getHashFunction(), getNameMap(),
                            getSymbolTable(), getShaderType(), shaderVer, precisionEmulation,
diff --git a/src/compiler/translator/TranslatorGLSL.cpp b/src/compiler/translator/TranslatorGLSL.cpp
index 41abbfc01..1c46dd036 100644
--- a/src/compiler/translator/TranslatorGLSL.cpp
+++ b/src/compiler/translator/TranslatorGLSL.cpp
@@ -200,6 +200,82 @@ void TranslatorGLSL::translate(TIntermBlock *root, ShCompileOptions compileOptio
              << ", local_size_z=" << localSize[2] << ") in;\n";
     }
 
+    if (getShaderType() == GL_GEOMETRY_SHADER_EXT)
+    {
+        sh::TLayoutGeometryShaderEXT inputPrimitive = getGeometryShaderInputPrimitives();
+        int invocations                             = getGeometryShaderInvocations();
+
+        if (inputPrimitive != EgsUndefined || invocations > 0)
+        {
+            sink << "layout (";
+
+            switch (inputPrimitive)
+            {
+                case EgsPoints:
+                    sink << "points";
+                    break;
+                case EgsLines:
+                    sink << "lines";
+                    break;
+                case EgsLinesAdjacency:
+                    sink << "lines_adjacency";
+                    break;
+                case EgsTriangles:
+                    sink << "triangles";
+                    break;
+                case EgsTrianglesAdjacency:
+                    sink << "triangles_adjacency";
+                    break;
+                default:
+                    break;
+            }
+
+            if (invocations)
+            {
+                if (inputPrimitive != EgsUndefined)
+                {
+                    sink << ", ";
+                }
+
+                sink << "invocations = " << invocations;
+            }
+            sink << ") in;\n";
+        }
+
+        sh::TLayoutGeometryShaderEXT outputPrimitive = getGeometryShaderOutputPrimitives();
+        int maxVertices                              = getGeometryShaderMaxVertices();
+
+        if (outputPrimitive != EgsUndefined || maxVertices != -1)
+        {
+            sink << "layout (";
+
+            switch (outputPrimitive)
+            {
+                case EgsPoints:
+                    sink << "points";
+                    break;
+                case EgsLineStrip:
+                    sink << "line_strip";
+                    break;
+                case EgsTriangleStrip:
+                    sink << "triangle_strip";
+                    break;
+                default:
+                    break;
+            }
+
+            if (maxVertices != -1)
+            {
+                if (outputPrimitive != EgsUndefined)
+                {
+                    sink << ", ";
+                }
+                sink << "max_vertices = " << maxVertices;
+            }
+            sink << ") out;\n";
+        }
+    }
+
     // Write translated shader.
     TOutputGLSL outputGLSL(sink, getArrayIndexClampingStrategy(), getHashFunction(), getNameMap(),
                            getSymbolTable(), getShaderType(), getShaderVersion(), getOutputType(),
@@ -268,6 +344,12 @@ void TranslatorGLSL::writeExtensionBehavior(TIntermNode *root)
                 sink << "#extension GL_ARB_draw_buffers : " << getBehaviorString(iter.second)
                      << "\n";
             }
+
+            if (iter.first == "GL_EXT_geometry_shader")
+            {
+                sink << "#extension GL_ARB_geometry_shader4 : " << getBehaviorString(iter.second)
+                     << "\n";
+            }
         }
     }
 
diff --git a/src/compiler/translator/Types.h b/src/compiler/translator/Types.h
index 6a1471fdc..cd5a084b6 100644
--- a/src/compiler/translator/Types.h
+++ b/src/compiler/translator/Types.h
@@ -175,6 +175,7 @@ class TInterfaceBlock : public TFieldListCollection
             mMangledName = buildMangledName("iblock-");
         return mMangledName;
     }
+    void setArraySize(int arraySize) { mArraySize = arraySize; }
 
   private:
     const TString *mInstanceName;  // for interface block instance names
@@ -356,6 +357,11 @@ class TType
             invalidateMangledName();
         }
     }
+    void setArrayUnsized()
+    {
+        array     = true;
+        arraySize = 0;
+    }
     void clearArrayness()
     {
         if (array)
diff --git a/src/compiler/translator/VariableInfo.cpp b/src/compiler/translator/VariableInfo.cpp
index d41d45140..a1e769fd9 100644
--- a/src/compiler/translator/VariableInfo.cpp
+++ b/src/compiler/translator/VariableInfo.cpp
@@ -67,16 +67,19 @@ VarT *FindVariable(const TString &name, std::vector<VarT> *infoList)
 CollectVariables::CollectVariables(std::vector<sh::Attribute> *attribs,
                                    std::vector<sh::OutputVariable> *outputVariables,
                                    std::vector<sh::Uniform> *uniforms,
-                                   std::vector<sh::Varying> *varyings,
+                                   std::vector<sh::Varying> *inVaryings,
+                                   std::vector<sh::Varying> *outVaryings,
                                    std::vector<sh::InterfaceBlock> *interfaceBlocks,
                                    ShHashFunction64 hashFunction,
+                                   GLenum shaderType,
                                    const TSymbolTable &symbolTable,
                                    const TExtensionBehavior &extensionBehavior)
     : TIntermTraverser(true, false, false),
       mAttribs(attribs),
       mOutputVariables(outputVariables),
       mUniforms(uniforms),
-      mVaryings(varyings),
+      mInVaryings(inVaryings),
+      mOutVaryings(outVaryings),
       mInterfaceBlocks(interfaceBlocks),
       mDepthRangeAdded(false),
       mPointCoordAdded(false),
@@ -93,7 +96,9 @@ CollectVariables::CollectVariables(std::vector<sh::Attribute> *attribs,
       mFragDepthAdded(false),
       mSecondaryFragColorEXTAdded(false),
       mSecondaryFragDataEXTAdded(false),
+      mPerVertexAdded(false),
       mHashFunction(hashFunction),
+      mShaderType(shaderType),
       mSymbolTable(symbolTable),
       mExtensionBehavior(extensionBehavior)
 {
@@ -112,11 +117,42 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
 
     if (IsVarying(symbol->getQualifier()))
     {
-        var = FindVariable(symbolName, mVaryings);
+        var = FindVariable(symbolName, mInVaryings);
+        if (var == nullptr)
+        {
+            var = FindVariable(symbolName, mOutVaryings);
+        }
     }
     else if (symbol->getType().getBasicType() == EbtInterfaceBlock)
     {
-        UNREACHABLE();
+        ASSERT(symbol->getQualifier() == EvqGLPerVertex);
+
+        if (!mPerVertexAdded)
+        {
+            Varying info;
+            constexpr char kName[] = "gl_in";
+            info.name              = kName;
+            info.mappedName        = kName;
+            info.type              = GL_STRUCT_ANGLEX;
+            info.arraySize         = symbol->getArraySize();
+            info.precision         = GL_HIGH_FLOAT;
+            info.staticUse         = true;
+            info.isInvariant       = mSymbolTable.isVaryingInvariant(kName);
+
+            ShaderVariable positionInfo;
+            constexpr char kPositionName[] = "gl_Position";
+            positionInfo.name              = kPositionName;
+            positionInfo.mappedName        = kPositionName;
+            positionInfo.type              = GL_FLOAT;
+            positionInfo.arraySize         = 0;
+            positionInfo.precision         = GL_HIGH_FLOAT;
+            positionInfo.staticUse         = true;
+
+            info.fields.push_back(positionInfo);
+
+            mInVaryings->push_back(info);
+            mPerVertexAdded = true;
+        }
     }
     else if (symbolName == "gl_DepthRange")
     {
@@ -179,6 +215,12 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
             case EvqFragmentOut:
                 var = FindVariable(symbolName, mOutputVariables);
                 break;
+            case EvqGeometryIn:
+                var = FindVariable(symbolName, mInVaryings);
+                break;
+            case EvqGeometryOut:
+                var = FindVariable(symbolName, mOutVaryings);
+                break;
             case EvqUniform:
             {
                 const TInterfaceBlock *interfaceBlock = symbol->getType().getInterfaceBlock();
@@ -213,7 +255,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision     = GL_MEDIUM_FLOAT;  // Defined by spec.
                     info.staticUse     = true;
                     info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mInVaryings->push_back(info);
                     mFragCoordAdded = true;
                 }
                 return;
@@ -229,7 +271,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision     = GL_NONE;
                     info.staticUse     = true;
                     info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mInVaryings->push_back(info);
                     mFrontFacingAdded = true;
                 }
                 return;
@@ -245,7 +287,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision     = GL_MEDIUM_FLOAT;  // Defined by spec.
                     info.staticUse     = true;
                     info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mInVaryings->push_back(info);
                     mPointCoordAdded = true;
                 }
                 return;
@@ -293,7 +335,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision     = GL_HIGH_FLOAT;  // Defined by spec.
                     info.staticUse     = true;
                     info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mOutVaryings->push_back(info);
                     mPositionAdded = true;
                 }
                 return;
@@ -309,7 +351,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision     = GL_MEDIUM_FLOAT;  // Defined by spec.
                     info.staticUse     = true;
                     info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mOutVaryings->push_back(info);
                     mPointSizeAdded = true;
                 }
                 return;
@@ -328,7 +370,7 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     info.precision   = GL_MEDIUM_FLOAT;  // Defined by spec.
                     info.staticUse   = true;
                     info.isInvariant = mSymbolTable.isVaryingInvariant(kName);
-                    mVaryings->push_back(info);
+                    mInVaryings->push_back(info);
                     mLastFragDataAdded = true;
                 }
                 return;
@@ -438,6 +480,70 @@ void CollectVariables::visitSymbol(TIntermSymbol *symbol)
                     mSecondaryFragDataEXTAdded = true;
                 }
                 return;
+            case EvqInvocationID:
+                if (!mInvocationIDAdded)
+                {
+                    Attribute info;
+                    const char kName[] = "gl_InvocationID";
+                    info.name          = kName;
+                    info.mappedName    = kName;
+                    info.type          = GL_INT;
+                    info.arraySize     = 0;
+                    info.precision     = GL_HIGH_INT;  // Defined by spec.
+                    info.staticUse     = true;
+                    info.location      = -1;
+                    mAttribs->push_back(info);
+                    mInvocationIDAdded = true;
+                }
+                return;
+            case EvqPrimitiveIDIn:
+                if (!mPrimitiveIDInAdded)
+                {
+                    Attribute info;
+                    const char kName[] = "gl_PrimitiveIDIn";
+                    info.name          = kName;
+                    info.mappedName    = kName;
+                    info.type          = GL_INT;
+                    info.arraySize     = 0;
+                    info.precision     = GL_HIGH_INT;  // Defined by spec.
+                    info.staticUse     = true;
+                    info.location      = -1;
+                    mAttribs->push_back(info);
+                    mPrimitiveIDInAdded = true;
+                }
+                return;
+            case EvqPrimitiveID:
+                if (!mPrimitiveIDAdded)
+                {
+                    Varying info;
+                    const char kName[] = "gl_PrimitiveID";
+                    info.name          = kName;
+                    info.mappedName    = kName;
+                    info.type          = GL_INT;
+                    info.arraySize     = 0;
+                    info.precision     = GL_HIGH_INT;  // Defined by spec.
+                    info.staticUse     = true;
+                    info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
+                    mOutVaryings->push_back(info);
+                    mPrimitiveIDAdded = true;
+                }
+                return;
+            case EvqLayer:
+                if (!mLayerAdded)
+                {
+                    Varying info;
+                    const char kName[] = "gl_Layer";
+                    info.name          = kName;
+                    info.mappedName    = kName;
+                    info.type          = GL_INT;
+                    info.arraySize     = 0;
+                    info.precision     = GL_HIGH_INT;  // Defined by spec.
+                    info.staticUse     = true;
+                    info.isInvariant   = mSymbolTable.isVaryingInvariant(kName);
+                    mOutVaryings->push_back(info);
+                    mLayerAdded = true;
+                }
+                return;
             default:
                 break;
         }
@@ -536,6 +642,7 @@ Varying CollectVariables::recordVarying(const TIntermSymbol &variable) const
     return varying;
 }
 
+// TODO(jiawei.shao@intel.com): implement EXT_shader_io_blocks
 InterfaceBlock CollectVariables::recordInterfaceBlock(const TIntermSymbol &variable) const
 {
     const TInterfaceBlock *blockType = variable.getType().getInterfaceBlock();
@@ -585,7 +692,8 @@ bool CollectVariables::visitDeclaration(Visit, TIntermDeclaration *node)
     TQualifier qualifier          = typedNode.getQualifier();
 
     bool isShaderVariable = qualifier == EvqAttribute || qualifier == EvqVertexIn ||
-                            qualifier == EvqFragmentOut || qualifier == EvqUniform ||
+                            qualifier == EvqFragmentOut || qualifier == EvqGeometryIn ||
+                            qualifier == EvqGeometryOut || qualifier == EvqUniform ||
                             IsVarying(qualifier);
 
     if (typedNode.getBasicType() != EbtInterfaceBlock && !isShaderVariable)
@@ -599,7 +707,7 @@ bool CollectVariables::visitDeclaration(Visit, TIntermDeclaration *node)
         // initialization. It will contain a TInterBinary node in that case. Since attributes,
         // uniforms, varyings, outputs and interface blocks cannot be initialized in a shader, we
         // must have only TIntermSymbol nodes in the sequence in the cases we are interested in.
-        const TIntermSymbol &variable = *variableNode->getAsSymbolNode();
+        TIntermSymbol &variable = *variableNode->getAsSymbolNode();
         if (typedNode.getBasicType() == EbtInterfaceBlock)
         {
             mInterfaceBlocks->push_back(recordInterfaceBlock(variable));
@@ -618,9 +726,33 @@ bool CollectVariables::visitDeclaration(Visit, TIntermDeclaration *node)
                 case EvqUniform:
                     mUniforms->push_back(recordUniform(variable));
                     break;
-                default:
-                    mVaryings->push_back(recordVarying(variable));
+                case EvqVaryingIn:
+                case EvqFragmentIn:
+                case EvqGeometryIn:
+                case EvqFlatIn:
+                case EvqCentroidIn:
+                case EvqSmoothIn:
+                {
+                    if (variable.isUnsizedArray())
+                    {
+                        const auto *symbol = dynamic_cast<TVariable *>(
+                            mSymbolTable.findGlobal(variable.getName().getString()));
+                        ASSERT(symbol);
+                        variable.getTypePointer()->setArraySize(symbol->getType().getArraySize());
+                    }
+                    mInVaryings->push_back(recordVarying(variable));
                     break;
+                }
+                case EvqVaryingOut:
+                case EvqVertexOut:
+                case EvqGeometryOut:
+                case EvqFlatOut:
+                case EvqCentroidOut:
+                case EvqSmoothOut:
+                    mOutVaryings->push_back(recordVarying(variable));
+                    break;
+                default:
+                    UNREACHABLE();
             }
         }
     }
@@ -643,12 +775,19 @@ bool CollectVariables::visitBinary(Visit, TIntermBinary *binaryNode)
 
         const TInterfaceBlock *interfaceBlock = blockNode->getType().getInterfaceBlock();
         InterfaceBlock *namedBlock = FindVariable(interfaceBlock->name(), mInterfaceBlocks);
-        ASSERT(namedBlock);
-        namedBlock->staticUse = true;
+        if (!namedBlock)
+        {
+            ASSERT(mShaderType == GL_GEOMETRY_SHADER_EXT);
+            return true;
+        }
+        else
+        {
+            namedBlock->staticUse = true;
 
-        unsigned int fieldIndex = constantUnion->getUConst(0);
-        ASSERT(fieldIndex < namedBlock->fields.size());
-        namedBlock->fields[fieldIndex].staticUse = true;
+            unsigned int fieldIndex = constantUnion->getUConst(0);
+            ASSERT(fieldIndex < namedBlock->fields.size());
+            namedBlock->fields[fieldIndex].staticUse = true;
+        }
         return false;
     }
 
diff --git a/src/compiler/translator/VariableInfo.h b/src/compiler/translator/VariableInfo.h
index f24e2c816..f7a69c194 100644
--- a/src/compiler/translator/VariableInfo.h
+++ b/src/compiler/translator/VariableInfo.h
@@ -24,9 +24,11 @@ class CollectVariables : public TIntermTraverser
     CollectVariables(std::vector<Attribute> *attribs,
                      std::vector<OutputVariable> *outputVariables,
                      std::vector<Uniform> *uniforms,
-                     std::vector<Varying> *varyings,
+                     std::vector<Varying> *inVaryings,
+                     std::vector<Varying> *outVaryings,
                      std::vector<InterfaceBlock> *interfaceBlocks,
                      ShHashFunction64 hashFunction,
+                     GLenum shaderType,
                      const TSymbolTable &symbolTable,
                      const TExtensionBehavior &extensionBehavior);
 
@@ -48,7 +50,9 @@ class CollectVariables : public TIntermTraverser
     std::vector<Attribute> *mAttribs;
     std::vector<OutputVariable> *mOutputVariables;
     std::vector<Uniform> *mUniforms;
-    std::vector<Varying> *mVaryings;
+
+    std::vector<Varying> *mInVaryings;
+    std::vector<Varying> *mOutVaryings;
     std::vector<InterfaceBlock> *mInterfaceBlocks;
 
     std::map<std::string, InterfaceBlockField *> mInterfaceBlockFields;
@@ -70,8 +74,15 @@ class CollectVariables : public TIntermTraverser
     bool mSecondaryFragColorEXTAdded;
     bool mSecondaryFragDataEXTAdded;
 
+    bool mPerVertexAdded;
+    bool mInvocationIDAdded;
+    bool mPrimitiveIDAdded;
+    bool mPrimitiveIDInAdded;
+    bool mLayerAdded;
+
     ShHashFunction64 mHashFunction;
 
+    const GLenum mShaderType;
     const TSymbolTable &mSymbolTable;
     const TExtensionBehavior &mExtensionBehavior;
 };
diff --git a/src/compiler/translator/glslang.y b/src/compiler/translator/glslang.y
index 03784dc16..4a239cc14 100644
--- a/src/compiler/translator/glslang.y
+++ b/src/compiler/translator/glslang.y
@@ -140,8 +140,9 @@ extern void yyerror(YYLTYPE* yylloc, TParseContext* context, void *scanner, cons
 }
 
 #define NON_COMPUTE_ONLY(S, L) {  \
-    if (context->getShaderType() != GL_VERTEX_SHADER && context->getShaderType() != GL_FRAGMENT_SHADER) {  \
-        context->error(L, " supported in vertex and fragment shaders only ", S);  \
+    if (context->getShaderType() != GL_VERTEX_SHADER && context->getShaderType() != GL_FRAGMENT_SHADER && \
+        context->getShaderType() != GL_GEOMETRY_SHADER_EXT) {  \
+        context->error(L, " supported in vertex, geometry and fragment shaders only ", S);  \
     }  \
 }
 
@@ -805,6 +806,11 @@ single_declaration
         $$.type = $1;
         $$.intermDeclaration = context->parseSingleDeclaration($$.type, @2, *$2.string);
     }
+    | fully_specified_type identifier LEFT_BRACKET RIGHT_BRACKET {
+        ES3_1_ONLY("[]", @3, "implicitly sized array declaration");
+        $$.type = $1;
+        $$.intermDeclaration = context->parseSingleArrayDeclaration($$.type, @2, *$2.string, @3, nullptr);
+    }
     | fully_specified_type identifier LEFT_BRACKET constant_expression RIGHT_BRACKET {
         $$.type = $1;
         $$.intermDeclaration = context->parseSingleArrayDeclaration($$.type, @2, *$2.string, @3, $4);
@@ -917,10 +923,14 @@ storage_qualifier
             ES3_OR_NEWER_OR_MULTIVIEW("in", @1, "storage qualifier");
             $$ = new TStorageQualifierWrapper(EvqVertexIn, @1);
         }
-        else
+        else if (context->getShaderType() == GL_COMPUTE_SHADER)
         {
             $$ = new TStorageQualifierWrapper(EvqComputeIn, @1);
         }
+        else
+        {
+            $$ = new TStorageQualifierWrapper(EvqGeometryIn, @1);
+        }
     }
     | OUT_QUAL {
         if (context->declaringFunction())
@@ -935,10 +945,14 @@ storage_qualifier
             {
                 $$ = new TStorageQualifierWrapper(EvqFragmentOut, @1);
             }
-            else
+            else if (context->getShaderType() == GL_VERTEX_SHADER)
             {
                 $$ = new TStorageQualifierWrapper(EvqVertexOut, @1);
             }
+            else
+            {
+                $$ = new TStorageQualifierWrapper(EvqGeometryOut, @1);
+            }
         }
     }
     | INOUT_QUAL {
diff --git a/src/compiler/translator/glslang_tab.cpp b/src/compiler/translator/glslang_tab.cpp
index 7c6da6481..1c949e6ae 100644
--- a/src/compiler/translator/glslang_tab.cpp
+++ b/src/compiler/translator/glslang_tab.cpp
@@ -409,8 +409,9 @@ extern void yyerror(YYLTYPE* yylloc, TParseContext* context, void *scanner, cons
 }
 
 #define NON_COMPUTE_ONLY(S, L) {  \
-    if (context->getShaderType() != GL_VERTEX_SHADER && context->getShaderType() != GL_FRAGMENT_SHADER) {  \
-        context->error(L, " supported in vertex and fragment shaders only ", S);  \
+    if (context->getShaderType() != GL_VERTEX_SHADER && context->getShaderType() != GL_FRAGMENT_SHADER && \
+        context->getShaderType() != GL_GEOMETRY_SHADER_EXT) {  \
+        context->error(L, " supported in vertex, geometry and fragment shaders only ", S);  \
     }  \
 }
 
@@ -689,7 +690,7 @@ union yyalloc
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  94
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  295
+#define YYNRULES  296
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  431
 
@@ -752,36 +753,36 @@ static const yytype_uint8 yytranslate[] =
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   255,   255,   256,   259,   269,   272,   277,   282,   287,
-     292,   300,   306,   309,   312,   315,   318,   321,   327,   334,
-     340,   344,   352,   355,   361,   365,   372,   377,   384,   392,
-     398,   404,   413,   416,   419,   422,   432,   433,   434,   435,
-     443,   444,   447,   450,   457,   458,   461,   467,   468,   472,
-     479,   480,   483,   486,   489,   495,   496,   499,   505,   506,
-     513,   514,   521,   522,   529,   530,   536,   537,   543,   544,
-     550,   551,   557,   558,   565,   566,   567,   568,   572,   573,
-     574,   578,   582,   586,   590,   597,   600,   606,   613,   620,
-     623,   626,   635,   639,   643,   647,   651,   658,   665,   668,
-     675,   683,   703,   713,   721,   746,   750,   754,   758,   765,
-     772,   775,   779,   783,   788,   793,   800,   804,   808,   812,
-     817,   822,   829,   833,   839,   842,   848,   852,   859,   865,
-     869,   873,   876,   879,   888,   894,   902,   905,   925,   944,
-     951,   955,   959,   962,   965,   968,   971,   974,   982,   989,
-     992,   995,  1001,  1008,  1011,  1017,  1020,  1023,  1026,  1032,
-    1035,  1040,  1051,  1054,  1057,  1060,  1063,  1066,  1070,  1074,
-    1078,  1082,  1086,  1090,  1094,  1098,  1102,  1106,  1110,  1114,
-    1118,  1122,  1126,  1130,  1134,  1138,  1142,  1146,  1150,  1156,
-    1159,  1162,  1165,  1168,  1171,  1174,  1177,  1180,  1183,  1186,
-    1189,  1192,  1195,  1198,  1201,  1204,  1207,  1210,  1217,  1223,
-    1229,  1232,  1235,  1238,  1241,  1244,  1247,  1250,  1253,  1256,
-    1259,  1262,  1265,  1268,  1271,  1283,  1283,  1286,  1286,  1292,
-    1295,  1301,  1304,  1311,  1315,  1321,  1327,  1339,  1343,  1347,
-    1348,  1354,  1355,  1356,  1357,  1358,  1359,  1360,  1364,  1365,
-    1365,  1365,  1374,  1375,  1379,  1379,  1380,  1380,  1385,  1388,
-    1397,  1402,  1409,  1410,  1414,  1421,  1425,  1432,  1432,  1439,
-    1442,  1449,  1453,  1466,  1466,  1471,  1471,  1477,  1477,  1485,
-    1488,  1494,  1497,  1503,  1507,  1514,  1517,  1520,  1523,  1526,
-    1535,  1541,  1547,  1550,  1556,  1556
+       0,   256,   256,   257,   260,   270,   273,   278,   283,   288,
+     293,   301,   307,   310,   313,   316,   319,   322,   328,   335,
+     341,   345,   353,   356,   362,   366,   373,   378,   385,   393,
+     399,   405,   414,   417,   420,   423,   433,   434,   435,   436,
+     444,   445,   448,   451,   458,   459,   462,   468,   469,   473,
+     480,   481,   484,   487,   490,   496,   497,   500,   506,   507,
+     514,   515,   522,   523,   530,   531,   537,   538,   544,   545,
+     551,   552,   558,   559,   566,   567,   568,   569,   573,   574,
+     575,   579,   583,   587,   591,   598,   601,   607,   614,   621,
+     624,   627,   636,   640,   644,   648,   652,   659,   666,   669,
+     676,   684,   704,   714,   722,   747,   751,   755,   759,   766,
+     773,   776,   780,   784,   789,   794,   801,   805,   809,   814,
+     818,   823,   828,   835,   839,   845,   848,   854,   858,   865,
+     871,   875,   879,   882,   885,   894,   900,   908,   911,   935,
+     958,   965,   969,   973,   976,   979,   982,   985,   988,   996,
+    1003,  1006,  1009,  1015,  1022,  1025,  1031,  1034,  1037,  1040,
+    1046,  1049,  1054,  1065,  1068,  1071,  1074,  1077,  1080,  1084,
+    1088,  1092,  1096,  1100,  1104,  1108,  1112,  1116,  1120,  1124,
+    1128,  1132,  1136,  1140,  1144,  1148,  1152,  1156,  1160,  1164,
+    1170,  1173,  1176,  1179,  1182,  1185,  1188,  1191,  1194,  1197,
+    1200,  1203,  1206,  1209,  1212,  1215,  1218,  1221,  1224,  1231,
+    1237,  1243,  1246,  1249,  1252,  1255,  1258,  1261,  1264,  1267,
+    1270,  1273,  1276,  1279,  1282,  1285,  1297,  1297,  1300,  1300,
+    1306,  1309,  1315,  1318,  1325,  1329,  1335,  1341,  1353,  1357,
+    1361,  1362,  1368,  1369,  1370,  1371,  1372,  1373,  1374,  1378,
+    1379,  1379,  1379,  1388,  1389,  1393,  1393,  1394,  1394,  1399,
+    1402,  1411,  1416,  1423,  1424,  1428,  1435,  1439,  1446,  1446,
+    1453,  1456,  1463,  1467,  1480,  1480,  1485,  1485,  1491,  1491,
+    1499,  1502,  1508,  1511,  1517,  1521,  1528,  1531,  1534,  1537,
+    1540,  1549,  1555,  1561,  1564,  1570,  1570
 };
 #endif
 
@@ -883,7 +884,7 @@ static const yytype_uint16 yytoknum[] =
 #define yypact_value_is_default(Yystate) \
   (!!((Yystate) == (-370)))
 
-#define YYTABLE_NINF -255
+#define YYTABLE_NINF -256
 
 #define yytable_value_is_error(Yytable_value) \
   0
@@ -943,50 +944,50 @@ static const yytype_int16 yypact[] =
      means the default is an error.  */
 static const yytype_uint16 yydefact[] =
 {
-       0,   128,   149,   150,   151,     0,   134,   136,   166,   163,
-     164,   165,   170,   171,   172,   173,   174,   175,   167,   168,
-     169,   176,   177,   178,   179,   180,   181,   137,   138,   139,
-     141,   135,   182,   183,   184,   185,   186,   187,   140,   125,
-     124,   142,   143,   144,   145,   146,   147,     0,   162,   189,
-     191,   207,   209,   192,   194,   195,   196,   197,   199,   200,
-     201,   202,   193,   198,   203,   190,   204,   205,   206,   208,
-     211,   212,   213,   214,   215,   216,   217,   218,   219,   220,
-     221,   222,   223,     0,   188,   224,   293,   294,     0,    99,
-      98,     0,   110,   116,   132,     0,   133,   126,   129,   122,
-     131,   130,   148,   159,   210,     0,   290,   292,     0,     2,
-       3,   227,     0,     0,    89,     0,    97,     0,   106,   100,
+       0,   129,   150,   151,   152,     0,   135,   137,   167,   164,
+     165,   166,   171,   172,   173,   174,   175,   176,   168,   169,
+     170,   177,   178,   179,   180,   181,   182,   138,   139,   140,
+     142,   136,   183,   184,   185,   186,   187,   188,   141,   126,
+     125,   143,   144,   145,   146,   147,   148,     0,   163,   190,
+     192,   208,   210,   193,   195,   196,   197,   198,   200,   201,
+     202,   203,   194,   199,   204,   191,   205,   206,   207,   209,
+     212,   213,   214,   215,   216,   217,   218,   219,   220,   221,
+     222,   223,   224,     0,   189,   225,   294,   295,     0,    99,
+      98,     0,   110,   116,   133,     0,   134,   127,   130,   123,
+     132,   131,   149,   160,   211,     0,   291,   293,     0,     2,
+       3,   228,     0,     0,    89,     0,    97,     0,   106,   100,
      108,     0,   109,     0,    90,     2,   117,     0,    95,     0,
-     127,   123,     0,     1,   291,     0,     0,   225,   158,   155,
-       0,   153,     0,   295,   101,   105,   107,   103,   111,   102,
-       0,     0,    88,    96,     0,     0,     0,   229,    10,     4,
-       8,     6,     7,     9,    31,     0,     0,     0,   160,    38,
+     128,   124,     0,     1,   292,     0,     0,   226,   159,   156,
+       0,   154,     0,   296,   101,   105,   107,   103,   111,   102,
+       0,     0,    88,    96,     0,     0,     0,   230,    10,     4,
+       8,     6,     7,     9,    31,     0,     0,     0,   161,    38,
       37,    39,    36,     5,    12,    32,    14,    19,    20,     0,
        0,    25,     0,    40,     0,    44,    47,    50,    55,    58,
       60,    62,    64,    66,    68,    70,    87,     0,    29,    91,
-       0,     0,     0,   152,     0,     0,     0,   275,     0,     0,
-       0,     0,     0,     0,     0,     0,   249,   258,   262,    40,
-      72,    85,     0,   238,     0,   148,   241,   260,   240,   239,
-       0,   242,   243,   244,   245,   246,   247,     0,     0,     0,
-       0,     0,   237,   121,     0,   235,     0,   233,     0,   230,
+       0,     0,     0,   153,     0,     0,     0,   276,     0,     0,
+       0,     0,     0,     0,     0,     0,   250,   259,   263,    40,
+      72,    85,     0,   239,     0,   149,   242,   261,   241,   240,
+       0,   243,   244,   245,   246,   247,   248,     0,     0,     0,
+     118,     0,   238,   122,     0,   236,     0,   234,     0,   231,
       33,    34,     0,    16,    17,     0,     0,    23,    22,     0,
-     162,    26,    28,    35,     0,     0,     0,     0,     0,     0,
+     163,    26,    28,    35,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,   161,   228,     0,   156,   157,   154,
-     286,   285,   256,   277,     0,   289,   287,     0,     0,     0,
-     270,   273,   248,     0,    75,    76,    78,    77,    80,    81,
-      82,    83,    84,    79,    74,     0,     0,   263,   259,   261,
-       0,     0,     0,   115,     0,   118,     0,     0,     0,   231,
+       0,     0,     0,     0,   162,   229,     0,   157,   158,   155,
+     287,   286,   257,   278,     0,   290,   288,     0,     0,     0,
+     271,   274,   249,     0,    75,    76,    78,    77,    80,    81,
+      82,    83,    84,    79,    74,     0,     0,   264,   260,   262,
+       0,     0,     0,   115,     0,   119,     0,     0,     0,   232,
        0,    92,    11,     0,    18,    30,    15,    21,    27,    41,
       42,    43,    46,    45,    48,    49,    53,    54,    51,    52,
-      56,    57,    59,    61,    63,    65,    67,    69,     0,   226,
-       0,     0,     0,     0,     0,   288,     0,   269,     0,   250,
-      73,    86,   104,     0,   112,   119,     0,   232,     0,   234,
-       0,    93,    13,     0,     0,   255,   257,   280,   279,   282,
-     256,   267,   271,     0,     0,     0,     0,   113,     0,   120,
-     236,     0,    71,     0,   281,     0,     0,   266,   264,     0,
-       0,     0,   251,   114,     0,     0,   283,     0,   256,   268,
-       0,   253,   274,   252,    94,     0,   284,   278,   265,   272,
-     276
+      56,    57,    59,    61,    63,    65,    67,    69,     0,   227,
+       0,     0,     0,     0,     0,   289,     0,   270,     0,   251,
+      73,    86,   104,     0,   112,   120,     0,   233,     0,   235,
+       0,    93,    13,     0,     0,   256,   258,   281,   280,   283,
+     257,   268,   272,     0,     0,     0,     0,   113,     0,   121,
+     237,     0,    71,     0,   282,     0,     0,   267,   265,     0,
+       0,     0,   252,   114,     0,     0,   284,     0,   257,   269,
+       0,   254,   275,   253,    94,     0,   285,   279,   266,   273,
+     277
 };
 
   /* YYPGOTO[NTERM-NUM].  */
@@ -1045,7 +1046,7 @@ static const yytype_int16 yytable[] =
      344,   345,   277,   350,   351,   280,   278,   183,   279,   281,
      284,   290,   291,   293,   294,   429,   295,   298,   155,   196,
      102,   102,   301,   300,   302,   183,   -29,   325,   154,   327,
-     324,   392,   -24,  -254,   378,   372,   367,   374,   382,   373,
+     324,   392,   -24,  -255,   378,   372,   367,   374,   382,   373,
      250,   251,   376,   316,   -31,   384,   398,   403,   242,   400,
      225,   242,   392,   411,   412,   416,   414,   417,   402,   263,
      418,   216,   337,   420,   355,   424,   415,   352,   430,   385,
@@ -1699,24 +1700,24 @@ static const yytype_uint8 yyr1[] =
      185,   185,   185,   185,   185,   185,   185,   186,   187,   187,
      188,   188,   189,   190,   190,   191,   191,   191,   191,   192,
      193,   193,   193,   193,   193,   193,   194,   194,   194,   194,
-     194,   194,   195,   195,   196,   196,   197,   197,   198,   199,
-     199,   199,   199,   199,   200,   200,   200,   200,   200,   200,
-     200,   200,   200,   200,   200,   200,   200,   200,   201,   202,
-     202,   202,   203,   204,   204,   205,   205,   205,   205,   206,
-     206,   206,   207,   207,   207,   207,   207,   207,   207,   207,
+     194,   194,   194,   195,   195,   196,   196,   197,   197,   198,
+     199,   199,   199,   199,   199,   200,   200,   200,   200,   200,
+     200,   200,   200,   200,   200,   200,   200,   200,   200,   201,
+     202,   202,   202,   203,   204,   204,   205,   205,   205,   205,
+     206,   206,   206,   207,   207,   207,   207,   207,   207,   207,
      207,   207,   207,   207,   207,   207,   207,   207,   207,   207,
      207,   207,   207,   207,   207,   207,   207,   207,   207,   207,
      207,   207,   207,   207,   207,   207,   207,   207,   207,   207,
      207,   207,   207,   207,   207,   207,   207,   207,   207,   207,
      207,   207,   207,   207,   207,   207,   207,   207,   207,   207,
-     207,   207,   207,   207,   207,   209,   208,   210,   208,   211,
-     211,   212,   212,   213,   213,   214,   214,   215,   216,   217,
-     217,   218,   218,   218,   218,   218,   218,   218,   219,   220,
-     221,   219,   222,   222,   224,   223,   225,   223,   226,   226,
-     227,   227,   228,   228,   229,   230,   230,   232,   231,   233,
-     233,   234,   234,   236,   235,   237,   235,   238,   235,   239,
-     239,   240,   240,   241,   241,   242,   242,   242,   242,   242,
-     243,   243,   244,   244,   246,   245
+     207,   207,   207,   207,   207,   207,   209,   208,   210,   208,
+     211,   211,   212,   212,   213,   213,   214,   214,   215,   216,
+     217,   217,   218,   218,   218,   218,   218,   218,   218,   219,
+     220,   221,   219,   222,   222,   224,   223,   225,   223,   226,
+     226,   227,   227,   228,   228,   229,   230,   230,   232,   231,
+     233,   233,   234,   234,   236,   235,   237,   235,   238,   235,
+     239,   239,   240,   240,   241,   241,   242,   242,   242,   242,
+     242,   243,   243,   244,   244,   246,   245
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
@@ -1733,25 +1734,25 @@ static const yytype_uint8 yyr2[] =
        1,     1,     1,     1,     1,     1,     3,     1,     2,     2,
        2,     4,     5,     6,     9,     2,     3,     2,     1,     1,
        2,     3,     3,     2,     5,     2,     1,     2,     1,     1,
-       1,     3,     6,     7,     8,     5,     1,     2,     5,     6,
-       7,     4,     1,     2,     1,     1,     1,     2,     1,     1,
+       1,     3,     6,     7,     8,     5,     1,     2,     4,     5,
+       6,     7,     4,     1,     2,     1,     1,     1,     2,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     4,     1,     3,     1,     3,     3,     1,     1,
-       3,     4,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     4,     1,     3,     1,     3,     3,     1,
+       1,     3,     4,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     0,     6,     0,     5,     1,
-       2,     3,     4,     1,     3,     1,     4,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     2,     0,
-       0,     5,     1,     1,     0,     2,     0,     2,     2,     3,
-       1,     2,     1,     2,     5,     3,     1,     0,     6,     3,
-       2,     1,     4,     0,     6,     0,     8,     0,     7,     1,
-       1,     1,     0,     2,     3,     2,     2,     2,     3,     2,
-       1,     2,     1,     1,     0,     3
+       1,     1,     1,     1,     1,     1,     0,     6,     0,     5,
+       1,     2,     3,     4,     1,     3,     1,     4,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       0,     0,     5,     1,     1,     0,     2,     0,     2,     2,
+       3,     1,     2,     1,     2,     5,     3,     1,     0,     6,
+       3,     2,     1,     4,     0,     6,     0,     8,     0,     7,
+       1,     1,     1,     0,     2,     3,     2,     2,     2,     3,
+       2,     1,     2,     1,     1,     0,     3
 };
 
 
@@ -3520,13 +3521,23 @@ yyreduce:
   case 118:
 
     {
+        ES3_1_ONLY("[]", (yylsp[-1]), "implicitly sized array declaration");
+        (yyval.interm).type = (yyvsp[-3].interm.type);
+        (yyval.interm).intermDeclaration = context->parseSingleArrayDeclaration((yyval.interm).type, (yylsp[-2]), *(yyvsp[-2].lex).string, (yylsp[-1]), nullptr);
+    }
+
+    break;
+
+  case 119:
+
+    {
         (yyval.interm).type = (yyvsp[-4].interm.type);
         (yyval.interm).intermDeclaration = context->parseSingleArrayDeclaration((yyval.interm).type, (yylsp[-3]), *(yyvsp[-3].lex).string, (yylsp[-2]), (yyvsp[-1].interm.intermTypedNode));
     }
 
     break;
 
-  case 119:
+  case 120:
 
     {
         ES3_OR_NEWER("[]", (yylsp[-3]), "implicitly sized array");
@@ -3536,7 +3547,7 @@ yyreduce:
 
     break;
 
-  case 120:
+  case 121:
 
     {
         ES3_OR_NEWER("=", (yylsp[-1]), "first-class arrays (array initializer)");
@@ -3546,7 +3557,7 @@ yyreduce:
 
     break;
 
-  case 121:
+  case 122:
 
     {
         (yyval.interm).type = (yyvsp[-3].interm.type);
@@ -3555,7 +3566,7 @@ yyreduce:
 
     break;
 
-  case 122:
+  case 123:
 
     {
         context->addFullySpecifiedType(&(yyvsp[0].interm.type));
@@ -3564,7 +3575,7 @@ yyreduce:
 
     break;
 
-  case 123:
+  case 124:
 
     {
         (yyval.interm.type) = context->addFullySpecifiedType(*(yyvsp[-1].interm.typeQualifierBuilder), (yyvsp[0].interm.type));
@@ -3572,7 +3583,7 @@ yyreduce:
 
     break;
 
-  case 124:
+  case 125:
 
     {
         (yyval.interm.qualifier) = EvqSmooth;
@@ -3580,7 +3591,7 @@ yyreduce:
 
     break;
 
-  case 125:
+  case 126:
 
     {
         (yyval.interm.qualifier) = EvqFlat;
@@ -3588,7 +3599,7 @@ yyreduce:
 
     break;
 
-  case 126:
+  case 127:
 
     {
         (yyval.interm.typeQualifierBuilder) = context->createTypeQualifierBuilder((yylsp[0]));
@@ -3597,7 +3608,7 @@ yyreduce:
 
     break;
 
-  case 127:
+  case 128:
 
     {
         (yyval.interm.typeQualifierBuilder) = (yyvsp[-1].interm.typeQualifierBuilder);
@@ -3606,7 +3617,7 @@ yyreduce:
 
     break;
 
-  case 128:
+  case 129:
 
     {
         // empty
@@ -3614,7 +3625,7 @@ yyreduce:
 
     break;
 
-  case 129:
+  case 130:
 
     {
         context->checkLocalVariableConstStorageQualifier(*(yyvsp[0].interm.qualifierWrapper));
@@ -3623,7 +3634,7 @@ yyreduce:
 
     break;
 
-  case 130:
+  case 131:
 
     {
         context->checkIsAtGlobalLevel((yylsp[0]), "layout");
@@ -3632,7 +3643,7 @@ yyreduce:
 
     break;
 
-  case 131:
+  case 132:
 
     {
         (yyval.interm.qualifierWrapper) = new TPrecisionQualifierWrapper((yyvsp[0].interm.precision), (yylsp[0]));
@@ -3640,7 +3651,7 @@ yyreduce:
 
     break;
 
-  case 132:
+  case 133:
 
     {
         (yyval.interm.qualifierWrapper) = new TInterpolationQualifierWrapper((yyvsp[0].interm.qualifier), (yylsp[0]));
@@ -3648,7 +3659,7 @@ yyreduce:
 
     break;
 
-  case 133:
+  case 134:
 
     {
         context->checkIsAtGlobalLevel((yylsp[0]), "invariant");
@@ -3657,7 +3668,7 @@ yyreduce:
 
     break;
 
-  case 134:
+  case 135:
 
     {
         VERTEX_ONLY("attribute", (yylsp[0]));
@@ -3668,7 +3679,7 @@ yyreduce:
 
     break;
 
-  case 135:
+  case 136:
 
     {
         ES2_ONLY("varying", (yylsp[0]));
@@ -3681,7 +3692,7 @@ yyreduce:
 
     break;
 
-  case 136:
+  case 137:
 
     {
         (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqConst, (yylsp[0]));
@@ -3689,7 +3700,7 @@ yyreduce:
 
     break;
 
-  case 137:
+  case 138:
 
     {
         if (context->declaringFunction())
@@ -3706,15 +3717,19 @@ yyreduce:
             ES3_OR_NEWER_OR_MULTIVIEW("in", (yylsp[0]), "storage qualifier");
             (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqVertexIn, (yylsp[0]));
         }
-        else
+        else if (context->getShaderType() == GL_COMPUTE_SHADER)
         {
             (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqComputeIn, (yylsp[0]));
         }
+        else
+        {
+            (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqGeometryIn, (yylsp[0]));
+        }
     }
 
     break;
 
-  case 138:
+  case 139:
 
     {
         if (context->declaringFunction())
@@ -3729,16 +3744,20 @@ yyreduce:
             {
                 (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqFragmentOut, (yylsp[0]));
             }
-            else
+            else if (context->getShaderType() == GL_VERTEX_SHADER)
             {
                 (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqVertexOut, (yylsp[0]));
             }
+            else
+            {
+                (yyval.interm.qualifierWrapper) = new TStorageQualifierWrapper(EvqGeometryOut, (yylsp[0]));
+            }
         }
     }
 
     break;
 
-  case 139:
+  case 140:
 
     {
         if (!context->declaringFunction())
@@ -3750,7 +3769,7 @@ yyreduce:
 
     break;
 
-  case 140:
+  case 141:
 
     {
         ES3_OR_NEWER("centroid", (yylsp[0]), "storage qualifier");
@@ -3759,7 +3778,7 @@ yyreduce:
 
     break;
 
-  case 141:
+  case 142:
 
     {
         context->checkIsAtGlobalLevel((yylsp[0]), "uniform");
@@ -3768,7 +3787,7 @@ yyreduce:
 
     break;
 
-  case 142:
+  case 143:
 
     {
         (yyval.interm.qualifierWrapper) = new TMemoryQualifierWrapper(EvqReadOnly, (yylsp[0]));
@@ -3776,7 +3795,7 @@ yyreduce:
 
     break;
 
-  case 143:
+  case 144:
 
     {
         (yyval.interm.qualifierWrapper) = new TMemoryQualifierWrapper(EvqWriteOnly, (yylsp[0]));
@@ -3784,7 +3803,7 @@ yyreduce:
 
     break;
 
-  case 144:
+  case 145:
 
     {
         (yyval.interm.qualifierWrapper) = new TMemoryQualifierWrapper(EvqCoherent, (yylsp[0]));
@@ -3792,7 +3811,7 @@ yyreduce:
 
     break;
 
-  case 145:
+  case 146:
 
     {
         (yyval.interm.qualifierWrapper) = new TMemoryQualifierWrapper(EvqRestrict, (yylsp[0]));
@@ -3800,7 +3819,7 @@ yyreduce:
 
     break;
 
-  case 146:
+  case 147:
 
     {
         (yyval.interm.qualifierWrapper) = new TMemoryQualifierWrapper(EvqVolatile, (yylsp[0]));
@@ -3808,7 +3827,7 @@ yyreduce:
 
     break;
 
-  case 147:
+  case 148:
 
     {
         context->checkIsAtGlobalLevel((yylsp[0]), "shared");
@@ -3818,7 +3837,7 @@ yyreduce:
 
     break;
 
-  case 148:
+  case 149:
 
     {
         (yyval.interm.type) = (yyvsp[0].interm.type);
@@ -3827,7 +3846,7 @@ yyreduce:
 
     break;
 
-  case 149:
+  case 150:
 
     {
         (yyval.interm.precision) = EbpHigh;
@@ -3835,7 +3854,7 @@ yyreduce:
 
     break;
 
-  case 150:
+  case 151:
 
     {
         (yyval.interm.precision) = EbpMedium;
@@ -3843,7 +3862,7 @@ yyreduce:
 
     break;
 
-  case 151:
+  case 152:
 
     {
         (yyval.interm.precision) = EbpLow;
@@ -3851,7 +3870,7 @@ yyreduce:
 
     break;
 
-  case 152:
+  case 153:
 
     {
         ES3_OR_NEWER_OR_MULTIVIEW("layout", (yylsp[-3]), "qualifier");
@@ -3860,7 +3879,7 @@ yyreduce:
 
     break;
 
-  case 153:
+  case 154:
 
     {
         (yyval.interm.layoutQualifier) = (yyvsp[0].interm.layoutQualifier);
@@ -3868,7 +3887,7 @@ yyreduce:
 
     break;
 
-  case 154:
+  case 155:
 
     {
         (yyval.interm.layoutQualifier) = context->joinLayoutQualifiers((yyvsp[-2].interm.layoutQualifier), (yyvsp[0].interm.layoutQualifier), (yylsp[0]));
@@ -3876,7 +3895,7 @@ yyreduce:
 
     break;
 
-  case 155:
+  case 156:
 
     {
         (yyval.interm.layoutQualifier) = context->parseLayoutQualifier(*(yyvsp[0].lex).string, (yylsp[0]));
@@ -3884,7 +3903,7 @@ yyreduce:
 
     break;
 
-  case 156:
+  case 157:
 
     {
         (yyval.interm.layoutQualifier) = context->parseLayoutQualifier(*(yyvsp[-2].lex).string, (yylsp[-2]), (yyvsp[0].lex).i, (yylsp[0]));
@@ -3892,7 +3911,7 @@ yyreduce:
 
     break;
 
-  case 157:
+  case 158:
 
     {
         (yyval.interm.layoutQualifier) = context->parseLayoutQualifier(*(yyvsp[-2].lex).string, (yylsp[-2]), (yyvsp[0].lex).i, (yylsp[0]));
@@ -3900,7 +3919,7 @@ yyreduce:
 
     break;
 
-  case 158:
+  case 159:
 
     {
         (yyval.interm.layoutQualifier) = context->parseLayoutQualifier("shared", (yylsp[0]));
@@ -3908,7 +3927,7 @@ yyreduce:
 
     break;
 
-  case 159:
+  case 160:
 
     {
         (yyval.interm.type).initialize((yyvsp[0].interm.typeSpecifierNonArray), (context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary));
@@ -3916,7 +3935,7 @@ yyreduce:
 
     break;
 
-  case 160:
+  case 161:
 
     {
         ES3_OR_NEWER("[]", (yylsp[-1]), "implicitly sized array");
@@ -3926,7 +3945,7 @@ yyreduce:
 
     break;
 
-  case 161:
+  case 162:
 
     {
         (yyval.interm.type).initialize((yyvsp[-3].interm.typeSpecifierNonArray), (context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary));
@@ -3939,7 +3958,7 @@ yyreduce:
 
     break;
 
-  case 162:
+  case 163:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtVoid, (yylsp[0]));
@@ -3947,7 +3966,7 @@ yyreduce:
 
     break;
 
-  case 163:
+  case 164:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -3955,7 +3974,7 @@ yyreduce:
 
     break;
 
-  case 164:
+  case 165:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtInt, (yylsp[0]));
@@ -3963,7 +3982,7 @@ yyreduce:
 
     break;
 
-  case 165:
+  case 166:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUInt, (yylsp[0]));
@@ -3971,7 +3990,7 @@ yyreduce:
 
     break;
 
-  case 166:
+  case 167:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtBool, (yylsp[0]));
@@ -3979,7 +3998,7 @@ yyreduce:
 
     break;
 
-  case 167:
+  case 168:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -3988,7 +4007,7 @@ yyreduce:
 
     break;
 
-  case 168:
+  case 169:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -3997,7 +4016,7 @@ yyreduce:
 
     break;
 
-  case 169:
+  case 170:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4006,7 +4025,7 @@ yyreduce:
 
     break;
 
-  case 170:
+  case 171:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtBool, (yylsp[0]));
@@ -4015,7 +4034,7 @@ yyreduce:
 
     break;
 
-  case 171:
+  case 172:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtBool, (yylsp[0]));
@@ -4024,7 +4043,7 @@ yyreduce:
 
     break;
 
-  case 172:
+  case 173:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtBool, (yylsp[0]));
@@ -4033,7 +4052,7 @@ yyreduce:
 
     break;
 
-  case 173:
+  case 174:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtInt, (yylsp[0]));
@@ -4042,7 +4061,7 @@ yyreduce:
 
     break;
 
-  case 174:
+  case 175:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtInt, (yylsp[0]));
@@ -4051,7 +4070,7 @@ yyreduce:
 
     break;
 
-  case 175:
+  case 176:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtInt, (yylsp[0]));
@@ -4060,7 +4079,7 @@ yyreduce:
 
     break;
 
-  case 176:
+  case 177:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUInt, (yylsp[0]));
@@ -4069,7 +4088,7 @@ yyreduce:
 
     break;
 
-  case 177:
+  case 178:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUInt, (yylsp[0]));
@@ -4078,7 +4097,7 @@ yyreduce:
 
     break;
 
-  case 178:
+  case 179:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUInt, (yylsp[0]));
@@ -4087,7 +4106,7 @@ yyreduce:
 
     break;
 
-  case 179:
+  case 180:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4096,7 +4115,7 @@ yyreduce:
 
     break;
 
-  case 180:
+  case 181:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4105,7 +4124,7 @@ yyreduce:
 
     break;
 
-  case 181:
+  case 182:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4114,7 +4133,7 @@ yyreduce:
 
     break;
 
-  case 182:
+  case 183:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4123,7 +4142,7 @@ yyreduce:
 
     break;
 
-  case 183:
+  case 184:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4132,7 +4151,7 @@ yyreduce:
 
     break;
 
-  case 184:
+  case 185:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4141,7 +4160,7 @@ yyreduce:
 
     break;
 
-  case 185:
+  case 186:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4150,7 +4169,7 @@ yyreduce:
 
     break;
 
-  case 186:
+  case 187:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4159,7 +4178,7 @@ yyreduce:
 
     break;
 
-  case 187:
+  case 188:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtFloat, (yylsp[0]));
@@ -4168,7 +4187,7 @@ yyreduce:
 
     break;
 
-  case 188:
+  case 189:
 
     {
         if (!context->isExtensionEnabled("GL_EXT_YUV_target")) {
@@ -4179,7 +4198,7 @@ yyreduce:
 
     break;
 
-  case 189:
+  case 190:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler2D, (yylsp[0]));
@@ -4187,7 +4206,7 @@ yyreduce:
 
     break;
 
-  case 190:
+  case 191:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler3D, (yylsp[0]));
@@ -4195,7 +4214,7 @@ yyreduce:
 
     break;
 
-  case 191:
+  case 192:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSamplerCube, (yylsp[0]));
@@ -4203,7 +4222,7 @@ yyreduce:
 
     break;
 
-  case 192:
+  case 193:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler2DArray, (yylsp[0]));
@@ -4211,7 +4230,7 @@ yyreduce:
 
     break;
 
-  case 193:
+  case 194:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler2DMS, (yylsp[0]));
@@ -4219,7 +4238,7 @@ yyreduce:
 
     break;
 
-  case 194:
+  case 195:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtISampler2D, (yylsp[0]));
@@ -4227,7 +4246,7 @@ yyreduce:
 
     break;
 
-  case 195:
+  case 196:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtISampler3D, (yylsp[0]));
@@ -4235,7 +4254,7 @@ yyreduce:
 
     break;
 
-  case 196:
+  case 197:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtISamplerCube, (yylsp[0]));
@@ -4243,7 +4262,7 @@ yyreduce:
 
     break;
 
-  case 197:
+  case 198:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtISampler2DArray, (yylsp[0]));
@@ -4251,7 +4270,7 @@ yyreduce:
 
     break;
 
-  case 198:
+  case 199:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtISampler2DMS, (yylsp[0]));
@@ -4259,7 +4278,7 @@ yyreduce:
 
     break;
 
-  case 199:
+  case 200:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUSampler2D, (yylsp[0]));
@@ -4267,7 +4286,7 @@ yyreduce:
 
     break;
 
-  case 200:
+  case 201:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUSampler3D, (yylsp[0]));
@@ -4275,7 +4294,7 @@ yyreduce:
 
     break;
 
-  case 201:
+  case 202:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUSamplerCube, (yylsp[0]));
@@ -4283,7 +4302,7 @@ yyreduce:
 
     break;
 
-  case 202:
+  case 203:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUSampler2DArray, (yylsp[0]));
@@ -4291,7 +4310,7 @@ yyreduce:
 
     break;
 
-  case 203:
+  case 204:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUSampler2DMS, (yylsp[0]));
@@ -4299,7 +4318,7 @@ yyreduce:
 
     break;
 
-  case 204:
+  case 205:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler2DShadow, (yylsp[0]));
@@ -4307,7 +4326,7 @@ yyreduce:
 
     break;
 
-  case 205:
+  case 206:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSamplerCubeShadow, (yylsp[0]));
@@ -4315,7 +4334,7 @@ yyreduce:
 
     break;
 
-  case 206:
+  case 207:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtSampler2DArrayShadow, (yylsp[0]));
@@ -4323,7 +4342,7 @@ yyreduce:
 
     break;
 
-  case 207:
+  case 208:
 
     {
         if (!context->supportsExtension("GL_OES_EGL_image_external") &&
@@ -4335,7 +4354,7 @@ yyreduce:
 
     break;
 
-  case 208:
+  case 209:
 
     {
         if (!context->isExtensionEnabled("GL_EXT_YUV_target")) {
@@ -4346,7 +4365,7 @@ yyreduce:
 
     break;
 
-  case 209:
+  case 210:
 
     {
         if (!context->supportsExtension("GL_ARB_texture_rectangle")) {
@@ -4357,7 +4376,7 @@ yyreduce:
 
     break;
 
-  case 210:
+  case 211:
 
     {
         (yyval.interm.typeSpecifierNonArray) = (yyvsp[0].interm.typeSpecifierNonArray);
@@ -4365,7 +4384,7 @@ yyreduce:
 
     break;
 
-  case 211:
+  case 212:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtImage2D, (yylsp[0]));
@@ -4373,7 +4392,7 @@ yyreduce:
 
     break;
 
-  case 212:
+  case 213:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtIImage2D, (yylsp[0]));
@@ -4381,7 +4400,7 @@ yyreduce:
 
     break;
 
-  case 213:
+  case 214:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUImage2D, (yylsp[0]));
@@ -4389,7 +4408,7 @@ yyreduce:
 
     break;
 
-  case 214:
+  case 215:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtImage3D, (yylsp[0]));
@@ -4397,7 +4416,7 @@ yyreduce:
 
     break;
 
-  case 215:
+  case 216:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtIImage3D, (yylsp[0]));
@@ -4405,7 +4424,7 @@ yyreduce:
 
     break;
 
-  case 216:
+  case 217:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUImage3D, (yylsp[0]));
@@ -4413,7 +4432,7 @@ yyreduce:
 
     break;
 
-  case 217:
+  case 218:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtImage2DArray, (yylsp[0]));
@@ -4421,7 +4440,7 @@ yyreduce:
 
     break;
 
-  case 218:
+  case 219:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtIImage2DArray, (yylsp[0]));
@@ -4429,7 +4448,7 @@ yyreduce:
 
     break;
 
-  case 219:
+  case 220:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUImage2DArray, (yylsp[0]));
@@ -4437,7 +4456,7 @@ yyreduce:
 
     break;
 
-  case 220:
+  case 221:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtImageCube, (yylsp[0]));
@@ -4445,7 +4464,7 @@ yyreduce:
 
     break;
 
-  case 221:
+  case 222:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtIImageCube, (yylsp[0]));
@@ -4453,7 +4472,7 @@ yyreduce:
 
     break;
 
-  case 222:
+  case 223:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtUImageCube, (yylsp[0]));
@@ -4461,7 +4480,7 @@ yyreduce:
 
     break;
 
-  case 223:
+  case 224:
 
     {
         (yyval.interm.typeSpecifierNonArray).initialize(EbtAtomicCounter, (yylsp[0]));
@@ -4469,7 +4488,7 @@ yyreduce:
 
     break;
 
-  case 224:
+  case 225:
 
     {
         //
@@ -4483,13 +4502,13 @@ yyreduce:
 
     break;
 
-  case 225:
+  case 226:
 
     { context->enterStructDeclaration((yylsp[-1]), *(yyvsp[-1].lex).string); }
 
     break;
 
-  case 226:
+  case 227:
 
     {
         (yyval.interm.typeSpecifierNonArray) = context->addStructure((yylsp[-5]), (yylsp[-4]), (yyvsp[-4].lex).string, (yyvsp[-1].interm.fieldList));
@@ -4497,13 +4516,13 @@ yyreduce:
 
     break;
 
-  case 227:
+  case 228:
 
     { context->enterStructDeclaration((yylsp[0]), *(yyvsp[0].lex).string); }
 
     break;
 
-  case 228:
+  case 229:
 
     {
         (yyval.interm.typeSpecifierNonArray) = context->addStructure((yylsp[-4]), (yyloc), NewPoolTString(""), (yyvsp[-1].interm.fieldList));
@@ -4511,7 +4530,7 @@ yyreduce:
 
     break;
 
-  case 229:
+  case 230:
 
     {
         (yyval.interm.fieldList) = (yyvsp[0].interm.fieldList);
@@ -4519,7 +4538,7 @@ yyreduce:
 
     break;
 
-  case 230:
+  case 231:
 
     {
         (yyval.interm.fieldList) = context->combineStructFieldLists((yyvsp[-1].interm.fieldList), (yyvsp[0].interm.fieldList), (yylsp[0]));
@@ -4527,7 +4546,7 @@ yyreduce:
 
     break;
 
-  case 231:
+  case 232:
 
     {
         (yyval.interm.fieldList) = context->addStructDeclaratorList((yyvsp[-2].interm.type), (yyvsp[-1].interm.fieldList));
@@ -4535,7 +4554,7 @@ yyreduce:
 
     break;
 
-  case 232:
+  case 233:
 
     {
         // ES3 Only, but errors should be handled elsewhere
@@ -4544,7 +4563,7 @@ yyreduce:
 
     break;
 
-  case 233:
+  case 234:
 
     {
         (yyval.interm.fieldList) = NewPoolTFieldList();
@@ -4553,7 +4572,7 @@ yyreduce:
 
     break;
 
-  case 234:
+  case 235:
 
     {
         (yyval.interm.fieldList)->push_back((yyvsp[0].interm.field));
@@ -4561,7 +4580,7 @@ yyreduce:
 
     break;
 
-  case 235:
+  case 236:
 
     {
         context->checkIsNotReserved((yylsp[0]), *(yyvsp[0].lex).string);
@@ -4572,7 +4591,7 @@ yyreduce:
 
     break;
 
-  case 236:
+  case 237:
 
     {
         context->checkIsNotReserved((yylsp[-3]), *(yyvsp[-3].lex).string);
@@ -4586,27 +4605,21 @@ yyreduce:
 
     break;
 
-  case 237:
-
-    { (yyval.interm.intermTypedNode) = (yyvsp[0].interm.intermTypedNode); }
-
-    break;
-
   case 238:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
+    { (yyval.interm.intermTypedNode) = (yyvsp[0].interm.intermTypedNode); }
 
     break;
 
   case 239:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermBlock); }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
 
     break;
 
   case 240:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermBlock); }
 
     break;
 
@@ -4630,19 +4643,19 @@ yyreduce:
 
   case 244:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermSwitch); }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
 
     break;
 
   case 245:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermCase); }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermSwitch); }
 
     break;
 
   case 246:
 
-    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermCase); }
 
     break;
 
@@ -4654,24 +4667,30 @@ yyreduce:
 
   case 248:
 
-    { (yyval.interm.intermBlock) = 0; }
+    { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
 
     break;
 
   case 249:
 
-    { context->symbolTable.push(); }
+    { (yyval.interm.intermBlock) = 0; }
 
     break;
 
   case 250:
 
-    { context->symbolTable.pop(); }
+    { context->symbolTable.push(); }
 
     break;
 
   case 251:
 
+    { context->symbolTable.pop(); }
+
+    break;
+
+  case 252:
+
     {
         if ((yyvsp[-2].interm.intermBlock) != 0) {
             (yyvsp[-2].interm.intermBlock)->setLine((yyloc));
@@ -4681,43 +4700,43 @@ yyreduce:
 
     break;
 
-  case 252:
+  case 253:
 
     { (yyval.interm.intermNode) = (yyvsp[0].interm.intermBlock); }
 
     break;
 
-  case 253:
+  case 254:
 
     { (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
 
     break;
 
-  case 254:
+  case 255:
 
     { context->symbolTable.push(); }
 
     break;
 
-  case 255:
+  case 256:
 
     { context->symbolTable.pop(); (yyval.interm.intermNode) = (yyvsp[0].interm.intermBlock); }
 
     break;
 
-  case 256:
+  case 257:
 
     { context->symbolTable.push(); }
 
     break;
 
-  case 257:
+  case 258:
 
     { context->symbolTable.pop(); (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode); }
 
     break;
 
-  case 258:
+  case 259:
 
     {
         (yyval.interm.intermBlock) = 0;
@@ -4725,7 +4744,7 @@ yyreduce:
 
     break;
 
-  case 259:
+  case 260:
 
     {
         if ((yyvsp[-1].interm.intermBlock)) {
@@ -4736,7 +4755,7 @@ yyreduce:
 
     break;
 
-  case 260:
+  case 261:
 
     {
         (yyval.interm.intermBlock) = new TIntermBlock();
@@ -4746,7 +4765,7 @@ yyreduce:
 
     break;
 
-  case 261:
+  case 262:
 
     {
         (yyval.interm.intermBlock) = (yyvsp[-1].interm.intermBlock);
@@ -4755,19 +4774,19 @@ yyreduce:
 
     break;
 
-  case 262:
+  case 263:
 
     { (yyval.interm.intermNode) = 0; }
 
     break;
 
-  case 263:
+  case 264:
 
     { (yyval.interm.intermNode) = static_cast<TIntermNode*>((yyvsp[-1].interm.intermTypedNode)); }
 
     break;
 
-  case 264:
+  case 265:
 
     {
         context->checkIsScalarBool((yylsp[-4]), (yyvsp[-2].interm.intermTypedNode));
@@ -4776,7 +4795,7 @@ yyreduce:
 
     break;
 
-  case 265:
+  case 266:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[-2].interm.intermNode);
@@ -4785,7 +4804,7 @@ yyreduce:
 
     break;
 
-  case 266:
+  case 267:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[0].interm.intermNode);
@@ -4794,13 +4813,13 @@ yyreduce:
 
     break;
 
-  case 267:
+  case 268:
 
     { context->incrSwitchNestingLevel(); }
 
     break;
 
-  case 268:
+  case 269:
 
     {
         (yyval.interm.intermSwitch) = context->addSwitch((yyvsp[-3].interm.intermTypedNode), (yyvsp[0].interm.intermBlock), (yylsp[-5]));
@@ -4809,7 +4828,7 @@ yyreduce:
 
     break;
 
-  case 269:
+  case 270:
 
     {
         (yyval.interm.intermCase) = context->addCase((yyvsp[-1].interm.intermTypedNode), (yylsp[-2]));
@@ -4817,7 +4836,7 @@ yyreduce:
 
     break;
 
-  case 270:
+  case 271:
 
     {
         (yyval.interm.intermCase) = context->addDefault((yylsp[-1]));
@@ -4825,7 +4844,7 @@ yyreduce:
 
     break;
 
-  case 271:
+  case 272:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[0].interm.intermTypedNode);
@@ -4834,7 +4853,7 @@ yyreduce:
 
     break;
 
-  case 272:
+  case 273:
 
     {
         TIntermBinary *initNode = nullptr;
@@ -4849,13 +4868,13 @@ yyreduce:
 
     break;
 
-  case 273:
+  case 274:
 
     { context->symbolTable.push(); context->incrLoopNestingLevel(); }
 
     break;
 
-  case 274:
+  case 275:
 
     {
         context->symbolTable.pop();
@@ -4865,13 +4884,13 @@ yyreduce:
 
     break;
 
-  case 275:
+  case 276:
 
     { context->incrLoopNestingLevel(); }
 
     break;
 
-  case 276:
+  case 277:
 
     {
         context->checkIsScalarBool((yylsp[0]), (yyvsp[-2].interm.intermTypedNode));
@@ -4882,13 +4901,13 @@ yyreduce:
 
     break;
 
-  case 277:
+  case 278:
 
     { context->symbolTable.push(); context->incrLoopNestingLevel(); }
 
     break;
 
-  case 278:
+  case 279:
 
     {
         context->symbolTable.pop();
@@ -4898,7 +4917,7 @@ yyreduce:
 
     break;
 
-  case 279:
+  case 280:
 
     {
         (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode);
@@ -4906,7 +4925,7 @@ yyreduce:
 
     break;
 
-  case 280:
+  case 281:
 
     {
         (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode);
@@ -4914,7 +4933,7 @@ yyreduce:
 
     break;
 
-  case 281:
+  case 282:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[0].interm.intermTypedNode);
@@ -4922,7 +4941,7 @@ yyreduce:
 
     break;
 
-  case 282:
+  case 283:
 
     {
         (yyval.interm.intermTypedNode) = 0;
@@ -4930,7 +4949,7 @@ yyreduce:
 
     break;
 
-  case 283:
+  case 284:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[-1].interm.intermTypedNode);
@@ -4939,7 +4958,7 @@ yyreduce:
 
     break;
 
-  case 284:
+  case 285:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[-2].interm.intermTypedNode);
@@ -4948,7 +4967,7 @@ yyreduce:
 
     break;
 
-  case 285:
+  case 286:
 
     {
         (yyval.interm.intermNode) = context->addBranch(EOpContinue, (yylsp[-1]));
@@ -4956,7 +4975,7 @@ yyreduce:
 
     break;
 
-  case 286:
+  case 287:
 
     {
         (yyval.interm.intermNode) = context->addBranch(EOpBreak, (yylsp[-1]));
@@ -4964,7 +4983,7 @@ yyreduce:
 
     break;
 
-  case 287:
+  case 288:
 
     {
         (yyval.interm.intermNode) = context->addBranch(EOpReturn, (yylsp[-1]));
@@ -4972,7 +4991,7 @@ yyreduce:
 
     break;
 
-  case 288:
+  case 289:
 
     {
         (yyval.interm.intermNode) = context->addBranch(EOpReturn, (yyvsp[-1].interm.intermTypedNode), (yylsp[-2]));
@@ -4980,7 +4999,7 @@ yyreduce:
 
     break;
 
-  case 289:
+  case 290:
 
     {
         FRAG_ONLY("discard", (yylsp[-1]));
@@ -4989,7 +5008,7 @@ yyreduce:
 
     break;
 
-  case 290:
+  case 291:
 
     {
         (yyval.interm.intermBlock) = new TIntermBlock();
@@ -5000,7 +5019,7 @@ yyreduce:
 
     break;
 
-  case 291:
+  case 292:
 
     {
         (yyval.interm.intermBlock)->appendStatement((yyvsp[0].interm.intermNode));
@@ -5008,7 +5027,7 @@ yyreduce:
 
     break;
 
-  case 292:
+  case 293:
 
     {
         (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode);
@@ -5016,7 +5035,7 @@ yyreduce:
 
     break;
 
-  case 293:
+  case 294:
 
     {
         (yyval.interm.intermNode) = (yyvsp[0].interm.intermNode);
@@ -5024,7 +5043,7 @@ yyreduce:
 
     break;
 
-  case 294:
+  case 295:
 
     {
         context->parseFunctionDefinitionHeader((yylsp[0]), &((yyvsp[0].interm).function), &((yyvsp[0].interm).intermFunctionPrototype));
@@ -5032,7 +5051,7 @@ yyreduce:
 
     break;
 
-  case 295:
+  case 296:
 
     {
         (yyval.interm.intermNode) = context->addFunctionDefinition((yyvsp[-2].interm).intermFunctionPrototype, (yyvsp[0].interm.intermBlock), (yylsp[-2]));
diff --git a/src/compiler/translator/util.cpp b/src/compiler/translator/util.cpp
index 77ee6d20f..51f5e932b 100644
--- a/src/compiler/translator/util.cpp
+++ b/src/compiler/translator/util.cpp
@@ -505,6 +505,8 @@ InterpolationType GetInterpolationType(TQualifier qualifier)
         case EvqFragmentIn:
         case EvqVaryingIn:
         case EvqVaryingOut:
+        case EvqGeometryIn:
+        case EvqGeometryOut:
             return INTERPOLATION_SMOOTH;
 
         case EvqCentroidIn:
diff --git a/src/libANGLE/Caps.cpp b/src/libANGLE/Caps.cpp
index 58b7b5ae8..548e2ab10 100644
--- a/src/libANGLE/Caps.cpp
+++ b/src/libANGLE/Caps.cpp
@@ -217,7 +217,8 @@ Extensions::Extensions()
       pathRendering(false),
       surfacelessContext(false),
       clientArrays(false),
-      robustResourceInitialization(false)
+      robustResourceInitialization(false),
+      geometryShader(false)
 {
 }
 
@@ -685,6 +686,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_OES_surfaceless_context"] = esOnlyExtension(&Extensions::surfacelessContext);
         map["GL_ANGLE_client_arrays"] = esOnlyExtension(&Extensions::clientArrays);
         map["GL_ANGLE_robust_resource_initialization"] = esOnlyExtension(&Extensions::robustResourceInitialization);
+        map["GL_EXT_geometry_shader"] = esOnlyExtension(&Extensions::geometryShader);
         // clang-format on
 
         return map;
@@ -832,7 +834,19 @@ Caps::Caps()
       maxTransformFeedbackSeparateComponents(0),
 
       // Table 20.49
-      maxSamples(0)
+      maxSamples(0),
+
+      // EXT_geometry_shader
+      maxGeometryInputComponents(0),
+      maxGeometryOutputComponents(0),
+      maxGeometryImageUniforms(0),
+      maxGeometryTextureImageUnits(0),
+      maxGeometryOutputVertices(0),
+      maxGeometryTotalOutputComponents(0),
+      maxGeometryUniformComponents(0),
+      maxGeometryAtomicCounters(0),
+      maxGeometryAtomicCounterBuffers(0),
+      maxGeometryShaderInvocations(0)
 
 {
     for (size_t i = 0; i < 3; ++i)
diff --git a/src/libANGLE/Caps.h b/src/libANGLE/Caps.h
index 8e6a5f64e..78ee4797e 100644
--- a/src/libANGLE/Caps.h
+++ b/src/libANGLE/Caps.h
@@ -363,6 +363,9 @@ struct Extensions
 
     // GL_ANGLE_robust_resource_initialization
     bool robustResourceInitialization;
+
+    // GL_EXT_geometry_shader
+    bool geometryShader;
 };
 
 struct ExtensionInfo
@@ -543,6 +546,18 @@ struct Caps
 
     // ES 3.1 (April 29, 2015) Table 20.49: Framebuffer Dependent Values
     GLuint maxSamples;
+
+    // EXT_geometry_shader
+    GLuint maxGeometryInputComponents;
+    GLuint maxGeometryOutputComponents;
+    GLuint maxGeometryImageUniforms;
+    GLuint maxGeometryTextureImageUnits;
+    GLuint maxGeometryOutputVertices;
+    GLuint maxGeometryTotalOutputComponents;
+    GLuint maxGeometryUniformComponents;
+    GLuint maxGeometryAtomicCounters;
+    GLuint maxGeometryAtomicCounterBuffers;
+    GLuint maxGeometryShaderInvocations;
 };
 
 Caps GenerateMinimumCaps(const Version &clientVersion);
diff --git a/src/libANGLE/Compiler.cpp b/src/libANGLE/Compiler.cpp
index 0633a2784..36aca99e2 100644
--- a/src/libANGLE/Compiler.cpp
+++ b/src/libANGLE/Compiler.cpp
@@ -50,7 +50,8 @@ Compiler::Compiler(rx::GLImplFactory *implFactory, const ContextState &state)
       mResources(),
       mFragmentCompiler(nullptr),
       mVertexCompiler(nullptr),
-      mComputeCompiler(nullptr)
+      mComputeCompiler(nullptr),
+      mGeometryCompiler(nullptr)
 {
     ASSERT(state.getClientMajorVersion() == 2 || state.getClientMajorVersion() == 3);
 
@@ -72,6 +73,7 @@ Compiler::Compiler(rx::GLImplFactory *implFactory, const ContextState &state)
     mResources.OES_EGL_image_external          = extensions.eglImageExternal;
     mResources.OES_EGL_image_external_essl3    = extensions.eglImageExternalEssl3;
     mResources.NV_EGL_stream_consumer_external = extensions.eglStreamConsumerExternal;
+    mResources.EXT_geometry_shader             = extensions.geometryShader;
     // TODO: use shader precision caps to determine if high precision is supported?
     mResources.FragmentPrecisionHigh = 1;
     mResources.EXT_frag_depth        = extensions.fragDepth;
@@ -111,9 +113,19 @@ Compiler::Compiler(rx::GLImplFactory *implFactory, const ContextState &state)
     mResources.MaxFragmentAtomicCounterBuffers = caps.maxFragmentAtomicCounterBuffers;
     mResources.MaxCombinedAtomicCounterBuffers = caps.maxCombinedAtomicCounterBuffers;
     mResources.MaxAtomicCounterBufferSize      = caps.maxAtomicCounterBufferSize;
-
     mResources.MaxUniformBufferBindings = caps.maxUniformBufferBindings;
 
+    // EXT_geometry_shader constants
+    mResources.MaxGeometryInputComponents       = caps.maxGeometryInputComponents;
+    mResources.MaxGeometryOutputComponents      = caps.maxGeometryOutputComponents;
+    mResources.MaxGeometryImageUniforms         = caps.maxGeometryImageUniforms;
+    mResources.MaxGeometryTextureImageUnits     = caps.maxGeometryTextureImageUnits;
+    mResources.MaxGeometryOutputVertices        = caps.maxGeometryOutputVertices;
+    mResources.MaxGeometryTotalOutputComponents = caps.maxGeometryTotalOutputComponents;
+    mResources.MaxGeometryUniformComponents     = caps.maxGeometryUniformComponents;
+    mResources.MaxGeometryAtomicCounters        = caps.maxGeometryAtomicCounters;
+    mResources.MaxGeometryAtomicCounterBuffers  = caps.maxGeometryAtomicCounterBuffers;
+
     if (state.getClientMajorVersion() == 2 && !extensions.drawBuffers)
     {
         mResources.MaxDrawBuffers = 1;
@@ -149,6 +161,15 @@ Compiler::~Compiler()
         activeCompilerHandles--;
     }
 
+    if (mGeometryCompiler)
+    {
+        sh::Destruct(mGeometryCompiler);
+        mGeometryCompiler = nullptr;
+
+        ASSERT(activeCompilerHandles > 0);
+        activeCompilerHandles--;
+    }
+
     if (activeCompilerHandles == 0)
     {
         sh::Finalize();
@@ -172,6 +193,9 @@ ShHandle Compiler::getCompilerHandle(GLenum type)
         case GL_COMPUTE_SHADER:
             compiler = &mComputeCompiler;
             break;
+        case GL_GEOMETRY_SHADER_EXT:
+            compiler = &mGeometryCompiler;
+            break;
         default:
             UNREACHABLE();
             return nullptr;
diff --git a/src/libANGLE/Compiler.h b/src/libANGLE/Compiler.h
index 35520544a..ba7d0f0b5 100644
--- a/src/libANGLE/Compiler.h
+++ b/src/libANGLE/Compiler.h
@@ -42,6 +42,7 @@ class Compiler final : public RefCountObjectNoID
     ShHandle mFragmentCompiler;
     ShHandle mVertexCompiler;
     ShHandle mComputeCompiler;
+    ShHandle mGeometryCompiler;
 };
 
 }  // namespace gl
diff --git a/src/libANGLE/ResourceManager.cpp b/src/libANGLE/ResourceManager.cpp
index 18e1fd221..71d8a5d9a 100644
--- a/src/libANGLE/ResourceManager.cpp
+++ b/src/libANGLE/ResourceManager.cpp
@@ -214,7 +214,8 @@ GLuint ShaderProgramManager::createShader(rx::GLImplFactory *factory,
                                           const gl::Limitations &rendererLimitations,
                                           GLenum type)
 {
-    ASSERT(type == GL_VERTEX_SHADER || type == GL_FRAGMENT_SHADER || type == GL_COMPUTE_SHADER);
+    ASSERT(type == GL_VERTEX_SHADER || type == GL_FRAGMENT_SHADER || type == GL_COMPUTE_SHADER ||
+           type == GL_GEOMETRY_SHADER_EXT);
     GLuint handle    = mHandleAllocator.allocate();
     mShaders[handle] = new Shader(this, factory, rendererLimitations, type, handle);
     return handle;
diff --git a/src/libANGLE/Shader.cpp b/src/libANGLE/Shader.cpp
index 9b778bf76..26c2fc8ea 100644
--- a/src/libANGLE/Shader.cpp
+++ b/src/libANGLE/Shader.cpp
@@ -83,6 +83,20 @@ ShaderState::~ShaderState()
 {
 }
 
+const std::vector<sh::Varying> &ShaderState::getVaryings() const
+{
+    switch (mShaderType)
+    {
+        case GL_VERTEX_SHADER:
+            return mOutVaryings;
+        case GL_FRAGMENT_SHADER:
+            return mInVaryings;
+        default:
+            UNREACHABLE();
+            return mOutVaryings;
+    }
+}
+
 Shader::Shader(ShaderProgramManager *manager,
                rx::GLImplFactory *implFactory,
                const gl::Limitations &rendererLimitations,
@@ -257,7 +271,8 @@ void Shader::compile(const Context *context)
     mState.mTranslatedSource.clear();
     mInfoLog.clear();
     mState.mShaderVersion = 100;
-    mState.mVaryings.clear();
+    mState.mInVaryings.clear();
+    mState.mOutVaryings.clear();
     mState.mUniforms.clear();
     mState.mInterfaceBlocks.clear();
     mState.mActiveAttributes.clear();
@@ -347,7 +362,6 @@ void Shader::resolveCompile(const Context *context)
     // Gather the shader information
     mState.mShaderVersion = sh::GetShaderVersion(compilerHandle);
 
-    mState.mVaryings        = GetShaderVariables(sh::GetVaryings(compilerHandle));
     mState.mUniforms        = GetShaderVariables(sh::GetUniforms(compilerHandle));
     mState.mInterfaceBlocks = GetShaderVariables(sh::GetInterfaceBlocks(compilerHandle));
 
@@ -361,14 +375,27 @@ void Shader::resolveCompile(const Context *context)
         case GL_VERTEX_SHADER:
         {
             mState.mActiveAttributes = GetActiveShaderVariables(sh::GetAttributes(compilerHandle));
+            mState.mOutVaryings      = GetShaderVariables(sh::GetOutputVaryings(compilerHandle));
             break;
         }
         case GL_FRAGMENT_SHADER:
         {
             // TODO(jmadill): Figure out why we only sort in the FS, and if we need to.
-            std::sort(mState.mVaryings.begin(), mState.mVaryings.end(), CompareShaderVar);
+            std::sort(mState.mInVaryings.begin(), mState.mInVaryings.end(), CompareShaderVar);
             mState.mActiveOutputVariables =
                 GetActiveShaderVariables(sh::GetOutputVariables(compilerHandle));
+            mState.mInVaryings = GetShaderVariables(sh::GetInputVaryings(compilerHandle));
+            break;
+        }
+        case GL_GEOMETRY_SHADER_EXT:
+        {
+            mState.mInVaryings  = GetShaderVariables(sh::GetInputVaryings(compilerHandle));
+            mState.mOutVaryings = GetShaderVariables(sh::GetOutputVaryings(compilerHandle));
+            mState.mGeometryInputPrimitives = sh::GetGeometryShaderInputPrimitives(compilerHandle);
+            mState.mGeometryOutputPrimitives =
+                sh::GetGeometryShaderOutputPrimitives(compilerHandle);
+            mState.mGeometryInvocations = sh::GetGeometryShaderInvocations(compilerHandle);
+            mState.mGeometryMaxVertices = sh::GetGeometryShaderMaxVertices(compilerHandle);
             break;
         }
         default:
diff --git a/src/libANGLE/Shader.h b/src/libANGLE/Shader.h
index 8df2b5a1b..33b96fcd0 100644
--- a/src/libANGLE/Shader.h
+++ b/src/libANGLE/Shader.h
@@ -54,7 +54,9 @@ class ShaderState final : angle::NonCopyable
     GLenum getShaderType() const { return mShaderType; }
     int getShaderVersion() const { return mShaderVersion; }
 
-    const std::vector<sh::Varying> &getVaryings() const { return mVaryings; }
+    const std::vector<sh::Varying> &getVaryings() const;
+    const std::vector<sh::Varying> &getInputVaryings() const { return mInVaryings; }
+    const std::vector<sh::Varying> &getOutputVaryings() const { return mOutVaryings; }
     const std::vector<sh::Uniform> &getUniforms() const { return mUniforms; }
     const std::vector<sh::InterfaceBlock> &getInterfaceBlocks() const { return mInterfaceBlocks; }
     const std::vector<sh::Attribute> &getActiveAttributes() const { return mActiveAttributes; }
@@ -75,11 +77,17 @@ class ShaderState final : angle::NonCopyable
 
     sh::WorkGroupSize mLocalSize;
 
-    std::vector<sh::Varying> mVaryings;
     std::vector<sh::Uniform> mUniforms;
     std::vector<sh::InterfaceBlock> mInterfaceBlocks;
     std::vector<sh::Attribute> mActiveAttributes;
     std::vector<sh::OutputVariable> mActiveOutputVariables;
+
+    std::vector<sh::Varying> mInVaryings;
+    std::vector<sh::Varying> mOutVaryings;
+    GLenum mGeometryInputPrimitives;
+    GLenum mGeometryOutputPrimitives;
+    int mGeometryInvocations;
+    int mGeometryMaxVertices;
 };
 
 class Shader final : angle::NonCopyable, public LabeledObject
diff --git a/src/libANGLE/renderer/gl/renderergl_utils.cpp b/src/libANGLE/renderer/gl/renderergl_utils.cpp
index 6945c5b99..a071e8beb 100644
--- a/src/libANGLE/renderer/gl/renderergl_utils.cpp
+++ b/src/libANGLE/renderer/gl/renderergl_utils.cpp
@@ -928,6 +928,33 @@ void GenerateCaps(const FunctionsGL *functions,
                                      functions->hasGLESExtension("GL_ARB_invalidate_subdata");
 
     extensions->translatedShaderSource = true;
+
+    if (functions->isAtLeastGL(gl::Version(4, 0)) || functions->isAtLeastGLES(gl::Version(3, 2)) ||
+        functions->hasGLExtension("GL_ARB_geometry_shader4") ||
+        functions->hasGLESExtension("GL_EXT_geometry_shader"))
+    {
+        extensions->geometryShader = true;
+        caps->maxGeometryInputComponents =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT);
+        caps->maxGeometryOutputComponents =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT);
+        caps->maxGeometryImageUniforms =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT);
+        caps->maxGeometryTextureImageUnits =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT);
+        caps->maxGeometryOutputVertices =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT);
+        caps->maxGeometryTotalOutputComponents =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT);
+        caps->maxGeometryUniformComponents =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT);
+        caps->maxGeometryAtomicCounters =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT);
+        caps->maxGeometryAtomicCounterBuffers =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT);
+        caps->maxGeometryShaderInvocations =
+            QuerySingleGLInt(functions, GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT);
+    }
 }
 
 void GenerateWorkarounds(const FunctionsGL *functions, WorkaroundsGL *workarounds)
diff --git a/src/libANGLE/validationES2.cpp b/src/libANGLE/validationES2.cpp
index dc3b49bdf..cca4aa891 100644
--- a/src/libANGLE/validationES2.cpp
+++ b/src/libANGLE/validationES2.cpp
@@ -3851,6 +3851,15 @@ bool ValidateCreateShader(Context *context, GLenum type)
             }
             break;
 
+        case GL_GEOMETRY_SHADER_EXT:
+            if (!context->getExtensions().geometryShader)
+            {
+                context->handleError(Error(
+                    GL_INVALID_ENUM, "GL_GEOMETRY_SHADER_EXT requires GL_EXT_geometry_shader."));
+                return false;
+            }
+            break;
+
         default:
             context->handleError(InvalidEnum() << "Unknown shader type.");
             return false;
diff --git a/src/tests/angle_end2end_tests.gypi b/src/tests/angle_end2end_tests.gypi
index fe0a604f4..8f973aec8 100644
--- a/src/tests/angle_end2end_tests.gypi
+++ b/src/tests/angle_end2end_tests.gypi
@@ -44,6 +44,7 @@
             '<(angle_path)/src/tests/gl_tests/FramebufferMixedSamplesTest.cpp',
             '<(angle_path)/src/tests/gl_tests/FramebufferRenderMipmapTest.cpp',
             '<(angle_path)/src/tests/gl_tests/FramebufferTest.cpp',
+            '<(angle_path)/src/tests/gl_tests/GeometryShaderTest.cpp',
             '<(angle_path)/src/tests/gl_tests/GLSLTest.cpp',
             '<(angle_path)/src/tests/gl_tests/ImageTest.cpp',
             '<(angle_path)/src/tests/gl_tests/IncompleteTextureTest.cpp',
diff --git a/src/tests/angle_unittests.gypi b/src/tests/angle_unittests.gypi
index 5d2d34abe..923a7988a 100644
--- a/src/tests/angle_unittests.gypi
+++ b/src/tests/angle_unittests.gypi
@@ -61,6 +61,7 @@
             '<(angle_path)/src/tests/compiler_tests/EXT_blend_func_extended_test.cpp',
             '<(angle_path)/src/tests/compiler_tests/FloatLex_test.cpp',
             '<(angle_path)/src/tests/compiler_tests/FragDepth_test.cpp',
+            '<(angle_path)/src/tests/compiler_tests/GeometryShader_test.cpp',
             '<(angle_path)/src/tests/compiler_tests/GLSLCompatibilityOutput_test.cpp',
             '<(angle_path)/src/tests/compiler_tests/IntermNode_test.cpp',
             '<(angle_path)/src/tests/compiler_tests/NV_draw_buffers_test.cpp',
diff --git a/src/tests/compiler_tests/CollectVariables_test.cpp b/src/tests/compiler_tests/CollectVariables_test.cpp
index 228223b24..33f8a36e0 100644
--- a/src/tests/compiler_tests/CollectVariables_test.cpp
+++ b/src/tests/compiler_tests/CollectVariables_test.cpp
@@ -419,7 +419,7 @@ TEST_F(CollectVertexVariablesTest, VaryingInterpolation)
 
     compile(shaderString);
 
-    const std::vector<Varying> &varyings = mTranslator->getVaryings();
+    const std::vector<Varying> &varyings = mTranslator->getOutputVaryings();
     ASSERT_EQ(2u, varyings.size());
 
     const Varying *varying = &varyings[0];
diff --git a/src/tests/compiler_tests/GeometryShader_test.cpp b/src/tests/compiler_tests/GeometryShader_test.cpp
new file mode 100644
index 000000000..d55010d7e
--- /dev/null
+++ b/src/tests/compiler_tests/GeometryShader_test.cpp
@@ -0,0 +1,1299 @@
+//
+// Copyright (c) 2017 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// GeometryShader_test.cpp:
+// tests for compiling a Geometry Shader
+//
+
+#include "GLSLANG/ShaderLang.h"
+#include "angle_gl.h"
+#include "compiler/translator/BaseTypes.h"
+#include "compiler/translator/TranslatorESSL.h"
+#include "gtest/gtest.h"
+#include "tests/test_utils/compiler_test.h"
+
+using namespace sh;
+
+class GeometryShaderTest : public testing::Test
+{
+  public:
+    GeometryShaderTest() {}
+
+  protected:
+    void SetUp() override
+    {
+        ShBuiltInResources resources;
+        InitBuiltInResources(&resources);
+        resources.EXT_geometry_shader = 1;
+
+        mTranslator = new TranslatorESSL(GL_GEOMETRY_SHADER_EXT, SH_GLES3_1_SPEC);
+        ASSERT_TRUE(mTranslator->Init(resources));
+    }
+
+    void TearDown() override { SafeDelete(mTranslator); }
+
+    // Return true when compilation succeeds
+    bool compile(const std::string &shaderString)
+    {
+        const char *shaderStrings[] = {shaderString.c_str()};
+
+        bool status         = mTranslator->compile(shaderStrings, 1, SH_OBJECT_CODE | SH_VARIABLES);
+        TInfoSink &infoSink = mTranslator->getInfoSink();
+        mInfoLog            = infoSink.info.c_str();
+        // std::cout << mInfoLog << std::endl;
+        // std::cout << infoSink.obj.c_str() << std::endl;
+        return status;
+    }
+
+    bool compileGeometryShader(const std::string &statement1, const std::string &statement2)
+    {
+        std::ostringstream sstream;
+        sstream << kHeader << statement1 << statement2 << kEmptyBody;
+        return compile(sstream.str());
+    }
+
+    bool compileGeometryShader(const std::string &statement1,
+                               const std::string &statement2,
+                               const std::string &statement3,
+                               const std::string &statement4)
+    {
+        std::ostringstream sstream;
+        sstream << kHeader << statement1 << statement2 << statement3 << statement4 << kEmptyBody;
+        return compile(sstream.str());
+    }
+
+    static std::string GetGeometryShaderLayout(const std::string &layoutType,
+                                               const std::string &primitive,
+                                               int invocations,
+                                               int maxVertices)
+    {
+        std::ostringstream sstream;
+
+        sstream << "layout (";
+        if (!primitive.empty())
+        {
+            sstream << primitive;
+        }
+        if (invocations > 0)
+        {
+            sstream << ", invocations = " << invocations;
+        }
+        if (maxVertices >= 0)
+        {
+            sstream << ", max_vertices = " << maxVertices;
+        }
+        sstream << ") " << layoutType << ";" << std::endl;
+
+        return sstream.str();
+    }
+
+    static std::string GetInputDeclaration(const std::string &var, int size)
+    {
+        std::ostringstream sstream;
+        sstream << "in vec4 ";
+        if (size < 0)
+        {
+            sstream << var << "[];\n";
+        }
+        else
+        {
+            sstream << var << "[" << size << "];\n";
+        }
+
+        return sstream.str();
+    }
+
+    const std::string kHeader =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n";
+    const std::string kEmptyBody =
+        "void main()\n"
+        "{\n"
+        "}\n";
+    const std::string kInputLayout  = "layout (points) in;\n";
+    const std::string kOutputLayout = "layout (points, max_vertices = 1) out;\n";
+
+    std::string mInfoLog;
+    TranslatorESSL *mTranslator = nullptr;
+};
+
+// Compile a basic Geometry Shader.
+TEST_F(GeometryShaderTest, BasicGeometryShader)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (triangles, invocations = 4) in;\n"
+        "layout (triangle_strip, max_vertices = 3) out;\n"
+        "in vec3 vs_normal[];\n"
+        "in vec2 vs_texcoord[3];\n"
+        "out vec3 gs_normal;\n"
+        "out vec2 gs_texcoord;\n"
+        "void main()\n"
+        "{\n"
+        "    int n;\n"
+        "    for (n = 0; n < gl_in.length(); n++)\n"
+        "    {\n"
+        "        gl_Position = gl_in[n].gl_Position;\n"
+        "        gs_normal = vs_normal[gl_InvocationID];\n"
+        "        gl_Layer   = gl_InvocationID;\n"
+        "        gs_texcoord = vs_texcoord[gl_InvocationID];\n"
+        "        EmitVertex();\n"
+        "    }\n"
+        "    EndPrimitive();\n"
+        "}";
+
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+
+    EXPECT_EQ(4, mTranslator->getGeometryShaderInvocations());
+    EXPECT_EQ(3, mTranslator->getGeometryShaderMaxVertices());
+    EXPECT_EQ(EgsTriangles, mTranslator->getGeometryShaderInputPrimitives());
+    EXPECT_EQ(EgsTriangleStrip, mTranslator->getGeometryShaderOutputPrimitives());
+}
+
+// Geometry Shaders are not supported in GLSL ES shaders version lower than 310.
+TEST_F(GeometryShaderTest, Version100)
+{
+    const std::string &shaderString =
+        "layout(points) in;\n"
+        "layout(points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders are not supported in GLSL ES shaders version lower than 310.
+TEST_F(GeometryShaderTest, Version300)
+{
+    const std::string &shaderString =
+        "#version 300 es\n"
+        "layout(points) in;\n"
+        "layout(points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders are not supported in GLSL ES shaders version 310 without extension
+// EXT_geometry_shader enabled.
+TEST_F(GeometryShaderTest, Version310WithoutExtension)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "layout(points) in;\n"
+        "layout(points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders are supported in GLSL ES shaders version 310 with EXT_geometry_shader enabled.
+TEST_F(GeometryShaderTest, Version310WithExtension)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout(points) in;\n"
+        "layout(points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeed:\n" << mInfoLog;
+    }
+}
+
+// It should be a linking error instead of compilation error to lack the declarations of input
+// primitive in a geometry shader.
+TEST_F(GeometryShaderTest, NoInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout(points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders can only support 5 kinds of input primitives, which cannot be used as output
+// primitives except 'points'.
+// Skip testing "points" as it can be used as both input and output primitives.
+TEST_F(GeometryShaderTest, ValidateInputPrimitives)
+{
+    const std::array<std::string, 4> kInputPrimitives = {
+        {"lines", "lines_adjacency", "triangles", "triangles_adjacency"}};
+
+    for (const std::string &inputPrimitive : kInputPrimitives)
+    {
+        if (!compileGeometryShader(GetGeometryShaderLayout("in", inputPrimitive, -1, -1),
+                                   kOutputLayout))
+        {
+            FAIL() << "Shader compilation failure, expecting succeed:\n" << mInfoLog;
+        }
+        if (compileGeometryShader(kInputLayout,
+                                  GetGeometryShaderLayout("out", inputPrimitive, -1, 6)))
+        {
+            FAIL() << "Shader compilation succeed, expecting failure:\n" << mInfoLog;
+        }
+    }
+}
+
+// Geometry Shaders	allow duplicated declaration of input primitive, but don't allow multiple
+// different input primitives.
+TEST_F(GeometryShaderTest, InputPrimitiveRedeclarations)
+{
+    const std::array<std::string, 5> kInputPrimitives = {
+        {"points", "lines", "lines_adjacency", "triangles", "triangles_adjacency"}};
+
+    for (GLuint i = 0; i < kInputPrimitives.size(); ++i)
+    {
+        const std::string &inputLayoutStr1 =
+            GetGeometryShaderLayout("in", kInputPrimitives[i], -1, -1);
+        if (!compileGeometryShader(inputLayoutStr1, inputLayoutStr1, kOutputLayout, ""))
+        {
+            FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+        }
+
+        for (GLuint j = i + 1; j < kInputPrimitives.size(); ++j)
+        {
+            const std::string &inputLayoutStr2 =
+                GetGeometryShaderLayout("in", kInputPrimitives[j], -1, -1);
+            if (compileGeometryShader(inputLayoutStr1, inputLayoutStr2, kOutputLayout, ""))
+            {
+                FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+            }
+        }
+    }
+}
+
+// Geometry Shaders don't allow declaring different input primitives.
+TEST_F(GeometryShaderTest, DeclareDifferentInputPrimitivesInOneLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, triangles) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow negative 'invocations'.
+TEST_F(GeometryShaderTest, NegativeInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = -1) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow 'invocations' larger than the maximum.
+TEST_F(GeometryShaderTest, TooLargeInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 9989899) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow 'invocations' declared in the same input layout with input primitives.
+TEST_F(GeometryShaderTest, InvocationsWithInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 3) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow 'invocations' declared before input primitives in the same input layout.
+TEST_F(GeometryShaderTest, InvocationsBeforeInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (invocations = 3, points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow 'invocations' declared in an individual input layout expressions.
+TEST_F(GeometryShaderTest, InvocationsInIndividualLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (invocations = 3) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders	allow duplicated declaration of 'invocations'.
+TEST_F(GeometryShaderTest, DuplicatedInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 3) in;\n"
+        "layout (invocations = 3) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders	don't allow multiple different 'invocations'.
+TEST_F(GeometryShaderTest, RedeclareDifferentInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 3) in;\n"
+        "layout (invocations = 5) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shader don't allow multiple different 'invocations'.
+TEST_F(GeometryShaderTest, RedeclareDifferentInvocationsInOneLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 3, invocations = 5) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow 'invocations' in out layouts.
+TEST_F(GeometryShaderTest, DeclareInvocationsInOutLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, invocations = 3, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow 'invocations' in layouts without qualifiers.
+TEST_F(GeometryShaderTest, DeclareInvocationsInLayoutNoQualifier)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (invocations = 3);\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders can only accept arrays as their inputs.
+TEST_F(GeometryShaderTest, InputNotArray)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "in vec4 texcoord;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// It is not a compile error to declare unsized inputs before the declaration of the
+// input primitive in a Geometry Shader.
+// It should be a linking error.
+TEST_F(GeometryShaderTest, UnsizedInputDeclaredBeforeInputPrimitive)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "in vec4 texcoord[];\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// The unsized Geometry Shader inputs declared before the declaration of the input primitive
+// won't be sized automatically.
+TEST_F(GeometryShaderTest, UseUnsizedInputDeclaredBeforeInputPrimitive)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "in vec4 texcoord[];\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_Position = texcoord[0];\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry shaders allow an input without explicitly declaring its size after the declaration of
+// the input primitive. Its size should be set by the type of the input primitive.
+TEST_F(GeometryShaderTest, InputWithoutSizeAfterInputPrimitiveDeclaration)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "in vec4 texcoord[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow inputs with location qualifiers.
+TEST_F(GeometryShaderTest, InputWithLocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "layout (location = 0) in vec4 texcoord[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow inputs with explicit size declared before the declaration of the
+// input primitive, but they should have same size and match the declaration of the
+// following input primitive declaration.
+TEST_F(GeometryShaderTest, InputWithSizeBeforeInputPrimitive)
+{
+    const std::array<std::string, 5> kInputPrimitives = {
+        {"points", "lines", "lines_adjacency", "triangles", "triangles_adjacency"}};
+    constexpr int kInputArraySize[] = {1, 2, 4, 3, 6};
+
+    for (GLuint i = 0; i < kInputPrimitives.size(); i++)
+    {
+        const std::string &inputLayoutStr =
+            GetGeometryShaderLayout("in", kInputPrimitives[i], -1, -1);
+        const int inputSize = kInputArraySize[i];
+
+        const std::string &inputDeclaration1 = GetInputDeclaration("var1", inputSize);
+        if (!compileGeometryShader(inputDeclaration1, "", inputLayoutStr, kOutputLayout))
+        {
+            FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+        }
+
+        const std::string &inputDeclaration2 = GetInputDeclaration("var2", inputSize);
+        if (!compileGeometryShader(inputDeclaration1, inputDeclaration2, inputLayoutStr,
+                                   kOutputLayout))
+        {
+            FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+        }
+
+        const std::string &inputDeclaration3 = GetInputDeclaration("var3", inputSize + 1);
+        if (compileGeometryShader(inputDeclaration3, "", inputLayoutStr, kOutputLayout) ||
+            compileGeometryShader(inputDeclaration1, inputDeclaration3, inputLayoutStr,
+                                  kOutputLayout))
+        {
+            FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+        }
+    }
+}
+
+// Geometry shaders allow inputs with explicit size declared after the declaration of the
+// input primitive, but their sizes should match the previous input primitive declaration.
+TEST_F(GeometryShaderTest, InputWithSizeAfterInputPrimitive)
+{
+    const std::array<std::string, 5> kInputPrimitives = {
+        {"points", "lines", "lines_adjacency", "triangles", "triangles_adjacency"}};
+    constexpr int kInputArraySize[] = {1, 2, 4, 3, 6};
+
+    for (GLuint i = 0; i < kInputPrimitives.size(); i++)
+    {
+        const std::string &inputLayoutStr =
+            GetGeometryShaderLayout("in", kInputPrimitives[i], -1, -1);
+        const int inputSize = kInputArraySize[i];
+
+        const std::string &inputDeclaration1 = GetInputDeclaration("var1", inputSize);
+        if (!compileGeometryShader(inputLayoutStr, kOutputLayout, inputDeclaration1, ""))
+        {
+            FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+        }
+
+        const std::string &inputDeclaration2 = GetInputDeclaration("var2", inputSize + 1);
+        if (compileGeometryShader(inputLayoutStr, kOutputLayout, inputDeclaration2, ""))
+        {
+            FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+        }
+    }
+}
+
+// Geometry Shaders allow declaring output primitive before input primitive declaration.
+TEST_F(GeometryShaderTest, DeclareOutputPrimitiveBeforeInputPrimitiveDeclare)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "layout (points) in;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow declaring 'max_vertices' before output primitive in the same output
+// layout.
+TEST_F(GeometryShaderTest, DeclareMaxVerticesBeforeOutputPrimitive)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (max_vertices = 1, points) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// It should be a linking error instead of a compilation error to lack the declarations of output
+// primitive in a geometry shader.
+TEST_F(GeometryShaderTest, NoOutputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders can only support 3 kinds of output primitives, which cannot be used as input
+// primitives except 'points'. Skip testing "points" as it can be used as both input and output
+// primitives.
+TEST_F(GeometryShaderTest, ValidateOutputPrimitives)
+{
+    const std::string outputPrimitives[] = {"line_strip", "triangle_strip"};
+
+    for (const std::string &outPrimitive : outputPrimitives)
+    {
+        if (!compileGeometryShader(kInputLayout,
+                                   GetGeometryShaderLayout("out", outPrimitive, -1, 6)))
+        {
+            FAIL() << "Shader compilation failure, expecting succeed:\n" << mInfoLog;
+        }
+
+        if (compileGeometryShader(GetGeometryShaderLayout("in", outPrimitive, -1, -1),
+                                  kOutputLayout))
+        {
+            FAIL() << "Shader compilation succeed, expecting failure:\n" << mInfoLog;
+        }
+    }
+}
+
+// Geometry Shaders	allow duplicated declaration of input primitive, but don't allow multiple
+// different input primitives.
+TEST_F(GeometryShaderTest, RedeclareOutputPrimitives)
+{
+    const std::array<std::string, 3> outPrimitives = {{"points", "line_strip", "triangle_strip"}};
+
+    for (GLuint i = 0; i < outPrimitives.size(); i++)
+    {
+        constexpr int maxVertices = 1;
+        const std::string &outputLayoutStr1 =
+            GetGeometryShaderLayout("out", outPrimitives[i], -1, maxVertices);
+        const std::string &outputLayoutStr2 =
+            GetGeometryShaderLayout("out", outPrimitives[i], -1, -1);
+        if (!compileGeometryShader(kInputLayout, outputLayoutStr1, outputLayoutStr2, ""))
+        {
+            FAIL() << "Shader compilation failure, expecting succeed:\n" << mInfoLog;
+        }
+        for (GLuint j = i + 1; j < outPrimitives.size(); j++)
+        {
+            const std::string &outputLayoutStr3 =
+                GetGeometryShaderLayout("out", outPrimitives[j], -1, -1);
+            if (compileGeometryShader(kInputLayout, outputLayoutStr1, outputLayoutStr3, ""))
+            {
+                FAIL() << "Shader compilation succeed, expecting failure:\n" << mInfoLog;
+            }
+        }
+    }
+}
+
+// Geometry Shaders don't allow declaring different output primitives.
+TEST_F(GeometryShaderTest, RedeclareDifferentOutputPrimitivesInOneLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 3, line_strip) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// It should be a linking error instead of a compilation error to lack the declarations of output
+// primitives and max_vertices in a geometry shader.
+TEST_F(GeometryShaderTest, NoOutLayouts)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// It should be a linking error instead of a compilation error to lack the declarations of
+// 'max_vertices' in a geometry shader.
+TEST_F(GeometryShaderTest, NoMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders cannot declare a negative 'max_vertices'.
+TEST_F(GeometryShaderTest, NegativeMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = -1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders cannot declare a 'max_vertices' that is greater than
+// MAX_GEOMETRY_OUTPUT_VERTICES_EXT (256).
+TEST_F(GeometryShaderTest, TooLargeMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 257) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders can declare 'max_vertices' declared in an individual out layout.
+TEST_F(GeometryShaderTest, MaxVerticesInIndividualLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points) out;\n"
+        "layout (max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow duplicated declaration of 'max_vertices'.
+TEST_F(GeometryShaderTest, DuplicatedMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "layout (max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow declaring different 'max_vertices'.
+TEST_F(GeometryShaderTest, RedeclareDifferentMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "layout (max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders don't allow declaring different 'max_vertices'.
+TEST_F(GeometryShaderTest, RedeclareDifferentMaxVerticesInOneLayout)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2, max_vertices = 1) out;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow declaring non-array outputs.
+TEST_F(GeometryShaderTest, NonArrayOutputs)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "out vec4 o_texcoord;\n"
+        "void main()\n"
+        "{\n"
+        "    o_texcoord = vec4(0, 0, 0, 1);\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow declaring non-array outputs with location layout qualifiers.
+TEST_F(GeometryShaderTest, NonArrayOutputsWithLocation)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "layout (location = 0) out vec4 o_texcoord;\n"
+        "void main()\n"
+        "{\n"
+        "    o_texcoord = vec4(0, 0, 0, 1);\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// It isn't allowed to declare unsized array outputs in Geometry Shaders.
+TEST_F(GeometryShaderTest, UnsizedArrayOutputs)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "out vec4 o_texcoord[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Geometry Shaders allow declaring sized array outputs.
+TEST_F(GeometryShaderTest, SizedArrayOutputs)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 1) out;\n"
+        "out vec4 o_texcoord[2];\n"
+        "void main()\n"
+        "{\n"
+        "    o_texcoord[0] = vec4(0, 1, 0, 1);\n"
+        "    o_texcoord[1] = vec4(1, 0, 0, 1);\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify the built-in variables that Geometry Shader should support
+TEST_F(GeometryShaderTest, BuiltInVariables)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 2) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_Position = gl_in[gl_InvocationID].gl_Position;\n"
+        "    gl_Layer = gl_InvocationID;\n"
+        "    gl_PrimitiveID = gl_PrimitiveIDIn;\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that gl_PrimitiveIDIn cannot be assigned a value.
+TEST_F(GeometryShaderTest, AssignValueToGLPrimitiveIn)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 2) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_PrimitiveIDIn = 1;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Verify that gl_InvocationID cannot be assigned a value.
+TEST_F(GeometryShaderTest, AssignValueToGLInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, invocations = 2) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_InvocationID = 1;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Verify that gl_in[].gl_Position cannot be assigned a value.
+TEST_F(GeometryShaderTest, AssignValueToGLIn)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_in[0].gl_Position = vec4(0, 0, 0, 1);\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Verify that both EmitVertex() and EndPrimitive() are supported in Geometry Shader.
+TEST_F(GeometryShaderTest, GeometryShaderBuiltInFunctions)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_Position = gl_in[0].gl_Position;\n"
+        "    EmitVertex();\n"
+        "    EndPrimitive();\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that all required built-in constant values are supported in Geometry Shaders
+TEST_F(GeometryShaderTest, GeometryShaderBuiltInConstants)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    int val1 = gl_MaxGeometryInputComponents;\n"
+        "    int val2 = gl_MaxGeometryOutputComponents;\n"
+        "    int val3 = gl_MaxGeometryImageUniforms;\n"
+        "    int val4 = gl_MaxGeometryTextureImageUnits;\n"
+        "    int val5 = gl_MaxGeometryOutputVertices;\n"
+        "    int val6 = gl_MaxGeometryTotalOutputComponents;\n"
+        "    int val7 = gl_MaxGeometryUniformComponents;\n"
+        "    int val8 = gl_MaxGeometryAtomicCounters;\n"
+        "    int val9 = gl_MaxGeometryAtomicCounterBuffers;\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded: \n" << mInfoLog;
+    }
+}
+
+// Verify that gl_in[].gl_PointSize isn't supported in Geometry Shaders without declaring
+// GL_EXT_geometry_point_size.
+TEST_F(GeometryShaderTest, GeometryShaderInputPointSizeNoExtension)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    float pointSize;\n"
+        "    pointSize = gl_in[0].gl_PointSize;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Verify that gl_PointSize isn't supported in Geometry Shaders without declaring
+// GL_EXT_geometry_point_size.
+TEST_F(GeometryShaderTest, GeometryShaderOutputPointSizeNoExtension)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_PointSize = 1.0;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'flat' interpolation qualifier on input variables.
+TEST_F(GeometryShaderTest, FlatInput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "flat in vec4 color[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'flat' interpolation qualifier on output variables.
+TEST_F(GeometryShaderTest, FlatOutput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "flat out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'smooth' interpolation qualifier on input variables.
+TEST_F(GeometryShaderTest, SmoothInput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "smooth in vec4 color[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'smooth' interpolation qualifier on output variables.
+TEST_F(GeometryShaderTest, SmoothOutput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "smooth out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'centroid' qualifier on input variables.
+TEST_F(GeometryShaderTest, CentroidInput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "centroid in vec4 color[];\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders allow 'centroid' qualifier on output variables.
+TEST_F(GeometryShaderTest, CentroidOutput)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "centroid out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (!compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// Verify that Geometry Shaders doesn't allow 'locations' defined with input/output primitives.
+TEST_F(GeometryShaderTest, invalidLocationDefinition)
+{
+    const std::string &shaderString1 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, location = 1) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString2 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (invocations = 2, location = 1) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString3 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, location = 3, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString4 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points) out;\n"
+        "layout (max_vertices = 2, location = 3) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString1) || compile(shaderString2) || compile(shaderString3) ||
+        compile(shaderString4))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
diff --git a/src/tests/compiler_tests/ShaderValidation_test.cpp b/src/tests/compiler_tests/ShaderValidation_test.cpp
index 2b91b78a5..c01ef6423 100644
--- a/src/tests/compiler_tests/ShaderValidation_test.cpp
+++ b/src/tests/compiler_tests/ShaderValidation_test.cpp
@@ -67,6 +67,20 @@ class ComputeShaderValidationTest : public ShaderCompileTreeTest
     ShShaderSpec getShaderSpec() const override { return SH_GLES3_1_SPEC; }
 };
 
+class GeometryShaderValidationTest : public ShaderCompileTreeTest
+{
+  public:
+    GeometryShaderValidationTest() {}
+
+  protected:
+    void initResources(ShBuiltInResources *resources) override
+    {
+        resources->EXT_geometry_shader = 1;
+    }
+    ::GLenum getShaderType() const override { return GL_GEOMETRY_SHADER_EXT; }
+    ShShaderSpec getShaderSpec() const override { return SH_GLES3_1_SPEC; }
+};
+
 // This is a test for a bug that used to exist in ANGLE:
 // Calling a function with all parameters missing should not succeed.
 TEST_F(FragmentShaderValidationTest, FunctionParameterMismatch)
@@ -2163,6 +2177,57 @@ TEST_F(FragmentShaderValidationTest, InvalidUseOfLocalSizeX)
     }
 }
 
+// The local_size layout qualifier is only available in compute shaders.
+TEST_F(GeometryShaderValidationTest, InvalidUseOfLocalSizeX)
+{
+    const std::string &shaderString1 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points, local_size_x = 15) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString2 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (invocations = 2, local_size_x = 15) in;\n"
+        "layout (points, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString3 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points, local_size_x = 15, max_vertices = 2) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+
+    const std::string &shaderString4 =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (points) in;\n"
+        "layout (points) out;\n"
+        "layout (max_vertices = 2, local_size_x = 15) out;\n"
+        "out vec4 color;\n"
+        "void main()\n"
+        "{\n"
+        "}\n";
+    if (compile(shaderString1) || compile(shaderString2) || compile(shaderString3) ||
+        compile(shaderString4))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
 // It is a compile time error to use the gl_WorkGroupSize constant if
 // the local size has not been declared yet.
 // GLSL ES 3.10 Revision 4, 7.1.3 Compute Shader Special Variables
@@ -3879,3 +3944,213 @@ TEST_F(FragmentShaderValidationTest, StructAsBoolConstructorArgument)
         FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
     }
 }
+
+// The input primitive layout qualifier is only available in geometry shaders.
+TEST_F(VertexShaderValidationTest, InvalidUseOfInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "layout(points) in vec4 myInput;\n"
+        "out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The input primitive layout qualifier is only available in geometry shaders.
+TEST_F(FragmentShaderValidationTest, InvalidUseOfInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "layout(points) in vec4 myInput;\n"
+        "out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The input primitive layout qualifier is only available in geometry shaders.
+TEST_F(ComputeShaderValidationTest, InvalidUseOfInputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "layout(points, local_size_x = 12) in;\n"
+        "void main()\n"
+        "{\n"
+        "   uvec3 WorkGroupSize = gl_WorkGroupSize;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The output primitive layout qualifier is only available in geometry shaders.
+TEST_F(VertexShaderValidationTest, InvalidUseOfOutputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput;\n"
+        "layout(points) out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The output primitive layout qualifier is only available in geometry shaders.
+TEST_F(FragmentShaderValidationTest, InvalidUseOfOutputPrimitives)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput;\n"
+        "layout(points) out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The invocations layout qualifier is only available in geometry shaders.
+TEST_F(VertexShaderValidationTest, InvalidUseOfInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "layout (invocations = 3) in vec4 myInput;\n"
+        "out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The invocations layout qualifier is only available in geometry shaders.
+TEST_F(FragmentShaderValidationTest, InvalidUseOfInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "layout (invocations = 3) in vec4 myInput;\n"
+        "out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The invocations layout qualifier is only available in geometry shaders.
+TEST_F(ComputeShaderValidationTest, InvalidUseOfInvocations)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "layout(invocations = 3, local_size_x = 12) in;\n"
+        "void main()\n"
+        "{\n"
+        "   uvec3 WorkGroupSize = gl_WorkGroupSize;\n"
+        "}\n";
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The max_vertices layout qualifier is only available in geometry shaders.
+TEST_F(VertexShaderValidationTest, InvalidUseOfMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput;\n"
+        "layout(max_vertices = 3) out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// The max_vertices layout qualifier is only available in geometry shaders.
+TEST_F(FragmentShaderValidationTest, InvalidUseOfMaxVertices)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput;\n"
+        "layout(max_vertices = 3) out vec4 myOutput;\n"
+        "void main() {\n"
+        "   myOutput = myInput;\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
+
+// It isn't allowed to declare unsized array outputs in vertex shaders.
+TEST_F(VertexShaderValidationTest, UnsizedArrayOutputs)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput;\n"
+        "out vec4 myOutput[];\n"
+        "void main() {\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation failure, expecting succeeded:\n" << mInfoLog;
+    }
+}
+
+// It isn't allowed to declare unsized array Inputs in fragment shaders.
+TEST_F(FragmentShaderValidationTest, UnsizedArrayInputs)
+{
+    const std::string &shaderString =
+        "#version 310 es\n"
+        "precision mediump float;\n"
+        "in vec4 myInput[];\n"
+        "out vec4 myOutput;\n"
+        "void main() {\n"
+        "}\n";
+
+    if (compile(shaderString))
+    {
+        FAIL() << "Shader compilation succeeded, expecting failure:\n" << mInfoLog;
+    }
+}
diff --git a/src/tests/gl_tests/GeometryShaderTest.cpp b/src/tests/gl_tests/GeometryShaderTest.cpp
new file mode 100644
index 000000000..fe4b90930
--- /dev/null
+++ b/src/tests/gl_tests/GeometryShaderTest.cpp
@@ -0,0 +1,50 @@
+//
+// Copyright 2017 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "test_utils/ANGLETest.h"
+
+using namespace angle;
+
+namespace
+{
+
+class GeometryShaderTest : public ANGLETest
+{
+};
+
+TEST_P(GeometryShaderTest, CompileBasicGeometryShader)
+{
+    const std::string &testGeometryShaderSource =
+        "#version 310 es\n"
+        "#extension GL_EXT_geometry_shader : require\n"
+        "layout (invocations = 3, triangles) in;\n"
+        "layout (triangle_strip, max_vertices = 3) out;\n"
+        "layout (location = 0) in vec4 vs_normal[];\n"
+        "layout (location = 1) in vec2 vs_texcoord[3];\n"
+        "layout (location = 0) out vec4 gs_normal;\n"
+        "out vec2 gs_texcoord[2];\n"
+        "void main()\n"
+        "{\n"
+        "    int n;\n"
+        "    for (n = 0; n < gl_in.length(); n++)\n"
+        "    {\n"
+        "        gl_Position = gl_in[n].gl_Position;\n"
+        "        gs_normal = vs_normal[gl_InvocationID];\n"
+        "        gl_Layer   = gl_InvocationID;\n"
+        "        gs_texcoord[0] = vs_texcoord[gl_InvocationID];\n"
+        "        EmitVertex();\n"
+        "    }\n"
+        "    EndPrimitive();\n"
+        "}";
+
+    GLuint geometryShader = CompileShader(GL_GEOMETRY_SHADER_EXT, testGeometryShaderSource);
+
+    EXPECT_NE(0u, geometryShader);
+}
+
+ANGLE_INSTANTIATE_TEST(GeometryShaderTest, ES31_OPENGL(), ES31_OPENGLES());
+
+}  // anonymous namespace
-- 
2.11.0.windows.1

