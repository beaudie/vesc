{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f491c90c_da06874b",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-13T14:50:43Z",
      "side": 1,
      "message": "Hmm, why can\u0027t this call be replaced with `removeActiveThreadAndPerformCleanup`?\n\nif `mActiveThreads.size() \u003e 1`, `removeActiveThreadAndPerformCleanup()` and `removeActiveThread()` calls are equivalent.\n\nif `mActiveThreads.size() \u003d\u003d 1`, then the thread calling eglTerminate is the last active thread - shouldn\u0027t we be performing the cleanup right away then? If I\u0027m missing something, could you add a comment to the code explaining why `removeActiveThreadAndPerformCleanup` can\u0027t be called here?",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ec0eb52_90193e16",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-13T16:48:13Z",
      "side": 1,
      "message": "wanted to keep `removeActiveThread` as a simple helper that does just 1 thing.\n\nI was thinking about this a bit more and it is not at all necessary to call `removeActiveThread` here. We can have good logical separation by allowing thread destruction call to perform any necessary cleanup and let `Display::terminate` not call into any additional cleanup routine. There is no value added by preempting the existing call flow with the clean up call flow when we can just wait for the thread to be destroyed and handle the clean up there. Let me know your thoughts",
      "parentUuid": "f491c90c_da06874b",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f34cc1f_151d85ad",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-13T18:31:04Z",
      "side": 1,
      "message": "\u003e when we can just wait for the thread to be destroyed and handle the clean up there\n\nBut the thread may not be destroyed for a while though? It might do another eglInitialize or just hang around for whatever reason. For example, a thread could do eglInitialize -\u003e test -\u003e eglTerminate in a loop, and then we would postpone all cleanups until the very end.\n\nGiven that the thread explicitly called eglTerminate, shouldn\u0027t we go ahead with the cleanup simply by calling `removeActiveThreadAndPerformCleanup` here? Are you seeing some potential issues we could run into by doing this?",
      "parentUuid": "1ec0eb52_90193e16",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d52133d_4b09a31f",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-13T18:52:18Z",
      "side": 1,
      "message": "\u003e For example, a thread could do eglInitialize -\u003e test -\u003e eglTerminate in a loop, and then we would postpone all cleanups until the very end\n\nif that was the only active thread and the test did something like this -\n```\n for (...)\n {\n     eglInitialize\n     test(...)\n     {\n         create context\n         create surface\n         makecurrent\n         draw\n         unmakecurrent\n     }\n     eglTerminate\n }\n```\n\nthen the regular flow of terminate will free all resources",
      "parentUuid": "4f34cc1f_151d85ad",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "245efd29_8b4e52b0",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-13T19:03:16Z",
      "side": 1,
      "message": "Ahh, yes I think you\u0027re right! We don\u0027t need to invoke `terminate(NoActiveThreads)` if it\u0027s explicitly terminated and there are no outstanding threads as `terminate(Api)` will have taken care of everything. We only need `terminate(NoActiveThreads)` when `terminate(Api)` couldn\u0027t have done a full cleanup due to outstanding threads, in which case doing what you did is going to take care of it. Thanks for bearing with me :) and all the adjustments!",
      "parentUuid": "6d52133d_4b09a31f",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "94a513c9_c3f6a694",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-13T19:36:59Z",
      "side": 1,
      "message": "\u003e We only need  terminate(NoActiveThreads)  when  terminate(Api)  couldn\u0027t have done a full cleanup due to outstanding threads\n\nexactly\n\nthank you for the review!",
      "parentUuid": "245efd29_8b4e52b0",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3909447d_286579e1",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-14T12:45:27Z",
      "side": 1,
      "message": "Mohan, I just realized that the way you had it on the previous iteration (with `removeActiveThread`) was probably right. Here is a scenario where that matters:\n\n```\nthreadA:\neglInitialize\nspawn longer-running threadB(dpy)\neglTerminate  \u003c-- can\u0027t fully cleanup due to threadB still running\n(threadA stays alive)\n\nthreadB:\nterminates but can\u0027t fully cleanup because threadA still in `mActiveThreads`\n*** we should be running cleanup here ***\n\nthreadA continues running (maybe does more of the above with more threads to aggravate)\n\nfull cleanup only possible when threadA terminates\n```\n\nSo I think you were right about calling `removeActiveThread` here. WDYT? LMK if you\u0027d like to add it or you want me to add it. Not sure if worth adding a test specifically for this as this is a fairly special case.",
      "parentUuid": "94a513c9_c3f6a694",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b2a492b_f8c3f1a5",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-14T13:20:54Z",
      "side": 1,
      "message": "i guess the spirit of the change was the coupling between memory cleanup and having no more active threads (which is why i ended up removing `removeActiveThread`). Having said that, in your usecase it also depends on what threadB does. If it calls say, context destroy then a cleanup will happen.\n\nthis is indeed a corner case that requires a more aggressive memory clean up, will leave the call to you.",
      "parentUuid": "3909447d_286579e1",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0707889_e47597ab",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-15T17:33:39Z",
      "side": 1,
      "message": "@romanl i think there is an easy way to address your test case and perform cleanup without preempting things with forced cleanup using `TerminateReason::InternalCleanup`. will try to put up a change today",
      "parentUuid": "2b2a492b_f8c3f1a5",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ab85811_2f6635e0",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1531247
      },
      "writtenOn": "2022-07-15T18:42:10Z",
      "side": 1,
      "message": "Thanks Mohan. I\u0027ve been looking into what is happening in tests, some findings:\n\n1. The same Display object is being reused again and again (probably because of this: https://crsrc.org/c/third_party/angle/src/libANGLE/Display.cpp;drc\u003d75425ebb5303c7bb416b2261e9b27114ec903d3f;l\u003d708). So the same object ends up transitioning between intialized / (partially)terminated states.\n\n2. When display is partially terminated (mTerminatedByApi\u003dtrue but mActiveThreads not empty, **mInitialized\u003dtrue** \u003c-- only false when fully terminated) we end up bypassing initialization here: https://crsrc.org/c/third_party/angle/src/libANGLE/Display.cpp;drc\u003d75425ebb5303c7bb416b2261e9b27114ec903d3f;l\u003d985\n\n3. destroyGL called by RepeatedEglInitAndTerminate calls eglTerminate, but the thread is still alive - so we end up in the situation I described above. If I comment out eglReleaseThread as your comment suggests, I see mActiveThreads never reaching 0 and so display is never terminated. When I add a patch that removes the thread calling eglTerminate from mActiveThreads, then the display is fully terminated.\n\n4. RepeatedEglInitAndTerminate becomes very slow (like 300ms per iteration) when display is actually fully terminated. The full termination/initialization cycle without the bypass in (2) seems quite expensive.",
      "parentUuid": "f0707889_e47597ab",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09acc22c_67fc716b",
        "filename": "src/libANGLE/Display.cpp",
        "patchSetId": 19
      },
      "lineNbr": 1114,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2022-07-15T21:52:38Z",
      "side": 1,
      "message": "re-reading your test case -\n```\nthreadA:\neglInitialize\nspawn longer-running threadB(dpy)\neglTerminate  \u003c-- can\u0027t fully cleanup due to threadB still running\n(threadA stays alive)\n\nthreadB:\nterminates but can\u0027t fully cleanup because threadA still in `mActiveThreads`\n*** we should be running cleanup here ***\n```\n\nwith the code as it stands, im not sure how\n\u003e terminates but can\u0027t fully cleanup because threadA still in `mActiveThreads`\n\nis possible. threadA never called makeCurrent so will never be added to `mActiveThreads`, can you clarify?",
      "parentUuid": "9ab85811_2f6635e0",
      "range": {
        "startLine": 1114,
        "startChar": 8,
        "endLine": 1114,
        "endChar": 26
      },
      "revId": "ff4ad8b0bca4f250d24981ebc9456e38c469c547",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}