{
  "comments": [
    {
      "key": {
        "uuid": "3275b552_5bf21e4f",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-08T15:18:04Z",
      "side": 1,
      "message": "This can be interrupted, so you need to turn the `if` into `while`. If you look at AsyncWorkerPool, it uses a variant of `wait()` that does that.",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "044526e0_dc855ef8",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1215674
      },
      "writtenOn": "2020-06-10T15:14:27Z",
      "side": 1,
      "message": "I don\u0027t understand at all what do you mean by \"interrupted\".\n\nIs it interrupt by the stl implementation? Does we provide an way to interrupt the tasks execution?\n\nI\u0027m reading the doc and I can\u0027t find an explanation for interruption.\n  https://en.cppreference.com/w/cpp/thread/condition_variable/wait\n\nCan you clarify?",
      "parentUuid": "3275b552_5bf21e4f",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5403699_2eccc821",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1215674
      },
      "writtenOn": "2020-06-10T15:21:30Z",
      "side": 1,
      "message": "If what you mean is related to |mIsPending|, you no longer need this.\n\nThe reason |mIsPending| is used if because you cannot wait on a future\nbefore it is created:\n \n    ASSERT(mFuture.valid());\n    mFuture.wait();\n\nThis is happening because the task can be in the working queue, not yet emited.\nThe AsyncWorkerPool code ensures the task is emited and the future is valid before\ntrying to wait for it.\n\nIn the current implementation, only one condition variable is used. The condition\nvariable is created before the task is posted and there is no need to wait for\nthe creation of the task. Since the task is posted on the worker pool. There is\nno mechanism to wait for task completion and solely rely on the condition variable\nto signal that the closure was executed.\n\nDoes that make sense?",
      "parentUuid": "044526e0_dc855ef8",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3972a281_e6863ef5",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-10T15:33:06Z",
      "side": 1,
      "message": "https://en.cppreference.com/w/cpp/thread/condition_variable/wait says:\n\n\u003e wait causes the current thread to block until the condition variable is notified **or a spurious wakeup occurs**\n\nLater it says again:\n\n\u003e The thread will be unblocked when notify_all() or notify_one() is executed. It may also be unblocked spuriously.\n\nThat\u0027s why the `if` should turn into a `while`.",
      "parentUuid": "e5403699_2eccc821",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fc71add_419adf39",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1215674
      },
      "writtenOn": "2020-06-10T17:10:00Z",
      "side": 1,
      "message": "I\u0027ve spent a bit of time looking on details. I find it a bit scary.\n\n1) Wait(..) can wake up Spurious. So,it must be around a while (!pred()) { wait(); } or \n   use the overloaded version with predicate.\n\n  see: https://en.cppreference.com/w/cpp/thread/condition_variable/wait\n\n  \"The thread will be unblocked when notify_all() or notify_one() is executed.\n   It may also be unblocked spuriously.\"\n  \n  \"This overload may be used to ignore spurious awakenings while waiting for\n   a specific condition to become true.\"\n\n\n2) Notify may be implemented as a broadcast all\n\n  see: https://en.wikipedia.org/wiki/Spurious_wakeup\n\n  \"The system may decide to wake them all up, treating every signal( ) to wake one\n   thread as a broadcast( ) to wake all of them, thus breaking any possibly\n   expected 1:1 relationship between signals and wakeups.[1] If there are ten threads\n   waiting, only one will win and the other nine will experience spurious wakeups.\"\n\n  see: https://devblogs.microsoft.com/oldnewthing/20180201-00/?p\u003d97946\n\n\n3) We do not have the lost notification issue since the lock is always taken while\n   updating the predicate and while notifying threads.\n\n\nShort story: We need to use the overloaded predicate version of wait as recommended\n             by Shahbaz.",
      "parentUuid": "3972a281_e6863ef5",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4390edc6_37c8d81b",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 248,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-06-10T18:56:33Z",
      "side": 1,
      "message": "Tobin has a good CL that you can follow with locks, waits, and signals:\n\nhttps://chromium-review.googlesource.com/c/angle/angle/+/2174719\n\nIn particular, functions like CommandProcessor::processCommandProcessorTasks().",
      "parentUuid": "8fc71add_419adf39",
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4242e156_80230a53",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 306,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-08T15:18:04Z",
      "side": 1,
      "message": "If both ANGLE_DELEGATE_WORKERS and ANGLE_DELEGATE_WORKERS are set, we still cannot enter this if, so it might as well say:\n\n    #elif ...STD...\n        if (multithreaded)",
      "range": {
        "startLine": 304,
        "startChar": 0,
        "endLine": 306,
        "endChar": 31
      },
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b54e546f_a8df5db8",
        "filename": "src/libANGLE/WorkerThread.cpp",
        "patchSetId": 9
      },
      "lineNbr": 306,
      "author": {
        "id": 1215674
      },
      "writtenOn": "2020-06-10T15:14:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4242e156_80230a53",
      "range": {
        "startLine": 304,
        "startChar": 0,
        "endLine": 306,
        "endChar": 31
      },
      "revId": "363ed9dee30ca9183f65138101fbb8f9f50611c7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}