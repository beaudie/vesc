{
  "comments": [
    {
      "key": {
        "uuid": "b5c18462_909d7348",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1393148
      },
      "writtenOn": "2020-09-03T09:48:52Z",
      "side": 1,
      "message": "Hi Jamie,Shahbaz.\nThis patch is releated to the issue https://issuetracker.google.com/issues/159995959.\n\"srcImageCoords\" needs to be aligned before being used in TEXEL_FETCH.\n\nFor example,in cts dEQP-GLES3.functional.fbo.invalidate.whole.unbind_blit_msaa_color. The input coordinates gl_GlobalInvocationID.x changes from 0 to 31, gl_GlobalInvocationID.y changes from 0 to 127. We can get the sample position srcImageCoords:(128-y,128-4x) after calculation for flipping and rotation. So the sample position srcImageCoords.x (128-y) changes between [1,128], srcImageCoords.y (128-4x) changes between [4,128] (after adding xDir).",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "36fe22ac_d7329a4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1424723
      },
      "writtenOn": "2020-09-03T09:59:59Z",
      "side": 1,
      "message": "commit msg",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ae38ed4_b9c2837a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1424723
      },
      "writtenOn": "2020-09-03T10:01:18Z",
      "side": 1,
      "message": "\"blitResolveStencil compute shader\" should more precisely be \n\"blitResolveStencilNoExport compute shader\"",
      "parentUuid": "36fe22ac_d7329a4a",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2161f3f3_9424abff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1393148
      },
      "writtenOn": "2020-09-03T11:46:22Z",
      "side": 1,
      "message": "fix comment: \nWhen gl_GlobalInvocationID.x/gl_GlobalInvocationID.y is 0, the sample position will be wrong.",
      "parentUuid": "b5c18462_909d7348",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "03b2cf2e_2a1cbe8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-03T13:20:39Z",
      "side": 1,
      "message": "Thank you for the fix!\n\nI wonder though, can you figure out why the calls to AdjustBlitResolveParametersForResolve in FramebufferVk::blit are not sufficient for this? That function was meant to do exactly this, but on the CPU.",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cdd2095b_6ff4da0c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2020-09-03T19:21:04Z",
      "side": 1,
      "message": "Also adding Ian who worked on the rotation code.",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "117e76f9_e2a8dce6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1290487
      },
      "writtenOn": "2020-09-03T22:59:07Z",
      "side": 1,
      "message": "Thank you for submitting this CL!  I was planning to get back to this bug last week, but was delayed.  LGTM and tests well on Pixel 4 XL.  I defer to Shabi on his comments.",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abfc3b84_c8cc6d8b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1424723
      },
      "writtenOn": "2020-09-04T02:50:38Z",
      "side": 1,
      "message": "Quote some comment from the function:\n\n// On the other hand, when resolving, the source and destination areas are used as fragment\n// coordinates to fetch from.  In that case, when flipped, the texture in the above example must\n// have an offset of 63.\n\nI think the calculation is correct, but it only work for fragment coordinate.\nIn this stencil export compute shader, it\u0027s mixing the concept.\nIt\u0027s using texel index(for texel_fetch) not fragment coordinate(for texture) which usually has 0.5 offset of index.",
      "parentUuid": "03b2cf2e_2a1cbe8e",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "070acda6_6899d0e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1393148
      },
      "writtenOn": "2020-09-04T03:27:59Z",
      "side": 1,
      "message": "Thanks.We are moving office recently.I\u0027ll continue to investigate it next week.Sorry for the delay.",
      "parentUuid": "03b2cf2e_2a1cbe8e",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "682bc428_84d11a8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-05T05:40:51Z",
      "side": 1,
      "message": "I took a look and here\u0027s what I see:\n\n- If blitting, the coordinates are vec2 and texture() is used to read from src\n- If resolving, the coordinates are ivec2 and texelFetch() is used to read from src\n\n---\n\nWith blit, I agree there\u0027s a difference between BlitResolve.frag and BlitResolveStencilNoExport.comp and that must be a bug. In the FS, the coordinates are NNN.5 but in the CS they would be NNN. With the point sampler that might be fine, but definitely an issue with the linear sampler (if that even makes sense for a stencil image?)\n\nThe solution is probably a simple param-\u003eoffset.xy -\u003d 0.5 (on the CPU) if blitting (and not resolving), or maybe +\u003d 0.5 if flipped. If you are interested in fixing this, a regression test to verify the change against would be a necessary first step.\n\n---\n\nWith resolve, I don\u0027t see a difference. The FS coordinates are 0.5 higher yes, but cast to ivec2 they should produce the same values.\n\nSee the comment in BlitResolve.frag. When flipped, the source coordinates correspond to the opposite side of the blit rectangle. When resolving, these are integer coordinates and AdjustBlitResolveParametersForResolve should have made sure they are -1ed. I still don\u0027t understand why there\u0027s a different between the FS and CS shaders in this regard.\n\nIt\u0027s possible that AdjustBlitResolveParametersForResolve is not doing the right thing. Maybe params-\u003eoffset needs to be modified based on flip too (which would have the same effect as the change in this CL), but that would affect the FS and CS similarly.\n\n---\n\nTo better understand/debug the issue, could you please write a few tests that reproduce the bug (with the +\u003d 2 hack removed) and don\u0027t rely on prerotation to fail? It might be possible that we already have tests that are affected by this, but the test is using a uniform value for stencil, masking the problem. It would be ok to modify those tests to have unique stencil values per pixel.",
      "parentUuid": "070acda6_6899d0e0",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1eab4ce7_5d0d7aba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1393148
      },
      "writtenOn": "2020-09-08T14:28:32Z",
      "side": 1,
      "message": "Thanks Shahbaz. We finished the office moving and started working on this CL again. \n\nSome test results to update:\n1）AdjustBlitResolveParametersForResolve\ndEQP-GLES3.functional.fbo.invalidate.whole.unbind_blit_msaa_color.\nOn Linux, AdjustBlitResolveParametersForResolve funcition can work because multisample stencil buffer is blitted to default framebuffer. So destFramebufferRotation is true, and filpY is enabled. The shaderParams.offset decreases from 300 to 299 and srcImageCoords.y in shader could be (127-gl_GlobalInvocationID.y).\nOn android, EarlyAdjustFlipYForPreRotation function will disable destFramebufferRotation. In AdjustBlitResolveParametersForResolve function, the four xxx.isReversedY() conditions are all false.\nSo I think AdjustBlitResolveParametersForResolve may only handle the filp operation in Linux but can\u0027t deal with prerotation correctly.\n\n2) added test\nAs mentioned in 1), it\u0027s wrong to add \"-1\" in compute shader, for linux, it would become (126-gl_GlobalInvocationID.y). There wasn\u0027t end2end to cover it and the CTS tests could accept mismatch in two rows, so the dry run passed. If you test the added end2end in patchset 2, you can get failures when y\u003d0.\nExpected equality of these values:\n  GLColor::blue\n    Which is: Blue\n  angle::ReadColor(0, 0)\n    Which is: Green\n......\nSo, maybe it\u0027s better to add -1/0.5 in CPU and change the offset in prerotaion path.\nIf needed, I\u0027ll add more end2end tests later.\n\n3)msaa\nOn Linux,msaa0 will enable canBlitWithCommand.\nI\u0027ll get more information on android tomorrow.",
      "parentUuid": "682bc428_84d11a8f",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "942de89e_a8369699",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-09-08T15:03:33Z",
      "side": 1,
      "message": "Thank you so much Amy for adding the test. I suspect as you look into it more closely, you\u0027ll find more trickiness that\u0027s not well tested, so any tests that can flush out bugs are very welcome.\n\nThanks for the information too, the prerotation code effectively nullifying AdjustBlitResolveParametersForResolve was certainly unintended. I agree that making sure those two play nice together would be a good path forward.\n\n---\n\nAs a side note, I have also been considering whether we should use texture() with a point sampler instead of texelFetch() for the resolve path. Then we don\u0027t need to have different coordinates for blit or resolve as both paths would use samplers. However, I suspect using a point sampler over texelFetch may incur a GPU performance penalty.",
      "parentUuid": "1eab4ce7_5d0d7aba",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "296cfd5d_10647d20",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1393148
      },
      "writtenOn": "2020-09-10T11:22:19Z",
      "side": 1,
      "message": "Hi Shahbaz. I add two end2end tests and fix the offset in CPU in patchset4.\n\n1) difference between ms0 and ms4\nI compared the msaa4 and msaa0 on android. They do haven\u0027t difference in CPU code, but in the compute shader, ms0 uses texture() to sample and ms4 uses texelFetch(). Texture() handles normalized ([0,1]) texture coordinates but texelFetch handles unnormalized coordinates. The way to sample seems to be the reason.\nAccording to GLSLangSpec.4.60, texture\u0027s src can\u0027t be gsampler2DMS. Maybe there is another way to deal with 2DMS using texture().\n\n2) two new added tests\nThe added test in patchset2 can only cover the flipY on Linux, but can\u0027t cover the prerotation code on android. I think they are needed to record bugs found and test the CL.\nIn the check part of these two tests, there are some comments for two bugs. One is the offset issue being discussed, the other is an unknown issue with prerotation on android. Though the cts tests can pass on linux and android after fixing the offset issue, but the result images aren\u0027t right actually. Some pixels near one of the image\u0027s edge are still wrong, they form a shape like “aliasing”. This issue may need a new ID to be fixed later.\n\n3)offset fix\nI think it\u0027s complex to fix the offset in AdjustBlitResolveParametersForResolve since it can\u0027t get useful isReserved() flags of prerotation on android. Do you think it can be accepted to fix it in AdjustBlitResolveParametersForPreRotation function like patchset4? It can work with prerotation and won\u0027t affect other path.",
      "parentUuid": "942de89e_a8369699",
      "revId": "d2d2fd565c7a09c917e388d98290031dadb7e942",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}