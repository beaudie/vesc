{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a3455842_c642f01e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-01T19:55:27Z",
      "side": 1,
      "message": "typo: from",
      "range": {
        "startLine": 13,
        "startChar": 28,
        "endLine": 13,
        "endChar": 32
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "415b5cef_206e7fc6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-01T19:55:27Z",
      "side": 1,
      "message": "The controversial part I guess is this: \"just use CPU\" makes it sound like it\u0027s obviously the better choice. While this may be true on ARM in some cases (which is why I suggested using `preferCPUForBufferDataSubData`), how do we know it\u0027s the right thing to do elsewhere?\n\n\u003e But this is only applying to a host visible memory, which  is system memory, there is no advantage to have GPU to do copy if src and dst are both system memory and host visible (GPU actually will be at disadvantage because it has to do across the PCIE bus and has to compete with other essential bus traffic).\n\nWell we let the GPU use these buffers for everything, so if there\u0027s really a bandwidth issue due the buffer being host-visible, that\u0027s a bigger problem that needs solving.\n\nBut also I don\u0027t think this is a given: \"there is no advantage to have GPU to do copy\". A dedicated DMA doing the copy over PCIe, vs the CPU doing the copy by looping, it\u0027s not clear to me which would be faster. Also, is the PCIe argument even valid on UMA architectures?\n\nPerhaps there should be a size check here too? Like if the copy is small, ok CPU may be fine, but I highly doubt that\u0027s true if the copy size is big.\n\nTL;DR, I\u0027d like to see a size limit for the CPU copy (even if a purely arbitrary constant), and some feature to decide the behavior, to make it easier in the future to play around with this.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 12
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9426894a_201c8213",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-10-01T20:46:00Z",
      "side": 1,
      "message": "\u003e Well we let the GPU use these buffers for everything, so if there\u0027s really a bandwidth issue due the buffer being host-visible, that\u0027s a bigger problem that needs solving.\n\u003e\nThat is why for buffer that we think does not get frequent update (i.e, static use) we put it in device local memory. For buffers that we think are frequent updated (i.e, dynamic update) we put it in system memory and made it host visible, so that we can use CPU to update it directly \n \n\u003e But also I don\u0027t think this is a given: \"there is no advantage to have GPU to do copy\". A dedicated DMA doing the copy over PCIe, vs the CPU doing the copy by looping, it\u0027s not clear to me which would be faster. Also, is the PCIe argument even valid on UMA architectures?\n\u003e \n\u003e Perhaps there should be a size check here too? Like if the copy is small, ok CPU may be fine, but I highly doubt that\u0027s true if the copy size is big.\n\u003e \n\u003e TL;DR, I\u0027d like to see a size limit for the CPU copy (even if a purely arbitrary constant), and some feature to decide the behavior, to make it easier in the future to play around with this.\n\nHow about I add a feature flag to limit this to android to end this conversation?",
      "parentUuid": "415b5cef_206e7fc6",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 12
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1e13c04c_50132547",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-10-01T23:34:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9426894a_201c8213",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 12
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7132b5de_76992c7c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-10-01T23:34:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a3455842_c642f01e",
      "range": {
        "startLine": 13,
        "startChar": 28,
        "endLine": 13,
        "endChar": 32
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "344e4f5e_1c51a8f3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-10-02T02:39:27Z",
      "side": 1,
      "message": "One last request here, please add a threshold constant (which you can arbitrarily set as you like for now) so that either of the before and after copies are only done on the CPU if the amount of data \u003c threshold, so that heavy copies end up on the GPU.",
      "parentUuid": "1e13c04c_50132547",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 12
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03c06fb9_bf334394",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2021-10-08T01:12:02Z",
      "side": 1,
      "message": "The feature flag as been changed to threshold.",
      "parentUuid": "344e4f5e_1c51a8f3",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 12
      },
      "revId": "6e728c055db50360711481e3c1c03f3682df5054",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}