{
  "comments": [
    {
      "key": {
        "uuid": "a34118be_97431107",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-22T16:38:46Z",
      "side": 1,
      "message": "Removing the +2, to give Courtney a chance to answer my questions.",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "015d3889_9b56305e",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2007,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-22T16:38:46Z",
      "side": 1,
      "message": "It looks like this is only called by syncPipelineCacheVk(), so it shouldn\u0027t need a lock.   Is there a good way to ASSERT() that the lock is held by the current thread so we can guarantee that in the future too?",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fcddc104_e9e6aa05",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2007,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-22T17:44:20Z",
      "side": 1,
      "message": "mPipelineCache is actually a Vulkan object and mPipelineCache.getCacheData is a Vulkan call made on that object so we don\u0027t need locking like we would for a cpu-based cache object.\nBasically we just lock for those things that would actually change the value of mPipelineCache, e.g. create a new Vulkan object. That only happens during RendererVk initialization and RendererVk::getPipelineCache.",
      "parentUuid": "015d3889_9b56305e",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aaf6a60f_720ff0f9",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2007,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-09-22T18:27:22Z",
      "side": 1,
      "message": "mPipelineCache is internally synchronized. We don\u0027t need to lock around invoking it, although we do need to lock around initializing the pointer. Is that the race?",
      "parentUuid": "fcddc104_e9e6aa05",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0f1c483d_c7200373",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2007,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-22T21:00:42Z",
      "side": 1,
      "message": "Correct. We were running into the race during initialization.",
      "parentUuid": "aaf6a60f_720ff0f9",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6d5002c_0e7d4398",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2017,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-22T16:38:46Z",
      "side": 1,
      "message": "Sounds like you\u0027re working on this now.   What are the thoughts on whether we need a lock here?\n\nSince this is called by WindowSurfaceVk::doDeferredAcquireNextImage(), it seems like it\u0027s necessary.   Can you try adding one to see how things look?",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a12b10a_02bfa07b",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2017,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-22T17:44:20Z",
      "side": 1,
      "message": "My understanding here is that we expect the pipelineCache Vulkan object to already have been created. Once created we don\u0027t change the value of mPipelineCache and can thus reference it without the lock.\nTechnically the ASSERT probably should grab the lock in case it\u0027s not true but that seems overkill for this ASSERT.",
      "parentUuid": "d6d5002c_0e7d4398",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73e95e9_22163b37",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2017,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-09-22T17:52:59Z",
      "side": 1,
      "message": "Should also add, we may need a lock around blob cache because there is more than just pipeline cache that uses blob cache. Will look at that for a future CL.",
      "parentUuid": "1a12b10a_02bfa07b",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a230aac_6590801a",
        "filename": "src/libANGLE/renderer/vulkan/RendererVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2017,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-09-22T20:16:38Z",
      "side": 1,
      "message": "Ok, doing some more reading, this is in the spec:\n\n9.6. Pipeline Cache\n\u003e If the pipeline cache passed into these commands is not VK_NULL_HANDLE, the implementation will query it for possible reuse opportunities and update it with new content. The use of the pipeline cache object in these commands is internally synchronized, and the same pipeline cache object can be used in multiple threads simultaneously.\n\nThat\u0027s how the pipeline cache is being used here, so it should be safe to access it without a lock.",
      "parentUuid": "c73e95e9_22163b37",
      "revId": "541ed41dc4c28cdd93623b9153942df2534e7f36",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}