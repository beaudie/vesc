{
  "comments": [
    {
      "key": {
        "uuid": "3586eba1_f81a781a",
        "filename": "extensions/ANGLE_multiview.txt",
        "patchSetId": 8
      },
      "lineNbr": 105,
      "author": {
        "id": 1119849
      },
      "writtenOn": "2017-08-14T13:26:32Z",
      "side": 1,
      "message": "What\u0027s the need for this? I\u0027m worried this will introduce UB when the WebGL implementation exposes an opaque multiview FBO: if the page decides to clear it without scissor enabled what happens?",
      "revId": "df8d11032f436ba5f8a5f0e19b15685adb9ad471",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9071cbcd_20f16881",
        "filename": "extensions/ANGLE_multiview.txt",
        "patchSetId": 8
      },
      "lineNbr": 105,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2017-08-14T13:41:24Z",
      "side": 1,
      "message": "The intent is that the WebGL implementation can always enable scissoring when an opaque multiview FBO is bound, so no UB will be exposed to web apps. The WebGL implementation will need to have some management for splitting the framebuffer either way, since at the ANGLE level we only know about viewport offsets. We decided on this design since it keeps the ANGLE API flexible and maps well to the underlying native APIs.",
      "parentUuid": "3586eba1_f81a781a",
      "revId": "df8d11032f436ba5f8a5f0e19b15685adb9ad471",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9817e92a_73aa37e3",
        "filename": "extensions/ANGLE_multiview.txt",
        "patchSetId": 8
      },
      "lineNbr": 105,
      "author": {
        "id": 1105284
      },
      "writtenOn": "2017-08-15T15:02:12Z",
      "side": 1,
      "message": "I\u0027m also concerned about this because with the passthrough command decoder and/or in other browsers, handling this undefined behaviour gets moved into ANGLE.  I think we should either make it an error in this extension or add an interaction with the WebGL compatibility extension that makes it an error.",
      "parentUuid": "9071cbcd_20f16881",
      "revId": "df8d11032f436ba5f8a5f0e19b15685adb9ad471",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2e2f70b_9cd60649",
        "filename": "extensions/ANGLE_multiview.txt",
        "patchSetId": 8
      },
      "lineNbr": 105,
      "author": {
        "id": 1142464
      },
      "writtenOn": "2017-08-15T16:44:19Z",
      "side": 1,
      "message": "Let me try to clarify the thinking behind how we ended up suggesting this kind of an API design.\n\nThere will always need to be at least a thin WebGL layer on top even after the passthrough command buffer is implemented. I think managing the opaque framebuffers will fit much better there rather than inside ANGLE, ANGLE just needs to give the higher level code sufficient tools to do that. The web-facing API is intended to be something like \"vrThingy.getOpaqueMultiviewFramebuffer({depth: true})\" - what kind of format that actually means at the native level will need to be filled in by the browser either way. It could be either layered or side-by-side. It might depend on the VR headset you want to render to, for example, and as far as I understand that kind of details aren\u0027t really within ANGLE\u0027s jurisdiction even after the passthrough command buffer will be in use.",
      "parentUuid": "9817e92a_73aa37e3",
      "revId": "df8d11032f436ba5f8a5f0e19b15685adb9ad471",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}