{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "63291f2a_d7bae5a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "The Mac failures seem to be because on OSX it throws SIGBUS instead of SEGV. Can you also handle SIGBUS?",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcb992f9_ad511474",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "I added handling `sig \u003d\u003d SIGBUS`, but the test still fails. Probably I also need to check for another `info-\u003esi_code`. I will take a deeper look at that.",
      "parentUuid": "63291f2a_d7bae5a9",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6cab3ce5_c265c27b",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 101,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: would call this PageFaultHandlerRangeType",
      "range": {
        "startLine": 101,
        "startChar": 11,
        "endLine": 101,
        "endChar": 26
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9b47dec_7885b7bd",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 101,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6cab3ce5_c265c27b",
      "range": {
        "startLine": 101,
        "startChar": 11,
        "endLine": 101,
        "endChar": 26
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b96c8482_812651b1",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 110,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: using PageFaultCallback \u003d",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 110,
        "endChar": 7
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a18979c3_10523671",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 110,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b96c8482_812651b1",
      "range": {
        "startLine": 110,
        "startChar": 0,
        "endLine": 110,
        "endChar": 7
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d30da007_e8969c27",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 119,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "How many page fault handlers would you install typically? At most one? Just wondering if these need to be virtual or if you can just skip the handler callback when it\u0027s disabled inside the implementation, and use a boolean here to track if it\u0027s enabled.",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 119,
        "endChar": 31
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e2dcd3f_434ea907",
        "filename": "src/common/system_utils.h",
        "patchSetId": 12
      },
      "lineNbr": 119,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T15:15:15Z",
      "side": 1,
      "message": "There can be at most one PageFaultHandler. When the handler is disabled there already won\u0027t be any call backs triggered. The enable/disable functions set the system API handler is place / remove it. I could couple that to the PageFaultHandler\u0027s life time, so enabling the system handler on construction and removing it on destruction, which would avoid these functions.\nAs for the boolean for tracking the state. There is also the possibility of querying the current handler with `sigaction`, to check if the override is in place. So I could expose a isEnabled function.",
      "parentUuid": "d30da007_e8969c27",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 119,
        "endChar": 31
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1a7602c_6ec98981",
        "filename": "src/common/system_utils_posix.cpp",
        "patchSetId": 12
      },
      "lineNbr": 263,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: most of the new code can be hidden inside anonymous namespace blocks, except the parts that are exposed to the header.",
      "range": {
        "startLine": 263,
        "startChar": 5,
        "endLine": 263,
        "endChar": 26
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf7de974_fe5b9331",
        "filename": "src/common/system_utils_posix.cpp",
        "patchSetId": 12
      },
      "lineNbr": 263,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b1a7602c_6ec98981",
      "range": {
        "startLine": 263,
        "startChar": 5,
        "endLine": 263,
        "endChar": 26
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d986302c_ec55b58c",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 209,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: please comment before each new test.",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f802592_2c87f9fd",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 209,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d986302c_ec55b58c",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "265b42b6_c1755794",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 225,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: please use unique_ptr",
      "range": {
        "startLine": 225,
        "startChar": 4,
        "endLine": 225,
        "endChar": 10
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac5373d6_fb158bef",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 225,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "265b42b6_c1755794",
      "range": {
        "startLine": 225,
        "startChar": 4,
        "endLine": 225,
        "endChar": 10
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3fb97b3_296bee55",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 247,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-19T20:57:45Z",
      "side": 1,
      "message": "Is it safe to lock a mutex inside a signal handler? What about mprotect?\n\nGenerally, you\u0027d use a `volatile sig_atomic_t` flag that you set inside the handler and do the actual job outside.",
      "range": {
        "startLine": 247,
        "startChar": 45,
        "endLine": 247,
        "endChar": 50
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98ed19e7_2cc7ba6e",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 247,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T15:15:15Z",
      "side": 1,
      "message": "apitrace and AGI do call mprotect from within the signal handler. apitrace also uses std::mutex inside the handler, while AGI implements a custom synchronization `SpinLock` class, which uses `std::atomic\u003cuint32_t\u003e`.\nReading the POSIX documentation, mprotect and threading functions are not part of the \"Async-Signal-Safe functions\" specified:\nhttps://linux.die.net/man/7/signal\n\nIn fact, locking the mutex in the test was only required on Android, while the test passed on Windows and Linux without.\nAlthough in FrameCapture I rely on the mutex in the page fault handler to block the application thread that is writing to the protected memory until the memory is done capturing.\n\nCan you elaborate or give code examples on how to solve this with `volatile sig_atomic_t`?",
      "parentUuid": "c3fb97b3_296bee55",
      "range": {
        "startLine": 247,
        "startChar": 45,
        "endLine": 247,
        "endChar": 50
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c22cc5d_b0c4638b",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 285,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: please use std::vector, angle::MemoryBuffer or similar RAII containers.",
      "range": {
        "startLine": 285,
        "startChar": 4,
        "endLine": 285,
        "endChar": 10
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6c25fa3_f52c2046",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 285,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0c22cc5d_b0c4638b",
      "range": {
        "startLine": 285,
        "startChar": 4,
        "endLine": 285,
        "endChar": 10
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "292f5e95_b2db481e",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 287,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2021-11-19T21:01:25Z",
      "side": 1,
      "message": "Another test you can add is to make sure the default page fault handler is called when access is outside the range. You can do that by setting up a signal handler before `CreatePageFaultHandler`, and make sure _that_ is called when `OutOfRange` is returned.",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e55436f8_0226d050",
        "filename": "src/common/system_utils_unittest.cpp",
        "patchSetId": 12
      },
      "lineNbr": 287,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T15:15:15Z",
      "side": 1,
      "message": "I added a `PageFaultHandlerDefaultHandler` test that is only built on `ANGLE_PLATFORM_POSIX` and sets a custom handler in place before calling `CreatePageFaultHandler`.",
      "parentUuid": "292f5e95_b2db481e",
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc88fdde_561bf8e9",
        "filename": "src/common/system_utils_win32.cpp",
        "patchSetId": 12
      },
      "lineNbr": 133,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2021-11-19T16:36:56Z",
      "side": 1,
      "message": "nit: same comment about anonymous namespaces",
      "range": {
        "startLine": 133,
        "startChar": 6,
        "endLine": 133,
        "endChar": 27
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f4e9e0a_877ad96b",
        "filename": "src/common/system_utils_win32.cpp",
        "patchSetId": 12
      },
      "lineNbr": 133,
      "author": {
        "id": 1491687
      },
      "writtenOn": "2021-11-23T14:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cc88fdde_561bf8e9",
      "range": {
        "startLine": 133,
        "startChar": 6,
        "endLine": 133,
        "endChar": 27
      },
      "revId": "1f7faabec642753f0afcfc0210ae133beab0bd51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}