{
  "comments": [
    {
      "key": {
        "uuid": "479b9675_664746cd",
        "filename": "src/libANGLE/BlobCache.cpp",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-05-13T16:35:42Z",
      "side": 1,
      "message": "It looks like everyone is ignoring the return value of this function now and it can be updated to return void.",
      "range": {
        "startLine": 152,
        "startChar": 15,
        "endLine": 152,
        "endChar": 25
      },
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "387e294d_6bb70095",
        "filename": "src/libANGLE/BlobCache.cpp",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 1130144
      },
      "writtenOn": "2020-05-13T17:35:50Z",
      "side": 1,
      "message": "Good call!",
      "parentUuid": "479b9675_664746cd",
      "range": {
        "startLine": 152,
        "startChar": 15,
        "endLine": 152,
        "endChar": 25
      },
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea954dc8_a0393665",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-05-13T16:35:42Z",
      "side": 1,
      "message": "This may be saying the same thing as Jamie, but can the value in linkEvent be returned as the result instead of the null/non-null checking?\n\n    mLinkingState.reset(new LinkingState());\n    mLinkingState-\u003elinkingFromBinary \u003d true;\n    mLinkingState-\u003elinkEvent         \u003d mProgram-\u003eload(context, \u0026stream, infoLog);\n    mLinkResolved                    \u003d false;\n\n    // wait() returns mResult, but a new getResult() probably makes more sense\n    return mLinkingState-\u003elinkEvent.mResult;",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25a8820f_49b05a46",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1130144
      },
      "writtenOn": "2020-05-13T17:35:50Z",
      "side": 1,
      "message": "@Tim, I do not think that is going to work.  \n\nmLinkingState-\u003elinkEvent is of type rx::LinkEvent, a base class with only \u003d0 virtual functions. Since implementations of mProgram-\u003eload can create tasks which run on background threads, any methods we call on linkEvent derived classes introduces race conditions in the code. If we\u0027re OK with that, we\u0027d need to add a new virtual method to LinkEvent which returns \"If you know you\u0027re finished with everything you need to do, tell me the result.\".  \n\nSince ProgramD3D::load knows for sure whether certain inputs are bad, returning nullptr (something definite) seems more robust to me.",
      "parentUuid": "ea954dc8_a0393665",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7784a15_b71adda6",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-05-14T16:56:29Z",
      "side": 1,
      "message": "What about processing the incomplete result same as how you process nullptr here?",
      "parentUuid": "25a8820f_49b05a46",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bed08ee1_6ffa294b",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1130144
      },
      "writtenOn": "2020-05-14T17:29:23Z",
      "side": 1,
      "message": "@Jamie, by the time Program::loadBinary receives the linkEvent, it doesn\u0027t know whether the link event represents a background compilation thread OR a failed attempt. In order to get the final result, it needs to wait for task to finish. Waiting here defeats the purpose of background compilation, where the wait happens later on when the program is used or the link status is queried.  \n\nBy returning nullptr instead, we have a definite answer that the program binary is for-sure incompatible. The caller can, then, queue up a different background compilation link event.",
      "parentUuid": "d7784a15_b71adda6",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50eec251_92d317ad",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-05-14T18:25:36Z",
      "side": 1,
      "message": "My concern is that nullptr is implicitly adding a new angle::Result value.   The other issue is that \u0027null\u0027 doesn\u0027t really tell you anything about why ProgramD3D::load() would return Incomplete in some cases but null in others (or what other backends should be doing when they hit errors).\n\nUnfortunately, I\u0027m not familiar enough with C++ threading (or how things like std::unique_ptr plays into that) to come up with something I\u0027m confident would work.   If we are able to trust null though, it seems we should be able to get linkEvent to contain something we trust also.\n\nWhat about creating a new angle::Result::Incompatible value that must have been set by a completed attempt?   Or should we initialize linkEvent to a new angle::Result::Pending value to indicate the background task is still running, so we know any value other than Pending means we are done?",
      "parentUuid": "bed08ee1_6ffa294b",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c97b4ed5_0d82afda",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-05-14T18:58:53Z",
      "side": 1,
      "message": "More enums for angle::Result is bad. I\u0027d prefer if we get rid of ::Incomplete and add a new return value (output value, or in a struct, somewhere) that indicates the success/fail of the operation. Anyway if Rafael you are too busy to do that it would be good to land this as a stop-gap improvement with a couple comments.",
      "parentUuid": "50eec251_92d317ad",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54e3e004_5403ab98",
        "filename": "src/libANGLE/Program.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1877,
      "author": {
        "id": 1130144
      },
      "writtenOn": "2020-05-14T19:35:41Z",
      "side": 1,
      "message": "\u003e I\u0027d prefer if we get rid of ::Incomplete and add a new return value (output value, or in a struct, somewhere) that indicates the success/fail of the operation. \n\nThe problem is not with angle::Result, the problem is that mProgram-\u003eload returns a pointer to an object that may or may not signify the operation is currently happening on a background thread. \n\nIn my solution, nullptr is the new return value that signifies the failure of the operation. This tells the caller \"don\u0027t bother waiting because we failed in making the background task\".  \n\n@Jamie, are you proposing that mProgram-\u003eloadLoad should return either an EventObject or some other enum? Is so, which enum did you have in mind? Something that doesn\u0027t exist today?\n\n\n\nIf you\u0027re uncomfortable with returning null from mProgram-\u003eload and you don\u0027t want to change the LinkEvent interface, here is an alternative: \n1. Restore ProgramD3D.cpp back to its original state.  \n2. In Program::loadBinary, instead of unconditionally returning angle::Result::Continue, we first call linkEvent-\u003eisLinking(). \n\nIf isLinking() returns false --\u003e We know the background thread is not active and it is safe to wait on the event. Passthrough the result of calling linkEvent-\u003ewait(). If the binary is incompatible, ProgramD3D::load will return an instance of LinkEventDone. LinkEventDone\u0027s isLinking implementation always returns false. The wait() implementation will return angle::Result::Incomplete.  \n\nIf isLinking() returns true --\u003e We know the background thread is active and doing its business. Return angle::Result::Continue like we did before and do not wait on the event. \n\nOne drawback of the proposal is that Program::loadBinary will now call isLinking where it didn\u0027t before. This will incur a small amount of overhead in the multi-threading case of checking state and potentially entering/leaving critical sections depending on the implementation.\n\nAnother drawback of the proposal, is that if the background thread finishes before the call to islinking, we will end up returning the result of the background thread\u0027s result. If the background thread returns \u0027Incomplete\u0027, the Program::loadBinary will attempt to recompile the shader again on a background thread, this time with the original source GLSL, not a binary. That\u0027s probably fine but it\u0027s a behavior change from what we had before .. and racy since sometimes you get a double compile, and sometimes you don\u0027t.\n\n\n\nIf you\u0027re comfortable with changing the interface of LinkEvent, then we can add a new method called \"ismultithread()\" or something similar. Program::loadBinary can use the return value of isMultithreaded to determine whether it is safe to wait on the event or return angle::Result::Continue unconditionally.  \n\n\n@Jamie and @Tim, WDTY?",
      "parentUuid": "c97b4ed5_0d82afda",
      "revId": "b878e41a34bada029d3f952e1df970ac38ce5422",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}