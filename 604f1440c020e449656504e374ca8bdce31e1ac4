{
  "comments": [
    {
      "key": {
        "uuid": "7e7645b2_dc912417",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-08-04T04:32:05Z",
      "side": 1,
      "message": "PTAL",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2da34c72_b65db34a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-08-04T13:54:16Z",
      "side": 1,
      "message": "Can you add a regression test to VulkanPerformanceCountersTest?",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "efe30aa8_e1140afb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-08-04T15:35:03Z",
      "side": 1,
      "message": "I took at a look at where updateScissor is called, and it looks like the only place this is optimizing is when gl::State::DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING is handled. Is that correct?\n\nWhy doesn\u0027t the `if (!mRenderPassCommands-\u003egetRenderArea().encloses(scissoredRenderArea))` test already prevent end render pass? And what does it mean if that indices the render pass must end, but you prevent it?\n",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28ecc828_3fa1ee9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-08-05T06:03:13Z",
      "side": 1,
      "message": "Yes, the problematic updateScissor() call that\u0027s ending the render pass is handling the case gl::State::DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING in ContextVk::syncState().\n\nIan\u0027s email has a good write-up on why the render pass is closed:\nhttps://groups.google.com/a/google.com/g/angle-for-android/c/ygQTl6ZghlM/m/FkXnJNVmCQAJ\n\nThe GL commands that are closing the RP are:\n\n    glDrawElements()\n    1753        glBindFramebuffer\n      target    GL_FRAMEBUFFER   \n      framebuffer Framebuffer 3486     \u003c\u003c--- dimensions: 1641x777\n\n    glClear()\n    1780        glBindFramebuffer                                 \n      target    GL_FRAMEBUFFER                                    \n      framebuffer Backbuffer FBO       \u003c\u003c--- dimensions: 777x1641 (rotated)\n    1781        glDepthMask                                       \n      flag      True                                              \n    1782        glClear                                           \n      mask      GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT\n\n    glBlitFramebuffer()\n    1783            glUseProgram       \n      program       Program 3234       \n    1784            glBindFramebuffer  \n      target        GL_READ_FRAMEBUFFER  \u003c\u003c--- dimensions: 1641x777\n      framebuffer   Framebuffer 3486   \n    1785            glBindFramebuffer  \n      target        GL_DRAW_FRAMEBUFFER  \u003c\u003c--- dimensions: 1641x777\n      framebuffer   Framebuffer 3484   \n    1786            glBlitFramebuffer  \n      readFramebuffer Framebuffer 3486   \n      drawFramebuffer Framebuffer 3484   \n      srcX0         0                  \n      srcY0         0                  \n      srcX1         1641               \n      srcY1         777                \n      dstX0         0                  \n      dstY0         0                  \n      dstX1         1641               \n      dstY1         777                \n      mask          GL_COLOR_BUFFER_BIT\n      filter        GL_NEAREST\n\nThe problem is that the backbuffer\u0027s dimensions don\u0027t match Framebuffer 3486\u0027s (since it\u0027s rotated, but the FBOs are not), so it ends the render pass before we can update it for the blit to resolve.\n\nThe app is rendering correctly and CQ is passing, so it seems safe so far.   I believe this is Jamie\u0027s deferred clears stuff hanging on to the clear (in the backbuffer\u0027s FramebufferVk) until it\u0027s actually necessary, to help optimize exactly this case, but I haven\u0027t dug in to prove it.\n\nAs an aside, calling updateScissorAndEndRenderPass() in FramebufferVk::syncState() is fine, since the dimensions do match at that point so the RP isn\u0027t ended.   I kept it with updateScissor() though, since there are explicit ends to the RP in that function also.",
      "parentUuid": "efe30aa8_e1140afb",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b11e4b68_88acd453",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-08-05T09:42:08Z",
      "side": 1,
      "message": "\u003e The problem is that the backbuffer\u0027s dimensions don\u0027t match Framebuffer 3486\u0027s (since it\u0027s rotated, but the FBOs are not)\n\u003e ...\n\u003e The app is rendering correctly\n\nThat doesn\u0027t make sense to me. If the app renders correctly it means that the read and draw framebuffers must have had the same dimensions, so they must have had the same scissor too.\n\nI actually don\u0027t understand how this optimization can work with rotation. Say the device is rotated 90 degrees. The dimensions of the images of the backbuffer are (W, H). The images of the FBO are (H, W). Isn\u0027t that correct? How can one be used as the resolve attachment of the other?\n\nEdit: I went to check, and indeed the condition under which vkCmdResolveImage is called has \"rotation \u003d\u003d SurfaceRotation::Identity\". The new code to use the resolve attachment is also under the same code. Does it matter then that the render pass gets closed with prerotation?\n\n\u003e As an aside, calling updateScissorAndEndRenderPass() in FramebufferVk::syncState() is fine.\n\nYou can\u0027t rely on FramebufferVk::syncState to do the right thing because it may never be called (if framebuffer is not dirty).\n\n---\n\nYou should in fact be able to write a test to trigger a bug in this change:\n\n1. Create FBO 1 with dimensions 16*32\n2. Draw red into FBO 1 (note, FramebufferVk::syncState is called)\n3. Create FBO 2 with dimensions 8x8\n4. Draw green into FBO 2 (note, FramebufferVk::syncState is called)\n5. Bind FBO 1 (note, it\u0027s not dirty)\n6. Draw blue into FBO 1\n7. Verify FBO 1 is entirely blue\n\nAt step 4, the scissor is updated to 8x8. At step 5, this change is skipping the scissor update. At step 6, the 8x8 scissor is used, leaving FBO 1 partially red. At step 7, verifying any coordinate outside the (0,0)-(8,8) rectangle should fail.\n\nNote that the test shouldn\u0027t verify pixels in the interim to avoid a flush (though I\u0027m not sure if that would mask the bug or not)",
      "parentUuid": "28ecc828_3fa1ee9f",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f22e4e1a_a3c8a20b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-08-05T19:05:30Z",
      "side": 1,
      "message": "This is the simplified sequence:\n\n1.) Draw to FBO 1 (1641x777)\n2.) Bind the backbuffer and clear it (777x1641)\n  - This gets deferred, since no other work is being done on the backbuffer.\n3.) Bind FBO 1 as read and FBO 2 as draw (both 1641x777)\n\nWe want to avoid ending the render pass when binding a new draw framebuffer with a different render area, if nothing is actually done with that new FBO.\n\nWhile rotation is involved, it\u0027s not actually important and more of a coincidence that the different dimensions are rotations of each other.   That aspect an be safely ignored.\n\nNo scissor updates are being skipped, we just aren\u0027t immediately ending the render pass if the render area is changed since ending the render pass will happen elsewhere when necessary.   In your scenario, each render pass will be correctly closed by either:\n- draw: the new draw will close any open render passes and start a new one (which we want, since the attachments have changed)\n- read pixels: necessarily needs to close the render pass to see the results\n\nI\u0027ve added the test you request as FramebufferTest::BindAndDrawDifferentSizedFBOs().   I changed the large dimensions to be square, since drawQuad() seems to require it (it was only drawing part of the rectangle otherwise).   The test passes without any additional code changes, so I think everything is working correctly.",
      "parentUuid": "b11e4b68_88acd453",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35bff809_d6fcad0b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-08-05T19:35:05Z",
      "side": 1,
      "message": "So the backbuffer has nothing to do with this resolve, right? Sigh at the fact that they are clearing the backbuffer in the middle of this.\n\nOk, I\u0027m convinced. Changing framebuffers must necessarily already handle closing the render pass with whatever command, even if their dimensions are identical. I realize now that `ContextVk::updateScissor`\u0027s `if` was bogus anyway when framebuffers change.",
      "parentUuid": "f22e4e1a_a3c8a20b",
      "revId": "604f1440c020e449656504e374ca8bdce31e1ac4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}