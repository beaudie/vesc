{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "78a40a53_d5784338",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 9,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-09T21:39:50Z",
      "side": 1,
      "message": "Would you please add more details to how the data race condition can happen?\n\nReading the description now, my understanding is:\n\n1. If buffer is not being suballocated, no data race condition can happen.\n\n2. If buffer is being suballocated, shared group owns bufferBlocks, and when the shared group pool destroys bufferBlocks, there will be data race condition, because in some scenario, the context in main thread will access the bufferBlocks at the same time. What is an example scenario?",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e419faa_87be24db",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 9,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-09T23:37:54Z",
      "side": 1,
      "message": "It is the opposite. #2 case will not have race because share group owns the buffer pool as well as descriptorSet pools. They only destroy with share group lock, so no race. #1 case is where the race could occur, since the buffer itself gets orphaned and then clean up thread may comes in and destroy the buffer which end up calling into descriptorSet cache code, all while the context thread is doing cache lookup.\n\nSo the fix is essentially for #1 case, we will release descriptorSet cache earlier, at the time the buffer is released, which we still had the shared group lock. Thus avoids this problem.",
      "parentUuid": "78a40a53_d5784338",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e16cca9_de90a332",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 9,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-10T05:31:55Z",
      "side": 1,
      "message": "Got it, thank you for the explanation!\n\nWould it be better to reword the CL description as:\n\n```\nRight now DynamicDescriptorPool::destroyCachedDescriptorSet can be\ncalled from garbage clean up thread, while simultaneously accessed by cache look up from the context main thread, and data race will happen and cause bugs. This can\nonly happen when the buffer is not being suballocated. In this case,\nsuballocation owns the bufferBlock and bufferBlock gets destroyed when\nsuballocation is destroyed from garbage collection thread. If buffer is\nsuballocated, the shared group owns pool which owns bufferBlocks and\nthey get destroyed from shared group with the share group lock. This CL avoids the data race problem by releasing the shared cacheKey when the buffer is released, while we still had the shared group lock.\n```",
      "parentUuid": "8e419faa_87be24db",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "634f1fab_54326e72",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 9,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-10T15:51:20Z",
      "side": 1,
      "message": "Thanks.",
      "parentUuid": "3e16cca9_de90a332",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9381ab4_91beb111",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-08-10T15:39:41Z",
      "side": 1,
      "message": "Do we have the same problem with images?",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c8920de_fc4f1889",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-10T15:51:20Z",
      "side": 1,
      "message": "No. Images already handled exactly this way - caches are released from TextureVk code.",
      "parentUuid": "c9381ab4_91beb111",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55bac4c8_f4686072",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6513,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-09T21:39:50Z",
      "side": 1,
      "message": "Now that `ReleaseCachedObject(ContextVk*)` is `UNREACHABLE`, do we still need to keep this function `releaseKeys(ContextVk *contextVk)` in `SharedCacheKeyManager`?",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f26c914_3a7198ea",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6513,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-09T23:37:54Z",
      "side": 1,
      "message": "Yea, otherwise compiler will complain when it instantiate the template. The main reason we end up with two different APIs here is because FramebufferCache and DescriptorSetCache requires different argument. In future we could clean up and make them take same argument, then we can delete the unreachable version (which is actually not been used).",
      "parentUuid": "55bac4c8_f4686072",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cde971c2_38fcad09",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6513,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-10T05:31:55Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "6f26c914_3a7198ea",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c12f21a_1f7d8eca",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6527,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-09T21:39:50Z",
      "side": 1,
      "message": "nit: is it a typo? `releaseRef` --\u003e `releaseKeys`",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d93954a_6a0900de",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6527,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-09T23:37:54Z",
      "side": 1,
      "message": "Yes it is typo. Will fix.",
      "parentUuid": "8c12f21a_1f7d8eca",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa40f844_b4b5e40f",
        "filename": "src/libANGLE/renderer/vulkan/vk_cache_utils.cpp",
        "patchSetId": 9
      },
      "lineNbr": 6527,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-10T15:51:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6d93954a_6a0900de",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "526d3404_40454917",
        "filename": "src/tests/gl_tests/TransformFeedbackTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 4395,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-09T21:39:50Z",
      "side": 1,
      "message": "Which part of this CL does this test try to verify?",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5cdeed54_359cda5f",
        "filename": "src/tests/gl_tests/TransformFeedbackTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 4395,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-09T23:37:54Z",
      "side": 1,
      "message": "This test ported from the webGL code in the bug (with some modification). It does not reproduce this bug, but I figured just check it in as well.",
      "parentUuid": "526d3404_40454917",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "caa5cbe6_a23182f6",
        "filename": "src/tests/gl_tests/TransformFeedbackTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 4395,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-10T05:31:55Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "5cdeed54_359cda5f",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39035a6e_37952741",
        "filename": "src/tests/gl_tests/UniformBufferTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 3465,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-09T21:39:50Z",
      "side": 1,
      "message": "Are there any asserts / checks in this test to make sure the cached bufferblocks are destroyed properly?",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be3b088a_86b12ef5",
        "filename": "src/tests/gl_tests/UniformBufferTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 3465,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2023-08-09T23:37:54Z",
      "side": 1,
      "message": "Context tear down has the assertions. That is ANGLE implementation detail, we can\u0027t assert/test here in the test.",
      "parentUuid": "39035a6e_37952741",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e51da8ed_c0c6a15a",
        "filename": "src/tests/gl_tests/UniformBufferTest.cpp",
        "patchSetId": 9
      },
      "lineNbr": 3465,
      "author": {
        "id": 1520902
      },
      "writtenOn": "2023-08-10T05:31:55Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "be3b088a_86b12ef5",
      "revId": "92b507031d2d6bbe01165ef106b57a964258ce42",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}