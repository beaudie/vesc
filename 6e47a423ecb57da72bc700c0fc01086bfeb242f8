{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d6a9c92d_18634164",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1883,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-25T15:20:29Z",
      "side": 1,
      "message": "Why not also use tail call in case of recreate?",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "193d44c3_ae9b31cd",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1883,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T03:08:13Z",
      "side": 1,
      "message": "It\u0027s a fresh swapchain, so it\u0027s not going to block anyway!",
      "parentUuid": "d6a9c92d_18634164",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2f1127b6_afdebb41",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1883,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-02T13:03:44Z",
      "side": 1,
      "message": "I know. But this is just more complex code.\n\nMy suggestion use tail call in this case even if it is not necessary. Simply because we already have this call and to avoid adding extra code path. What is wrong with that? (this was my original question).",
      "parentUuid": "193d44c3_ae9b31cd",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b26149f0_6a473bed",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1883,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T14:01:50Z",
      "side": 1,
      "message": "Ok, I\u0027ll do that as a follow up if you don\u0027t mind. I recall when writing this CL that there were a lot of tricky cases, and I don\u0027t remember if I put it there to handle a particular scenario or not. We\u0027ll discover that in the follow up CL!",
      "parentUuid": "2f1127b6_afdebb41",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ce81fdb_bb797b52",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-25T15:20:29Z",
      "side": 1,
      "message": "Technically `mSwapchain` is not accessed, lambda uses a copy.\n\nShould be `mPresentFenceRecycler`.\nAlso it seems that we can avoid using `mPresentFenceRecycler` without the lock either. Just prepare fence before the call.\n\nIt is hard to follow, and possible easy to break, why it is safe to use `mPresentFenceRecycler` without the lock, since it is used in `WindowSurfaceVk::cleanUpPresentHistory()`, for example. Maybe add `ASSERT(!needsAcquireNextSwapchainImage()` into `cleanUpPresentHistory()`?\n\nAt the same time, I can\u0027t think about case when `prepareSwap()` may be called concurrently with ANI related methods.\nExcept maybe if `eglPrepareSwap()` is called directly (not as part of swap), and right after that surface made current to other surface and we use that surface.",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c09aff2b_2c3600fd",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T03:08:13Z",
      "side": 1,
      "message": "\u003e Technically mSwapchain is not accessed, lambda uses a copy.\n\nRight, I mean to say the swapchain object itself is accessed.\n\n\u003e Should be mPresentFenceRecycler.\n\nDone.\n\n\u003e Also it seems that we can avoid using mPresentFenceRecycler without the lock either. Just prepare fence before the call.\n\nThis is a bit less straightforward. The thing is by the time the actual unlocked call is made, another thread may end up doing ANI anyway (not today, but in a follow up change I intend to make where ANI is moved to the end of render pass, which means now it can be triggered with other contexts causing a flush in this context). And now you are left with a fence that you need to release back to the recycler.\n\nIn that case, if the fence release can be made thread safe, so can the fence acquire!\n\n\u003e I can\u0027t think about case when prepareSwap() may be called concurrently with ANI related methods.\n\nThat is the idea. Otherwise this couldn\u0027t work given that it only uses the new mutex inside the try-acquire call, and nowhere else where the result is being processed.\n\n\u003e Maybe add ASSERT(!needsAcquireNextSwapchainImage() into cleanUpPresentHistory()?\n\nDone.",
      "parentUuid": "9ce81fdb_bb797b52",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "80deac0c_75f2291e",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-02T13:03:44Z",
      "side": 1,
      "message": "\u003e In that case, if the fence release can be made thread safe, so can the fence acquire!\n\nUnderstand.\n\n\u003e That is the idea. Otherwise this couldn\u0027t work given that it only uses the new mutex inside the try-acquire call, and nowhere else where the result is being processed.\n\nThis I do not understand)",
      "parentUuid": "c09aff2b_2c3600fd",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e73fbd11_44c51474",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T14:01:50Z",
      "side": 1,
      "message": "\u003e \u003e That is the idea. Otherwise this couldn\u0027t work given that it only uses the new mutex inside the try-acquire call, and nowhere else where the result is being processed.\n\n\u003e This I do not understand)\n\nI was trying to emphasize that what you said is correct:\n\n\u003e At the same time, I can\u0027t think about case when prepareSwap() may be called concurrently with ANI related methods.\n\nAnd the reason this code works is exactly because there _shouldn\u0027t_ be a case when `prepareSwap` is called concurrently with ANI related methods.\n\nWhat can happen (again, not now, but in a future where ANI is called at the end of RP, i.e. potentially from another context) is this:\n\n- Thread/Context 1 calls prepareSwap\n- Thread/Context 2 causes context 1 to flush, causing ANI\n\nThe atomic `needToAcquireNextSwapchainImage` makes sure accesses to it are safe from both threads. Depending on ordering, both threads may end up calling `TryAcquireNextImageUnlocked`. One of them will go through, the other would block. The one that blocked would early-out because after mutex lock it sees that `needToAcquireNextSwapchainImage` is no longer true.\n\nWhoever ends up post-processing the result of ANI is doing it under the share group lock.\n\nDid I miss anything?",
      "parentUuid": "80deac0c_75f2291e",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92b22825_3d8365bf",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-05-02T14:17:35Z",
      "side": 1,
      "message": "Thanks, now I understand)\n\nExcept one thing:\n\u003e And the reason this code works is exactly because there shouldn\u0027t be a case when prepareSwap is called concurrently with ANI related methods.\n\n\"ANI related methods\" is any method that can call ANI. So in your example (in the future), flush will be ANI related method.\n\nNow ANI may be called from syncState, but this method should not be called from other threads. And if we do not use `eglPrepareSwap()` directly, then we do not need atomic or TryAcquire mutex. That was my question, why we need atomic and mutex if concurrent calls is not possible. Now I understand, that it is for future changes.\n\n\u003e Whoever ends up post-processing the result of ANI is doing it under the share group lock\n\nIt will be the one from flush. eglSwap after prepareSwap will see processed result.\n\n\u003e Did I miss anything?\n\nI think everything is correct.",
      "parentUuid": "e73fbd11_44c51474",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8d097dbc_cd0fbb81",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1897,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T16:15:11Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "92b22825_3d8365bf",
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8fa5560d_83682d7e",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1905,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-25T15:20:29Z",
      "side": 1,
      "message": "EGL/GLES call.",
      "range": {
        "startLine": 1905,
        "startChar": 58,
        "endLine": 1905,
        "endChar": 62
      },
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4fe24602_4413cb38",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1905,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T03:08:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8fa5560d_83682d7e",
      "range": {
        "startLine": 1905,
        "startChar": 58,
        "endLine": 1905,
        "endChar": 62
      },
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65a7a42b_155d2d10",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 2618,
      "author": {
        "id": 1564492
      },
      "writtenOn": "2023-04-25T15:20:29Z",
      "side": 1,
      "message": "Name is confusing with `mNeedToAcquireNextSwapchainImage` member.\n\nSuggest renaming to `isCurrentSwapchainImageReady()`. You will also need to negate all conditions...",
      "range": {
        "startLine": 2618,
        "startChar": 22,
        "endLine": 2618,
        "endChar": 52
      },
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18d5673d_e0e183b0",
        "filename": "src/libANGLE/renderer/vulkan/SurfaceVk.cpp",
        "patchSetId": 9
      },
      "lineNbr": 2618,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-05-02T03:08:13Z",
      "side": 1,
      "message": "Renamed to `needsAcquireImageOrProcessResult`",
      "parentUuid": "65a7a42b_155d2d10",
      "range": {
        "startLine": 2618,
        "startChar": 22,
        "endLine": 2618,
        "endChar": 52
      },
      "revId": "6e47a423ecb57da72bc700c0fc01086bfeb242f8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}