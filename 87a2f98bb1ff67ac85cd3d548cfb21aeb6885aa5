{
  "comments": [
    {
      "key": {
        "uuid": "6f429094_fc029394",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T02:01:49Z",
      "side": 1,
      "message": "It would be great if you could write a regression test for this. The test should frequently change the driver uniforms, and make many draw calls, but it should only verify the results at the end (as flushes in between may accidentally fix the issue)",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14adc6b0_e0c95d92",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T02:02:13Z",
      "side": 1,
      "message": "Could be a follow up so we have the fix landed earlier",
      "parentUuid": "6f429094_fc029394",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34d7cded_fcdc1451",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-07-09T02:50:50Z",
      "side": 1,
      "message": "Yes, I will keep a note to myself and should come back to this later.",
      "parentUuid": "14adc6b0_e0c95d92",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bebdcbe2_dadb6a9c",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 3690,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-07-09T15:01:23Z",
      "side": 1,
      "message": "onto",
      "range": {
        "startLine": 3690,
        "startChar": 33,
        "endLine": 3690,
        "endChar": 36
      },
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18fe7528_c1b1b1ad",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 3691,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T02:01:49Z",
      "side": 1,
      "message": "You wouldn\u0027t need this if `allocate` retains unconditionally.\n\nThere are also a number of other places that call `retain` right after `allocate`, and those can also all be removed.",
      "range": {
        "startLine": 3690,
        "startChar": 0,
        "endLine": 3691,
        "endChar": 80
      },
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc3a5863_0489ac53",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 3691,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-07-09T02:50:04Z",
      "side": 1,
      "message": "What if dynamicBuffer itself gets released()? I am not seeing code prevent the current buffer from released. I did this mostly try to keep it consistent with the use pattern in other places. But even with this change, I still not sure we covered every usage case. What if the current buffer been used for multiple submissions and then dynamicBuffer gets destroyed. Will we wait for the last usage of mBuffer properly?\n\nI do think we need to revisit this once I move all dynamicBuffers into ContextVk. Then it should be a lot easier to handle these situations since context knows all the dynamicBuffers, at that time I believe we can delete this retain call and other places as well. Right now there are many per object dynamicBuffers that you don\u0027t have an easy/cheap way to reach into them probably is part of the problem.",
      "parentUuid": "18fe7528_c1b1b1ad",
      "range": {
        "startLine": 3690,
        "startChar": 0,
        "endLine": 3691,
        "endChar": 80
      },
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "214d9cf6_99228dcf",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 3691,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T05:02:16Z",
      "side": 1,
      "message": "That sounds good.\n\nIn that case, I believe this should be moved above the `if`. Even if the buffer is not new, we need to retain it (for example, maybe last allocation was by a previous frame)",
      "parentUuid": "fc3a5863_0489ac53",
      "range": {
        "startLine": 3690,
        "startChar": 0,
        "endLine": 3691,
        "endChar": 80
      },
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "455ca927_3a33d3b0",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 3691,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-07-09T15:26:40Z",
      "side": 1,
      "message": "\u003e What if dynamicBuffer itself gets released()? I am not seeing code prevent the current buffer from released. I did this mostly try to keep it consistent with the use pattern in other places. But even with this change, I still not sure we covered every usage case. What if the current buffer been used for multiple submissions and then dynamicBuffer gets destroyed. Will we wait for the last usage of mBuffer properly?\n\nYou shouldn\u0027t run into this case. DynamicBuffer isn\u0027t meant to have a lifetime that\u0027s shorter than a possible use.\n\nTechnically I think you\u0027d need to retain the driver uniforms every draw call/submission even if no new descriptor set is allocated. If this works to fix the bug then that might be okay for now.",
      "parentUuid": "214d9cf6_99228dcf",
      "range": {
        "startLine": 3690,
        "startChar": 0,
        "endLine": 3691,
        "endChar": 80
      },
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1b496b7_60367529",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 6
      },
      "lineNbr": 998,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T02:01:49Z",
      "side": 1,
      "message": "This doesn\u0027t seem right to me either. Say there is only one allocation from the DynamicBuffer in the frame. This call is never made then.\n\nI think the right place is above (or below) where it says:\n\n    if (bufferOut !\u003d nullptr)\n    {\n        *bufferOut \u003d mBuffer-\u003egetBuffer().getHandle();\n    }\n\nIn other words, every time allocate is called, regardless of whether a new buffer is used or not, the current buffer is retained.",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2be2b8c_037354a0",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 6
      },
      "lineNbr": 998,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-07-09T02:50:04Z",
      "side": 1,
      "message": "I agree. I think right now the correct way really is to call retain every time you allocate. But I believe it was not done this way mainly for performance. allocate() will get called a lot, and my understanding is there is no way to prevent it add to list multiple times. The way it is right now reduces the retain() call only when we switch to new buffer. As I explained above, I still think there is a hole here when dynamicBuffer gets released(). But move to retain for eveyr allocate() likely will introduce perf regressions, and I am try not do that. Once we move all dynamicBuffers to context, it should be handled easily if context at that time.",
      "parentUuid": "b1b496b7_60367529",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69357187_10ccb1b7",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 6
      },
      "lineNbr": 998,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-07-09T05:02:16Z",
      "side": 1,
      "message": "Well the user has to call retain after every allocate anyway, but I see in most cases that happens on bufferRead and bufferWrite calls automatically which is hard to de-duplicate.\n\nSince the context is retaining the buffer after calling allocate (for driver uniforms), this is not really necessary here then, don\u0027t you think? (Assuming you add retain on DynamicBuffer::release() to handle that case correctly)",
      "parentUuid": "a2be2b8c_037354a0",
      "revId": "87a2f98bb1ff67ac85cd3d548cfb21aeb6885aa5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}