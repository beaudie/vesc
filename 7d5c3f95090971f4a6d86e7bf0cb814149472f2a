{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "841147e5_47929ca1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2022-03-25T18:59:12Z",
      "side": 1,
      "message": "also, regression test is welcome.",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce04019a_1693d484",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-26T02:39:02Z",
      "side": 1,
      "message": "I managed to figure out a way to test this:\n\n```\n    constexpr GLsizei kSize \u003d 2;\n\n    // tex[0] is what\u0027s being tested.  The others are helpers.\n    GLTexture tex[3];\n    for (int i \u003d 0; i \u003c 3; ++i)\n    {\n        glBindTexture(GL_TEXTURE_2D, tex[i]);\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, kSize, kSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n    }\n\n    GLFramebuffer fbo[3];\n    for (int i \u003d 0; i \u003c 3; ++i)\n    {\n        glBindFramebuffer(GL_FRAMEBUFFER, fbo[i]);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex[i], 0);\n    }\n\n    // Clear the image through fbo[0], and make sure the clear is flushed outside the render pass.\n    glBindFramebuffer(GL_FRAMEBUFFER, fbo[0]);\n    glClearColor(1, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::red);\n\n    // Invalidate it such that the contents are marked as undefined.  Note that regarldess of the\n    // marking, the image is cleared nevertheless.\n    const GLenum discards[] \u003d {GL_COLOR_ATTACHMENT0};\n    glInvalidateFramebuffer(GL_FRAMEBUFFER, 1, discards);\n\n    // Clear it again to the same color.\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Bind tex[0] to fbo[1] as the read fbo, and blit to fbo[2]\n    glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo[1]);\n    glFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex[0], 0);\n    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo[2]);\n\n    // Blit.  This causes the second clear of tex[0] to be flushed outside the render pass, which\n    // may be optimized out.\n    glBlitFramebuffer(0, 0, kSize, kSize, 0, 0, kSize, kSize, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n\n    // Switch back to fbo[0] and draw with blend.  If the second clear is dropped and the image\n    // continues to be marked as invalidated, loadOp\u003dDONT_CARE would be used instead of loadOp\u003dLOAD.\n    glBindFramebuffer(GL_FRAMEBUFFER, fbo[0]);\n\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_ONE, GL_ONE);\n\n    ANGLE_GL_PROGRAM(program, essl1_shaders::vs::Simple(), essl1_shaders::fs::Blue());\n    drawQuad(program, essl1_shaders::PositionAttrib(), 0);\n    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::magenta);\n```\n\nThis should go in the VulkanPerformanceCounterTests, and should verify that loadOp\u003dLOAD is used (instead of loadOp\u003dDONT_CARE).\n\nThe core algorithm of the test is:\n\n- Clear and flush outside RP\n- Invalidate\n- Clear again and flush outside RP (I did this with blit)\n- Draw (uses loadOp\u003dDONT_CARE which is wrong)",
      "parentUuid": "841147e5_47929ca1",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "677abadd_628981a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-26T02:46:07Z",
      "side": 1,
      "message": "And here\u0027s a simplified version of the above that flushes the clear with glReadPixels, demonstrating the same problem. Feel free to include both tests:\n\n```\n    constexpr GLsizei kSize \u003d 2;\n\n    GLTexture tex;\n    glBindTexture(GL_TEXTURE_2D, tex);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, kSize, kSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n\n    GLFramebuffer fbo;\n    glBindFramebuffer(GL_FRAMEBUFFER, fbo);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);\n\n    // Clear the image, and make sure the clear is flushed outside the render pass.\n    glClearColor(1, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::red);\n\n    // Invalidate it such that the contents are marked as undefined.  Note that regarldess of the\n    // marking, the image is cleared nevertheless.\n    const GLenum discards[] \u003d {GL_COLOR_ATTACHMENT0};\n    glInvalidateFramebuffer(GL_FRAMEBUFFER, 1, discards);\n\n    // Clear it again to the same color, and make sure the clear is flushed outside the render pass,\n    // which may be optimized out.\n    glClear(GL_COLOR_BUFFER_BIT);\n    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::red);\n\n    // Draw with blend.  If the second clear is dropped and the image continues to be marked as\n    // invalidated, loadOp\u003dDONT_CARE would be used instead of loadOp\u003dLOAD.\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_ONE, GL_ONE);\n\n    ANGLE_GL_PROGRAM(program, essl1_shaders::vs::Simple(), essl1_shaders::fs::Blue());\n    drawQuad(program, essl1_shaders::PositionAttrib(), 0);\n    EXPECT_PIXEL_COLOR_EQ(0, 0, GLColor::magenta);\n```",
      "parentUuid": "ce04019a_1693d484",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea1648ac_8893fed6",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-26T02:46:07Z",
      "side": 1,
      "message": "I changed my mind about this. The truth is that even though the image is *marked as* invalidated, it does actually continue to contain the cleared value. On repeated clear, this change makes the image get cleared again for no reason.\n\nArguably all this is in the \"app is doing nonsense realm\", but an equally valid (and more efficient) fix would be to mark the contents of the image defined in `ImageHelper::flushStagedUpdates`, right where the perf warning about duplicate clear being dropped is issued.\n\nIn other words, we continue to remember that the image is actually cleared, and if so on next flushStagedUpdates we mark it as contents-defined, similarly to how every other update in that function do it.",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08d56e6e_badca4df",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-03-26T05:30:00Z",
      "side": 1,
      "message": "So something like this?\n\n- If contents are marked as defined, and the clear value is the same as the previous clear value, spew the existing perf warning\n- If contents are marked as *not* defined, and the clear value is the same as the previous clear value, mark contents as defined\n\nThat sort of makes sense, but...\n\nI\u0027m a little puzzled as to how we know the memory backing the image is actually present and cleared after it\u0027s been marked as undefined by an invalidate. In my app\u0027s case, when the Vulkan backend dropped the \"redundant\" clear, my app was later reading from that FBO\u0027s color attachment texture and getting garbage data back. Where was it actually reading from?",
      "parentUuid": "ea1648ac_8893fed6",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ce432e1_d570b5e5",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-03-26T07:06:27Z",
      "side": 1,
      "message": "Updated the patch, please verify this is what you were asking for. ðŸ˜Š",
      "parentUuid": "08d56e6e_badca4df",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e1a4e4a_a317a871",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-03-26T07:17:49Z",
      "side": 1,
      "message": "I\u0027m not totally certain I did this right, actually. It functionally works but...\n\nIf we have a sequence like:\n\n- Invalidate color+depth\n- Clear\n- Draw depth\n- Invalidate depth\n\nAnd the image was cleared identically in the previous frame with only depth writes since the last clear, should the start of this renderpass use LoadOp C\u003dClear,D\u003dClear or C\u003dLoad,D\u003dLoad since the clear is the same as the previous one?\n\nRight now, with this patch series, it results in LoadOp C\u003dClear,D\u003dClear and StoreOp C\u003dStore,D\u003dDontCare. I imagine it should probably be either:\n\n- LoadOp C\u003dLoad,D\u003dClear + StoreOp C\u003dStore,D\u003dDontCare\n- LoadOp C\u003dLoad,D\u003dClear + StoreOp C\u003dDontCare,D\u003dDontCare (if it notices there were no color writes and the previous LoadOp was C\u003dLoad, it could just skip storing and leave the old contents alone, right?)",
      "parentUuid": "0ce432e1_d570b5e5",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e15bb56_2c908c47",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-03-26T07:18:32Z",
      "side": 1,
      "message": "Er that should read \"should the start of this renderpass use LoadOp C\u003dClear,D\u003dClear or C\u003dLoad,D\u003dClear since the clear is the same as the previous one?\"",
      "parentUuid": "8e1a4e4a_a317a871",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dadc3b8f_cab54552",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-27T01:53:31Z",
      "side": 1,
      "message": "Nah, it\u0027s much simpler than that. See the other comment.\n\n\u003e I\u0027m a little puzzled as to how we know the memory backing the image is actually present and cleared after it\u0027s been marked as undefined by an invalidate.\n\nAs ugly as this (necessary) optimization is, we are very conservative with disabling it. It only needs to serve to optimize one benchmark. Basically soon as there\u0027s anything that might touch the image, we disable the optimization. If the contents have just been marked invalid, but not otherwise touched, there\u0027s no reason to think it doesn\u0027t still contain the cleared value.\n\n\u003e In my app\u0027s case, when the Vulkan backend dropped the \"redundant\" clear, my app was later reading from that FBO\u0027s color attachment texture and getting garbage data back. Where was it actually reading from?\n\nCan\u0027t really tell without a test or capture or something, but one thing I could think for example is if you had a render pass after the second clear, it would use loadOp\u003dDONT_CARE, maybe that\u0027s where garbage was coming from? Or maybe you just hit another bug?",
      "parentUuid": "3e15bb56_2c908c47",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d1ce903_ae288821",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2022-03-27T02:04:45Z",
      "side": 1,
      "message": "\u003e Er that should read \"should the start of this renderpass use LoadOp C\u003dClear,D\u003dClear or C\u003dLoad,D\u003dClear since the clear is the same as the previous one?\"\n\nSo, currently we use loadOp\u003dLOAD I believe. It shouldn\u0027t be hard to change that to loadOp\u003dCLEAR, but I don\u0027t believe anything here is worth optimizing.\n\nThat said:\n\n\u003e if it notices there were no color writes and the previous LoadOp was C\u003dLoad, it could just skip storing and leave the old contents alone, right?\n\nYou should know that storeOp\u003dDONT_CARE is a write operation. It doesn\u0027t mean \"leave the contents be\", but rather \"feel free to write garbage over it\". So no, we can\u0027t do that. We _could_ use storeOp\u003dNONE though, and I have a patch (not yet put up) that does that. That patch in turn builds on the patches I recently submitted (because before we didn\u0027t know that color is not written to). In your particular case, it would even realize that loadOp\u003dLOAD was unnecessary and it would use loadOp\u003dNONE+storeOp\u003dNONE.",
      "parentUuid": "dadc3b8f_cab54552",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0db8bc5_207c4ce7",
        "filename": "src/libANGLE/renderer/vulkan/vk_helpers.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6643,
      "author": {
        "id": 1518892
      },
      "writtenOn": "2022-03-27T02:17:02Z",
      "side": 1,
      "message": "Yeah, I read the docs on the store operations after I wrote that comment, so I agree that loadOp None storeOp None would be far better.\n\nBut right now with this patch series it ends up as loadOp C\u003dClear,D\u003dClear, which is correct for depth but not for color (it\u0027s still doing the redundant clear there).",
      "parentUuid": "2d1ce903_ae288821",
      "revId": "7d5c3f95090971f4a6d86e7bf0cb814149472f2a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}