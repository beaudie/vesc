{
  "comments": [
    {
      "key": {
        "uuid": "5ed0f17e_b799c581",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-08-07T23:42:51Z",
      "side": 1,
      "message": "Does using these 2 functions work instead of this macro?\n\ntemplate \u003ctypename T\u003e\nANGLE_INLINE T FromGL(GLuint handle)\n{\n    return {handle};\n}\n\ntemplate \u003ctypename T\u003e\nANGLE_INLINE T FromGL(const GLuint *handle)\n{\n    return reinterpret_cast\u003cT\u003e(handle);\n}\n\nBased on how these are defined, the code calling them should be able to stay the same.",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22e6bee7_cbb95cae",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-08-09T16:37:17Z",
      "side": 1,
      "message": "Unfortunately not. Defining your functions here would be overly broad and catches other \"FromGL\" invocations for other non-ID types.",
      "parentUuid": "5ed0f17e_b799c581",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ee6d898_30bc397e",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-08-09T16:53:26Z",
      "side": 1,
      "message": "How large is the list of ANGLE_INSTANTIATE_RESOURCE_ID_FUNCS() going to get before this is cleaned up?   Will it need to include each of these types (this is just a small grab from the full list)?\n\n2733:        MaterialParameter pnamePacked \u003d FromGL\u003cMaterialParameter\u003e(pname);\n2789:        MatrixType modePacked \u003d FromGL\u003cMatrixType\u003e(mode);\n4026:        ShadingModel modePacked \u003d FromGL\u003cShadingModel\u003e(mode);\n4611:        TextureEnvTarget targetPacked   \u003d FromGL\u003cTextureEnvTarget\u003e(target);\n4612:        TextureEnvParameter pnamePacked \u003d FromGL\u003cTextureEnvParameter\u003e(pname);\n\nI\u0027m wondering if this is the right approach before it goes too far, since it looks a little strange re-implementing templates with macros.",
      "parentUuid": "22e6bee7_cbb95cae",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e25f04c4_6992e0c2",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-08-09T17:34:10Z",
      "side": 1,
      "message": "These macro inserts explicit template instantiations. They\u0027re specifically for resource ID types. We have FromGL instantiations for each and every packed enum type but those are defined in PackedGLEnums_autogen.cpp. Please see that file for more detail.\n\nIs this okay to proceed with? I\u0027d be happy to explain more about template instantiation offline.",
      "parentUuid": "3ee6d898_30bc397e",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "098fae9c_6b931c98",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-08-09T20:28:35Z",
      "side": 1,
      "message": "I\u0027m not sure PackedGLEnums_autogen.cpp addresses my question.   Those are different functions than the catch-all FromGL() that\u0027s defined here and is used by this macro:\n\n// Pass-through for resource types that aren\u0027t yet represented by IDs.\n// TODO(jmadill): Remove when all resource types use IDs. http://anglebug.com/3611\ntemplate \u003c\u003e\nANGLE_INLINE GLuint FromGL(GLuint id)\n{\n    return id;\n}\n\nBased on the grep results, it seems we will eventually see:\nANGLE_INSTANTIATE_RESOURCE_ID_FUNCS(MaterialParameter)\nANGLE_INSTANTIATE_RESOURCE_ID_FUNCS(MatrixType)\nANGLE_INSTANTIATE_RESOURCE_ID_FUNCS(ShadingModel)\nANGLE_INSTANTIATE_RESOURCE_ID_FUNCS(TextureEnvTarget)\netc.\n\nThis means that each new struct needs to be defined and have a line added here, and then when everything is converted all of this needs to be removed and converted to just the functions (outside of the macro).   Instead, I think we can do something like this:\n\n    #include \u003ciostream\u003e\n    #include \u003cstring\u003e\n\n    enum class GLenumGroup\n    {\n        AccumOp,\n        AlphaFunction\n    };\n\n    class ResourceIDType\n    {\n    public:\n        ResourceIDType(int value) : mValue(value) {}\n        virtual ~ResourceIDType() {};\n        int getIDValue() { return mValue; }\n\n    private:\n        int mValue;\n    };\n\n    template \u003ctypename ResourceIDType\u003e\n    inline int GetIDValue(ResourceIDType id)\n    {\n        return id.getIDValue();\n    }\n\n    template \u003ctypename T\u003e\n    T FromGL(int handle)\n    {\n        if (std::is_enum\u003cT\u003e::value)\n        {\n            // Not a child of ResourceIDType yet\n            return static_cast\u003cT\u003e(handle);\n        }\n        else\n        {\n            return T(handle);\n        }\n    }\n\n    template \u003ctypename T\u003e\n    T FromGL(int *handle)\n    {\n        return reinterpret_cast\u003cT\u003e(handle);\n    }\n\n    class BufferID : public ResourceIDType\n    {\n    public:\n        BufferID(int value) : ResourceIDType(value) {}\n        virtual ~BufferID() {};\n    };\n\n    class RenderbufferID : public ResourceIDType\n    {\n    public:\n        RenderbufferID(int value) : ResourceIDType(value) {}\n        virtual ~RenderbufferID() {};\n    };\n\n    int main()\n    {\n      std::cout \u003c\u003c \"What is your name? \";\n      BufferID b \u003d FromGL\u003cBufferID\u003e(10);\n      std::cout \u003c\u003c \"b \u003d \" \u003c\u003c GetIDValue(b) \u003c\u003c std::endl;\n      GLenumGroup i \u003d FromGL\u003cGLenumGroup\u003e(11);\n      std::cout \u003c\u003c \"i \u003d \" \u003c\u003c static_cast\u003cint\u003e(i) \u003c\u003c std::endl;\n      int temp \u003d 12;\n      BufferID *c \u003d FromGL\u003cBufferID*\u003e(\u0026temp);\n    }\n\n\nThis only requires two FromGL() functions, with just one needing special treatment for the old enum values still out there.   Adding new types just requires declaring the new class that inherits from ResourceIDType and the only cleanup should be removing the is_enum block.\n\nThat little test main() obviously doesn\u0027t cover all of the cases where this is used in ANGLE, but hopefully it\u0027s mostly there.   Thoughts?",
      "parentUuid": "e25f04c4_6992e0c2",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "abef6aff_7d90b667",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-08-09T22:44:22Z",
      "side": 1,
      "message": "Here\u0027s a patch that is able to build the end2end tests:\nhttps://chromium-review.googlesource.com/c/angle/angle/+/1747168\n\nI\u0027m not sure how representative of a build that is for this stuff though or if this is actually any better.",
      "parentUuid": "098fae9c_6b931c98",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26917548_ba9c52c6",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2019-08-12T14:24:21Z",
      "side": 1,
      "message": "I was able to figure out how to use std::enable_if to avoid both inheritance and macros.\n\nhttps://en.cppreference.com/w/cpp/types/enable_if\nhttps://stackoverflow.com/questions/6972368/stdenable-if-to-conditionally-compile-a-member-function",
      "parentUuid": "abef6aff_7d90b667",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "afd59cca_3245b1b6",
        "filename": "src/common/PackedEnums.h",
        "patchSetId": 5
      },
      "lineNbr": 408,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2019-08-12T15:41:40Z",
      "side": 1,
      "message": "Oh, that\u0027s a cool way to do that. I think it looks cleaner than the macros.",
      "parentUuid": "26917548_ba9c52c6",
      "revId": "54e5323177a67c2b01fb8d87ca22ca19ab0d0057",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}