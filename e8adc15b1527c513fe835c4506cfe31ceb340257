{
  "comments": [
    {
      "key": {
        "uuid": "adb918c9_d9064a1e",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 363,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-18T04:11:58Z",
      "side": 1,
      "message": "max",
      "range": {
        "startLine": 363,
        "startChar": 39,
        "endLine": 363,
        "endChar": 42
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f014b56_e53f836d",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 363,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T16:20:08Z",
      "side": 1,
      "message": "Good catch! Thanks!",
      "parentUuid": "adb918c9_d9064a1e",
      "range": {
        "startLine": 363,
        "startChar": 39,
        "endLine": 363,
        "endChar": 42
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c013cf02_fd49dc3e",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 363,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T23:34:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1f014b56_e53f836d",
      "range": {
        "startLine": 363,
        "startChar": 39,
        "endLine": 363,
        "endChar": 42
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "69404a5b_860499ee",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1050,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-18T04:11:58Z",
      "side": 1,
      "message": "Looks like this change can be reverted",
      "range": {
        "startLine": 1040,
        "startChar": 0,
        "endLine": 1050,
        "endChar": 5
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21b4e869_aea8682a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1050,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T17:31:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "69404a5b_860499ee",
      "range": {
        "startLine": 1040,
        "startChar": 0,
        "endLine": 1050,
        "endChar": 5
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecb58106_f4848d94",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1068,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-06-18T04:11:58Z",
      "side": 1,
      "message": "I don\u0027t particularly have a problem with this, but the idiom is to write a small class whose constructor takes mDescripSetUpdates and device, and whose destructor calls flushWritesToDevice. Then you don\u0027t need to split the function in such an awkward manner.",
      "range": {
        "startLine": 1064,
        "startChar": 0,
        "endLine": 1068,
        "endChar": 18
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d60c7b8e_67fa584d",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1068,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T16:20:08Z",
      "side": 1,
      "message": "Good idea, I didn\u0027t thought about that c++ trick!",
      "parentUuid": "ecb58106_f4848d94",
      "range": {
        "startLine": 1064,
        "startChar": 0,
        "endLine": 1068,
        "endChar": 18
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "abe12d42_01097e32",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1068,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-18T17:14:52Z",
      "side": 1,
      "message": "Alternately clear the descriptor set updates on entry to setupDraw instead of after flush. Then I don\u0027t even think you need the scoped handler.",
      "parentUuid": "d60c7b8e_67fa584d",
      "range": {
        "startLine": 1064,
        "startChar": 0,
        "endLine": 1068,
        "endChar": 18
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a234784_b3dfdec1",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1068,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T23:34:28Z",
      "side": 1,
      "message": "The new way I did is DescriporSetUpdates object is a short lived local object.",
      "parentUuid": "abe12d42_01097e32",
      "range": {
        "startLine": 1064,
        "startChar": 0,
        "endLine": 1068,
        "endChar": 18
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "814cfdb8_5e6ec1bd",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 62,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-18T17:14:52Z",
      "side": 1,
      "message": "growCapacity seems overly optimized. You can replace these with angle::FixedVector with a reasonable implementation limit. Because this is one-per-Context there should be minimal waste and it ensures you never have to worry about dynamic allocation. It also saves an indirection because the objects are stored inline.",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 62,
        "endChar": 50
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa5bb6f2_43b3b63a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 62,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T17:31:20Z",
      "side": 1,
      "message": "Let me actually calculate the storage needs and we can decide with that data in hand.",
      "parentUuid": "814cfdb8_5e6ec1bd",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 62,
        "endChar": 50
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0c87b7b_47d1fac6",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 62,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T23:34:28Z",
      "side": 1,
      "message": "ContextVk::updateDriverUniformsDescriptorSet\t\t\tbuffer\tx 1\n ProgramExecutableVk::updateDefaultUniformsDescriptorSet\tbuffer: x 1\n ProgramExecutableVk::updateTransformFeedbackDescriptorSet\tbuffer: x 1\n ProgramExecutableVk::updateBuffersDescriptorSet:\t\tbuffer: x IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS (64)\n ProgramExecutableVk::updateAtomicCounterBuffersDescriptorSet   buffer: x IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS (8)\n ProgramExecutableVk::updateImagesDescriptorSet\t\t\timage x IMPLEMENTATION_MAX_ACTIVE_TEXTURES (64)\n ProgramExecutableVk::updateTexturesDescriptorSet\t\ttexture x IMPLEMENTATION_MAX_ACTIVE_TEXTURES (64)\n TransformFeedbackVk::initDescriptorSet\t\t\t\tbuffer: x IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS (4)\n TransformFeedbackVk::updateDescriptorSet\t\t\t\t\t\n TransformFeedbackVk::writeDescriptorSet\t\t\t\n ----------------\n Total (1+1+1+64+8+64+64)*2 + 4 \u003d 410\n (10 uint64 for writeinfo + 3 uint64 for bufferInfo) ) x 8 bytes \u003d 104 bytes\n 410 x 104bytes \u003d 42640 bytes\n\nNot sure if image and textures max counts are independent or not. I count them as independent, which adds up to max possible storage around 42K. I think its too much to waste, especially that the grow logic isn\u0027t that complicated.",
      "parentUuid": "aa5bb6f2_43b3b63a",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 62,
        "endChar": 50
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0c0a974_dfcbfcac",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 62,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-22T19:47:15Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a0c87b7b_47d1fac6",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 62,
        "endChar": 50
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7aa31b15_b4cfb849",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 556,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-18T17:14:52Z",
      "side": 1,
      "message": "can you pass this around instead of adding an accessor? To encapsulate Context class.",
      "range": {
        "startLine": 556,
        "startChar": 0,
        "endLine": 556,
        "endChar": 98
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc75aba5_ae69baca",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 556,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T17:31:20Z",
      "side": 1,
      "message": "Right. This also solves the problem that you and Shabi commented in the setupDraw. I am going to move the std::vectors into ContextVK but use the DescriptorSetUpdate object to manage the update and flush. It solves both issues you guys pointed out. The only downside is that I have to modify quite a few APIs to pass this around, which was my original reason of doing the accessor. But as you point out, pass around makes it cleaner and encapsulates context class better.",
      "parentUuid": "7aa31b15_b4cfb849",
      "range": {
        "startLine": 556,
        "startChar": 0,
        "endLine": 556,
        "endChar": 98
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ebda814_d1661a45",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 556,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-06-18T23:34:28Z",
      "side": 1,
      "message": "I end up having to modify way too many APIs: All handleDirty* APIs, all functions leading to the functions that uses it. I think it just too dirty to do this way. The other alternative I tried is to stick it in the vk::CommandBuffer object, but even that, I end up having to modify many APIs that leading to the use of DescriptorSetUpdates object. With the new way I did, the contextVK now owns the actual std::vector data, the DescriptorSetUpdates only has a reference to the actual data, and the DescriptorSetUpdates object itself is a shirt lived object, I think it helps encapsulation a little bit as well. Hopefully this is a good compromise.",
      "parentUuid": "fc75aba5_ae69baca",
      "range": {
        "startLine": 556,
        "startChar": 0,
        "endLine": 556,
        "endChar": 98
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7023165_a3b9e146",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.h",
        "patchSetId": 6
      },
      "lineNbr": 556,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-06-22T19:47:15Z",
      "side": 1,
      "message": "Hey Charlie, I didn\u0027t see if you explained this elsewhere. Why are you flushing the update descriptor set calls on an error? I get that you\u0027re doing some kind of graceful error handling. I don\u0027t see why. What does the write do that makes the state recoverable? What triggers the unexpected error?",
      "parentUuid": "5ebda814_d1661a45",
      "range": {
        "startLine": 556,
        "startChar": 0,
        "endLine": 556,
        "endChar": 98
      },
      "revId": "e8adc15b1527c513fe835c4506cfe31ceb340257",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}