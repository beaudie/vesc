{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "19c239e2_0769417a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-09-15T17:55:02Z",
      "side": 1,
      "message": "PTAL",
      "revId": "dd3bf976c4beb74a535493a32e145853b09271c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77885bac_bb264424",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4723,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-09-15T18:00:56Z",
      "side": 1,
      "message": "This is going to fail. If not, a new test should be added to demonstrate this bug:\n\n- Stage a clear in the image (like with a full sized glClear)\n- Trigger an empty scissor clear\n- Do something else with the framebuffer, like blit, copyTexImage, etc.\n  * Another test would be to bind a new framebuffer to the texture and read back, ensure clear is done\n\nIn `prepareForClear`, the framebuffer is synced. `FramebufferVk::syncState` picks up the previous clear in `mDeferredClears` as a clear-to-be-dealt-with-in-the-following-call. Here, you are removing the \"following call\", which means the clear is picked out of the image, but is not actually applied anywhere (it\u0027s stuck in `FramebufferVk::mDeferredClears`).\n\nFor the first usage described above (\"do something else with the framebuffer\"), assertions may fire about `mDeferredClear` not being empty... or rather you\u0027d have to do something to make the framebuffer sync again and then the assert would fire.\n\nFor the second usage (bind new framebuffer), the test would find that the image is not actually cleared.",
      "revId": "dd3bf976c4beb74a535493a32e145853b09271c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32d57b27_4074f6d7",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4723,
      "author": {
        "id": 1340649
      },
      "writtenOn": "2023-09-15T18:05:12Z",
      "side": 1,
      "message": "\u003e If not, a new test should be added to demonstrate this bug\n\nthis usecase is triggered by `dEQP-EGL.functional.swap_buffers_with_damage.resize_after_swap.preserve_buffer_clear_clear` when we enable preserve behavior (see here -\u003e https://chromium-swarm.appspot.com/task?id\u003d64a3c6a384fa4d11)\n\ndont really want to duplicate that test",
      "parentUuid": "77885bac_bb264424",
      "revId": "dd3bf976c4beb74a535493a32e145853b09271c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3befe36f_f3bf083f",
        "filename": "src/libANGLE/Context.cpp",
        "patchSetId": 1
      },
      "lineNbr": 4723,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2023-09-15T18:27:21Z",
      "side": 1,
      "message": "Looks I\u0027ve also written that test in the past for a similar bug :P\n\nhttps://chromium-review.googlesource.com/c/angle/angle/+/2453466",
      "parentUuid": "32d57b27_4074f6d7",
      "revId": "dd3bf976c4beb74a535493a32e145853b09271c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}