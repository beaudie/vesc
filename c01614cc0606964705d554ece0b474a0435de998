{
  "comments": [
    {
      "key": {
        "uuid": "098c4d06_e12fed8f",
        "filename": "src/libANGLE/renderer/d3d/VertexDataManager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-08-17T14:09:56Z",
      "side": 1,
      "message": "Jiajia, this probably will work, but I would like it if we don\u0027t generate validation errors within normal program execution. To address this, we can look at the WebGL spec:\n\n Out-of-range vertex fetches may return any of the following values:\n * Values from anywhere within the buffer object.\n * Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value represented in the type of the vector components and may be any of:\n   * 0, 1, or the maximum representable positive integer value, for signed or unsigned integer components\n   * 0.0 or 1.0, for floating-point components\n\nCan we do the following:\n\n * clamp the vertex count in this code block\n * when we are streaming an out of range vertex, stream either a zero vertex or the first available vertex in the vertex buffer.\n\nThis would solve the validation error problem. Usually we assume that once we reach the Context, the call should be successful except for internal errors.",
      "range": {
        "startLine": 468,
        "startChar": 0,
        "endLine": 471,
        "endChar": 9
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c532954f_8ef2d8b7",
        "filename": "src/libANGLE/renderer/d3d/VertexDataManager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-08-17T14:37:45Z",
      "side": 1,
      "message": "Sorry, I don\u0027t think this suggestion works. It would require reserving more space in the vertex buffer, possibly up to the last available element, and this could lead to a situation where subsequent dynamic attributes would not have space to stream.\n\nAnother option is to scan the set of dynamic attributes in IndexDataManager::prepareIndexData and force the index buffer to clamp any out of range indices in ConvertIndexArray. A final option would be to get rid of the ring buffer in D3D11 and use an approach similar to static buffers, where reading past the end wouldn\u0027t read into unvalidated data. However, your solution is so much simpler I think I\u0027m okay with keeping it like you have it for now.\n\nThe only danger is that because we entered the implementation call for drawing, and then error out, we might leave something in a partially initialized state on error, but the tests should be able to cover this.",
      "parentUuid": "098c4d06_e12fed8f",
      "range": {
        "startLine": 468,
        "startChar": 0,
        "endLine": 471,
        "endChar": 9
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "823d7b8d_29fad5c9",
        "filename": "src/libANGLE/renderer/d3d/VertexDataManager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1165541
      },
      "writtenOn": "2017-08-18T06:31:56Z",
      "side": 1,
      "message": "I agree to keep current implementation since it\u0027s very simple.\n\n\u003eThe only danger is that because we entered the implementation call for drawing, and then error out, we might leave something in a partially initialized state on error\n\nI think it should be similar with other gl error. Such as, gl::OutOfMemory(), gl::InternalError(). They all face the problem that you said (leave something in a partially initialized state on error). I am not sure if it will really cause some unexpected behaviors.",
      "parentUuid": "c532954f_8ef2d8b7",
      "range": {
        "startLine": 468,
        "startChar": 0,
        "endLine": 471,
        "endChar": 9
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4d2b300_c2eeafb2",
        "filename": "src/libANGLE/renderer/d3d/VertexDataManager.cpp",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-08-18T13:12:50Z",
      "side": 1,
      "message": "The difference between this an OutOfMemory is that on OutOfMemory Chromium we restart the GPU process, but here it\u0027s an expected validation error. InternalError should also be very rare, not a normal validation error.",
      "parentUuid": "823d7b8d_29fad5c9",
      "range": {
        "startLine": 468,
        "startChar": 0,
        "endLine": 471,
        "endChar": 9
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e9e5e6f_3fcf1b42",
        "filename": "src/tests/gl_tests/VertexAttributeTest.cpp",
        "patchSetId": 5
      },
      "lineNbr": 719,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-08-17T14:09:56Z",
      "side": 1,
      "message": "why did you have to make this change?",
      "range": {
        "startLine": 719,
        "startChar": 24,
        "endLine": 719,
        "endChar": 42
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19800ad7_916bbff2",
        "filename": "src/tests/gl_tests/VertexAttributeTest.cpp",
        "patchSetId": 5
      },
      "lineNbr": 719,
      "author": {
        "id": 1165541
      },
      "writtenOn": "2017-08-18T06:31:56Z",
      "side": 1,
      "message": "The original data.bufferOffset won\u0027t produce invalid operation error when we remove the IndexRange validation. It\u0027s just like the one that failed on try-bot. If we want to pass the case and don\u0027t change the bufferoffset, we must modify it like below:\nreplace \u0027EXPECT_GL_ERROR(GL_INVALID_OPERATION);\u0027 to\nGLenum error \u003d glGetError();\nif (error \u003d\u003d GL_INVALID_OPERATION) {\n    // ok\n} else if (error \u003d\u003d GL_NO_ERROR) {\n    // ok, out of range, check the buffer data\n}\n\nWebgl conformance test have covered such kind of situation. So I think the most simple change is to modify bufferOffset to ensure that it must produce the invalid operation error.",
      "parentUuid": "0e9e5e6f_3fcf1b42",
      "range": {
        "startLine": 719,
        "startChar": 24,
        "endLine": 719,
        "endChar": 42
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fdb3c58_eff240ea",
        "filename": "src/tests/gl_tests/VertexAttributeTest.cpp",
        "patchSetId": 5
      },
      "lineNbr": 719,
      "author": {
        "id": 1105324
      },
      "writtenOn": "2017-08-18T13:12:50Z",
      "side": 1,
      "message": "so, if we call vertexAttribPointer with (kVertexCount - 3) * sizeof(float), it should be 84 bytes, and the total size of the vertex buffer is kVertexCount * sizeof(float) or 96 bytes.  DrawIndexedQuad will read four vertices, for a total of 16 bytes. So 84 + 16 \u003d 100, so it should read past the end of the buffer. Then this should generate an error.",
      "parentUuid": "19800ad7_916bbff2",
      "range": {
        "startLine": 719,
        "startChar": 24,
        "endLine": 719,
        "endChar": 42
      },
      "revId": "c01614cc0606964705d554ece0b474a0435de998",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}