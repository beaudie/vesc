{
  "comments": [
    {
      "key": {
        "uuid": "1837db6e_963d8e75",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-15T05:15:27Z",
      "side": 1,
      "message": "Maybe in some benchmark this shows an improvement, but this could hit a finishToSerial if the buffer is in use by the GPU. That\u0027s definitely not better than closing a renderpass.\n\nIdeally, you want the condition to say:\n\n    if (host_visible \u0026\u0026 !in_use_by_gpu \u0026\u0026 renderpass_started)\n\nSo:\n\n- If not host visible, convert on GPU (only option)\n- If in use by the GPU, convert on GPU (to avoid finishToSerial, making CPU wait for GPU) and suffer the renderpass closing.\n- (this is an optimization) If no render pass is started, convert on GPU (faster than CPU)\n\n---\n\nAlso, I\u0027m fairly certain the benchmark is not filling the buffer inside the renderpass, so ideally this operation should be reordered and done before the renderpass starts (so this change is unnecessary altogether). Jamie, is the new graph capable of doing such a thing? Charlie, was this breaking the renderpass using the old command graph?",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b4e28b5_33382f08",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-02-18T05:50:27Z",
      "side": 1,
      "message": "It is using dynamic buffer which my understanding is always allocate new space to avoid hitting finishToSerial. Yes it will use more memory, but not more than the GPU copy as well. Regardless CPU or GPU, both are using dynamic buffer.\n\nThe glBufferData call probably not in the render pass. But the conversion happens not at bufferData time but at draw time since data type was only known at draw time. So it will break the render pass.\n\nThis is with command graph disabled. If you look at my test example (attached to the bug), it cut the GPU time in half, partly because the GPU copy prevents the glClear call folds into the draw call.",
      "parentUuid": "1837db6e_963d8e75",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45719051_64e654ac",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-18T12:56:32Z",
      "side": 1,
      "message": "Manhattan and T-Rex don\u0027t need reordering here. As Charlie said we\u0027re about to draw with the buffer anyway. It is possible that we could instrument a path that doesn\u0027t use the GPU at all with host coherent memory.",
      "parentUuid": "4b4e28b5_33382f08",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71b7c3e1_1af49a6a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-18T16:01:28Z",
      "side": 1,
      "message": "A new buffer is allocated for the result, but the input buffer could be in use by the GPU (for example because it was written to by a compute shader), regardless of whether the memory is host-visible. So yes, there are scenarios where this could lead to finishToSerial.\n\nAlso, if you can do this on the CPU without needing to wait for the GPU, you can also do it on the GPU for example at the beginning of the frame or basically any time before the renderpass starts, don\u0027t you think? So the issue is not so much CPU vs GPU work as it is about reordering the operations so that this is done before the renderpass.\n\nI don\u0027t think it ever makes sense to do something on the CPU when you could have otherwise done it on the GPU. There is already so much happening on the CPU, it doesn\u0027t make sense to offload work from the GPU to the CPU!\n\nJamie, IIUC, without the graph it\u0027s still possible to record to the command buffer that\u0027s run before the renderpass while the renderpass has started, isn\u0027t that so? We should then find out why this is closing the renderpass and resolve that issue instead.",
      "parentUuid": "45719051_64e654ac",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e154680_47db8f71",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-18T16:16:17Z",
      "side": 1,
      "message": "For sure there are some reordering scenarios. For now we should put those aside and focus our attention and effort into the key optimization targets: Manhattan and T-Rex. When we get to suboptimizal usage optimization and deferring multiple RPs at once we can take a look and see if this scenario pops up in any benchmarks or games. I\u0027m not sure what it would take to implement right now and I think we should keep the super simple design.\n\nI agree on desktop platforms likely GPU conversion is always a good thing. On mobile likely using the CPU conversion can outperform the GPU in some (or all?) cases. So my thinking is we could make this a \"Feature\" in FeaturesVk and toggle it experimentally.",
      "parentUuid": "71b7c3e1_1af49a6a",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a330b01f_42dca05a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-18T16:24:25Z",
      "side": 1,
      "message": "\u003e On mobile likely using the CPU conversion can outperform the GPU in some (or all?) cases\n\nI find it hard to believe that serial conversion on the CPU is \"generally\" faster than parallel conversion on the GPU! Maybe on some corner cases (like very few indices)\n\nI obviously can\u0027t stop anyone from adding hacks and technical debt, but I suggest to at least consider implementing anglebug.com/4405 first which may make this unnecessary.",
      "parentUuid": "7e154680_47db8f71",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2239f632_64368c10",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 883,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-02-18T15:40:11Z",
      "side": 1,
      "message": "Is the offset here always going to be 0?",
      "range": {
        "startLine": 883,
        "startChar": 80,
        "endLine": 883,
        "endChar": 81
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}