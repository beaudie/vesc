{
  "comments": [
    {
      "key": {
        "uuid": "1837db6e_963d8e75",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-15T05:15:27Z",
      "side": 1,
      "message": "Maybe in some benchmark this shows an improvement, but this could hit a finishToSerial if the buffer is in use by the GPU. That\u0027s definitely not better than closing a renderpass.\n\nIdeally, you want the condition to say:\n\n    if (host_visible \u0026\u0026 !in_use_by_gpu \u0026\u0026 renderpass_started)\n\nSo:\n\n- If not host visible, convert on GPU (only option)\n- If in use by the GPU, convert on GPU (to avoid finishToSerial, making CPU wait for GPU) and suffer the renderpass closing.\n- (this is an optimization) If no render pass is started, convert on GPU (faster than CPU)\n\n---\n\nAlso, I\u0027m fairly certain the benchmark is not filling the buffer inside the renderpass, so ideally this operation should be reordered and done before the renderpass starts (so this change is unnecessary altogether). Jamie, is the new graph capable of doing such a thing? Charlie, was this breaking the renderpass using the old command graph?",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b4e28b5_33382f08",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-02-18T05:50:27Z",
      "side": 1,
      "message": "It is using dynamic buffer which my understanding is always allocate new space to avoid hitting finishToSerial. Yes it will use more memory, but not more than the GPU copy as well. Regardless CPU or GPU, both are using dynamic buffer.\n\nThe glBufferData call probably not in the render pass. But the conversion happens not at bufferData time but at draw time since data type was only known at draw time. So it will break the render pass.\n\nThis is with command graph disabled. If you look at my test example (attached to the bug), it cut the GPU time in half, partly because the GPU copy prevents the glClear call folds into the draw call.",
      "parentUuid": "1837db6e_963d8e75",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45719051_64e654ac",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-18T12:56:32Z",
      "side": 1,
      "message": "Manhattan and T-Rex don\u0027t need reordering here. As Charlie said we\u0027re about to draw with the buffer anyway. It is possible that we could instrument a path that doesn\u0027t use the GPU at all with host coherent memory.",
      "parentUuid": "4b4e28b5_33382f08",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71b7c3e1_1af49a6a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-18T16:01:28Z",
      "side": 1,
      "message": "A new buffer is allocated for the result, but the input buffer could be in use by the GPU (for example because it was written to by a compute shader), regardless of whether the memory is host-visible. So yes, there are scenarios where this could lead to finishToSerial.\n\nAlso, if you can do this on the CPU without needing to wait for the GPU, you can also do it on the GPU for example at the beginning of the frame or basically any time before the renderpass starts, don\u0027t you think? So the issue is not so much CPU vs GPU work as it is about reordering the operations so that this is done before the renderpass.\n\nI don\u0027t think it ever makes sense to do something on the CPU when you could have otherwise done it on the GPU. There is already so much happening on the CPU, it doesn\u0027t make sense to offload work from the GPU to the CPU!\n\nJamie, IIUC, without the graph it\u0027s still possible to record to the command buffer that\u0027s run before the renderpass while the renderpass has started, isn\u0027t that so? We should then find out why this is closing the renderpass and resolve that issue instead.",
      "parentUuid": "45719051_64e654ac",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e154680_47db8f71",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1329751
      },
      "writtenOn": "2020-02-18T16:16:17Z",
      "side": 1,
      "message": "For sure there are some reordering scenarios. For now we should put those aside and focus our attention and effort into the key optimization targets: Manhattan and T-Rex. When we get to suboptimizal usage optimization and deferring multiple RPs at once we can take a look and see if this scenario pops up in any benchmarks or games. I\u0027m not sure what it would take to implement right now and I think we should keep the super simple design.\n\nI agree on desktop platforms likely GPU conversion is always a good thing. On mobile likely using the CPU conversion can outperform the GPU in some (or all?) cases. So my thinking is we could make this a \"Feature\" in FeaturesVk and toggle it experimentally.",
      "parentUuid": "71b7c3e1_1af49a6a",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a330b01f_42dca05a",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-18T16:24:25Z",
      "side": 1,
      "message": "\u003e On mobile likely using the CPU conversion can outperform the GPU in some (or all?) cases\n\nI find it hard to believe that serial conversion on the CPU is \"generally\" faster than parallel conversion on the GPU! Maybe on some corner cases (like very few indices)\n\nI obviously can\u0027t stop anyone from adding hacks and technical debt, but I suggest to at least consider implementing anglebug.com/4405 first which may make this unnecessary.",
      "parentUuid": "7e154680_47db8f71",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d04dee5_ec216853",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-02-18T19:23:48Z",
      "side": 1,
      "message": "On desktop GPU and if the index data is on VRAM, you will have to move data to VRAM anyway, and doing conversion using GPU usually is the right thing (not always). But when the data is in system memory, it does not make sense to let GPU to move data across the bus and do a simple conversion. This is especially true on mobile tiled renderer, where breaking render pass is expensive. In addition, most mobile games are GPU limited not CPU limited. You can not move the conversion outside render pass since only at the draw call time you know the data type is unsigned byte.\n\nI am ok with adding another feature flag, or even better a compile time flag so that desktop and mobile can take different route. There will be more scenarios like this will pop up later.",
      "parentUuid": "a330b01f_42dca05a",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03eb7c23_1aa52e3b",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1297197
      },
      "writtenOn": "2020-02-18T20:00:10Z",
      "side": 1,
      "message": "This is a good discussion and I think a lot of interesting ideas are being brought up.\n\nThis seems like a good place to be objective and use the benchmark data to inform our decision about whether to take the change or not.\n\nOnce CQ is green and we are confident the change is correctly implemented, we can benchmark it again and see if there is an improvement on mobile or not.   If it improves mobile but hurts desktop, we can add the additional logic to handle both cases correctly.\n\nIf there are additional ideas to improve things further, we can track those with bugs (like anglebug.com/4405) to revisit them in the future.   Those changes may invalidate the changes here at some point, but the incremental improvement now should at least allow us to move forward to the next issue and buy us some time to investigate those additional fixes and make sure we\u0027re confident we end up with the right answer for both mobile and desktop.",
      "parentUuid": "9d04dee5_ec216853",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7caf27c3_479ef563",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 880,
      "author": {
        "id": 1300114
      },
      "writtenOn": "2020-02-18T21:32:36Z",
      "side": 1,
      "message": "\u003e This is especially true on mobile tiled renderer, where breaking render pass is expensive.\n\nObviously the goal is not the break the renderpass, so I\u0027m not suggesting a solution that does that.\n\n\u003e In addition, most mobile games are GPU limited not CPU limited.\n\nGood to know.\n\n\u003e You can not move the conversion outside render pass since only at the draw call time you know the data type is unsigned byte.\n\nI don\u0027t agree with this. If you can do the conversion on the CPU, you can also do it before the renderpass on the GPU. There are many cases where we do things at draw time, but schedule them to be done before the renderpass, for example flushing staged texture updates, or changing image layouts.\n\n---\n\nI would still like to see anglebug.com/4405 done first, which is an even better optimization since you won\u0027t need to do this work in the first place.",
      "parentUuid": "03eb7c23_1aa52e3b",
      "range": {
        "startLine": 880,
        "startChar": 20,
        "endLine": 880,
        "endChar": 55
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2239f632_64368c10",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 883,
      "author": {
        "id": 1263724
      },
      "writtenOn": "2020-02-18T15:40:11Z",
      "side": 1,
      "message": "Is the offset here always going to be 0?",
      "range": {
        "startLine": 883,
        "startChar": 80,
        "endLine": 883,
        "endChar": 81
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "795d5db5_7e2921f6",
        "filename": "src/libANGLE/renderer/vulkan/ContextVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 883,
      "author": {
        "id": 1392020
      },
      "writtenOn": "2020-02-18T19:30:06Z",
      "side": 1,
      "message": "We have to do whole buffer conversion if we want to use dirty bit to avoid repeated conversion. Or alternatively you will have to record the dirty ranges if you want to avoid the whole buffer conversion. The unsigned byte index buffer usage is not that popular to warrant a more complicated solution and whole buffer data usually will be consumed anyway, so I think this is the right approach. But we need to be careful that if people store both unsigned byte and unsigned int data in the same buffer, we must switch back to the unconverted buffer for data other than unsigned byte. Even though I am pretty sure no one actually use it that way, such usage is within specification.",
      "parentUuid": "2239f632_64368c10",
      "range": {
        "startLine": 883,
        "startChar": 80,
        "endLine": 883,
        "endChar": 81
      },
      "revId": "ac3faae2f4037bd58b43c1f2e3837a01ac3a10b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}